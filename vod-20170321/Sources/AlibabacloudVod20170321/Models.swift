import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddAITemplateRequest : Tea.TeaModel {
    public var templateConfig: String?

    public var templateName: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class AddAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class AddAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectRequest : Tea.TeaModel {
    public var coverURL: String?

    public var description_: String?

    public var division: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.division != nil {
            map["Division"] = self.division!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Division") {
            self.division = dict["Division"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class AddEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var creationTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: AddEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = AddEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class MaterialList : Tea.TeaModel {
        public var cateId: Int32?

        public var cateName: String?

        public var coverURL: String?

        public var createTime: String?

        public var customerId: Int64?

        public var description_: String?

        public var duration: Double?

        public var materialId: String?

        public var materialType: String?

        public var modifyTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var spriteConfig: String?

        public var sprites: [String]?

        public var status: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.customerId != nil {
                map["CustomerId"] = self.customerId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.materialId != nil {
                map["MaterialId"] = self.materialId!
            }
            if self.materialType != nil {
                map["MaterialType"] = self.materialType!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.spriteConfig != nil {
                map["SpriteConfig"] = self.spriteConfig!
            }
            if self.sprites != nil {
                map["Sprites"] = self.sprites!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int32
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CustomerId") {
                self.customerId = dict["CustomerId"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MaterialId") {
                self.materialId = dict["MaterialId"] as! String
            }
            if dict.keys.contains("MaterialType") {
                self.materialType = dict["MaterialType"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("SpriteConfig") {
                self.spriteConfig = dict["SpriteConfig"] as! String
            }
            if dict.keys.contains("Sprites") {
                self.sprites = dict["Sprites"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var materialList: [AddEditingProjectMaterialsResponseBody.MaterialList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialList != nil {
            var tmp : [Any] = []
            for k in self.materialList! {
                tmp.append(k.toMap())
            }
            map["MaterialList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialList") {
            var tmp : [AddEditingProjectMaterialsResponseBody.MaterialList] = []
            for v in dict["MaterialList"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.MaterialList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.materialList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateList != nil {
            map["TranscodeTemplateList"] = self.transcodeTemplateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateList") {
            self.transcodeTemplateList = dict["TranscodeTemplateList"] as! String
        }
    }
}

public class AddTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class AddTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodDomainRequest : Tea.TeaModel {
    public var checkUrl: String?

    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var scope: String?

    public var securityToken: String?

    public var sources: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkUrl != nil {
            map["CheckUrl"] = self.checkUrl!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sources != nil {
            map["Sources"] = self.sources!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckUrl") {
            self.checkUrl = dict["CheckUrl"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sources") {
            self.sources = dict["Sources"] as! String
        }
        if dict.keys.contains("TopLevelDomain") {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class AddVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodStorageForAppRequest : Tea.TeaModel {
    public var appId: String?

    public var storageLocation: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class AddVodStorageForAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class AddVodStorageForAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodStorageForAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddVodStorageForAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodTemplateRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var templateConfig: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class AddVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class AddVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWatermarkRequest : Tea.TeaModel {
    public var appId: String?

    public var fileUrl: String?

    public var name: String?

    public var type: String?

    public var watermarkConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.watermarkConfig != nil {
            map["WatermarkConfig"] = self.watermarkConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FileUrl") {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WatermarkConfig") {
            self.watermarkConfig = dict["WatermarkConfig"] as! String
        }
    }
}

public class AddWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: AddWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") {
            var model = AddWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class AddWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachAppPolicyToIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public var policyNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.policyNames != nil {
            map["PolicyNames"] = self.policyNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("PolicyNames") {
            self.policyNames = dict["PolicyNames"] as! String
        }
    }
}

public class AttachAppPolicyToIdentityResponseBody : Tea.TeaModel {
    public var failedPolicyNames: [String]?

    public var nonExistPolicyNames: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedPolicyNames != nil {
            map["FailedPolicyNames"] = self.failedPolicyNames!
        }
        if self.nonExistPolicyNames != nil {
            map["NonExistPolicyNames"] = self.nonExistPolicyNames!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedPolicyNames") {
            self.failedPolicyNames = dict["FailedPolicyNames"] as! [String]
        }
        if dict.keys.contains("NonExistPolicyNames") {
            self.nonExistPolicyNames = dict["NonExistPolicyNames"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachAppPolicyToIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAppPolicyToIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachAppPolicyToIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchSetVodDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("Functions") {
            self.functions = dict["Functions"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchSetVodDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchSetVodDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSetVodDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchSetVodDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStartVodDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchStartVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchStartVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStartVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchStartVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStopVodDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchStopVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchStopVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStopVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchStopVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelUrlUploadJobsRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadUrls: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadUrls != nil {
            map["UploadUrls"] = self.uploadUrls!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadUrls") {
            self.uploadUrls = dict["UploadUrls"] as! String
        }
    }
}

public class CancelUrlUploadJobsResponseBody : Tea.TeaModel {
    public var canceledJobs: [String]?

    public var nonExists: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canceledJobs != nil {
            map["CanceledJobs"] = self.canceledJobs!
        }
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanceledJobs") {
            self.canceledJobs = dict["CanceledJobs"] as! [String]
        }
        if dict.keys.contains("NonExists") {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelUrlUploadJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelUrlUploadJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelUrlUploadJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var description_: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateAppInfoResponseBody : Tea.TeaModel {
    public var appId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuditContent") {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadAttachedMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var businessType: String?

    public var cateIds: String?

    public var description_: String?

    public var fileName: String?

    public var fileSize: String?

    public var mediaExt: String?

    public var storageLocation: String?

    public var tags: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateIds != nil {
            map["CateIds"] = self.cateIds!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSize != nil {
            map["FileSize"] = self.fileSize!
        }
        if self.mediaExt != nil {
            map["MediaExt"] = self.mediaExt!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateIds") {
            self.cateIds = dict["CateIds"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSize") {
            self.fileSize = dict["FileSize"] as! String
        }
        if dict.keys.contains("MediaExt") {
            self.mediaExt = dict["MediaExt"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadAttachedMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadAttachedMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadAttachedMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadAttachedMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadImageRequest : Tea.TeaModel {
    public var appId: String?

    public var cateId: Int64?

    public var description_: String?

    public var imageExt: String?

    public var imageType: String?

    public var originalFileName: String?

    public var storageLocation: String?

    public var tags: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageExt != nil {
            map["ImageExt"] = self.imageExt!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.originalFileName != nil {
            map["OriginalFileName"] = self.originalFileName!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageExt") {
            self.imageExt = dict["ImageExt"] as! String
        }
        if dict.keys.contains("ImageType") {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("OriginalFileName") {
            self.originalFileName = dict["OriginalFileName"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadImageResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var imageId: String?

    public var imageURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageURL != nil {
            map["ImageURL"] = self.imageURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageURL") {
            self.imageURL = dict["ImageURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadVideoRequest : Tea.TeaModel {
    public var appId: String?

    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var fileName: String?

    public var fileSize: Int64?

    public var storageLocation: String?

    public var tags: String?

    public var templateGroupId: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSize != nil {
            map["FileSize"] = self.fileSize!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSize") {
            self.fileSize = dict["FileSize"] as! Int64
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TemplateGroupId") {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class CreateUploadVideoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class CreateUploadVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUploadVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DecryptKMSDataKeyRequest : Tea.TeaModel {
    public var cipherText: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherText != nil {
            map["CipherText"] = self.cipherText!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherText") {
            self.cipherText = dict["CipherText"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponseBody : Tea.TeaModel {
    public var keyId: String?

    public var plaintext: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.plaintext != nil {
            map["Plaintext"] = self.plaintext!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyId") {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("Plaintext") {
            self.plaintext = dict["Plaintext"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DecryptKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DecryptKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAIImageInfosRequest : Tea.TeaModel {
    public var AIImageInfoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageInfoIds != nil {
            map["AIImageInfoIds"] = self.AIImageInfoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageInfoIds") {
            self.AIImageInfoIds = dict["AIImageInfoIds"] as! String
        }
    }
}

public class DeleteAIImageInfosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAIImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAIImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAIImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteAppInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAttachedMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteAttachedMediaResponseBody : Tea.TeaModel {
    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistMediaIds") {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAttachedMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAttachedMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAttachedMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDynamicImageRequest : Tea.TeaModel {
    public var dynamicImageIds: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageIds != nil {
            map["DynamicImageIds"] = self.dynamicImageIds!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageIds") {
            self.dynamicImageIds = dict["DynamicImageIds"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteDynamicImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDynamicImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDynamicImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDynamicImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var projectIds: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DeleteEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var deleteImageType: String?

    public var imageIds: String?

    public var imageType: String?

    public var imageURLs: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteImageType != nil {
            map["DeleteImageType"] = self.deleteImageType!
        }
        if self.imageIds != nil {
            map["ImageIds"] = self.imageIds!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.imageURLs != nil {
            map["ImageURLs"] = self.imageURLs!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteImageType") {
            self.deleteImageType = dict["DeleteImageType"] as! String
        }
        if dict.keys.contains("ImageIds") {
            self.imageIds = dict["ImageIds"] as! String
        }
        if dict.keys.contains("ImageType") {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("ImageURLs") {
            self.imageURLs = dict["ImageURLs"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class DeleteMessageCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMezzaninesRequest : Tea.TeaModel {
    public var force: Bool?

    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("VideoIds") {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class DeleteMezzaninesResponseBody : Tea.TeaModel {
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var unRemoveableVideoIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unRemoveableVideoIds != nil {
            map["UnRemoveableVideoIds"] = self.unRemoveableVideoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnRemoveableVideoIds") {
            self.unRemoveableVideoIds = dict["UnRemoveableVideoIds"] as! [String]
        }
    }
}

public class DeleteMezzaninesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMezzaninesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMezzaninesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMultipartUploadRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaType: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class DeleteMultipartUploadResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMultipartUploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMultipartUploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMultipartUploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStreamRequest : Tea.TeaModel {
    public var jobIds: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var forceDelGroup: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelGroup != nil {
            map["ForceDelGroup"] = self.forceDelGroup!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateIds != nil {
            map["TranscodeTemplateIds"] = self.transcodeTemplateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceDelGroup") {
            self.forceDelGroup = dict["ForceDelGroup"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateIds") {
            self.transcodeTemplateIds = dict["TranscodeTemplateIds"] as! String
        }
    }
}

public class DeleteTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var nonExistTranscodeTemplateIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistTranscodeTemplateIds != nil {
            map["NonExistTranscodeTemplateIds"] = self.nonExistTranscodeTemplateIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistTranscodeTemplateIds") {
            self.nonExistTranscodeTemplateIds = dict["NonExistTranscodeTemplateIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVideoRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class DeleteVideoResponseBody : Tea.TeaModel {
    public var forbiddenVideoIds: [String]?

    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenVideoIds != nil {
            map["ForbiddenVideoIds"] = self.forbiddenVideoIds!
        }
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenVideoIds") {
            self.forbiddenVideoIds = dict["ForbiddenVideoIds"] as! [String]
        }
        if dict.keys.contains("NonExistVideoIds") {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodSpecificConfigRequest : Tea.TeaModel {
    public var configId: String?

    public var domainName: String?

    public var env: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Env") {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteVodSpecificConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodSpecificConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodSpecificConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodSpecificConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodTemplateRequest : Tea.TeaModel {
    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class DeleteVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class DeleteVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class DeleteWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayTopVideosRequest : Tea.TeaModel {
    public var bizDate: String?

    public var ownerId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribePlayTopVideosResponseBody : Tea.TeaModel {
    public class TopPlayVideos : Tea.TeaModel {
        public class TopPlayVideoStatis : Tea.TeaModel {
            public var playDuration: String?

            public var title: String?

            public var UV: String?

            public var VV: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                if self.VV != nil {
                    map["VV"] = self.VV!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PlayDuration") {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UV") {
                    self.UV = dict["UV"] as! String
                }
                if dict.keys.contains("VV") {
                    self.VV = dict["VV"] as! String
                }
                if dict.keys.contains("VideoId") {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var topPlayVideoStatis: [DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topPlayVideoStatis != nil {
                var tmp : [Any] = []
                for k in self.topPlayVideoStatis! {
                    tmp.append(k.toMap())
                }
                map["TopPlayVideoStatis"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TopPlayVideoStatis") {
                var tmp : [DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis] = []
                for v in dict["TopPlayVideoStatis"] as! [Any] {
                    var model = DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topPlayVideoStatis = tmp
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var topPlayVideos: DescribePlayTopVideosResponseBody.TopPlayVideos?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topPlayVideos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.topPlayVideos != nil {
            map["TopPlayVideos"] = self.topPlayVideos?.toMap()
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TopPlayVideos") {
            var model = DescribePlayTopVideosResponseBody.TopPlayVideos()
            model.fromMap(dict["TopPlayVideos"] as! [String: Any])
            self.topPlayVideos = model
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayTopVideosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayTopVideosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayTopVideosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayUserAvgRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribePlayUserAvgResponseBody : Tea.TeaModel {
    public class UserPlayStatisAvgs : Tea.TeaModel {
        public class UserPlayStatisAvg : Tea.TeaModel {
            public var avgPlayCount: String?

            public var avgPlayDuration: String?

            public var date: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgPlayCount != nil {
                    map["AvgPlayCount"] = self.avgPlayCount!
                }
                if self.avgPlayDuration != nil {
                    map["AvgPlayDuration"] = self.avgPlayDuration!
                }
                if self.date != nil {
                    map["Date"] = self.date!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgPlayCount") {
                    self.avgPlayCount = dict["AvgPlayCount"] as! String
                }
                if dict.keys.contains("AvgPlayDuration") {
                    self.avgPlayDuration = dict["AvgPlayDuration"] as! String
                }
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
            }
        }
        public var userPlayStatisAvg: [DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPlayStatisAvg != nil {
                var tmp : [Any] = []
                for k in self.userPlayStatisAvg! {
                    tmp.append(k.toMap())
                }
                map["UserPlayStatisAvg"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPlayStatisAvg") {
                var tmp : [DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg] = []
                for v in dict["UserPlayStatisAvg"] as! [Any] {
                    var model = DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPlayStatisAvg = tmp
            }
        }
    }
    public var requestId: String?

    public var userPlayStatisAvgs: DescribePlayUserAvgResponseBody.UserPlayStatisAvgs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPlayStatisAvgs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userPlayStatisAvgs != nil {
            map["UserPlayStatisAvgs"] = self.userPlayStatisAvgs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserPlayStatisAvgs") {
            var model = DescribePlayUserAvgResponseBody.UserPlayStatisAvgs()
            model.fromMap(dict["UserPlayStatisAvgs"] as! [String: Any])
            self.userPlayStatisAvgs = model
        }
    }
}

public class DescribePlayUserAvgResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayUserAvgResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayUserAvgResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayUserTotalRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribePlayUserTotalResponseBody : Tea.TeaModel {
    public class UserPlayStatisTotals : Tea.TeaModel {
        public class UserPlayStatisTotal : Tea.TeaModel {
            public class UV : Tea.TeaModel {
                public var android: String?

                public var flash: String?

                public var HTML5: String?

                public var iOS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.android != nil {
                        map["Android"] = self.android!
                    }
                    if self.flash != nil {
                        map["Flash"] = self.flash!
                    }
                    if self.HTML5 != nil {
                        map["HTML5"] = self.HTML5!
                    }
                    if self.iOS != nil {
                        map["iOS"] = self.iOS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Android") {
                        self.android = dict["Android"] as! String
                    }
                    if dict.keys.contains("Flash") {
                        self.flash = dict["Flash"] as! String
                    }
                    if dict.keys.contains("HTML5") {
                        self.HTML5 = dict["HTML5"] as! String
                    }
                    if dict.keys.contains("iOS") {
                        self.iOS = dict["iOS"] as! String
                    }
                }
            }
            public class VV : Tea.TeaModel {
                public var android: String?

                public var flash: String?

                public var HTML5: String?

                public var iOS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.android != nil {
                        map["Android"] = self.android!
                    }
                    if self.flash != nil {
                        map["Flash"] = self.flash!
                    }
                    if self.HTML5 != nil {
                        map["HTML5"] = self.HTML5!
                    }
                    if self.iOS != nil {
                        map["iOS"] = self.iOS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Android") {
                        self.android = dict["Android"] as! String
                    }
                    if dict.keys.contains("Flash") {
                        self.flash = dict["Flash"] as! String
                    }
                    if dict.keys.contains("HTML5") {
                        self.HTML5 = dict["HTML5"] as! String
                    }
                    if dict.keys.contains("iOS") {
                        self.iOS = dict["iOS"] as! String
                    }
                }
            }
            public var date: String?

            public var playDuration: String?

            public var playRange: String?

            public var UV: DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.UV?

            public var VV: DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.VV?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.UV?.validate()
                try self.VV?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.playRange != nil {
                    map["PlayRange"] = self.playRange!
                }
                if self.UV != nil {
                    map["UV"] = self.UV?.toMap()
                }
                if self.VV != nil {
                    map["VV"] = self.VV?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("PlayDuration") {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("PlayRange") {
                    self.playRange = dict["PlayRange"] as! String
                }
                if dict.keys.contains("UV") {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.UV()
                    model.fromMap(dict["UV"] as! [String: Any])
                    self.UV = model
                }
                if dict.keys.contains("VV") {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.VV()
                    model.fromMap(dict["VV"] as! [String: Any])
                    self.VV = model
                }
            }
        }
        public var userPlayStatisTotal: [DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPlayStatisTotal != nil {
                var tmp : [Any] = []
                for k in self.userPlayStatisTotal! {
                    tmp.append(k.toMap())
                }
                map["UserPlayStatisTotal"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPlayStatisTotal") {
                var tmp : [DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal] = []
                for v in dict["UserPlayStatisTotal"] as! [Any] {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPlayStatisTotal = tmp
            }
        }
    }
    public var requestId: String?

    public var userPlayStatisTotals: DescribePlayUserTotalResponseBody.UserPlayStatisTotals?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPlayStatisTotals?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userPlayStatisTotals != nil {
            map["UserPlayStatisTotals"] = self.userPlayStatisTotals?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserPlayStatisTotals") {
            var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals()
            model.fromMap(dict["UserPlayStatisTotals"] as! [String: Any])
            self.userPlayStatisTotals = model
        }
    }
}

public class DescribePlayUserTotalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayUserTotalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayUserTotalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayVideoStatisRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DescribePlayVideoStatisResponseBody : Tea.TeaModel {
    public class VideoPlayStatisDetails : Tea.TeaModel {
        public class VideoPlayStatisDetail : Tea.TeaModel {
            public var date: String?

            public var playDuration: String?

            public var playRange: String?

            public var title: String?

            public var UV: String?

            public var VV: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.playRange != nil {
                    map["PlayRange"] = self.playRange!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                if self.VV != nil {
                    map["VV"] = self.VV!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("PlayDuration") {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("PlayRange") {
                    self.playRange = dict["PlayRange"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UV") {
                    self.UV = dict["UV"] as! String
                }
                if dict.keys.contains("VV") {
                    self.VV = dict["VV"] as! String
                }
            }
        }
        public var videoPlayStatisDetail: [DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoPlayStatisDetail != nil {
                var tmp : [Any] = []
                for k in self.videoPlayStatisDetail! {
                    tmp.append(k.toMap())
                }
                map["VideoPlayStatisDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VideoPlayStatisDetail") {
                var tmp : [DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail] = []
                for v in dict["VideoPlayStatisDetail"] as! [Any] {
                    var model = DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoPlayStatisDetail = tmp
            }
        }
    }
    public var requestId: String?

    public var videoPlayStatisDetails: DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoPlayStatisDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoPlayStatisDetails != nil {
            map["VideoPlayStatisDetails"] = self.videoPlayStatisDetails?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoPlayStatisDetails") {
            var model = DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails()
            model.fromMap(dict["VideoPlayStatisDetails"] as! [String: Any])
            self.videoPlayStatisDetails = model
        }
    }
}

public class DescribePlayVideoStatisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayVideoStatisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePlayVideoStatisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodAIDataRequest : Tea.TeaModel {
    public var AIType: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIType != nil {
            map["AIType"] = self.AIType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIType") {
            self.AIType = dict["AIType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodAIDataResponseBody : Tea.TeaModel {
    public class AIData : Tea.TeaModel {
        public class AIDataItem : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public class DataItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var dataItem: [DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataItem != nil {
                        var tmp : [Any] = []
                        for k in self.dataItem! {
                            tmp.append(k.toMap())
                        }
                        map["DataItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataItem") {
                        var tmp : [DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem] = []
                        for v in dict["DataItem"] as! [Any] {
                            var model = DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataItem = tmp
                    }
                }
            }
            public var data: DescribeVodAIDataResponseBody.AIData.AIDataItem.Data?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    var model = DescribeVodAIDataResponseBody.AIData.AIDataItem.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var AIDataItem: [DescribeVodAIDataResponseBody.AIData.AIDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIDataItem != nil {
                var tmp : [Any] = []
                for k in self.AIDataItem! {
                    tmp.append(k.toMap())
                }
                map["AIDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIDataItem") {
                var tmp : [DescribeVodAIDataResponseBody.AIData.AIDataItem] = []
                for v in dict["AIDataItem"] as! [Any] {
                    var model = DescribeVodAIDataResponseBody.AIData.AIDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIDataItem = tmp
            }
        }
    }
    public var AIData: DescribeVodAIDataResponseBody.AIData?

    public var dataInterval: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIData != nil {
            map["AIData"] = self.AIData?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIData") {
            var model = DescribeVodAIDataResponseBody.AIData()
            model.fromMap(dict["AIData"] as! [String: Any])
            self.AIData = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodAIDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodAIDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodAIDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodCertificateListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodCertificateListResponseBody : Tea.TeaModel {
    public class CertificateListModel : Tea.TeaModel {
        public class CertList : Tea.TeaModel {
            public class Cert : Tea.TeaModel {
                public var algorithm: String?

                public var certId: Int64?

                public var certIdentifier: String?

                public var certName: String?

                public var common: String?

                public var createTime: Int64?

                public var domainMatchCert: Bool?

                public var endTime: Int64?

                public var fingerprint: String?

                public var instanceId: String?

                public var issuer: String?

                public var lastTime: Int64?

                public var signAlgorithm: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithm != nil {
                        map["Algorithm"] = self.algorithm!
                    }
                    if self.certId != nil {
                        map["CertId"] = self.certId!
                    }
                    if self.certIdentifier != nil {
                        map["CertIdentifier"] = self.certIdentifier!
                    }
                    if self.certName != nil {
                        map["CertName"] = self.certName!
                    }
                    if self.common != nil {
                        map["Common"] = self.common!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.domainMatchCert != nil {
                        map["DomainMatchCert"] = self.domainMatchCert!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.fingerprint != nil {
                        map["Fingerprint"] = self.fingerprint!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.lastTime != nil {
                        map["LastTime"] = self.lastTime!
                    }
                    if self.signAlgorithm != nil {
                        map["SignAlgorithm"] = self.signAlgorithm!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Algorithm") {
                        self.algorithm = dict["Algorithm"] as! String
                    }
                    if dict.keys.contains("CertId") {
                        self.certId = dict["CertId"] as! Int64
                    }
                    if dict.keys.contains("CertIdentifier") {
                        self.certIdentifier = dict["CertIdentifier"] as! String
                    }
                    if dict.keys.contains("CertName") {
                        self.certName = dict["CertName"] as! String
                    }
                    if dict.keys.contains("Common") {
                        self.common = dict["Common"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("DomainMatchCert") {
                        self.domainMatchCert = dict["DomainMatchCert"] as! Bool
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("Fingerprint") {
                        self.fingerprint = dict["Fingerprint"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Issuer") {
                        self.issuer = dict["Issuer"] as! String
                    }
                    if dict.keys.contains("LastTime") {
                        self.lastTime = dict["LastTime"] as! Int64
                    }
                    if dict.keys.contains("SignAlgorithm") {
                        self.signAlgorithm = dict["SignAlgorithm"] as! String
                    }
                }
            }
            public var cert: [DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cert != nil {
                    var tmp : [Any] = []
                    for k in self.cert! {
                        tmp.append(k.toMap())
                    }
                    map["Cert"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cert") {
                    var tmp : [DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert] = []
                    for v in dict["Cert"] as! [Any] {
                        var model = DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.cert = tmp
                }
            }
        }
        public var certList: DescribeVodCertificateListResponseBody.CertificateListModel.CertList?

        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.certList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certList != nil {
                map["CertList"] = self.certList?.toMap()
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertList") {
                var model = DescribeVodCertificateListResponseBody.CertificateListModel.CertList()
                model.fromMap(dict["CertList"] as! [String: Any])
                self.certList = model
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
        }
    }
    public var certificateListModel: DescribeVodCertificateListResponseBody.CertificateListModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certificateListModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateListModel != nil {
            map["CertificateListModel"] = self.certificateListModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateListModel") {
            var model = DescribeVodCertificateListResponseBody.CertificateListModel()
            model.fromMap(dict["CertificateListModel"] as! [String: Any])
            self.certificateListModel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodCertificateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodCertificateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodCertificateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var domesticValue: String?

            public var httpsDomesticValue: String?

            public var httpsOverseasValue: String?

            public var httpsValue: String?

            public var overseasValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domesticValue != nil {
                    map["DomesticValue"] = self.domesticValue!
                }
                if self.httpsDomesticValue != nil {
                    map["HttpsDomesticValue"] = self.httpsDomesticValue!
                }
                if self.httpsOverseasValue != nil {
                    map["HttpsOverseasValue"] = self.httpsOverseasValue!
                }
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.overseasValue != nil {
                    map["OverseasValue"] = self.overseasValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomesticValue") {
                    self.domesticValue = dict["DomesticValue"] as! String
                }
                if dict.keys.contains("HttpsDomesticValue") {
                    self.httpsDomesticValue = dict["HttpsDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsOverseasValue") {
                    self.httpsOverseasValue = dict["HttpsOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("OverseasValue") {
                    self.overseasValue = dict["OverseasValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataPerInterval: DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataPerInterval") {
            var model = DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(dict["BpsDataPerInterval"] as! [String: Any])
            self.bpsDataPerInterval = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainBpsDataByLayerRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var layer: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.layer != nil {
            map["Layer"] = self.layer!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("Layer") {
            self.layer = dict["Layer"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataByLayerResponseBody : Tea.TeaModel {
    public class BpsDataInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var trafficValue: Int64?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("TrafficValue") {
                    self.trafficValue = dict["TrafficValue"] as! Int64
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Double
                }
            }
        }
        public var dataModule: [DescribeVodDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataInterval: DescribeVodDomainBpsDataByLayerResponseBody.BpsDataInterval?

    public var dataInterval: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataInterval != nil {
            map["BpsDataInterval"] = self.bpsDataInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataInterval") {
            var model = DescribeVodDomainBpsDataByLayerResponseBody.BpsDataInterval()
            model.fromMap(dict["BpsDataInterval"] as! [String: Any])
            self.bpsDataInterval = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataByLayerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainBpsDataByLayerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainBpsDataByLayerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainCertificateInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeVodDomainCertificateInfoResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certDomainName: String?

            public var certExpireTime: String?

            public var certLife: String?

            public var certName: String?

            public var certOrg: String?

            public var certType: String?

            public var domainName: String?

            public var serverCertificateStatus: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certDomainName != nil {
                    map["CertDomainName"] = self.certDomainName!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certLife != nil {
                    map["CertLife"] = self.certLife!
                }
                if self.certName != nil {
                    map["CertName"] = self.certName!
                }
                if self.certOrg != nil {
                    map["CertOrg"] = self.certOrg!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.serverCertificateStatus != nil {
                    map["ServerCertificateStatus"] = self.serverCertificateStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CertDomainName") {
                    self.certDomainName = dict["CertDomainName"] as! String
                }
                if dict.keys.contains("CertExpireTime") {
                    self.certExpireTime = dict["CertExpireTime"] as! String
                }
                if dict.keys.contains("CertLife") {
                    self.certLife = dict["CertLife"] as! String
                }
                if dict.keys.contains("CertName") {
                    self.certName = dict["CertName"] as! String
                }
                if dict.keys.contains("CertOrg") {
                    self.certOrg = dict["CertOrg"] as! String
                }
                if dict.keys.contains("CertType") {
                    self.certType = dict["CertType"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("ServerCertificateStatus") {
                    self.serverCertificateStatus = dict["ServerCertificateStatus"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certInfo: [DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertInfo") {
                var tmp : [DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo] = []
                for v in dict["CertInfo"] as! [Any] {
                    var model = DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certInfo = tmp
            }
        }
    }
    public var certInfos: DescribeVodDomainCertificateInfoResponseBody.CertInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertInfos") {
            var model = DescribeVodDomainCertificateInfoResponseBody.CertInfos()
            model.fromMap(dict["CertInfos"] as! [String: Any])
            self.certInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainCertificateInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainCertificateInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainCertificateInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionNames") {
            self.functionNames = dict["FunctionNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodDomainConfigsResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class DomainConfig : Tea.TeaModel {
            public class FunctionArgs : Tea.TeaModel {
                public class FunctionArg : Tea.TeaModel {
                    public var argName: String?

                    public var argValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.argName != nil {
                            map["ArgName"] = self.argName!
                        }
                        if self.argValue != nil {
                            map["ArgValue"] = self.argValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArgName") {
                            self.argName = dict["ArgName"] as! String
                        }
                        if dict.keys.contains("ArgValue") {
                            self.argValue = dict["ArgValue"] as! String
                        }
                    }
                }
                public var functionArg: [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.functionArg != nil {
                        var tmp : [Any] = []
                        for k in self.functionArg! {
                            tmp.append(k.toMap())
                        }
                        map["FunctionArg"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FunctionArg") {
                        var tmp : [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg] = []
                        for v in dict["FunctionArg"] as! [Any] {
                            var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.functionArg = tmp
                    }
                }
            }
            public var configId: String?

            public var functionArgs: DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs?

            public var functionName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.functionArgs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.functionArgs != nil {
                    map["FunctionArgs"] = self.functionArgs?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigId") {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("FunctionArgs") {
                    var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs()
                    model.fromMap(dict["FunctionArgs"] as! [String: Any])
                    self.functionArgs = model
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var domainConfig: [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainConfig != nil {
                var tmp : [Any] = []
                for k in self.domainConfig! {
                    tmp.append(k.toMap())
                }
                map["DomainConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainConfig") {
                var tmp : [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig] = []
                for v in dict["DomainConfig"] as! [Any] {
                    var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainConfig = tmp
            }
        }
    }
    public var domainConfigs: DescribeVodDomainConfigsResponseBody.DomainConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            map["DomainConfigs"] = self.domainConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainConfigs") {
            var model = DescribeVodDomainConfigsResponseBody.DomainConfigs()
            model.fromMap(dict["DomainConfigs"] as! [String: Any])
            self.domainConfigs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainDetailRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodDomainDetailResponseBody : Tea.TeaModel {
    public class DomainDetail : Tea.TeaModel {
        public class Sources : Tea.TeaModel {
            public class Source : Tea.TeaModel {
                public var content: String?

                public var enabled: String?

                public var port: Int32?

                public var priority: String?

                public var type: String?

                public var weight: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.enabled != nil {
                        map["Enabled"] = self.enabled!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.weight != nil {
                        map["Weight"] = self.weight!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Enabled") {
                        self.enabled = dict["Enabled"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Weight") {
                        self.weight = dict["Weight"] as! String
                    }
                }
            }
            public var source: [DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.source != nil {
                    var tmp : [Any] = []
                    for k in self.source! {
                        tmp.append(k.toMap())
                    }
                    map["Source"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Source") {
                    var tmp : [DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source] = []
                    for v in dict["Source"] as! [Any] {
                        var model = DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.source = tmp
                }
            }
        }
        public var certName: String?

        public var cname: String?

        public var description_: String?

        public var domainName: String?

        public var domainStatus: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var SSLProtocol: String?

        public var SSLPub: String?

        public var scope: String?

        public var sources: DescribeVodDomainDetailResponseBody.DomainDetail.Sources?

        public var weight: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sources?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.cname != nil {
                map["Cname"] = self.cname!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainStatus != nil {
                map["DomainStatus"] = self.domainStatus!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.SSLProtocol != nil {
                map["SSLProtocol"] = self.SSLProtocol!
            }
            if self.SSLPub != nil {
                map["SSLPub"] = self.SSLPub!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.sources != nil {
                map["Sources"] = self.sources?.toMap()
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("Cname") {
                self.cname = dict["Cname"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainStatus") {
                self.domainStatus = dict["DomainStatus"] as! String
            }
            if dict.keys.contains("GmtCreated") {
                self.gmtCreated = dict["GmtCreated"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("SSLProtocol") {
                self.SSLProtocol = dict["SSLProtocol"] as! String
            }
            if dict.keys.contains("SSLPub") {
                self.SSLPub = dict["SSLPub"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("Sources") {
                var model = DescribeVodDomainDetailResponseBody.DomainDetail.Sources()
                model.fromMap(dict["Sources"] as! [String: Any])
                self.sources = model
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! String
            }
        }
    }
    public var domainDetail: DescribeVodDomainDetailResponseBody.DomainDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainDetail != nil {
            map["DomainDetail"] = self.domainDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainDetail") {
            var model = DescribeVodDomainDetailResponseBody.DomainDetail()
            model.fromMap(dict["DomainDetail"] as! [String: Any])
            self.domainDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainHitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainHitRateDataResponseBody : Tea.TeaModel {
    public class HitRateInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainHitRateDataResponseBody.HitRateInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainHitRateDataResponseBody.HitRateInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainHitRateDataResponseBody.HitRateInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var hitRateInterval: DescribeVodDomainHitRateDataResponseBody.HitRateInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hitRateInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.hitRateInterval != nil {
            map["HitRateInterval"] = self.hitRateInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("HitRateInterval") {
            var model = DescribeVodDomainHitRateDataResponseBody.HitRateInterval()
            model.fromMap(dict["HitRateInterval"] as! [String: Any])
            self.hitRateInterval = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainHitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainHitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainHitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("LogName") {
                            self.logName = dict["LogName"] as! String
                        }
                        if dict.keys.contains("LogPath") {
                            self.logPath = dict["LogPath"] as! String
                        }
                        if dict.keys.contains("LogSize") {
                            self.logSize = dict["LogSize"] as! Int64
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var logInfoDetail: [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogInfoDetail") {
                        var tmp : [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in dict["LogInfoDetail"] as! [Any] {
                            var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageNumber: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageNumber != nil {
                        map["PageNumber"] = self.pageNumber!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PageNumber") {
                        self.pageNumber = dict["PageNumber"] as! Int64
                    }
                    if dict.keys.contains("PageSize") {
                        self.pageSize = dict["PageSize"] as! Int64
                    }
                    if dict.keys.contains("Total") {
                        self.total = dict["Total"] as! Int64
                    }
                }
            }
            public var domainName: String?

            public var logCount: Int64?

            public var logInfos: DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("LogCount") {
                    self.logCount = dict["LogCount"] as! Int64
                }
                if dict.keys.contains("LogInfos") {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(dict["LogInfos"] as! [String: Any])
                    self.logInfos = model
                }
                if dict.keys.contains("PageInfos") {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(dict["PageInfos"] as! [String: Any])
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainLogDetail") {
                var tmp : [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in dict["DomainLogDetail"] as! [Any] {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeVodDomainLogResponseBody.DomainLogDetails?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLogDetails") {
            var model = DescribeVodDomainLogResponseBody.DomainLogDetails()
            model.fromMap(dict["DomainLogDetails"] as! [String: Any])
            self.domainLogDetails = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainMax95BpsDataRequest : Tea.TeaModel {
    public var cycle: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var timePoint: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cycle != nil {
            map["Cycle"] = self.cycle!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.timePoint != nil {
            map["TimePoint"] = self.timePoint!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cycle") {
            self.cycle = dict["Cycle"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TimePoint") {
            self.timePoint = dict["TimePoint"] as! String
        }
    }
}

public class DescribeVodDomainMax95BpsDataResponseBody : Tea.TeaModel {
    public class DetailData : Tea.TeaModel {
        public class Max95Detail : Tea.TeaModel {
            public var area: String?

            public var max95Bps: Double?

            public var max95BpsPeakTime: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.max95Bps != nil {
                    map["Max95Bps"] = self.max95Bps!
                }
                if self.max95BpsPeakTime != nil {
                    map["Max95BpsPeakTime"] = self.max95BpsPeakTime!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("Max95Bps") {
                    self.max95Bps = dict["Max95Bps"] as! Double
                }
                if dict.keys.contains("Max95BpsPeakTime") {
                    self.max95BpsPeakTime = dict["Max95BpsPeakTime"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var max95Detail: [DescribeVodDomainMax95BpsDataResponseBody.DetailData.Max95Detail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.max95Detail != nil {
                var tmp : [Any] = []
                for k in self.max95Detail! {
                    tmp.append(k.toMap())
                }
                map["Max95Detail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Max95Detail") {
                var tmp : [DescribeVodDomainMax95BpsDataResponseBody.DetailData.Max95Detail] = []
                for v in dict["Max95Detail"] as! [Any] {
                    var model = DescribeVodDomainMax95BpsDataResponseBody.DetailData.Max95Detail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.max95Detail = tmp
            }
        }
    }
    public var detailData: DescribeVodDomainMax95BpsDataResponseBody.DetailData?

    public var domainName: String?

    public var domesticMax95Bps: String?

    public var endTime: String?

    public var max95Bps: String?

    public var overseasMax95Bps: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detailData != nil {
            map["DetailData"] = self.detailData?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domesticMax95Bps != nil {
            map["DomesticMax95Bps"] = self.domesticMax95Bps!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.max95Bps != nil {
            map["Max95Bps"] = self.max95Bps!
        }
        if self.overseasMax95Bps != nil {
            map["OverseasMax95Bps"] = self.overseasMax95Bps!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DetailData") {
            var model = DescribeVodDomainMax95BpsDataResponseBody.DetailData()
            model.fromMap(dict["DetailData"] as! [String: Any])
            self.detailData = model
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomesticMax95Bps") {
            self.domesticMax95Bps = dict["DomesticMax95Bps"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Max95Bps") {
            self.max95Bps = dict["Max95Bps"] as! String
        }
        if dict.keys.contains("OverseasMax95Bps") {
            self.overseasMax95Bps = dict["OverseasMax95Bps"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainMax95BpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainMax95BpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainMax95BpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainQpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainQpsDataResponseBody : Tea.TeaModel {
    public class QpsDataInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var accDomesticValue: String?

            public var accOverseasValue: String?

            public var accValue: String?

            public var domesticValue: String?

            public var httpsAccDomesticValue: String?

            public var httpsAccOverseasValue: String?

            public var httpsAccValue: String?

            public var httpsDomesticValue: String?

            public var httpsOverseasValue: String?

            public var httpsValue: String?

            public var overseasValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accDomesticValue != nil {
                    map["AccDomesticValue"] = self.accDomesticValue!
                }
                if self.accOverseasValue != nil {
                    map["AccOverseasValue"] = self.accOverseasValue!
                }
                if self.accValue != nil {
                    map["AccValue"] = self.accValue!
                }
                if self.domesticValue != nil {
                    map["DomesticValue"] = self.domesticValue!
                }
                if self.httpsAccDomesticValue != nil {
                    map["HttpsAccDomesticValue"] = self.httpsAccDomesticValue!
                }
                if self.httpsAccOverseasValue != nil {
                    map["HttpsAccOverseasValue"] = self.httpsAccOverseasValue!
                }
                if self.httpsAccValue != nil {
                    map["HttpsAccValue"] = self.httpsAccValue!
                }
                if self.httpsDomesticValue != nil {
                    map["HttpsDomesticValue"] = self.httpsDomesticValue!
                }
                if self.httpsOverseasValue != nil {
                    map["HttpsOverseasValue"] = self.httpsOverseasValue!
                }
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.overseasValue != nil {
                    map["OverseasValue"] = self.overseasValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccDomesticValue") {
                    self.accDomesticValue = dict["AccDomesticValue"] as! String
                }
                if dict.keys.contains("AccOverseasValue") {
                    self.accOverseasValue = dict["AccOverseasValue"] as! String
                }
                if dict.keys.contains("AccValue") {
                    self.accValue = dict["AccValue"] as! String
                }
                if dict.keys.contains("DomesticValue") {
                    self.domesticValue = dict["DomesticValue"] as! String
                }
                if dict.keys.contains("HttpsAccDomesticValue") {
                    self.httpsAccDomesticValue = dict["HttpsAccDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsAccOverseasValue") {
                    self.httpsAccOverseasValue = dict["HttpsAccOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsAccValue") {
                    self.httpsAccValue = dict["HttpsAccValue"] as! String
                }
                if dict.keys.contains("HttpsDomesticValue") {
                    self.httpsDomesticValue = dict["HttpsDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsOverseasValue") {
                    self.httpsOverseasValue = dict["HttpsOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("OverseasValue") {
                    self.overseasValue = dict["OverseasValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainQpsDataResponseBody.QpsDataInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainQpsDataResponseBody.QpsDataInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainQpsDataResponseBody.QpsDataInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var qpsDataInterval: DescribeVodDomainQpsDataResponseBody.QpsDataInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.qpsDataInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.qpsDataInterval != nil {
            map["QpsDataInterval"] = self.qpsDataInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("QpsDataInterval") {
            var model = DescribeVodDomainQpsDataResponseBody.QpsDataInterval()
            model.fromMap(dict["QpsDataInterval"] as! [String: Any])
            self.qpsDataInterval = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainQpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainQpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainQpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeBpsDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BpsModel : Tea.TeaModel {
            public var bps: Double?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bps != nil {
                    map["Bps"] = self.bps!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bps") {
                    self.bps = dict["Bps"] as! Double
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var bpsModel: [DescribeVodDomainRealTimeBpsDataResponseBody.Data.BpsModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bpsModel != nil {
                var tmp : [Any] = []
                for k in self.bpsModel! {
                    tmp.append(k.toMap())
                }
                map["BpsModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BpsModel") {
                var tmp : [DescribeVodDomainRealTimeBpsDataResponseBody.Data.BpsModel] = []
                for v in dict["BpsModel"] as! [Any] {
                    var model = DescribeVodDomainRealTimeBpsDataResponseBody.Data.BpsModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bpsModel = tmp
            }
        }
    }
    public var data: DescribeVodDomainRealTimeBpsDataResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeVodDomainRealTimeBpsDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeByteHitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeByteHitRateDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ByteHitRateDataModel : Tea.TeaModel {
            public var byteHitRate: Double?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.byteHitRate != nil {
                    map["ByteHitRate"] = self.byteHitRate!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ByteHitRate") {
                    self.byteHitRate = dict["ByteHitRate"] as! Double
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var byteHitRateDataModel: [DescribeVodDomainRealTimeByteHitRateDataResponseBody.Data.ByteHitRateDataModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.byteHitRateDataModel != nil {
                var tmp : [Any] = []
                for k in self.byteHitRateDataModel! {
                    tmp.append(k.toMap())
                }
                map["ByteHitRateDataModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ByteHitRateDataModel") {
                var tmp : [DescribeVodDomainRealTimeByteHitRateDataResponseBody.Data.ByteHitRateDataModel] = []
                for v in dict["ByteHitRateDataModel"] as! [Any] {
                    var model = DescribeVodDomainRealTimeByteHitRateDataResponseBody.Data.ByteHitRateDataModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.byteHitRateDataModel = tmp
            }
        }
    }
    public var data: DescribeVodDomainRealTimeByteHitRateDataResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeVodDomainRealTimeByteHitRateDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeByteHitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeByteHitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeByteHitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeDetailDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var field: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var merge: String?

    public var mergeLocIsp: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.field != nil {
            map["Field"] = self.field!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.merge != nil {
            map["Merge"] = self.merge!
        }
        if self.mergeLocIsp != nil {
            map["MergeLocIsp"] = self.mergeLocIsp!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Field") {
            self.field = dict["Field"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("Merge") {
            self.merge = dict["Merge"] as! String
        }
        if dict.keys.contains("MergeLocIsp") {
            self.mergeLocIsp = dict["MergeLocIsp"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeDetailDataResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeDetailDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeHttpCodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeHttpCodeDataResponseBody : Tea.TeaModel {
    public class RealTimeHttpCodeData : Tea.TeaModel {
        public class UsageData : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public class RealTimeCodeProportionData : Tea.TeaModel {
                    public var code: String?

                    public var count: String?

                    public var proportion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.proportion != nil {
                            map["Proportion"] = self.proportion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("Proportion") {
                            self.proportion = dict["Proportion"] as! String
                        }
                    }
                }
                public var realTimeCodeProportionData: [DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.realTimeCodeProportionData != nil {
                        var tmp : [Any] = []
                        for k in self.realTimeCodeProportionData! {
                            tmp.append(k.toMap())
                        }
                        map["RealTimeCodeProportionData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RealTimeCodeProportionData") {
                        var tmp : [DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData] = []
                        for v in dict["RealTimeCodeProportionData"] as! [Any] {
                            var model = DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.realTimeCodeProportionData = tmp
                    }
                }
            }
            public var timeStamp: String?

            public var value: DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    var model = DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value()
                    model.fromMap(dict["Value"] as! [String: Any])
                    self.value = model
                }
            }
        }
        public var usageData: [DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.usageData != nil {
                var tmp : [Any] = []
                for k in self.usageData! {
                    tmp.append(k.toMap())
                }
                map["UsageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UsageData") {
                var tmp : [DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData] = []
                for v in dict["UsageData"] as! [Any] {
                    var model = DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.usageData = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeHttpCodeData: DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeHttpCodeData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeHttpCodeData != nil {
            map["RealTimeHttpCodeData"] = self.realTimeHttpCodeData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RealTimeHttpCodeData") {
            var model = DescribeVodDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData()
            model.fromMap(dict["RealTimeHttpCodeData"] as! [String: Any])
            self.realTimeHttpCodeData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeHttpCodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeHttpCodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeHttpCodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeQpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeQpsDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class QpsModel : Tea.TeaModel {
            public var qps: Double?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.qps != nil {
                    map["Qps"] = self.qps!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Qps") {
                    self.qps = dict["Qps"] as! Double
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var qpsModel: [DescribeVodDomainRealTimeQpsDataResponseBody.Data.QpsModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.qpsModel != nil {
                var tmp : [Any] = []
                for k in self.qpsModel! {
                    tmp.append(k.toMap())
                }
                map["QpsModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QpsModel") {
                var tmp : [DescribeVodDomainRealTimeQpsDataResponseBody.Data.QpsModel] = []
                for v in dict["QpsModel"] as! [Any] {
                    var model = DescribeVodDomainRealTimeQpsDataResponseBody.Data.QpsModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.qpsModel = tmp
            }
        }
    }
    public var data: DescribeVodDomainRealTimeQpsDataResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeVodDomainRealTimeQpsDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeQpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeQpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeQpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeReqHitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeReqHitRateDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ReqHitRateDataModel : Tea.TeaModel {
            public var reqHitRate: Double?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reqHitRate != nil {
                    map["ReqHitRate"] = self.reqHitRate!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReqHitRate") {
                    self.reqHitRate = dict["ReqHitRate"] as! Double
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var reqHitRateDataModel: [DescribeVodDomainRealTimeReqHitRateDataResponseBody.Data.ReqHitRateDataModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reqHitRateDataModel != nil {
                var tmp : [Any] = []
                for k in self.reqHitRateDataModel! {
                    tmp.append(k.toMap())
                }
                map["ReqHitRateDataModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReqHitRateDataModel") {
                var tmp : [DescribeVodDomainRealTimeReqHitRateDataResponseBody.Data.ReqHitRateDataModel] = []
                for v in dict["ReqHitRateDataModel"] as! [Any] {
                    var model = DescribeVodDomainRealTimeReqHitRateDataResponseBody.Data.ReqHitRateDataModel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reqHitRateDataModel = tmp
            }
        }
    }
    public var data: DescribeVodDomainRealTimeReqHitRateDataResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeVodDomainRealTimeReqHitRateDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeReqHitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeReqHitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeReqHitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainRealTimeTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeTrafficDataResponseBody : Tea.TeaModel {
    public class RealTimeTrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeTrafficDataPerInterval: DescribeVodDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeTrafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeTrafficDataPerInterval != nil {
            map["RealTimeTrafficDataPerInterval"] = self.realTimeTrafficDataPerInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RealTimeTrafficDataPerInterval") {
            var model = DescribeVodDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval()
            model.fromMap(dict["RealTimeTrafficDataPerInterval"] as! [String: Any])
            self.realTimeTrafficDataPerInterval = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainRealTimeTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainRealTimeTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainRealTimeTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainReqHitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainReqHitRateDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainReqHitRateDataResponseBody.Data.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainReqHitRateDataResponseBody.Data.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainReqHitRateDataResponseBody.Data.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var data: DescribeVodDomainReqHitRateDataResponseBody.Data?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeVodDomainReqHitRateDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainReqHitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainReqHitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainReqHitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainSrcBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcBpsDataResponseBody : Tea.TeaModel {
    public class SrcBpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var srcBpsDataPerInterval: DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.srcBpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.srcBpsDataPerInterval != nil {
            map["SrcBpsDataPerInterval"] = self.srcBpsDataPerInterval?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SrcBpsDataPerInterval") {
            var model = DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval()
            model.fromMap(dict["SrcBpsDataPerInterval"] as! [String: Any])
            self.srcBpsDataPerInterval = model
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainSrcBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainSrcBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainSrcTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcTrafficDataResponseBody : Tea.TeaModel {
    public class SrcTrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var srcTrafficDataPerInterval: DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval?

    public var startTime: String?

    public var totalTraffic: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.srcTrafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.srcTrafficDataPerInterval != nil {
            map["SrcTrafficDataPerInterval"] = self.srcTrafficDataPerInterval?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTraffic != nil {
            map["TotalTraffic"] = self.totalTraffic!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SrcTrafficDataPerInterval") {
            var model = DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval()
            model.fromMap(dict["SrcTrafficDataPerInterval"] as! [String: Any])
            self.srcTrafficDataPerInterval = model
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTraffic") {
            self.totalTraffic = dict["TotalTraffic"] as! String
        }
    }
}

public class DescribeVodDomainSrcTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainSrcTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainSrcTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var domesticValue: String?

            public var httpsDomesticValue: String?

            public var httpsOverseasValue: String?

            public var httpsValue: String?

            public var overseasValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domesticValue != nil {
                    map["DomesticValue"] = self.domesticValue!
                }
                if self.httpsDomesticValue != nil {
                    map["HttpsDomesticValue"] = self.httpsDomesticValue!
                }
                if self.httpsOverseasValue != nil {
                    map["HttpsOverseasValue"] = self.httpsOverseasValue!
                }
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.overseasValue != nil {
                    map["OverseasValue"] = self.overseasValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomesticValue") {
                    self.domesticValue = dict["DomesticValue"] as! String
                }
                if dict.keys.contains("HttpsDomesticValue") {
                    self.httpsDomesticValue = dict["HttpsDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsOverseasValue") {
                    self.httpsOverseasValue = dict["HttpsOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsValue") {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("OverseasValue") {
                    self.overseasValue = dict["OverseasValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var totalTraffic: String?

    public var trafficDataPerInterval: DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTraffic != nil {
            map["TotalTraffic"] = self.totalTraffic!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTraffic") {
            self.totalTraffic = dict["TotalTraffic"] as! String
        }
        if dict.keys.contains("TrafficDataPerInterval") {
            var model = DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(dict["TrafficDataPerInterval"] as! [String: Any])
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeVodDomainTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainUsageDataRequest : Tea.TeaModel {
    public var area: String?

    public var domainName: String?

    public var endTime: String?

    public var field: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.field != nil {
            map["Field"] = self.field!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Field") {
            self.field = dict["Field"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeVodDomainUsageDataResponseBody : Tea.TeaModel {
    public class UsageDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                var tmp : [DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var area: String?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var type: String?

    public var usageDataPerInterval: DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.usageDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.usageDataPerInterval != nil {
            map["UsageDataPerInterval"] = self.usageDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UsageDataPerInterval") {
            var model = DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval()
            model.fromMap(dict["UsageDataPerInterval"] as! [String: Any])
            self.usageDataPerInterval = model
        }
    }
}

public class DescribeVodDomainUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodDomainUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodMediaPlayDataRequest : Tea.TeaModel {
    public var mediaId: String?

    public var orderName: String?

    public var orderType: String?

    public var os: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var playDate: String?

    public var region: String?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.orderName != nil {
            map["OrderName"] = self.orderName!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playDate != nil {
            map["PlayDate"] = self.playDate!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OrderName") {
            self.orderName = dict["OrderName"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Os") {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlayDate") {
            self.playDate = dict["PlayDate"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("TerminalType") {
            self.terminalType = dict["TerminalType"] as! String
        }
    }
}

public class DescribeVodMediaPlayDataResponseBody : Tea.TeaModel {
    public class QoeInfoList : Tea.TeaModel {
        public var DAU: Double?

        public var mediaId: String?

        public var playDuration: Double?

        public var playDurationPerUv: Double?

        public var playPerVv: Double?

        public var playSuccessVv: Double?

        public var videoDuration: Double?

        public var videoTitle: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DAU != nil {
                map["DAU"] = self.DAU!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.playDuration != nil {
                map["PlayDuration"] = self.playDuration!
            }
            if self.playDurationPerUv != nil {
                map["PlayDurationPerUv"] = self.playDurationPerUv!
            }
            if self.playPerVv != nil {
                map["PlayPerVv"] = self.playPerVv!
            }
            if self.playSuccessVv != nil {
                map["PlaySuccessVv"] = self.playSuccessVv!
            }
            if self.videoDuration != nil {
                map["VideoDuration"] = self.videoDuration!
            }
            if self.videoTitle != nil {
                map["VideoTitle"] = self.videoTitle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DAU") {
                self.DAU = dict["DAU"] as! Double
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("PlayDuration") {
                self.playDuration = dict["PlayDuration"] as! Double
            }
            if dict.keys.contains("PlayDurationPerUv") {
                self.playDurationPerUv = dict["PlayDurationPerUv"] as! Double
            }
            if dict.keys.contains("PlayPerVv") {
                self.playPerVv = dict["PlayPerVv"] as! Double
            }
            if dict.keys.contains("PlaySuccessVv") {
                self.playSuccessVv = dict["PlaySuccessVv"] as! Double
            }
            if dict.keys.contains("VideoDuration") {
                self.videoDuration = dict["VideoDuration"] as! Double
            }
            if dict.keys.contains("VideoTitle") {
                self.videoTitle = dict["VideoTitle"] as! String
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var qoeInfoList: [DescribeVodMediaPlayDataResponseBody.QoeInfoList]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.qoeInfoList != nil {
            var tmp : [Any] = []
            for k in self.qoeInfoList! {
                tmp.append(k.toMap())
            }
            map["QoeInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("QoeInfoList") {
            var tmp : [DescribeVodMediaPlayDataResponseBody.QoeInfoList] = []
            for v in dict["QoeInfoList"] as! [Any] {
                var model = DescribeVodMediaPlayDataResponseBody.QoeInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.qoeInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeVodMediaPlayDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodMediaPlayDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodMediaPlayDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodRangeDataByLocateAndIspServiceRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodRangeDataByLocateAndIspServiceResponseBody : Tea.TeaModel {
    public var jsonResult: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jsonResult != nil {
            map["JsonResult"] = self.jsonResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JsonResult") {
            self.jsonResult = dict["JsonResult"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodRangeDataByLocateAndIspServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodRangeDataByLocateAndIspServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodRangeDataByLocateAndIspServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodRefreshQuotaRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodRefreshQuotaResponseBody : Tea.TeaModel {
    public var blockQuota: String?

    public var dirQuota: String?

    public var dirRemain: String?

    public var preloadQuota: String?

    public var preloadRemain: String?

    public var requestId: String?

    public var urlQuota: String?

    public var urlRemain: String?

    public var blockRemain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockQuota != nil {
            map["BlockQuota"] = self.blockQuota!
        }
        if self.dirQuota != nil {
            map["DirQuota"] = self.dirQuota!
        }
        if self.dirRemain != nil {
            map["DirRemain"] = self.dirRemain!
        }
        if self.preloadQuota != nil {
            map["PreloadQuota"] = self.preloadQuota!
        }
        if self.preloadRemain != nil {
            map["PreloadRemain"] = self.preloadRemain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.urlQuota != nil {
            map["UrlQuota"] = self.urlQuota!
        }
        if self.urlRemain != nil {
            map["UrlRemain"] = self.urlRemain!
        }
        if self.blockRemain != nil {
            map["blockRemain"] = self.blockRemain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockQuota") {
            self.blockQuota = dict["BlockQuota"] as! String
        }
        if dict.keys.contains("DirQuota") {
            self.dirQuota = dict["DirQuota"] as! String
        }
        if dict.keys.contains("DirRemain") {
            self.dirRemain = dict["DirRemain"] as! String
        }
        if dict.keys.contains("PreloadQuota") {
            self.preloadQuota = dict["PreloadQuota"] as! String
        }
        if dict.keys.contains("PreloadRemain") {
            self.preloadRemain = dict["PreloadRemain"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UrlQuota") {
            self.urlQuota = dict["UrlQuota"] as! String
        }
        if dict.keys.contains("UrlRemain") {
            self.urlRemain = dict["UrlRemain"] as! String
        }
        if dict.keys.contains("blockRemain") {
            self.blockRemain = dict["blockRemain"] as! String
        }
    }
}

public class DescribeVodRefreshQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodRefreshQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodRefreshQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodRefreshTasksRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var objectPath: String?

    public var objectType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var startTime: String?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ObjectPath") {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeVodRefreshTasksResponseBody : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var objectPath: String?

            public var objectType: String?

            public var process: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.objectPath != nil {
                    map["ObjectPath"] = self.objectPath!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.process != nil {
                    map["Process"] = self.process!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ObjectPath") {
                    self.objectPath = dict["ObjectPath"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("Process") {
                    self.process = dict["Process"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var task: [DescribeVodRefreshTasksResponseBody.Tasks.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Task") {
                var tmp : [DescribeVodRefreshTasksResponseBody.Tasks.Task] = []
                for v in dict["Task"] as! [Any] {
                    var model = DescribeVodRefreshTasksResponseBody.Tasks.Task()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.task = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var tasks: DescribeVodRefreshTasksResponseBody.Tasks?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tasks") {
            var model = DescribeVodRefreshTasksResponseBody.Tasks()
            model.fromMap(dict["Tasks"] as! [String: Any])
            self.tasks = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeVodRefreshTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodRefreshTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodRefreshTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodStorageDataRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public var storage: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Storage") {
            self.storage = dict["Storage"] as! String
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class DescribeVodStorageDataResponseBody : Tea.TeaModel {
    public class StorageData : Tea.TeaModel {
        public class StorageDataItem : Tea.TeaModel {
            public var networkOut: String?

            public var storageUtilization: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkOut != nil {
                    map["NetworkOut"] = self.networkOut!
                }
                if self.storageUtilization != nil {
                    map["StorageUtilization"] = self.storageUtilization!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetworkOut") {
                    self.networkOut = dict["NetworkOut"] as! String
                }
                if dict.keys.contains("StorageUtilization") {
                    self.storageUtilization = dict["StorageUtilization"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var storageDataItem: [DescribeVodStorageDataResponseBody.StorageData.StorageDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageDataItem != nil {
                var tmp : [Any] = []
                for k in self.storageDataItem! {
                    tmp.append(k.toMap())
                }
                map["StorageDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageDataItem") {
                var tmp : [DescribeVodStorageDataResponseBody.StorageData.StorageDataItem] = []
                for v in dict["StorageDataItem"] as! [Any] {
                    var model = DescribeVodStorageDataResponseBody.StorageData.StorageDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.storageDataItem = tmp
            }
        }
    }
    public var dataInterval: String?

    public var requestId: String?

    public var storageData: DescribeVodStorageDataResponseBody.StorageData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageData != nil {
            map["StorageData"] = self.storageData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageData") {
            var model = DescribeVodStorageDataResponseBody.StorageData()
            model.fromMap(dict["StorageData"] as! [String: Any])
            self.storageData = model
        }
    }
}

public class DescribeVodStorageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodStorageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodStorageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodTieringStorageDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StorageClass") {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class DescribeVodTieringStorageDataResponseBody : Tea.TeaModel {
    public class StorageData : Tea.TeaModel {
        public var lessthanMonthDatasize: Int64?

        public var region: String?

        public var storageClass: String?

        public var storageUtilization: Int64?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lessthanMonthDatasize != nil {
                map["LessthanMonthDatasize"] = self.lessthanMonthDatasize!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.storageUtilization != nil {
                map["StorageUtilization"] = self.storageUtilization!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LessthanMonthDatasize") {
                self.lessthanMonthDatasize = dict["LessthanMonthDatasize"] as! Int64
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("StorageUtilization") {
                self.storageUtilization = dict["StorageUtilization"] as! Int64
            }
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
        }
    }
    public var requestId: String?

    public var storageData: [DescribeVodTieringStorageDataResponseBody.StorageData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageData != nil {
            var tmp : [Any] = []
            for k in self.storageData! {
                tmp.append(k.toMap())
            }
            map["StorageData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageData") {
            var tmp : [DescribeVodTieringStorageDataResponseBody.StorageData] = []
            for v in dict["StorageData"] as! [Any] {
                var model = DescribeVodTieringStorageDataResponseBody.StorageData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.storageData = tmp
        }
    }
}

public class DescribeVodTieringStorageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodTieringStorageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodTieringStorageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodTieringStorageRetrievalDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StorageClass") {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class DescribeVodTieringStorageRetrievalDataResponseBody : Tea.TeaModel {
    public class RetrievalData : Tea.TeaModel {
        public var CABulkRetrievalData: Int64?

        public var CAHighPriorRetrievalData: Int64?

        public var CAStdRetrievalData: Int64?

        public var region: String?

        public var retrievalData: Int64?

        public var storageClass: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.CABulkRetrievalData != nil {
                map["CABulkRetrievalData"] = self.CABulkRetrievalData!
            }
            if self.CAHighPriorRetrievalData != nil {
                map["CAHighPriorRetrievalData"] = self.CAHighPriorRetrievalData!
            }
            if self.CAStdRetrievalData != nil {
                map["CAStdRetrievalData"] = self.CAStdRetrievalData!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.retrievalData != nil {
                map["RetrievalData"] = self.retrievalData!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CABulkRetrievalData") {
                self.CABulkRetrievalData = dict["CABulkRetrievalData"] as! Int64
            }
            if dict.keys.contains("CAHighPriorRetrievalData") {
                self.CAHighPriorRetrievalData = dict["CAHighPriorRetrievalData"] as! Int64
            }
            if dict.keys.contains("CAStdRetrievalData") {
                self.CAStdRetrievalData = dict["CAStdRetrievalData"] as! Int64
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RetrievalData") {
                self.retrievalData = dict["RetrievalData"] as! Int64
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
        }
    }
    public var requestId: String?

    public var retrievalData: [DescribeVodTieringStorageRetrievalDataResponseBody.RetrievalData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retrievalData != nil {
            var tmp : [Any] = []
            for k in self.retrievalData! {
                tmp.append(k.toMap())
            }
            map["RetrievalData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetrievalData") {
            var tmp : [DescribeVodTieringStorageRetrievalDataResponseBody.RetrievalData] = []
            for v in dict["RetrievalData"] as! [Any] {
                var model = DescribeVodTieringStorageRetrievalDataResponseBody.RetrievalData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.retrievalData = tmp
        }
    }
}

public class DescribeVodTieringStorageRetrievalDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodTieringStorageRetrievalDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodTieringStorageRetrievalDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodTranscodeDataRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var specification: String?

    public var startTime: String?

    public var storage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Specification") {
            self.specification = dict["Specification"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Storage") {
            self.storage = dict["Storage"] as! String
        }
    }
}

public class DescribeVodTranscodeDataResponseBody : Tea.TeaModel {
    public class TranscodeData : Tea.TeaModel {
        public class TranscodeDataItem : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public class DataItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var dataItem: [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataItem != nil {
                        var tmp : [Any] = []
                        for k in self.dataItem! {
                            tmp.append(k.toMap())
                        }
                        map["DataItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataItem") {
                        var tmp : [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem] = []
                        for v in dict["DataItem"] as! [Any] {
                            var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataItem = tmp
                    }
                }
            }
            public var data: DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var transcodeDataItem: [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeDataItem != nil {
                var tmp : [Any] = []
                for k in self.transcodeDataItem! {
                    tmp.append(k.toMap())
                }
                map["TranscodeDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeDataItem") {
                var tmp : [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem] = []
                for v in dict["TranscodeDataItem"] as! [Any] {
                    var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeDataItem = tmp
            }
        }
    }
    public var dataInterval: String?

    public var requestId: String?

    public var transcodeData: DescribeVodTranscodeDataResponseBody.TranscodeData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeData != nil {
            map["TranscodeData"] = self.transcodeData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeData") {
            var model = DescribeVodTranscodeDataResponseBody.TranscodeData()
            model.fromMap(dict["TranscodeData"] as! [String: Any])
            self.transcodeData = model
        }
    }
}

public class DescribeVodTranscodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodTranscodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodTranscodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodUserDomainsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var domainName: String?

    public var domainSearchType: String?

    public var domainStatus: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var tag: [DescribeVodUserDomainsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSearchType != nil {
            map["DomainSearchType"] = self.domainSearchType!
        }
        if self.domainStatus != nil {
            map["DomainStatus"] = self.domainStatus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSearchType") {
            self.domainSearchType = dict["DomainSearchType"] as! String
        }
        if dict.keys.contains("DomainStatus") {
            self.domainStatus = dict["DomainStatus"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeVodUserDomainsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVodUserDomainsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeVodUserDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class PageData : Tea.TeaModel {
            public class Sources : Tea.TeaModel {
                public class Source : Tea.TeaModel {
                    public var content: String?

                    public var port: Int32?

                    public var priority: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var source: [DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.source != nil {
                        var tmp : [Any] = []
                        for k in self.source! {
                            tmp.append(k.toMap())
                        }
                        map["Source"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Source") {
                        var tmp : [DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source] = []
                        for v in dict["Source"] as! [Any] {
                            var model = DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.source = tmp
                    }
                }
            }
            public var cname: String?

            public var description_: String?

            public var domainName: String?

            public var domainStatus: String?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var sandbox: String?

            public var sources: DescribeVodUserDomainsResponseBody.Domains.PageData.Sources?

            public var sslProtocol: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainStatus != nil {
                    map["DomainStatus"] = self.domainStatus!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.sandbox != nil {
                    map["Sandbox"] = self.sandbox!
                }
                if self.sources != nil {
                    map["Sources"] = self.sources?.toMap()
                }
                if self.sslProtocol != nil {
                    map["SslProtocol"] = self.sslProtocol!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cname") {
                    self.cname = dict["Cname"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainStatus") {
                    self.domainStatus = dict["DomainStatus"] as! String
                }
                if dict.keys.contains("GmtCreated") {
                    self.gmtCreated = dict["GmtCreated"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Sandbox") {
                    self.sandbox = dict["Sandbox"] as! String
                }
                if dict.keys.contains("Sources") {
                    var model = DescribeVodUserDomainsResponseBody.Domains.PageData.Sources()
                    model.fromMap(dict["Sources"] as! [String: Any])
                    self.sources = model
                }
                if dict.keys.contains("SslProtocol") {
                    self.sslProtocol = dict["SslProtocol"] as! String
                }
            }
        }
        public var pageData: [DescribeVodUserDomainsResponseBody.Domains.PageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageData != nil {
                var tmp : [Any] = []
                for k in self.pageData! {
                    tmp.append(k.toMap())
                }
                map["PageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageData") {
                var tmp : [DescribeVodUserDomainsResponseBody.Domains.PageData] = []
                for v in dict["PageData"] as! [Any] {
                    var model = DescribeVodUserDomainsResponseBody.Domains.PageData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pageData = tmp
            }
        }
    }
    public var domains: DescribeVodUserDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            var model = DescribeVodUserDomainsResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeVodUserDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodUserDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodUserDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodVerifyContentRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeVodVerifyContentResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodVerifyContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodVerifyContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVodVerifyContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachAppPolicyFromIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public var policyNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.policyNames != nil {
            map["PolicyNames"] = self.policyNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("PolicyNames") {
            self.policyNames = dict["PolicyNames"] as! String
        }
    }
}

public class DetachAppPolicyFromIdentityResponseBody : Tea.TeaModel {
    public var failedPolicyNames: [String]?

    public var nonExistPolicyNames: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedPolicyNames != nil {
            map["FailedPolicyNames"] = self.failedPolicyNames!
        }
        if self.nonExistPolicyNames != nil {
            map["NonExistPolicyNames"] = self.nonExistPolicyNames!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedPolicyNames") {
            self.failedPolicyNames = dict["FailedPolicyNames"] as! [String]
        }
        if dict.keys.contains("NonExistPolicyNames") {
            self.nonExistPolicyNames = dict["NonExistPolicyNames"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachAppPolicyFromIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAppPolicyFromIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachAppPolicyFromIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateDownloadSecretKeyRequest : Tea.TeaModel {
    public var appDecryptKey: String?

    public var appIdentification: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appDecryptKey != nil {
            map["AppDecryptKey"] = self.appDecryptKey!
        }
        if self.appIdentification != nil {
            map["AppIdentification"] = self.appIdentification!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppDecryptKey") {
            self.appDecryptKey = dict["AppDecryptKey"] as! String
        }
        if dict.keys.contains("AppIdentification") {
            self.appIdentification = dict["AppIdentification"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GenerateDownloadSecretKeyResponseBody : Tea.TeaModel {
    public var appEncryptKey: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEncryptKey != nil {
            map["AppEncryptKey"] = self.appEncryptKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppEncryptKey") {
            self.appEncryptKey = dict["AppEncryptKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateDownloadSecretKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDownloadSecretKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateDownloadSecretKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateKMSDataKeyRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponseBody : Tea.TeaModel {
    public var ciphertextBlob: String?

    public var keyId: String?

    public var plaintext: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ciphertextBlob != nil {
            map["CiphertextBlob"] = self.ciphertextBlob!
        }
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.plaintext != nil {
            map["Plaintext"] = self.plaintext!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CiphertextBlob") {
            self.ciphertextBlob = dict["CiphertextBlob"] as! String
        }
        if dict.keys.contains("KeyId") {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("Plaintext") {
            self.plaintext = dict["Plaintext"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIImageJobsRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetAIImageJobsResponseBody : Tea.TeaModel {
    public class AIImageJobList : Tea.TeaModel {
        public var AIImageResult: String?

        public var code: String?

        public var creationTime: String?

        public var jobId: String?

        public var message: String?

        public var status: String?

        public var templateConfig: String?

        public var templateId: String?

        public var userData: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIImageResult != nil {
                map["AIImageResult"] = self.AIImageResult!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIImageResult") {
                self.AIImageResult = dict["AIImageResult"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var AIImageJobList: [GetAIImageJobsResponseBody.AIImageJobList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageJobList != nil {
            var tmp : [Any] = []
            for k in self.AIImageJobList! {
                tmp.append(k.toMap())
            }
            map["AIImageJobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageJobList") {
            var tmp : [GetAIImageJobsResponseBody.AIImageJobList] = []
            for v in dict["AIImageJobList"] as! [Any] {
                var model = GetAIImageJobsResponseBody.AIImageJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.AIImageJobList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAIImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAIImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIMediaAuditJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetAIMediaAuditJobResponseBody : Tea.TeaModel {
    public class MediaAuditJob : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class AudioResult : Tea.TeaModel {
                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class ImageResult : Tea.TeaModel {
                public class Result : Tea.TeaModel {
                    public var label: String?

                    public var scene: String?

                    public var score: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Scene") {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var label: String?

                public var result: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result]?

                public var suggestion: String?

                public var type: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.result != nil {
                        var tmp : [Any] = []
                        for k in self.result! {
                            tmp.append(k.toMap())
                        }
                        map["Result"] = tmp
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Result") {
                        var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result] = []
                        for v in dict["Result"] as! [Any] {
                            var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.result = tmp
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Url") {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public class TextResult : Tea.TeaModel {
                public var content: String?

                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class VideoResult : Tea.TeaModel {
                public class AdResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class LiveResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class LogoResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class PornResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class TerrorismResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public var adResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult?

                public var label: String?

                public var liveResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult?

                public var logoResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult?

                public var pornResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult?

                public var suggestion: String?

                public var terrorismResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adResult?.validate()
                    try self.liveResult?.validate()
                    try self.logoResult?.validate()
                    try self.pornResult?.validate()
                    try self.terrorismResult?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adResult != nil {
                        map["AdResult"] = self.adResult?.toMap()
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.liveResult != nil {
                        map["LiveResult"] = self.liveResult?.toMap()
                    }
                    if self.logoResult != nil {
                        map["LogoResult"] = self.logoResult?.toMap()
                    }
                    if self.pornResult != nil {
                        map["PornResult"] = self.pornResult?.toMap()
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.terrorismResult != nil {
                        map["TerrorismResult"] = self.terrorismResult?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdResult") {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult()
                        model.fromMap(dict["AdResult"] as! [String: Any])
                        self.adResult = model
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("LiveResult") {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult()
                        model.fromMap(dict["LiveResult"] as! [String: Any])
                        self.liveResult = model
                    }
                    if dict.keys.contains("LogoResult") {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult()
                        model.fromMap(dict["LogoResult"] as! [String: Any])
                        self.logoResult = model
                    }
                    if dict.keys.contains("PornResult") {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult()
                        model.fromMap(dict["PornResult"] as! [String: Any])
                        self.pornResult = model
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TerrorismResult") {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult()
                        model.fromMap(dict["TerrorismResult"] as! [String: Any])
                        self.terrorismResult = model
                    }
                }
            }
            public var abnormalModules: String?

            public var audioResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult]?

            public var imageResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult]?

            public var label: String?

            public var suggestion: String?

            public var textResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult]?

            public var videoResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.videoResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalModules != nil {
                    map["AbnormalModules"] = self.abnormalModules!
                }
                if self.audioResult != nil {
                    var tmp : [Any] = []
                    for k in self.audioResult! {
                        tmp.append(k.toMap())
                    }
                    map["AudioResult"] = tmp
                }
                if self.imageResult != nil {
                    var tmp : [Any] = []
                    for k in self.imageResult! {
                        tmp.append(k.toMap())
                    }
                    map["ImageResult"] = tmp
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.textResult != nil {
                    var tmp : [Any] = []
                    for k in self.textResult! {
                        tmp.append(k.toMap())
                    }
                    map["TextResult"] = tmp
                }
                if self.videoResult != nil {
                    map["VideoResult"] = self.videoResult?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbnormalModules") {
                    self.abnormalModules = dict["AbnormalModules"] as! String
                }
                if dict.keys.contains("AudioResult") {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult] = []
                    for v in dict["AudioResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioResult = tmp
                }
                if dict.keys.contains("ImageResult") {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult] = []
                    for v in dict["ImageResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.imageResult = tmp
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TextResult") {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult] = []
                    for v in dict["TextResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.textResult = tmp
                }
                if dict.keys.contains("VideoResult") {
                    var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult()
                    model.fromMap(dict["VideoResult"] as! [String: Any])
                    self.videoResult = model
                }
            }
        }
        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var data: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data?

        public var jobId: String?

        public var mediaId: String?

        public var message: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Data") {
                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var mediaAuditJob: GetAIMediaAuditJobResponseBody.MediaAuditJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditJob != nil {
            map["MediaAuditJob"] = self.mediaAuditJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditJob") {
            var model = GetAIMediaAuditJobResponseBody.MediaAuditJob()
            model.fromMap(dict["MediaAuditJob"] as! [String: Any])
            self.mediaAuditJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAIMediaAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIMediaAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAIMediaAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfo: GetAITemplateResponseBody.TemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfo != nil {
            map["TemplateInfo"] = self.templateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfo") {
            var model = GetAITemplateResponseBody.TemplateInfo()
            model.fromMap(dict["TemplateInfo"] as! [String: Any])
            self.templateInfo = model
        }
    }
}

public class GetAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIVideoTagResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetAIVideoTagResultResponseBody : Tea.TeaModel {
    public class VideoTagResult : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var tag: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
            }
        }
        public class Keyword : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Person : Tea.TeaModel {
            public var faceUrl: String?

            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.faceUrl != nil {
                    map["FaceUrl"] = self.faceUrl!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FaceUrl") {
                    self.faceUrl = dict["FaceUrl"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Time : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public var category: [GetAIVideoTagResultResponseBody.VideoTagResult.Category]?

        public var keyword: [GetAIVideoTagResultResponseBody.VideoTagResult.Keyword]?

        public var location: [GetAIVideoTagResultResponseBody.VideoTagResult.Location]?

        public var person: [GetAIVideoTagResultResponseBody.VideoTagResult.Person]?

        public var time: [GetAIVideoTagResultResponseBody.VideoTagResult.Time]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            if self.keyword != nil {
                var tmp : [Any] = []
                for k in self.keyword! {
                    tmp.append(k.toMap())
                }
                map["Keyword"] = tmp
            }
            if self.location != nil {
                var tmp : [Any] = []
                for k in self.location! {
                    tmp.append(k.toMap())
                }
                map["Location"] = tmp
            }
            if self.person != nil {
                var tmp : [Any] = []
                for k in self.person! {
                    tmp.append(k.toMap())
                }
                map["Person"] = tmp
            }
            if self.time != nil {
                var tmp : [Any] = []
                for k in self.time! {
                    tmp.append(k.toMap())
                }
                map["Time"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
            if dict.keys.contains("Keyword") {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Keyword] = []
                for v in dict["Keyword"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Keyword()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.keyword = tmp
            }
            if dict.keys.contains("Location") {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Location] = []
                for v in dict["Location"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Location()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.location = tmp
            }
            if dict.keys.contains("Person") {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Person] = []
                for v in dict["Person"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Person()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.person = tmp
            }
            if dict.keys.contains("Time") {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Time] = []
                for v in dict["Time"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Time()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.time = tmp
            }
        }
    }
    public var requestId: String?

    public var videoTagResult: GetAIVideoTagResultResponseBody.VideoTagResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoTagResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoTagResult != nil {
            map["VideoTagResult"] = self.videoTagResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoTagResult") {
            var model = GetAIVideoTagResultResponseBody.VideoTagResult()
            model.fromMap(dict["VideoTagResult"] as! [String: Any])
            self.videoTagResult = model
        }
    }
}

public class GetAIVideoTagResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIVideoTagResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAIVideoTagResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppInfosRequest : Tea.TeaModel {
    public var appIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
    }
}

public class GetAppInfosResponseBody : Tea.TeaModel {
    public class AppInfoList : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var resourceGroupId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var appInfoList: [GetAppInfosResponseBody.AppInfoList]?

    public var code: String?

    public var nonExistAppIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfoList != nil {
            var tmp : [Any] = []
            for k in self.appInfoList! {
                tmp.append(k.toMap())
            }
            map["AppInfoList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.nonExistAppIds != nil {
            map["NonExistAppIds"] = self.nonExistAppIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfoList") {
            var tmp : [GetAppInfosResponseBody.AppInfoList] = []
            for v in dict["AppInfoList"] as! [Any] {
                var model = GetAppInfosResponseBody.AppInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appInfoList = tmp
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("NonExistAppIds") {
            self.nonExistAppIds = dict["NonExistAppIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAppInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAttachedMediaInfoRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var mediaIds: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetAttachedMediaInfoResponseBody : Tea.TeaModel {
    public class AttachedMediaList : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public var appId: String?

        public var categories: [GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories]?

        public var creationTime: String?

        public var description_: String?

        public var mediaId: String?

        public var modificationTime: String?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var type: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Categories") {
                var tmp : [GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("URL") {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var attachedMediaList: [GetAttachedMediaInfoResponseBody.AttachedMediaList]?

    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachedMediaList != nil {
            var tmp : [Any] = []
            for k in self.attachedMediaList! {
                tmp.append(k.toMap())
            }
            map["AttachedMediaList"] = tmp
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachedMediaList") {
            var tmp : [GetAttachedMediaInfoResponseBody.AttachedMediaList] = []
            for v in dict["AttachedMediaList"] as! [Any] {
                var model = GetAttachedMediaInfoResponseBody.AttachedMediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attachedMediaList = tmp
        }
        if dict.keys.contains("NonExistMediaIds") {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAttachedMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAttachedMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAttachedMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuditHistoryRequest : Tea.TeaModel {
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetAuditHistoryResponseBody : Tea.TeaModel {
    public class Histories : Tea.TeaModel {
        public var auditor: String?

        public var comment: String?

        public var creationTime: String?

        public var reason: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditor != nil {
                map["Auditor"] = self.auditor!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Auditor") {
                self.auditor = dict["Auditor"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var histories: [GetAuditHistoryResponseBody.Histories]?

    public var requestId: String?

    public var status: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.histories != nil {
            var tmp : [Any] = []
            for k in self.histories! {
                tmp.append(k.toMap())
            }
            map["Histories"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Histories") {
            var tmp : [GetAuditHistoryResponseBody.Histories] = []
            for v in dict["Histories"] as! [Any] {
                var model = GetAuditHistoryResponseBody.Histories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.histories = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class GetAuditHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuditHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAuditHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [GetCategoriesResponseBody.SubCategories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoriesResponseBody.SubCategories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultAITemplateRequest : Tea.TeaModel {
    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class GetDefaultAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfo: GetDefaultAITemplateResponseBody.TemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfo != nil {
            map["TemplateInfo"] = self.templateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfo") {
            var model = GetDefaultAITemplateResponseBody.TemplateInfo()
            model.fromMap(dict["TemplateInfo"] as! [String: Any])
            self.templateInfo = model
        }
    }
}

public class GetDefaultAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDefaultAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDigitalWatermarkExtractResultRequest : Tea.TeaModel {
    public var extractType: String?

    public var jobId: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extractType != nil {
            map["ExtractType"] = self.extractType!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtractType") {
            self.extractType = dict["ExtractType"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetDigitalWatermarkExtractResultResponseBody : Tea.TeaModel {
    public class AiExtractResultList : Tea.TeaModel {
        public var createTime: String?

        public var errorMessage: String?

        public var jobId: String?

        public var modifyTime: String?

        public var status: String?

        public var waterMarkText: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.waterMarkText != nil {
                map["WaterMarkText"] = self.waterMarkText!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("WaterMarkText") {
                self.waterMarkText = dict["WaterMarkText"] as! String
            }
        }
    }
    public var aiExtractResultList: [GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiExtractResultList != nil {
            var tmp : [Any] = []
            for k in self.aiExtractResultList! {
                tmp.append(k.toMap())
            }
            map["AiExtractResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiExtractResultList") {
            var tmp : [GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList] = []
            for v in dict["AiExtractResultList"] as! [Any] {
                var model = GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aiExtractResultList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDigitalWatermarkExtractResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDigitalWatermarkExtractResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDigitalWatermarkExtractResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var regionId: String?

        public var status: String?

        public var storageLocation: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Timeline") {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialType") {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class MaterialList : Tea.TeaModel {
        public class Material : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public var snapshot: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        self.snapshot = dict["Snapshot"] as! [String]
                    }
                }
            }
            public class Sprites : Tea.TeaModel {
                public var sprite: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sprite != nil {
                        map["Sprite"] = self.sprite!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sprite") {
                        self.sprite = dict["Sprite"] as! [String]
                    }
                }
            }
            public var cateId: Int32?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var materialId: String?

            public var materialType: String?

            public var modifiedTime: String?

            public var size: Int64?

            public var snapshots: GetEditingProjectMaterialsResponseBody.MaterialList.Material.Snapshots?

            public var source: String?

            public var spriteConfig: String?

            public var sprites: GetEditingProjectMaterialsResponseBody.MaterialList.Material.Sprites?

            public var status: String?

            public var tags: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
                try self.sprites?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialType != nil {
                    map["MaterialType"] = self.materialType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteConfig != nil {
                    map["SpriteConfig"] = self.spriteConfig!
                }
                if self.sprites != nil {
                    map["Sprites"] = self.sprites?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int32
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MaterialId") {
                    self.materialId = dict["MaterialId"] as! String
                }
                if dict.keys.contains("MaterialType") {
                    self.materialType = dict["MaterialType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material.Snapshots()
                    model.fromMap(dict["Snapshots"] as! [String: Any])
                    self.snapshots = model
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteConfig") {
                    self.spriteConfig = dict["SpriteConfig"] as! String
                }
                if dict.keys.contains("Sprites") {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material.Sprites()
                    model.fromMap(dict["Sprites"] as! [String: Any])
                    self.sprites = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var material: [GetEditingProjectMaterialsResponseBody.MaterialList.Material]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.material != nil {
                var tmp : [Any] = []
                for k in self.material! {
                    tmp.append(k.toMap())
                }
                map["Material"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Material") {
                var tmp : [GetEditingProjectMaterialsResponseBody.MaterialList.Material] = []
                for v in dict["Material"] as! [Any] {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.material = tmp
            }
        }
    }
    public var materialList: GetEditingProjectMaterialsResponseBody.MaterialList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.materialList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialList != nil {
            map["MaterialList"] = self.materialList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialList") {
            var model = GetEditingProjectMaterialsResponseBody.MaterialList()
            model.fromMap(dict["MaterialList"] as! [String: Any])
            self.materialList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageInfoRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var imageId: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetImageInfoResponseBody : Tea.TeaModel {
    public class ImageInfo : Tea.TeaModel {
        public class Mezzanine : Tea.TeaModel {
            public var fileSize: String?

            public var fileURL: String?

            public var height: Int32?

            public var originalFileName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.fileURL != nil {
                    map["FileURL"] = self.fileURL!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.originalFileName != nil {
                    map["OriginalFileName"] = self.originalFileName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileSize") {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("FileURL") {
                    self.fileURL = dict["FileURL"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("OriginalFileName") {
                    self.originalFileName = dict["OriginalFileName"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var creationTime: String?

        public var description_: String?

        public var imageId: String?

        public var imageType: String?

        public var mezzanine: GetImageInfoResponseBody.ImageInfo.Mezzanine?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mezzanine?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageType != nil {
                map["ImageType"] = self.imageType!
            }
            if self.mezzanine != nil {
                map["Mezzanine"] = self.mezzanine?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageType") {
                self.imageType = dict["ImageType"] as! String
            }
            if dict.keys.contains("Mezzanine") {
                var model = GetImageInfoResponseBody.ImageInfo.Mezzanine()
                model.fromMap(dict["Mezzanine"] as! [String: Any])
                self.mezzanine = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("URL") {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var imageInfo: GetImageInfoResponseBody.ImageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfo != nil {
            map["ImageInfo"] = self.imageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfo") {
            var model = GetImageInfoResponseBody.ImageInfo()
            model.fromMap(dict["ImageInfo"] as! [String: Any])
            self.imageInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageInfosRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var imageIds: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.imageIds != nil {
            map["ImageIds"] = self.imageIds!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("ImageIds") {
            self.imageIds = dict["ImageIds"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetImageInfosResponseBody : Tea.TeaModel {
    public class ImageInfo : Tea.TeaModel {
        public class Mezzanine : Tea.TeaModel {
            public var fileSize: String?

            public var fileURL: String?

            public var height: Int32?

            public var originalFileName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.fileURL != nil {
                    map["FileURL"] = self.fileURL!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.originalFileName != nil {
                    map["OriginalFileName"] = self.originalFileName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileSize") {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("FileURL") {
                    self.fileURL = dict["FileURL"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("OriginalFileName") {
                    self.originalFileName = dict["OriginalFileName"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var creationTime: String?

        public var description_: String?

        public var imageId: String?

        public var imageType: String?

        public var mezzanine: GetImageInfosResponseBody.ImageInfo.Mezzanine?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mezzanine?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageType != nil {
                map["ImageType"] = self.imageType!
            }
            if self.mezzanine != nil {
                map["Mezzanine"] = self.mezzanine?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageType") {
                self.imageType = dict["ImageType"] as! String
            }
            if dict.keys.contains("Mezzanine") {
                var model = GetImageInfosResponseBody.ImageInfo.Mezzanine()
                model.fromMap(dict["Mezzanine"] as! [String: Any])
                self.mezzanine = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("URL") {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var imageInfo: [GetImageInfosResponseBody.ImageInfo]?

    public var nonExistImageIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfo != nil {
            var tmp : [Any] = []
            for k in self.imageInfo! {
                tmp.append(k.toMap())
            }
            map["ImageInfo"] = tmp
        }
        if self.nonExistImageIds != nil {
            map["NonExistImageIds"] = self.nonExistImageIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfo") {
            var tmp : [GetImageInfosResponseBody.ImageInfo] = []
            for v in dict["ImageInfo"] as! [Any] {
                var model = GetImageInfosResponseBody.ImageInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInfo = tmp
        }
        if dict.keys.contains("NonExistImageIds") {
            self.nonExistImageIds = dict["NonExistImageIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditAudioResultDetailRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var pageNo: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetMediaAuditAudioResultDetailResponseBody : Tea.TeaModel {
    public class MediaAuditAudioResultDetail : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var endTime: Int64?

            public var label: String?

            public var startTime: Int64?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Text") {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public var list: [GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List]?

        public var pageTotal: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageTotal != nil {
                map["PageTotal"] = self.pageTotal!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageTotal") {
                self.pageTotal = dict["PageTotal"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var mediaAuditAudioResultDetail: GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditAudioResultDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditAudioResultDetail != nil {
            map["MediaAuditAudioResultDetail"] = self.mediaAuditAudioResultDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditAudioResultDetail") {
            var model = GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail()
            model.fromMap(dict["MediaAuditAudioResultDetail"] as! [String: Any])
            self.mediaAuditAudioResultDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditAudioResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditAudioResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaAuditAudioResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetMediaAuditResultResponseBody : Tea.TeaModel {
    public class MediaAuditResult : Tea.TeaModel {
        public class AudioResult : Tea.TeaModel {
            public var label: String?

            public var scene: String?

            public var score: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class ImageResult : Tea.TeaModel {
            public class Result : Tea.TeaModel {
                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public var label: String?

            public var result: [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result]?

            public var suggestion: String?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.result != nil {
                    var tmp : [Any] = []
                    for k in self.result! {
                        tmp.append(k.toMap())
                    }
                    map["Result"] = tmp
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Result") {
                    var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result] = []
                    for v in dict["Result"] as! [Any] {
                        var model = GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.result = tmp
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class TextResult : Tea.TeaModel {
            public var content: String?

            public var label: String?

            public var scene: String?

            public var score: String?

            public var suggestion: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class VideoResult : Tea.TeaModel {
            public class AdResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class LiveResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class LogoResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class PornResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class TerrorismResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public var adResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult?

            public var label: String?

            public var liveResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult?

            public var logoResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult?

            public var pornResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult?

            public var suggestion: String?

            public var terrorismResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adResult?.validate()
                try self.liveResult?.validate()
                try self.logoResult?.validate()
                try self.pornResult?.validate()
                try self.terrorismResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adResult != nil {
                    map["AdResult"] = self.adResult?.toMap()
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.liveResult != nil {
                    map["LiveResult"] = self.liveResult?.toMap()
                }
                if self.logoResult != nil {
                    map["LogoResult"] = self.logoResult?.toMap()
                }
                if self.pornResult != nil {
                    map["PornResult"] = self.pornResult?.toMap()
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.terrorismResult != nil {
                    map["TerrorismResult"] = self.terrorismResult?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdResult") {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult()
                    model.fromMap(dict["AdResult"] as! [String: Any])
                    self.adResult = model
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("LiveResult") {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult()
                    model.fromMap(dict["LiveResult"] as! [String: Any])
                    self.liveResult = model
                }
                if dict.keys.contains("LogoResult") {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult()
                    model.fromMap(dict["LogoResult"] as! [String: Any])
                    self.logoResult = model
                }
                if dict.keys.contains("PornResult") {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult()
                    model.fromMap(dict["PornResult"] as! [String: Any])
                    self.pornResult = model
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TerrorismResult") {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult()
                    model.fromMap(dict["TerrorismResult"] as! [String: Any])
                    self.terrorismResult = model
                }
            }
        }
        public var abnormalModules: String?

        public var audioResult: [GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult]?

        public var imageResult: [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult]?

        public var label: String?

        public var suggestion: String?

        public var textResult: [GetMediaAuditResultResponseBody.MediaAuditResult.TextResult]?

        public var videoResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.videoResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalModules != nil {
                map["AbnormalModules"] = self.abnormalModules!
            }
            if self.audioResult != nil {
                var tmp : [Any] = []
                for k in self.audioResult! {
                    tmp.append(k.toMap())
                }
                map["AudioResult"] = tmp
            }
            if self.imageResult != nil {
                var tmp : [Any] = []
                for k in self.imageResult! {
                    tmp.append(k.toMap())
                }
                map["ImageResult"] = tmp
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.textResult != nil {
                var tmp : [Any] = []
                for k in self.textResult! {
                    tmp.append(k.toMap())
                }
                map["TextResult"] = tmp
            }
            if self.videoResult != nil {
                map["VideoResult"] = self.videoResult?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalModules") {
                self.abnormalModules = dict["AbnormalModules"] as! String
            }
            if dict.keys.contains("AudioResult") {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult] = []
                for v in dict["AudioResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioResult = tmp
            }
            if dict.keys.contains("ImageResult") {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult] = []
                for v in dict["ImageResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageResult = tmp
            }
            if dict.keys.contains("Label") {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TextResult") {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.TextResult] = []
                for v in dict["TextResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.TextResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.textResult = tmp
            }
            if dict.keys.contains("VideoResult") {
                var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult()
                model.fromMap(dict["VideoResult"] as! [String: Any])
                self.videoResult = model
            }
        }
    }
    public var mediaAuditResult: GetMediaAuditResultResponseBody.MediaAuditResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResult != nil {
            map["MediaAuditResult"] = self.mediaAuditResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResult") {
            var model = GetMediaAuditResultResponseBody.MediaAuditResult()
            model.fromMap(dict["MediaAuditResult"] as! [String: Any])
            self.mediaAuditResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaAuditResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultDetailRequest : Tea.TeaModel {
    public var mediaId: String?

    public var pageNo: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
    }
}

public class GetMediaAuditResultDetailResponseBody : Tea.TeaModel {
    public class MediaAuditResultDetail : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var adLabel: String?

            public var adScore: String?

            public var liveLabel: String?

            public var liveScore: String?

            public var logoLabel: String?

            public var logoScore: String?

            public var pornLabel: String?

            public var pornScore: String?

            public var terrorismLabel: String?

            public var terrorismScore: String?

            public var timestamp: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adLabel != nil {
                    map["AdLabel"] = self.adLabel!
                }
                if self.adScore != nil {
                    map["AdScore"] = self.adScore!
                }
                if self.liveLabel != nil {
                    map["LiveLabel"] = self.liveLabel!
                }
                if self.liveScore != nil {
                    map["LiveScore"] = self.liveScore!
                }
                if self.logoLabel != nil {
                    map["LogoLabel"] = self.logoLabel!
                }
                if self.logoScore != nil {
                    map["LogoScore"] = self.logoScore!
                }
                if self.pornLabel != nil {
                    map["PornLabel"] = self.pornLabel!
                }
                if self.pornScore != nil {
                    map["PornScore"] = self.pornScore!
                }
                if self.terrorismLabel != nil {
                    map["TerrorismLabel"] = self.terrorismLabel!
                }
                if self.terrorismScore != nil {
                    map["TerrorismScore"] = self.terrorismScore!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdLabel") {
                    self.adLabel = dict["AdLabel"] as! String
                }
                if dict.keys.contains("AdScore") {
                    self.adScore = dict["AdScore"] as! String
                }
                if dict.keys.contains("LiveLabel") {
                    self.liveLabel = dict["LiveLabel"] as! String
                }
                if dict.keys.contains("LiveScore") {
                    self.liveScore = dict["LiveScore"] as! String
                }
                if dict.keys.contains("LogoLabel") {
                    self.logoLabel = dict["LogoLabel"] as! String
                }
                if dict.keys.contains("LogoScore") {
                    self.logoScore = dict["LogoScore"] as! String
                }
                if dict.keys.contains("PornLabel") {
                    self.pornLabel = dict["PornLabel"] as! String
                }
                if dict.keys.contains("PornScore") {
                    self.pornScore = dict["PornScore"] as! String
                }
                if dict.keys.contains("TerrorismLabel") {
                    self.terrorismLabel = dict["TerrorismLabel"] as! String
                }
                if dict.keys.contains("TerrorismScore") {
                    self.terrorismScore = dict["TerrorismScore"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var list: [GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var mediaAuditResultDetail: GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResultDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResultDetail != nil {
            map["MediaAuditResultDetail"] = self.mediaAuditResultDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResultDetail") {
            var model = GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail()
            model.fromMap(dict["MediaAuditResultDetail"] as! [String: Any])
            self.mediaAuditResultDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaAuditResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultTimelineRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetMediaAuditResultTimelineResponseBody : Tea.TeaModel {
    public class MediaAuditResultTimeline : Tea.TeaModel {
        public class Ad : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Live : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Logo : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Porn : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Terrorism : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var ad: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad]?

        public var live: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live]?

        public var logo: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo]?

        public var porn: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn]?

        public var terrorism: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ad != nil {
                var tmp : [Any] = []
                for k in self.ad! {
                    tmp.append(k.toMap())
                }
                map["Ad"] = tmp
            }
            if self.live != nil {
                var tmp : [Any] = []
                for k in self.live! {
                    tmp.append(k.toMap())
                }
                map["Live"] = tmp
            }
            if self.logo != nil {
                var tmp : [Any] = []
                for k in self.logo! {
                    tmp.append(k.toMap())
                }
                map["Logo"] = tmp
            }
            if self.porn != nil {
                var tmp : [Any] = []
                for k in self.porn! {
                    tmp.append(k.toMap())
                }
                map["Porn"] = tmp
            }
            if self.terrorism != nil {
                var tmp : [Any] = []
                for k in self.terrorism! {
                    tmp.append(k.toMap())
                }
                map["Terrorism"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ad") {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad] = []
                for v in dict["Ad"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ad = tmp
            }
            if dict.keys.contains("Live") {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live] = []
                for v in dict["Live"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.live = tmp
            }
            if dict.keys.contains("Logo") {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo] = []
                for v in dict["Logo"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logo = tmp
            }
            if dict.keys.contains("Porn") {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn] = []
                for v in dict["Porn"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.porn = tmp
            }
            if dict.keys.contains("Terrorism") {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism] = []
                for v in dict["Terrorism"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.terrorism = tmp
            }
        }
    }
    public var mediaAuditResultTimeline: GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResultTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResultTimeline != nil {
            map["MediaAuditResultTimeline"] = self.mediaAuditResultTimeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResultTimeline") {
            var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline()
            model.fromMap(dict["MediaAuditResultTimeline"] as! [String: Any])
            self.mediaAuditResultTimeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaAuditResultTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaDNAResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetMediaDNAResultResponseBody : Tea.TeaModel {
    public class DNAResult : Tea.TeaModel {
        public class VideoDNA : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public class Duplication : Tea.TeaModel {
                    public var duration: String?

                    public var start: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! String
                        }
                    }
                }
                public class Input : Tea.TeaModel {
                    public var duration: String?

                    public var start: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Start") {
                            self.start = dict["Start"] as! String
                        }
                    }
                }
                public var duplication: GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Duplication?

                public var input: GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.duplication?.validate()
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duplication != nil {
                        map["Duplication"] = self.duplication?.toMap()
                    }
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duplication") {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Duplication()
                        model.fromMap(dict["Duplication"] as! [String: Any])
                        self.duplication = model
                    }
                    if dict.keys.contains("Input") {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public var detail: [GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail]?

            public var primaryKey: String?

            public var similarity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.primaryKey != nil {
                    map["PrimaryKey"] = self.primaryKey!
                }
                if self.similarity != nil {
                    map["Similarity"] = self.similarity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("PrimaryKey") {
                    self.primaryKey = dict["PrimaryKey"] as! String
                }
                if dict.keys.contains("Similarity") {
                    self.similarity = dict["Similarity"] as! String
                }
            }
        }
        public var videoDNA: [GetMediaDNAResultResponseBody.DNAResult.VideoDNA]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoDNA != nil {
                var tmp : [Any] = []
                for k in self.videoDNA! {
                    tmp.append(k.toMap())
                }
                map["VideoDNA"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VideoDNA") {
                var tmp : [GetMediaDNAResultResponseBody.DNAResult.VideoDNA] = []
                for v in dict["VideoDNA"] as! [Any] {
                    var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoDNA = tmp
            }
        }
    }
    public var DNAResult: GetMediaDNAResultResponseBody.DNAResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DNAResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DNAResult != nil {
            map["DNAResult"] = self.DNAResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DNAResult") {
            var model = GetMediaDNAResultResponseBody.DNAResult()
            model.fromMap(dict["DNAResult"] as! [String: Any])
            self.DNAResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaDNAResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaDNAResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaDNAResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaRefreshJobsRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaRefreshJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaRefreshJobId != nil {
            map["MediaRefreshJobId"] = self.mediaRefreshJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaRefreshJobId") {
            self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
        }
    }
}

public class GetMediaRefreshJobsResponseBody : Tea.TeaModel {
    public class MediaRefreshJobs : Tea.TeaModel {
        public var errorCode: String?

        public var errorMessage: String?

        public var filterPolicy: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var mediaId: String?

        public var mediaRefreshJobId: String?

        public var status: String?

        public var successPlayUrls: String?

        public var taskIds: String?

        public var taskType: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.filterPolicy != nil {
                map["FilterPolicy"] = self.filterPolicy!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaRefreshJobId != nil {
                map["MediaRefreshJobId"] = self.mediaRefreshJobId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.successPlayUrls != nil {
                map["SuccessPlayUrls"] = self.successPlayUrls!
            }
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FilterPolicy") {
                self.filterPolicy = dict["FilterPolicy"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaRefreshJobId") {
                self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SuccessPlayUrls") {
                self.successPlayUrls = dict["SuccessPlayUrls"] as! String
            }
            if dict.keys.contains("TaskIds") {
                self.taskIds = dict["TaskIds"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaRefreshJobs: [GetMediaRefreshJobsResponseBody.MediaRefreshJobs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaRefreshJobs != nil {
            var tmp : [Any] = []
            for k in self.mediaRefreshJobs! {
                tmp.append(k.toMap())
            }
            map["MediaRefreshJobs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaRefreshJobs") {
            var tmp : [GetMediaRefreshJobsResponseBody.MediaRefreshJobs] = []
            for v in dict["MediaRefreshJobs"] as! [Any] {
                var model = GetMediaRefreshJobsResponseBody.MediaRefreshJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaRefreshJobs = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaRefreshJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaRefreshJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMediaRefreshJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class GetMessageCallbackResponseBody : Tea.TeaModel {
    public class MessageCallback : Tea.TeaModel {
        public var appId: String?

        public var authKey: String?

        public var authSwitch: String?

        public var callbackType: String?

        public var callbackURL: String?

        public var eventTypeList: String?

        public var mnsEndpoint: String?

        public var mnsQueueName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.authKey != nil {
                map["AuthKey"] = self.authKey!
            }
            if self.authSwitch != nil {
                map["AuthSwitch"] = self.authSwitch!
            }
            if self.callbackType != nil {
                map["CallbackType"] = self.callbackType!
            }
            if self.callbackURL != nil {
                map["CallbackURL"] = self.callbackURL!
            }
            if self.eventTypeList != nil {
                map["EventTypeList"] = self.eventTypeList!
            }
            if self.mnsEndpoint != nil {
                map["MnsEndpoint"] = self.mnsEndpoint!
            }
            if self.mnsQueueName != nil {
                map["MnsQueueName"] = self.mnsQueueName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AuthKey") {
                self.authKey = dict["AuthKey"] as! String
            }
            if dict.keys.contains("AuthSwitch") {
                self.authSwitch = dict["AuthSwitch"] as! String
            }
            if dict.keys.contains("CallbackType") {
                self.callbackType = dict["CallbackType"] as! String
            }
            if dict.keys.contains("CallbackURL") {
                self.callbackURL = dict["CallbackURL"] as! String
            }
            if dict.keys.contains("EventTypeList") {
                self.eventTypeList = dict["EventTypeList"] as! String
            }
            if dict.keys.contains("MnsEndpoint") {
                self.mnsEndpoint = dict["MnsEndpoint"] as! String
            }
            if dict.keys.contains("MnsQueueName") {
                self.mnsQueueName = dict["MnsQueueName"] as! String
            }
        }
    }
    public var messageCallback: GetMessageCallbackResponseBody.MessageCallback?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.messageCallback?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageCallback != nil {
            map["MessageCallback"] = self.messageCallback?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MessageCallback") {
            var model = GetMessageCallbackResponseBody.MessageCallback()
            model.fromMap(dict["MessageCallback"] as! [String: Any])
            self.messageCallback = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMezzanineInfoRequest : Tea.TeaModel {
    public var additionType: String?

    public var authTimeout: Int64?

    public var outputType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetMezzanineInfoResponseBody : Tea.TeaModel {
    public class Mezzanine : Tea.TeaModel {
        public class AudioStreamList : Tea.TeaModel {
            public var bitrate: String?

            public var channelLayout: String?

            public var channels: String?

            public var codecLongName: String?

            public var codecName: String?

            public var codecTag: String?

            public var codecTagString: String?

            public var codecTimeBase: String?

            public var duration: String?

            public var index: String?

            public var lang: String?

            public var numFrames: String?

            public var sampleFmt: String?

            public var sampleRate: String?

            public var startTime: String?

            public var timebase: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channelLayout != nil {
                    map["ChannelLayout"] = self.channelLayout!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codecLongName != nil {
                    map["CodecLongName"] = self.codecLongName!
                }
                if self.codecName != nil {
                    map["CodecName"] = self.codecName!
                }
                if self.codecTag != nil {
                    map["CodecTag"] = self.codecTag!
                }
                if self.codecTagString != nil {
                    map["CodecTagString"] = self.codecTagString!
                }
                if self.codecTimeBase != nil {
                    map["CodecTimeBase"] = self.codecTimeBase!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.lang != nil {
                    map["Lang"] = self.lang!
                }
                if self.numFrames != nil {
                    map["NumFrames"] = self.numFrames!
                }
                if self.sampleFmt != nil {
                    map["SampleFmt"] = self.sampleFmt!
                }
                if self.sampleRate != nil {
                    map["SampleRate"] = self.sampleRate!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.timebase != nil {
                    map["Timebase"] = self.timebase!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("ChannelLayout") {
                    self.channelLayout = dict["ChannelLayout"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("CodecLongName") {
                    self.codecLongName = dict["CodecLongName"] as! String
                }
                if dict.keys.contains("CodecName") {
                    self.codecName = dict["CodecName"] as! String
                }
                if dict.keys.contains("CodecTag") {
                    self.codecTag = dict["CodecTag"] as! String
                }
                if dict.keys.contains("CodecTagString") {
                    self.codecTagString = dict["CodecTagString"] as! String
                }
                if dict.keys.contains("CodecTimeBase") {
                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Lang") {
                    self.lang = dict["Lang"] as! String
                }
                if dict.keys.contains("NumFrames") {
                    self.numFrames = dict["NumFrames"] as! String
                }
                if dict.keys.contains("SampleFmt") {
                    self.sampleFmt = dict["SampleFmt"] as! String
                }
                if dict.keys.contains("SampleRate") {
                    self.sampleRate = dict["SampleRate"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Timebase") {
                    self.timebase = dict["Timebase"] as! String
                }
            }
        }
        public class VideoStreamList : Tea.TeaModel {
            public var avgFPS: String?

            public var bitrate: String?

            public var codecLongName: String?

            public var codecName: String?

            public var codecTag: String?

            public var codecTagString: String?

            public var codecTimeBase: String?

            public var dar: String?

            public var duration: String?

            public var fps: String?

            public var HDRType: String?

            public var hasBFrames: String?

            public var height: String?

            public var index: String?

            public var lang: String?

            public var level: String?

            public var numFrames: String?

            public var pixFmt: String?

            public var profile: String?

            public var rotate: String?

            public var sar: String?

            public var startTime: String?

            public var timebase: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgFPS != nil {
                    map["AvgFPS"] = self.avgFPS!
                }
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codecLongName != nil {
                    map["CodecLongName"] = self.codecLongName!
                }
                if self.codecName != nil {
                    map["CodecName"] = self.codecName!
                }
                if self.codecTag != nil {
                    map["CodecTag"] = self.codecTag!
                }
                if self.codecTagString != nil {
                    map["CodecTagString"] = self.codecTagString!
                }
                if self.codecTimeBase != nil {
                    map["CodecTimeBase"] = self.codecTimeBase!
                }
                if self.dar != nil {
                    map["Dar"] = self.dar!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.HDRType != nil {
                    map["HDRType"] = self.HDRType!
                }
                if self.hasBFrames != nil {
                    map["HasBFrames"] = self.hasBFrames!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.lang != nil {
                    map["Lang"] = self.lang!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.numFrames != nil {
                    map["NumFrames"] = self.numFrames!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.rotate != nil {
                    map["Rotate"] = self.rotate!
                }
                if self.sar != nil {
                    map["Sar"] = self.sar!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.timebase != nil {
                    map["Timebase"] = self.timebase!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgFPS") {
                    self.avgFPS = dict["AvgFPS"] as! String
                }
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CodecLongName") {
                    self.codecLongName = dict["CodecLongName"] as! String
                }
                if dict.keys.contains("CodecName") {
                    self.codecName = dict["CodecName"] as! String
                }
                if dict.keys.contains("CodecTag") {
                    self.codecTag = dict["CodecTag"] as! String
                }
                if dict.keys.contains("CodecTagString") {
                    self.codecTagString = dict["CodecTagString"] as! String
                }
                if dict.keys.contains("CodecTimeBase") {
                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                }
                if dict.keys.contains("Dar") {
                    self.dar = dict["Dar"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("HDRType") {
                    self.HDRType = dict["HDRType"] as! String
                }
                if dict.keys.contains("HasBFrames") {
                    self.hasBFrames = dict["HasBFrames"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Lang") {
                    self.lang = dict["Lang"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("NumFrames") {
                    self.numFrames = dict["NumFrames"] as! String
                }
                if dict.keys.contains("PixFmt") {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Rotate") {
                    self.rotate = dict["Rotate"] as! String
                }
                if dict.keys.contains("Sar") {
                    self.sar = dict["Sar"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Timebase") {
                    self.timebase = dict["Timebase"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioStreamList: [GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList]?

        public var bitrate: String?

        public var creationTime: String?

        public var duration: String?

        public var fileName: String?

        public var fileURL: String?

        public var fps: String?

        public var height: Int64?

        public var outputType: String?

        public var preprocessStatus: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var status: String?

        public var storageClass: String?

        public var videoId: String?

        public var videoStreamList: [GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList]?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioStreamList != nil {
                var tmp : [Any] = []
                for k in self.audioStreamList! {
                    tmp.append(k.toMap())
                }
                map["AudioStreamList"] = tmp
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.outputType != nil {
                map["OutputType"] = self.outputType!
            }
            if self.preprocessStatus != nil {
                map["PreprocessStatus"] = self.preprocessStatus!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            if self.videoStreamList != nil {
                var tmp : [Any] = []
                for k in self.videoStreamList! {
                    tmp.append(k.toMap())
                }
                map["VideoStreamList"] = tmp
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioStreamList") {
                var tmp : [GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList] = []
                for v in dict["AudioStreamList"] as! [Any] {
                    var model = GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioStreamList = tmp
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("OutputType") {
                self.outputType = dict["OutputType"] as! String
            }
            if dict.keys.contains("PreprocessStatus") {
                self.preprocessStatus = dict["PreprocessStatus"] as! String
            }
            if dict.keys.contains("RestoreExpiration") {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
            if dict.keys.contains("VideoStreamList") {
                var tmp : [GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList] = []
                for v in dict["VideoStreamList"] as! [Any] {
                    var model = GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoStreamList = tmp
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mezzanine: GetMezzanineInfoResponseBody.Mezzanine?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mezzanine?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mezzanine != nil {
            map["Mezzanine"] = self.mezzanine?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mezzanine") {
            var model = GetMezzanineInfoResponseBody.Mezzanine()
            model.fromMap(dict["Mezzanine"] as! [String: Any])
            self.mezzanine = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMezzanineInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMezzanineInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMezzanineInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var additionType: String?

    public var authTimeout: Int64?

    public var definition: String?

    public var digitalWatermarkType: String?

    public var formats: String?

    public var outputType: String?

    public var playConfig: String?

    public var reAuthInfo: String?

    public var resultType: String?

    public var streamType: String?

    public var trace: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.digitalWatermarkType != nil {
            map["DigitalWatermarkType"] = self.digitalWatermarkType!
        }
        if self.formats != nil {
            map["Formats"] = self.formats!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.playConfig != nil {
            map["PlayConfig"] = self.playConfig!
        }
        if self.reAuthInfo != nil {
            map["ReAuthInfo"] = self.reAuthInfo!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        if self.trace != nil {
            map["Trace"] = self.trace!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("DigitalWatermarkType") {
            self.digitalWatermarkType = dict["DigitalWatermarkType"] as! String
        }
        if dict.keys.contains("Formats") {
            self.formats = dict["Formats"] as! String
        }
        if dict.keys.contains("OutputType") {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("PlayConfig") {
            self.playConfig = dict["PlayConfig"] as! String
        }
        if dict.keys.contains("ReAuthInfo") {
            self.reAuthInfo = dict["ReAuthInfo"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! String
        }
        if dict.keys.contains("Trace") {
            self.trace = dict["Trace"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class PlayInfoList : Tea.TeaModel {
        public class PlayInfo : Tea.TeaModel {
            public var bitDepth: Int32?

            public var bitrate: String?

            public var creationTime: String?

            public var definition: String?

            public var duration: String?

            public var encrypt: Int64?

            public var encryptType: String?

            public var format: String?

            public var fps: String?

            public var HDRType: String?

            public var height: Int64?

            public var jobExt: String?

            public var jobId: String?

            public var jobType: Int32?

            public var modificationTime: String?

            public var narrowBandType: String?

            public var playURL: String?

            public var size: Int64?

            public var specification: String?

            public var status: String?

            public var streamType: String?

            public var watermarkId: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitDepth != nil {
                    map["BitDepth"] = self.bitDepth!
                }
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.encrypt != nil {
                    map["Encrypt"] = self.encrypt!
                }
                if self.encryptType != nil {
                    map["EncryptType"] = self.encryptType!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.HDRType != nil {
                    map["HDRType"] = self.HDRType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.jobExt != nil {
                    map["JobExt"] = self.jobExt!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.narrowBandType != nil {
                    map["NarrowBandType"] = self.narrowBandType!
                }
                if self.playURL != nil {
                    map["PlayURL"] = self.playURL!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.specification != nil {
                    map["Specification"] = self.specification!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.watermarkId != nil {
                    map["WatermarkId"] = self.watermarkId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BitDepth") {
                    self.bitDepth = dict["BitDepth"] as! Int32
                }
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Definition") {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Encrypt") {
                    self.encrypt = dict["Encrypt"] as! Int64
                }
                if dict.keys.contains("EncryptType") {
                    self.encryptType = dict["EncryptType"] as! String
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("HDRType") {
                    self.HDRType = dict["HDRType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("JobExt") {
                    self.jobExt = dict["JobExt"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobType") {
                    self.jobType = dict["JobType"] as! Int32
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("NarrowBandType") {
                    self.narrowBandType = dict["NarrowBandType"] as! String
                }
                if dict.keys.contains("PlayURL") {
                    self.playURL = dict["PlayURL"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Specification") {
                    self.specification = dict["Specification"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StreamType") {
                    self.streamType = dict["StreamType"] as! String
                }
                if dict.keys.contains("WatermarkId") {
                    self.watermarkId = dict["WatermarkId"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var playInfo: [GetPlayInfoResponseBody.PlayInfoList.PlayInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.playInfo != nil {
                var tmp : [Any] = []
                for k in self.playInfo! {
                    tmp.append(k.toMap())
                }
                map["PlayInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PlayInfo") {
                var tmp : [GetPlayInfoResponseBody.PlayInfoList.PlayInfo] = []
                for v in dict["PlayInfo"] as! [Any] {
                    var model = GetPlayInfoResponseBody.PlayInfoList.PlayInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.playInfo = tmp
            }
        }
    }
    public class VideoBase : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var danMuURL: String?

        public var duration: String?

        public var mediaType: String?

        public var status: String?

        public var storageClass: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.danMuURL != nil {
                map["DanMuURL"] = self.danMuURL!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DanMuURL") {
                self.danMuURL = dict["DanMuURL"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var playInfoList: GetPlayInfoResponseBody.PlayInfoList?

    public var requestId: String?

    public var videoBase: GetPlayInfoResponseBody.VideoBase?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.playInfoList?.validate()
        try self.videoBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playInfoList != nil {
            map["PlayInfoList"] = self.playInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoBase != nil {
            map["VideoBase"] = self.videoBase?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayInfoList") {
            var model = GetPlayInfoResponseBody.PlayInfoList()
            model.fromMap(dict["PlayInfoList"] as! [String: Any])
            self.playInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoBase") {
            var model = GetPlayInfoResponseBody.VideoBase()
            model.fromMap(dict["VideoBase"] as! [String: Any])
            self.videoBase = model
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeSummaryRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class GetTranscodeSummaryResponseBody : Tea.TeaModel {
    public class TranscodeSummaryList : Tea.TeaModel {
        public class TranscodeJobInfoSummaryList : Tea.TeaModel {
            public var bitrate: String?

            public var completeTime: String?

            public var creationTime: String?

            public var duration: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var filesize: Int64?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var transcodeJobStatus: String?

            public var transcodeProgress: Int64?

            public var transcodeTemplateId: String?

            public var watermarkIdList: [String]?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.filesize != nil {
                    map["Filesize"] = self.filesize!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.transcodeJobStatus != nil {
                    map["TranscodeJobStatus"] = self.transcodeJobStatus!
                }
                if self.transcodeProgress != nil {
                    map["TranscodeProgress"] = self.transcodeProgress!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                if self.watermarkIdList != nil {
                    map["WatermarkIdList"] = self.watermarkIdList!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CompleteTime") {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Filesize") {
                    self.filesize = dict["Filesize"] as! Int64
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("TranscodeJobStatus") {
                    self.transcodeJobStatus = dict["TranscodeJobStatus"] as! String
                }
                if dict.keys.contains("TranscodeProgress") {
                    self.transcodeProgress = dict["TranscodeProgress"] as! Int64
                }
                if dict.keys.contains("TranscodeTemplateId") {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
                if dict.keys.contains("WatermarkIdList") {
                    self.watermarkIdList = dict["WatermarkIdList"] as! [String]
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var completeTime: String?

        public var creationTime: String?

        public var transcodeJobInfoSummaryList: [GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList]?

        public var transcodeStatus: String?

        public var transcodeTemplateGroupId: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.transcodeJobInfoSummaryList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobInfoSummaryList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobInfoSummaryList"] = tmp
            }
            if self.transcodeStatus != nil {
                map["TranscodeStatus"] = self.transcodeStatus!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TranscodeJobInfoSummaryList") {
                var tmp : [GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList] = []
                for v in dict["TranscodeJobInfoSummaryList"] as! [Any] {
                    var model = GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobInfoSummaryList = tmp
            }
            if dict.keys.contains("TranscodeStatus") {
                self.transcodeStatus = dict["TranscodeStatus"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var transcodeSummaryList: [GetTranscodeSummaryResponseBody.TranscodeSummaryList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeSummaryList != nil {
            var tmp : [Any] = []
            for k in self.transcodeSummaryList! {
                tmp.append(k.toMap())
            }
            map["TranscodeSummaryList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeSummaryList") {
            var tmp : [GetTranscodeSummaryResponseBody.TranscodeSummaryList] = []
            for v in dict["TranscodeSummaryList"] as! [Any] {
                var model = GetTranscodeSummaryResponseBody.TranscodeSummaryList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeSummaryList = tmp
        }
    }
}

public class GetTranscodeSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeTaskRequest : Tea.TeaModel {
    public var transcodeTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTaskId != nil {
            map["TranscodeTaskId"] = self.transcodeTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTaskId") {
            self.transcodeTaskId = dict["TranscodeTaskId"] as! String
        }
    }
}

public class GetTranscodeTaskResponseBody : Tea.TeaModel {
    public class TranscodeTask : Tea.TeaModel {
        public class TranscodeJobInfoList : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var audioStreamList: String?

                public var bitrate: String?

                public var duration: String?

                public var encryption: String?

                public var filesize: Int64?

                public var format: String?

                public var fps: String?

                public var height: String?

                public var outputFileUrl: String?

                public var subtitleStreamList: String?

                public var videoStreamList: String?

                public var watermarkIdList: [String]?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamList != nil {
                        map["AudioStreamList"] = self.audioStreamList!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption!
                    }
                    if self.filesize != nil {
                        map["Filesize"] = self.filesize!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.outputFileUrl != nil {
                        map["OutputFileUrl"] = self.outputFileUrl!
                    }
                    if self.subtitleStreamList != nil {
                        map["SubtitleStreamList"] = self.subtitleStreamList!
                    }
                    if self.videoStreamList != nil {
                        map["VideoStreamList"] = self.videoStreamList!
                    }
                    if self.watermarkIdList != nil {
                        map["WatermarkIdList"] = self.watermarkIdList!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamList") {
                        self.audioStreamList = dict["AudioStreamList"] as! String
                    }
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Encryption") {
                        self.encryption = dict["Encryption"] as! String
                    }
                    if dict.keys.contains("Filesize") {
                        self.filesize = dict["Filesize"] as! Int64
                    }
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("OutputFileUrl") {
                        self.outputFileUrl = dict["OutputFileUrl"] as! String
                    }
                    if dict.keys.contains("SubtitleStreamList") {
                        self.subtitleStreamList = dict["SubtitleStreamList"] as! String
                    }
                    if dict.keys.contains("VideoStreamList") {
                        self.videoStreamList = dict["VideoStreamList"] as! String
                    }
                    if dict.keys.contains("WatermarkIdList") {
                        self.watermarkIdList = dict["WatermarkIdList"] as! [String]
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var completeTime: String?

            public var creationTime: String?

            public var definition: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var inputFileUrl: String?

            public var outputFile: GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList.OutputFile?

            public var priority: String?

            public var transcodeJobId: String?

            public var transcodeJobStatus: String?

            public var transcodeProgress: Int64?

            public var transcodeTemplateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.inputFileUrl != nil {
                    map["InputFileUrl"] = self.inputFileUrl!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.transcodeJobId != nil {
                    map["TranscodeJobId"] = self.transcodeJobId!
                }
                if self.transcodeJobStatus != nil {
                    map["TranscodeJobStatus"] = self.transcodeJobStatus!
                }
                if self.transcodeProgress != nil {
                    map["TranscodeProgress"] = self.transcodeProgress!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompleteTime") {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Definition") {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InputFileUrl") {
                    self.inputFileUrl = dict["InputFileUrl"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("TranscodeJobId") {
                    self.transcodeJobId = dict["TranscodeJobId"] as! String
                }
                if dict.keys.contains("TranscodeJobStatus") {
                    self.transcodeJobStatus = dict["TranscodeJobStatus"] as! String
                }
                if dict.keys.contains("TranscodeProgress") {
                    self.transcodeProgress = dict["TranscodeProgress"] as! Int64
                }
                if dict.keys.contains("TranscodeTemplateId") {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
            }
        }
        public var completeTime: String?

        public var creationTime: String?

        public var taskStatus: String?

        public var transcodeJobInfoList: [GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList]?

        public var transcodeTaskId: String?

        public var transcodeTemplateGroupId: String?

        public var trigger: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.transcodeJobInfoList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobInfoList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobInfoList"] = tmp
            }
            if self.transcodeTaskId != nil {
                map["TranscodeTaskId"] = self.transcodeTaskId!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
            if dict.keys.contains("TranscodeJobInfoList") {
                var tmp : [GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList] = []
                for v in dict["TranscodeJobInfoList"] as! [Any] {
                    var model = GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobInfoList = tmp
            }
            if dict.keys.contains("TranscodeTaskId") {
                self.transcodeTaskId = dict["TranscodeTaskId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("Trigger") {
                self.trigger = dict["Trigger"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTask: GetTranscodeTaskResponseBody.TranscodeTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTask != nil {
            map["TranscodeTask"] = self.transcodeTask?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTask") {
            var model = GetTranscodeTaskResponseBody.TranscodeTask()
            model.fromMap(dict["TranscodeTask"] as! [String: Any])
            self.transcodeTask = model
        }
    }
}

public class GetTranscodeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class GetTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public class TranscodeTemplateGroup : Tea.TeaModel {
        public class TranscodeTemplateList : Tea.TeaModel {
            public var audio: String?

            public var clip: String?

            public var container: String?

            public var copyrightMark: String?

            public var definition: String?

            public var encryptSetting: String?

            public var muxConfig: String?

            public var packageSetting: String?

            public var rotate: String?

            public var subtitleList: String?

            public var templateName: String?

            public var traceMark: String?

            public var transConfig: String?

            public var transcodeFileRegular: String?

            public var transcodeTemplateId: String?

            public var type: String?

            public var video: String?

            public var watermarkIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio!
                }
                if self.clip != nil {
                    map["Clip"] = self.clip!
                }
                if self.container != nil {
                    map["Container"] = self.container!
                }
                if self.copyrightMark != nil {
                    map["CopyrightMark"] = self.copyrightMark!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.encryptSetting != nil {
                    map["EncryptSetting"] = self.encryptSetting!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig!
                }
                if self.packageSetting != nil {
                    map["PackageSetting"] = self.packageSetting!
                }
                if self.rotate != nil {
                    map["Rotate"] = self.rotate!
                }
                if self.subtitleList != nil {
                    map["SubtitleList"] = self.subtitleList!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.traceMark != nil {
                    map["TraceMark"] = self.traceMark!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig!
                }
                if self.transcodeFileRegular != nil {
                    map["TranscodeFileRegular"] = self.transcodeFileRegular!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.video != nil {
                    map["Video"] = self.video!
                }
                if self.watermarkIds != nil {
                    map["WatermarkIds"] = self.watermarkIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") {
                    self.audio = dict["Audio"] as! String
                }
                if dict.keys.contains("Clip") {
                    self.clip = dict["Clip"] as! String
                }
                if dict.keys.contains("Container") {
                    self.container = dict["Container"] as! String
                }
                if dict.keys.contains("CopyrightMark") {
                    self.copyrightMark = dict["CopyrightMark"] as! String
                }
                if dict.keys.contains("Definition") {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("EncryptSetting") {
                    self.encryptSetting = dict["EncryptSetting"] as! String
                }
                if dict.keys.contains("MuxConfig") {
                    self.muxConfig = dict["MuxConfig"] as! String
                }
                if dict.keys.contains("PackageSetting") {
                    self.packageSetting = dict["PackageSetting"] as! String
                }
                if dict.keys.contains("Rotate") {
                    self.rotate = dict["Rotate"] as! String
                }
                if dict.keys.contains("SubtitleList") {
                    self.subtitleList = dict["SubtitleList"] as! String
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("TraceMark") {
                    self.traceMark = dict["TraceMark"] as! String
                }
                if dict.keys.contains("TransConfig") {
                    self.transConfig = dict["TransConfig"] as! String
                }
                if dict.keys.contains("TranscodeFileRegular") {
                    self.transcodeFileRegular = dict["TranscodeFileRegular"] as! String
                }
                if dict.keys.contains("TranscodeTemplateId") {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Video") {
                    self.video = dict["Video"] as! String
                }
                if dict.keys.contains("WatermarkIds") {
                    self.watermarkIds = dict["WatermarkIds"] as! [String]
                }
            }
        }
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var locked: String?

        public var modifyTime: String?

        public var name: String?

        public var transcodeTemplateGroupId: String?

        public var transcodeTemplateList: [GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.locked != nil {
                map["Locked"] = self.locked!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.transcodeTemplateList != nil {
                var tmp : [Any] = []
                for k in self.transcodeTemplateList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeTemplateList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Locked") {
                self.locked = dict["Locked"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateList") {
                var tmp : [GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList] = []
                for v in dict["TranscodeTemplateList"] as! [Any] {
                    var model = GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeTemplateList = tmp
            }
        }
    }
    public var requestId: String?

    public var transcodeTemplateGroup: GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeTemplateGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroup != nil {
            map["TranscodeTemplateGroup"] = self.transcodeTemplateGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroup") {
            var model = GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup()
            model.fromMap(dict["TranscodeTemplateGroup"] as! [String: Any])
            self.transcodeTemplateGroup = model
        }
    }
}

public class GetTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetURLUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetURLUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetURLUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") {
            var tmp : [GetURLUploadInfosResponseBody.URLUploadInfoList] = []
            for v in dict["URLUploadInfoList"] as! [Any] {
                var model = GetURLUploadInfosResponseBody.URLUploadInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.URLUploadInfoList = tmp
        }
    }
}

public class GetURLUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetURLUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetURLUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUploadDetailsRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var mediaType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
    }
}

public class GetUploadDetailsResponseBody : Tea.TeaModel {
    public class UploadDetails : Tea.TeaModel {
        public var completionTime: String?

        public var creationTime: String?

        public var deviceModel: String?

        public var fileSize: Int64?

        public var mediaId: String?

        public var modificationTime: String?

        public var status: String?

        public var title: String?

        public var uploadIP: String?

        public var uploadRatio: Double?

        public var uploadSize: Int64?

        public var uploadSource: String?

        public var uploadStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completionTime != nil {
                map["CompletionTime"] = self.completionTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deviceModel != nil {
                map["DeviceModel"] = self.deviceModel!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.uploadIP != nil {
                map["UploadIP"] = self.uploadIP!
            }
            if self.uploadRatio != nil {
                map["UploadRatio"] = self.uploadRatio!
            }
            if self.uploadSize != nil {
                map["UploadSize"] = self.uploadSize!
            }
            if self.uploadSource != nil {
                map["UploadSource"] = self.uploadSource!
            }
            if self.uploadStatus != nil {
                map["UploadStatus"] = self.uploadStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompletionTime") {
                self.completionTime = dict["CompletionTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeviceModel") {
                self.deviceModel = dict["DeviceModel"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UploadIP") {
                self.uploadIP = dict["UploadIP"] as! String
            }
            if dict.keys.contains("UploadRatio") {
                self.uploadRatio = dict["UploadRatio"] as! Double
            }
            if dict.keys.contains("UploadSize") {
                self.uploadSize = dict["UploadSize"] as! Int64
            }
            if dict.keys.contains("UploadSource") {
                self.uploadSource = dict["UploadSource"] as! String
            }
            if dict.keys.contains("UploadStatus") {
                self.uploadStatus = dict["UploadStatus"] as! String
            }
        }
    }
    public var forbiddenMediaIds: [String]?

    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public var uploadDetails: [GetUploadDetailsResponseBody.UploadDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenMediaIds != nil {
            map["ForbiddenMediaIds"] = self.forbiddenMediaIds!
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadDetails != nil {
            var tmp : [Any] = []
            for k in self.uploadDetails! {
                tmp.append(k.toMap())
            }
            map["UploadDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenMediaIds") {
            self.forbiddenMediaIds = dict["ForbiddenMediaIds"] as! [String]
        }
        if dict.keys.contains("NonExistMediaIds") {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadDetails") {
            var tmp : [GetUploadDetailsResponseBody.UploadDetails] = []
            for v in dict["UploadDetails"] as! [Any] {
                var model = GetUploadDetailsResponseBody.UploadDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadDetails = tmp
        }
    }
}

public class GetUploadDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUploadDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUploadDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoInfoRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetVideoInfoResponseBody : Tea.TeaModel {
    public class Video : Tea.TeaModel {
        public class Snapshots : Tea.TeaModel {
            public var snapshot: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.snapshot != nil {
                    map["Snapshot"] = self.snapshot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Snapshot") {
                    self.snapshot = dict["Snapshot"] as! [String]
                }
            }
        }
        public var appId: String?

        public var auditStatus: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverURL: String?

        public var creationTime: String?

        public var customMediaInfo: String?

        public var description_: String?

        public var downloadSwitch: String?

        public var duration: Double?

        public var modificationTime: String?

        public var regionId: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var snapshots: GetVideoInfoResponseBody.Video.Snapshots?

        public var status: String?

        public var storageClass: String?

        public var storageLocation: String?

        public var tags: String?

        public var templateGroupId: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshots?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.auditStatus != nil {
                map["AuditStatus"] = self.auditStatus!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.customMediaInfo != nil {
                map["CustomMediaInfo"] = self.customMediaInfo!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.downloadSwitch != nil {
                map["DownloadSwitch"] = self.downloadSwitch!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.templateGroupId != nil {
                map["TemplateGroupId"] = self.templateGroupId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AuditStatus") {
                self.auditStatus = dict["AuditStatus"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CustomMediaInfo") {
                self.customMediaInfo = dict["CustomMediaInfo"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DownloadSwitch") {
                self.downloadSwitch = dict["DownloadSwitch"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RestoreExpiration") {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                var model = GetVideoInfoResponseBody.Video.Snapshots()
                model.fromMap(dict["Snapshots"] as! [String: Any])
                self.snapshots = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("TemplateGroupId") {
                self.templateGroupId = dict["TemplateGroupId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var video: GetVideoInfoResponseBody.Video?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.video?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.video != nil {
            map["Video"] = self.video?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Video") {
            var model = GetVideoInfoResponseBody.Video()
            model.fromMap(dict["Video"] as! [String: Any])
            self.video = model
        }
    }
}

public class GetVideoInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoInfosRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class GetVideoInfosResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var downloadSwitch: String?

        public var duration: Double?

        public var modificationTime: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageClass: String?

        public var storageLocation: String?

        public var tags: String?

        public var templateGroupId: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.downloadSwitch != nil {
                map["DownloadSwitch"] = self.downloadSwitch!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.templateGroupId != nil {
                map["TemplateGroupId"] = self.templateGroupId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DownloadSwitch") {
                self.downloadSwitch = dict["DownloadSwitch"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("RestoreExpiration") {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("StorageLocation") {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("TemplateGroupId") {
                self.templateGroupId = dict["TemplateGroupId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var videoList: [GetVideoInfosResponseBody.VideoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoList != nil {
            var tmp : [Any] = []
            for k in self.videoList! {
                tmp.append(k.toMap())
            }
            map["VideoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoList") {
            var tmp : [GetVideoInfosResponseBody.VideoList] = []
            for v in dict["VideoList"] as! [Any] {
                var model = GetVideoInfosResponseBody.VideoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoList = tmp
        }
    }
}

public class GetVideoInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoListRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class GetVideoListResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public class Video : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public var snapshot: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        self.snapshot = dict["Snapshot"] as! [String]
                    }
                }
            }
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var modificationTime: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: GetVideoListResponseBody.VideoList.Video.Snapshots?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("RestoreExpiration") {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") {
                    var model = GetVideoListResponseBody.VideoList.Video.Snapshots()
                    model.fromMap(dict["Snapshots"] as! [String: Any])
                    self.snapshots = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("VideoId") {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var video: [GetVideoListResponseBody.VideoList.Video]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.video != nil {
                var tmp : [Any] = []
                for k in self.video! {
                    tmp.append(k.toMap())
                }
                map["Video"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Video") {
                var tmp : [GetVideoListResponseBody.VideoList.Video] = []
                for v in dict["Video"] as! [Any] {
                    var model = GetVideoListResponseBody.VideoList.Video()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.video = tmp
            }
        }
    }
    public var requestId: String?

    public var total: Int32?

    public var videoList: GetVideoListResponseBody.VideoList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.videoList != nil {
            map["VideoList"] = self.videoList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("VideoList") {
            var model = GetVideoListResponseBody.VideoList()
            model.fromMap(dict["VideoList"] as! [String: Any])
            self.videoList = model
        }
    }
}

public class GetVideoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoPlayAuthRequest : Tea.TeaModel {
    public var apiVersion: String?

    public var authInfoTimeout: Int64?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiVersion != nil {
            map["ApiVersion"] = self.apiVersion!
        }
        if self.authInfoTimeout != nil {
            map["AuthInfoTimeout"] = self.authInfoTimeout!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiVersion") {
            self.apiVersion = dict["ApiVersion"] as! String
        }
        if dict.keys.contains("AuthInfoTimeout") {
            self.authInfoTimeout = dict["AuthInfoTimeout"] as! Int64
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetVideoPlayAuthResponseBody : Tea.TeaModel {
    public class VideoMeta : Tea.TeaModel {
        public var coverURL: String?

        public var duration: Double?

        public var status: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var playAuth: String?

    public var requestId: String?

    public var videoMeta: GetVideoPlayAuthResponseBody.VideoMeta?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoMeta?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playAuth != nil {
            map["PlayAuth"] = self.playAuth!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoMeta != nil {
            map["VideoMeta"] = self.videoMeta?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayAuth") {
            self.playAuth = dict["PlayAuth"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoMeta") {
            var model = GetVideoPlayAuthResponseBody.VideoMeta()
            model.fromMap(dict["VideoMeta"] as! [String: Any])
            self.videoMeta = model
        }
    }
}

public class GetVideoPlayAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoPlayAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoPlayAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVodTemplateRequest : Tea.TeaModel {
    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class GetVodTemplateResponseBody : Tea.TeaModel {
    public class VodTemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var name: String?

        public var templateConfig: String?

        public var templateType: String?

        public var vodTemplateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.vodTemplateId != nil {
                map["VodTemplateId"] = self.vodTemplateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("VodTemplateId") {
                self.vodTemplateId = dict["VodTemplateId"] as! String
            }
        }
    }
    public var requestId: String?

    public var vodTemplateInfo: GetVodTemplateResponseBody.VodTemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vodTemplateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateInfo != nil {
            map["VodTemplateInfo"] = self.vodTemplateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateInfo") {
            var model = GetVodTemplateResponseBody.VodTemplateInfo()
            model.fromMap(dict["VodTemplateInfo"] as! [String: Any])
            self.vodTemplateInfo = model
        }
    }
}

public class GetVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class GetWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: GetWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") {
            var model = GetWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class GetWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIImageInfoRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListAIImageInfoResponseBody : Tea.TeaModel {
    public class AIImageInfoList : Tea.TeaModel {
        public var AIImageInfoId: String?

        public var creationTime: String?

        public var fileURL: String?

        public var format: String?

        public var jobId: String?

        public var score: String?

        public var version: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIImageInfoId != nil {
                map["AIImageInfoId"] = self.AIImageInfoId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIImageInfoId") {
                self.AIImageInfoId = dict["AIImageInfoId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Score") {
                self.score = dict["Score"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var AIImageInfoList: [ListAIImageInfoResponseBody.AIImageInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageInfoList != nil {
            var tmp : [Any] = []
            for k in self.AIImageInfoList! {
                tmp.append(k.toMap())
            }
            map["AIImageInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageInfoList") {
            var tmp : [ListAIImageInfoResponseBody.AIImageInfoList] = []
            for v in dict["AIImageInfoList"] as! [Any] {
                var model = ListAIImageInfoResponseBody.AIImageInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.AIImageInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAIImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIJobRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class ListAIJobResponseBody : Tea.TeaModel {
    public class AIJobList : Tea.TeaModel {
        public class AIJob : Tea.TeaModel {
            public var code: String?

            public var completeTime: String?

            public var creationTime: String?

            public var data: String?

            public var jobId: String?

            public var mediaId: String?

            public var message: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CompleteTime") {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var AIJob: [ListAIJobResponseBody.AIJobList.AIJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIJob != nil {
                var tmp : [Any] = []
                for k in self.AIJob! {
                    tmp.append(k.toMap())
                }
                map["AIJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIJob") {
                var tmp : [ListAIJobResponseBody.AIJobList.AIJob] = []
                for v in dict["AIJob"] as! [Any] {
                    var model = ListAIJobResponseBody.AIJobList.AIJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIJob = tmp
            }
        }
    }
    public class NonExistAIJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var AIJobList: ListAIJobResponseBody.AIJobList?

    public var nonExistAIJobIds: ListAIJobResponseBody.NonExistAIJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIJobList?.validate()
        try self.nonExistAIJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIJobList != nil {
            map["AIJobList"] = self.AIJobList?.toMap()
        }
        if self.nonExistAIJobIds != nil {
            map["NonExistAIJobIds"] = self.nonExistAIJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIJobList") {
            var model = ListAIJobResponseBody.AIJobList()
            model.fromMap(dict["AIJobList"] as! [String: Any])
            self.AIJobList = model
        }
        if dict.keys.contains("NonExistAIJobIds") {
            var model = ListAIJobResponseBody.NonExistAIJobIds()
            model.fromMap(dict["NonExistAIJobIds"] as! [String: Any])
            self.nonExistAIJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAITemplateRequest : Tea.TeaModel {
    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class ListAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfoList : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfoList: [ListAITemplateResponseBody.TemplateInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfoList != nil {
            var tmp : [Any] = []
            for k in self.templateInfoList! {
                tmp.append(k.toMap())
            }
            map["TemplateInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfoList") {
            var tmp : [ListAITemplateResponseBody.TemplateInfoList] = []
            for v in dict["TemplateInfoList"] as! [Any] {
                var model = ListAITemplateResponseBody.TemplateInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateInfoList = tmp
        }
    }
}

public class ListAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppInfoRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAppInfoResponseBody : Tea.TeaModel {
    public class AppInfoList : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var appInfoList: [ListAppInfoResponseBody.AppInfoList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfoList != nil {
            var tmp : [Any] = []
            for k in self.appInfoList! {
                tmp.append(k.toMap())
            }
            map["AppInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfoList") {
            var tmp : [ListAppInfoResponseBody.AppInfoList] = []
            for v in dict["AppInfoList"] as! [Any] {
                var model = ListAppInfoResponseBody.AppInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appInfoList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppPoliciesForIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") {
            self.identityType = dict["IdentityType"] as! String
        }
    }
}

public class ListAppPoliciesForIdentityResponseBody : Tea.TeaModel {
    public class AppPolicyList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var policyName: String?

        public var policyType: String?

        public var policyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            if self.policyValue != nil {
                map["PolicyValue"] = self.policyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("PolicyName") {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicyType") {
                self.policyType = dict["PolicyType"] as! String
            }
            if dict.keys.contains("PolicyValue") {
                self.policyValue = dict["PolicyValue"] as! String
            }
        }
    }
    public var appPolicyList: [ListAppPoliciesForIdentityResponseBody.AppPolicyList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appPolicyList != nil {
            var tmp : [Any] = []
            for k in self.appPolicyList! {
                tmp.append(k.toMap())
            }
            map["AppPolicyList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppPolicyList") {
            var tmp : [ListAppPoliciesForIdentityResponseBody.AppPolicyList] = []
            for v in dict["AppPolicyList"] as! [Any] {
                var model = ListAppPoliciesForIdentityResponseBody.AppPolicyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appPolicyList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAppPoliciesForIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppPoliciesForIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppPoliciesForIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuditSecurityIpRequest : Tea.TeaModel {
    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class ListAuditSecurityIpResponseBody : Tea.TeaModel {
    public class SecurityIpList : Tea.TeaModel {
        public var creationTime: String?

        public var ips: String?

        public var modificationTime: String?

        public var securityGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! String
            }
            if dict.keys.contains("ModificationTime") {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("SecurityGroupName") {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpList: [ListAuditSecurityIpResponseBody.SecurityIpList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpList != nil {
            var tmp : [Any] = []
            for k in self.securityIpList! {
                tmp.append(k.toMap())
            }
            map["SecurityIpList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpList") {
            var tmp : [ListAuditSecurityIpResponseBody.SecurityIpList] = []
            for v in dict["SecurityIpList"] as! [Any] {
                var model = ListAuditSecurityIpResponseBody.SecurityIpList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityIpList = tmp
        }
    }
}

public class ListAuditSecurityIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuditSecurityIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAuditSecurityIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListDynamicImageResponseBody : Tea.TeaModel {
    public class DynamicImageList : Tea.TeaModel {
        public var creationTime: String?

        public var duration: String?

        public var dynamicImageId: String?

        public var fileSize: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var jobId: String?

        public var videoId: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.dynamicImageId != nil {
                map["DynamicImageId"] = self.dynamicImageId!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("DynamicImageId") {
                self.dynamicImageId = dict["DynamicImageId"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var dynamicImageList: [ListDynamicImageResponseBody.DynamicImageList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageList != nil {
            var tmp : [Any] = []
            for k in self.dynamicImageList! {
                tmp.append(k.toMap())
            }
            map["DynamicImageList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageList") {
            var tmp : [ListDynamicImageResponseBody.DynamicImageList] = []
            for v in dict["DynamicImageList"] as! [Any] {
                var model = ListDynamicImageResponseBody.DynamicImageList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dynamicImageList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDynamicImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordVideoRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class ListLiveRecordVideoResponseBody : Tea.TeaModel {
    public class LiveRecordVideoList : Tea.TeaModel {
        public class LiveRecordVideo : Tea.TeaModel {
            public class Video : Tea.TeaModel {
                public class Snapshots : Tea.TeaModel {
                    public var snapshot: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.snapshot != nil {
                            map["Snapshot"] = self.snapshot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Snapshot") {
                            self.snapshot = dict["Snapshot"] as! [String]
                        }
                    }
                }
                public var cateId: Int32?

                public var cateName: String?

                public var coverURL: String?

                public var creationTime: String?

                public var description_: String?

                public var duration: Double?

                public var modifyTime: String?

                public var size: Int64?

                public var snapshots: ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video.Snapshots?

                public var status: String?

                public var tags: String?

                public var templateGroupId: String?

                public var title: String?

                public var videoId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.snapshots?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cateId != nil {
                        map["CateId"] = self.cateId!
                    }
                    if self.cateName != nil {
                        map["CateName"] = self.cateName!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.snapshots != nil {
                        map["Snapshots"] = self.snapshots?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags!
                    }
                    if self.templateGroupId != nil {
                        map["TemplateGroupId"] = self.templateGroupId!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.videoId != nil {
                        map["VideoId"] = self.videoId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CateId") {
                        self.cateId = dict["CateId"] as! Int32
                    }
                    if dict.keys.contains("CateName") {
                        self.cateName = dict["CateName"] as! String
                    }
                    if dict.keys.contains("CoverURL") {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreationTime") {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("ModifyTime") {
                        self.modifyTime = dict["ModifyTime"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! Int64
                    }
                    if dict.keys.contains("Snapshots") {
                        var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video.Snapshots()
                        model.fromMap(dict["Snapshots"] as! [String: Any])
                        self.snapshots = model
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Tags") {
                        self.tags = dict["Tags"] as! String
                    }
                    if dict.keys.contains("TemplateGroupId") {
                        self.templateGroupId = dict["TemplateGroupId"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("VideoId") {
                        self.videoId = dict["VideoId"] as! String
                    }
                }
            }
            public var appName: String?

            public var domainName: String?

            public var playlistId: String?

            public var recordEndTime: String?

            public var recordStartTime: String?

            public var streamName: String?

            public var video: ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.playlistId != nil {
                    map["PlaylistId"] = self.playlistId!
                }
                if self.recordEndTime != nil {
                    map["RecordEndTime"] = self.recordEndTime!
                }
                if self.recordStartTime != nil {
                    map["RecordStartTime"] = self.recordStartTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("PlaylistId") {
                    self.playlistId = dict["PlaylistId"] as! String
                }
                if dict.keys.contains("RecordEndTime") {
                    self.recordEndTime = dict["RecordEndTime"] as! String
                }
                if dict.keys.contains("RecordStartTime") {
                    self.recordStartTime = dict["RecordStartTime"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("Video") {
                    var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var liveRecordVideo: [ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveRecordVideo != nil {
                var tmp : [Any] = []
                for k in self.liveRecordVideo! {
                    tmp.append(k.toMap())
                }
                map["LiveRecordVideo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveRecordVideo") {
                var tmp : [ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo] = []
                for v in dict["LiveRecordVideo"] as! [Any] {
                    var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.liveRecordVideo = tmp
            }
        }
    }
    public var liveRecordVideoList: ListLiveRecordVideoResponseBody.LiveRecordVideoList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordVideoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordVideoList != nil {
            map["LiveRecordVideoList"] = self.liveRecordVideoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordVideoList") {
            var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList()
            model.fromMap(dict["LiveRecordVideoList"] as! [String: Any])
            self.liveRecordVideoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListLiveRecordVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRecordVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotsRequest : Tea.TeaModel {
    public var authTimeout: String?

    public var pageNo: String?

    public var pageSize: String?

    public var snapshotType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotType != nil {
            map["SnapshotType"] = self.snapshotType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") {
            self.authTimeout = dict["AuthTimeout"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotType") {
            self.snapshotType = dict["SnapshotType"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListSnapshotsResponseBody : Tea.TeaModel {
    public class MediaSnapshot : Tea.TeaModel {
        public class Snapshots : Tea.TeaModel {
            public class Snapshot : Tea.TeaModel {
                public var index: Int64?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int64
                    }
                    if dict.keys.contains("Url") {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public var snapshot: [ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.snapshot != nil {
                    var tmp : [Any] = []
                    for k in self.snapshot! {
                        tmp.append(k.toMap())
                    }
                    map["Snapshot"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Snapshot") {
                    var tmp : [ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot] = []
                    for v in dict["Snapshot"] as! [Any] {
                        var model = ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.snapshot = tmp
                }
            }
        }
        public var creationTime: String?

        public var jobId: String?

        public var regular: String?

        public var snapshots: ListSnapshotsResponseBody.MediaSnapshot.Snapshots?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshots?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.regular != nil {
                map["Regular"] = self.regular!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Regular") {
                self.regular = dict["Regular"] as! String
            }
            if dict.keys.contains("Snapshots") {
                var model = ListSnapshotsResponseBody.MediaSnapshot.Snapshots()
                model.fromMap(dict["Snapshots"] as! [String: Any])
                self.snapshots = model
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var mediaSnapshot: ListSnapshotsResponseBody.MediaSnapshot?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaSnapshot?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaSnapshot != nil {
            map["MediaSnapshot"] = self.mediaSnapshot?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaSnapshot") {
            var model = ListSnapshotsResponseBody.MediaSnapshot()
            model.fromMap(dict["MediaSnapshot"] as! [String: Any])
            self.mediaSnapshot = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeTaskRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListTranscodeTaskResponseBody : Tea.TeaModel {
    public class TranscodeTaskList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var taskStatus: String?

        public var transcodeTaskId: String?

        public var transcodeTemplateGroupId: String?

        public var trigger: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.transcodeTaskId != nil {
                map["TranscodeTaskId"] = self.transcodeTaskId!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
            if dict.keys.contains("TranscodeTaskId") {
                self.transcodeTaskId = dict["TranscodeTaskId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("Trigger") {
                self.trigger = dict["Trigger"] as! String
            }
            if dict.keys.contains("VideoId") {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTaskList: [ListTranscodeTaskResponseBody.TranscodeTaskList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTaskList != nil {
            var tmp : [Any] = []
            for k in self.transcodeTaskList! {
                tmp.append(k.toMap())
            }
            map["TranscodeTaskList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTaskList") {
            var tmp : [ListTranscodeTaskResponseBody.TranscodeTaskList] = []
            for v in dict["TranscodeTaskList"] as! [Any] {
                var model = ListTranscodeTaskResponseBody.TranscodeTaskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeTaskList = tmp
        }
    }
}

public class ListTranscodeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTranscodeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public class TranscodeTemplateGroupList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var locked: String?

        public var modifyTime: String?

        public var name: String?

        public var transcodeTemplateGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.locked != nil {
                map["Locked"] = self.locked!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Locked") {
                self.locked = dict["Locked"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTemplateGroupList: [ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupList != nil {
            var tmp : [Any] = []
            for k in self.transcodeTemplateGroupList! {
                tmp.append(k.toMap())
            }
            map["TranscodeTemplateGroupList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupList") {
            var tmp : [ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList] = []
            for v in dict["TranscodeTemplateGroupList"] as! [Any] {
                var model = ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeTemplateGroupList = tmp
        }
    }
}

public class ListTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVodTemplateRequest : Tea.TeaModel {
    public var appId: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class ListVodTemplateResponseBody : Tea.TeaModel {
    public class VodTemplateInfoList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var name: String?

        public var templateConfig: String?

        public var templateType: String?

        public var vodTemplateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.vodTemplateId != nil {
                map["VodTemplateId"] = self.vodTemplateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateType") {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("VodTemplateId") {
                self.vodTemplateId = dict["VodTemplateId"] as! String
            }
        }
    }
    public var requestId: String?

    public var vodTemplateInfoList: [ListVodTemplateResponseBody.VodTemplateInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateInfoList != nil {
            var tmp : [Any] = []
            for k in self.vodTemplateInfoList! {
                tmp.append(k.toMap())
            }
            map["VodTemplateInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateInfoList") {
            var tmp : [ListVodTemplateResponseBody.VodTemplateInfoList] = []
            for v in dict["VodTemplateInfoList"] as! [Any] {
                var model = ListVodTemplateResponseBody.VodTemplateInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vodTemplateInfoList = tmp
        }
    }
}

public class ListVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWatermarkRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfos : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfos: [ListWatermarkResponseBody.WatermarkInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfos != nil {
            var tmp : [Any] = []
            for k in self.watermarkInfos! {
                tmp.append(k.toMap())
            }
            map["WatermarkInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfos") {
            var tmp : [ListWatermarkResponseBody.WatermarkInfos] = []
            for v in dict["WatermarkInfos"] as! [Any] {
                var model = ListWatermarkResponseBody.WatermarkInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.watermarkInfos = tmp
        }
    }
}

public class ListWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveAppResourceRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var resourceType: String?

    public var targetAppId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.targetAppId != nil {
            map["TargetAppId"] = self.targetAppId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TargetAppId") {
            self.targetAppId = dict["TargetAppId"] as! String
        }
    }
}

public class MoveAppResourceResponseBody : Tea.TeaModel {
    public var failedResourceIds: [String]?

    public var nonExistResourceIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedResourceIds != nil {
            map["FailedResourceIds"] = self.failedResourceIds!
        }
        if self.nonExistResourceIds != nil {
            map["NonExistResourceIds"] = self.nonExistResourceIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedResourceIds") {
            self.failedResourceIds = dict["FailedResourceIds"] as! [String]
        }
        if dict.keys.contains("NonExistResourceIds") {
            self.nonExistResourceIds = dict["NonExistResourceIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveAppResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveAppResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveAppResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreloadVodObjectCachesRequest : Tea.TeaModel {
    public var area: String?

    public var l2Preload: Bool?

    public var objectPath: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var withHeader: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.l2Preload != nil {
            map["L2Preload"] = self.l2Preload!
        }
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.withHeader != nil {
            map["WithHeader"] = self.withHeader!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("L2Preload") {
            self.l2Preload = dict["L2Preload"] as! Bool
        }
        if dict.keys.contains("ObjectPath") {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("WithHeader") {
            self.withHeader = dict["WithHeader"] as! String
        }
    }
}

public class PreloadVodObjectCachesResponseBody : Tea.TeaModel {
    public var preloadTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preloadTaskId != nil {
            map["PreloadTaskId"] = self.preloadTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreloadTaskId") {
            self.preloadTaskId = dict["PreloadTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PreloadVodObjectCachesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreloadVodObjectCachesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreloadVodObjectCachesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ProduceEditingProjectVideoRequest : Tea.TeaModel {
    public var appId: String?

    public var coverURL: String?

    public var description_: String?

    public var mediaMetadata: String?

    public var ownerId: Int64?

    public var produceConfig: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timeline: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mediaMetadata != nil {
            map["MediaMetadata"] = self.mediaMetadata!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.produceConfig != nil {
            map["ProduceConfig"] = self.produceConfig!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MediaMetadata") {
            self.mediaMetadata = dict["MediaMetadata"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProduceConfig") {
            self.produceConfig = dict["ProduceConfig"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ProduceEditingProjectVideoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ProduceEditingProjectVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ProduceEditingProjectVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ProduceEditingProjectVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshMediaPlayUrlsRequest : Tea.TeaModel {
    public var definitions: String?

    public var formats: String?

    public var mediaIds: String?

    public var resultType: String?

    public var sliceCount: Int32?

    public var sliceFlag: Bool?

    public var streamType: String?

    public var taskType: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definitions != nil {
            map["Definitions"] = self.definitions!
        }
        if self.formats != nil {
            map["Formats"] = self.formats!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.sliceCount != nil {
            map["SliceCount"] = self.sliceCount!
        }
        if self.sliceFlag != nil {
            map["SliceFlag"] = self.sliceFlag!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definitions") {
            self.definitions = dict["Definitions"] as! String
        }
        if dict.keys.contains("Formats") {
            self.formats = dict["Formats"] as! String
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SliceCount") {
            self.sliceCount = dict["SliceCount"] as! Int32
        }
        if dict.keys.contains("SliceFlag") {
            self.sliceFlag = dict["SliceFlag"] as! Bool
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RefreshMediaPlayUrlsResponseBody : Tea.TeaModel {
    public var forbiddenMediaIds: String?

    public var mediaRefreshJobId: String?

    public var nonExistMediaIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenMediaIds != nil {
            map["ForbiddenMediaIds"] = self.forbiddenMediaIds!
        }
        if self.mediaRefreshJobId != nil {
            map["MediaRefreshJobId"] = self.mediaRefreshJobId!
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenMediaIds") {
            self.forbiddenMediaIds = dict["ForbiddenMediaIds"] as! String
        }
        if dict.keys.contains("MediaRefreshJobId") {
            self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
        }
        if dict.keys.contains("NonExistMediaIds") {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshMediaPlayUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshMediaPlayUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshMediaPlayUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadVideoRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class RefreshUploadVideoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class RefreshUploadVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshUploadVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshVodObjectCachesRequest : Tea.TeaModel {
    public var force: Bool?

    public var objectPath: String?

    public var objectType: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("ObjectPath") {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RefreshVodObjectCachesResponseBody : Tea.TeaModel {
    public var refreshTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.refreshTaskId != nil {
            map["RefreshTaskId"] = self.refreshTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RefreshTaskId") {
            self.refreshTaskId = dict["RefreshTaskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshVodObjectCachesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshVodObjectCachesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefreshVodObjectCachesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaRequest : Tea.TeaModel {
    public var registerMetadatas: String?

    public var templateGroupId: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registerMetadatas != nil {
            map["RegisterMetadatas"] = self.registerMetadatas!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegisterMetadatas") {
            self.registerMetadatas = dict["RegisterMetadatas"] as! String
        }
        if dict.keys.contains("TemplateGroupId") {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaResponseBody : Tea.TeaModel {
    public class RegisteredMediaList : Tea.TeaModel {
        public var fileURL: String?

        public var mediaId: String?

        public var newRegister: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.newRegister != nil {
                map["NewRegister"] = self.newRegister!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("NewRegister") {
                self.newRegister = dict["NewRegister"] as! Bool
            }
        }
    }
    public var failedFileURLs: [String]?

    public var registeredMediaList: [RegisterMediaResponseBody.RegisteredMediaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedFileURLs != nil {
            map["FailedFileURLs"] = self.failedFileURLs!
        }
        if self.registeredMediaList != nil {
            var tmp : [Any] = []
            for k in self.registeredMediaList! {
                tmp.append(k.toMap())
            }
            map["RegisteredMediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedFileURLs") {
            self.failedFileURLs = dict["FailedFileURLs"] as! [String]
        }
        if dict.keys.contains("RegisteredMediaList") {
            var tmp : [RegisterMediaResponseBody.RegisteredMediaList] = []
            for v in dict["RegisteredMediaList"] as! [Any] {
                var model = RegisterMediaResponseBody.RegisteredMediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.registeredMediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestoreMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var restoreDays: String?

    public var restoreTier: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.restoreDays != nil {
            map["RestoreDays"] = self.restoreDays!
        }
        if self.restoreTier != nil {
            map["RestoreTier"] = self.restoreTier!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("RestoreDays") {
            self.restoreDays = dict["RestoreDays"] as! String
        }
        if dict.keys.contains("RestoreTier") {
            self.restoreTier = dict["RestoreTier"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
    }
}

public class RestoreMediaResponseBody : Tea.TeaModel {
    public class ForbiddenList : Tea.TeaModel {
        public class MediaForbiddenReasonDTO : Tea.TeaModel {
            public var mediaId: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var mediaForbiddenReasonDTO: [RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaForbiddenReasonDTO != nil {
                var tmp : [Any] = []
                for k in self.mediaForbiddenReasonDTO! {
                    tmp.append(k.toMap())
                }
                map["MediaForbiddenReasonDTO"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaForbiddenReasonDTO") {
                var tmp : [RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO] = []
                for v in dict["MediaForbiddenReasonDTO"] as! [Any] {
                    var model = RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaForbiddenReasonDTO = tmp
            }
        }
    }
    public class IgnoredList : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var forbiddenList: RestoreMediaResponseBody.ForbiddenList?

    public var ignoredList: RestoreMediaResponseBody.IgnoredList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forbiddenList?.validate()
        try self.ignoredList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList?.toMap()
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            var model = RestoreMediaResponseBody.ForbiddenList()
            model.fromMap(dict["ForbiddenList"] as! [String: Any])
            self.forbiddenList = model
        }
        if dict.keys.contains("IgnoredList") {
            var model = RestoreMediaResponseBody.IgnoredList()
            model.fromMap(dict["IgnoredList"] as! [String: Any])
            self.ignoredList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestoreMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestoreMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public class Project : Tea.TeaModel {
            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var modifiedTime: String?

            public var projectId: String?

            public var regionId: String?

            public var status: String?

            public var storageLocation: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var project: [SearchEditingProjectResponseBody.ProjectList.Project]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.project != nil {
                var tmp : [Any] = []
                for k in self.project! {
                    tmp.append(k.toMap())
                }
                map["Project"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Project") {
                var tmp : [SearchEditingProjectResponseBody.ProjectList.Project] = []
                for v in dict["Project"] as! [Any] {
                    var model = SearchEditingProjectResponseBody.ProjectList.Project()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.project = tmp
            }
        }
    }
    public var projectList: SearchEditingProjectResponseBody.ProjectList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectList != nil {
            map["ProjectList"] = self.projectList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectList") {
            var model = SearchEditingProjectResponseBody.ProjectList()
            model.fromMap(dict["ProjectList"] as! [String: Any])
            self.projectList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var fields: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var scrollToken: String?

    public var searchType: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fields != nil {
            map["Fields"] = self.fields!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.searchType != nil {
            map["SearchType"] = self.searchType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Fields") {
            self.fields = dict["Fields"] as! String
        }
        if dict.keys.contains("Match") {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("SearchType") {
            self.searchType = dict["SearchType"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public var from: Double?

                    public var score: Double?

                    public var to: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("From") {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Score") {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("To") {
                            self.to = dict["To"] as! Double
                        }
                    }
                }
                public var category: String?

                public var labelId: String?

                public var labelName: String?

                public var occurrences: [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("LabelId") {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("Occurrences") {
                        var tmp : [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var content: String?

                public var from: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("To") {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo]?

            public var ocrInfo: [SearchMediaResponseBody.MediaList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") {
                    var tmp : [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("OcrInfo") {
                    var tmp : [SearchMediaResponseBody.MediaList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("SaveType") {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class AttachedMedia : Tea.TeaModel {
            public class Categories : Tea.TeaModel {
                public var cateId: Int64?

                public var cateName: String?

                public var level: Int64?

                public var parentId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cateId != nil {
                        map["CateId"] = self.cateId!
                    }
                    if self.cateName != nil {
                        map["CateName"] = self.cateName!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.parentId != nil {
                        map["ParentId"] = self.parentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CateId") {
                        self.cateId = dict["CateId"] as! Int64
                    }
                    if dict.keys.contains("CateName") {
                        self.cateName = dict["CateName"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! Int64
                    }
                    if dict.keys.contains("ParentId") {
                        self.parentId = dict["ParentId"] as! Int64
                    }
                }
            }
            public var appId: String?

            public var businessType: String?

            public var categories: [SearchMediaResponseBody.MediaList.AttachedMedia.Categories]?

            public var creationTime: String?

            public var description_: String?

            public var mediaId: String?

            public var modificationTime: String?

            public var status: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.categories != nil {
                    var tmp : [Any] = []
                    for k in self.categories! {
                        tmp.append(k.toMap())
                    }
                    map["Categories"] = tmp
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("BusinessType") {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Categories") {
                    var tmp : [SearchMediaResponseBody.MediaList.AttachedMedia.Categories] = []
                    for v in dict["Categories"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AttachedMedia.Categories()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.categories = tmp
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class Audio : Tea.TeaModel {
            public var appId: String?

            public var audioId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var downloadSwitch: String?

            public var duration: Double?

            public var mediaSource: String?

            public var modificationTime: String?

            public var preprocessStatus: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: [String]?

            public var spriteSnapshots: [String]?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var transcodeMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.audioId != nil {
                    map["AudioId"] = self.audioId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadSwitch != nil {
                    map["DownloadSwitch"] = self.downloadSwitch!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.mediaSource != nil {
                    map["MediaSource"] = self.mediaSource!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.preprocessStatus != nil {
                    map["PreprocessStatus"] = self.preprocessStatus!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.spriteSnapshots != nil {
                    map["SpriteSnapshots"] = self.spriteSnapshots!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeMode != nil {
                    map["TranscodeMode"] = self.transcodeMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AudioId") {
                    self.audioId = dict["AudioId"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DownloadSwitch") {
                    self.downloadSwitch = dict["DownloadSwitch"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MediaSource") {
                    self.mediaSource = dict["MediaSource"] as! String
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("PreprocessStatus") {
                    self.preprocessStatus = dict["PreprocessStatus"] as! String
                }
                if dict.keys.contains("RestoreExpiration") {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! [String]
                }
                if dict.keys.contains("SpriteSnapshots") {
                    self.spriteSnapshots = dict["SpriteSnapshots"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeMode") {
                    self.transcodeMode = dict["TranscodeMode"] as! String
                }
            }
        }
        public class Image : Tea.TeaModel {
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var creationTime: String?

            public var description_: String?

            public var imageId: String?

            public var modificationTime: String?

            public var status: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var downloadSwitch: String?

            public var duration: Double?

            public var mediaSource: String?

            public var modificationTime: String?

            public var preprocessStatus: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: [String]?

            public var spriteSnapshots: [String]?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var transcodeMode: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadSwitch != nil {
                    map["DownloadSwitch"] = self.downloadSwitch!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.mediaSource != nil {
                    map["MediaSource"] = self.mediaSource!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.preprocessStatus != nil {
                    map["PreprocessStatus"] = self.preprocessStatus!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.spriteSnapshots != nil {
                    map["SpriteSnapshots"] = self.spriteSnapshots!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeMode != nil {
                    map["TranscodeMode"] = self.transcodeMode!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DownloadSwitch") {
                    self.downloadSwitch = dict["DownloadSwitch"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MediaSource") {
                    self.mediaSource = dict["MediaSource"] as! String
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("PreprocessStatus") {
                    self.preprocessStatus = dict["PreprocessStatus"] as! String
                }
                if dict.keys.contains("RestoreExpiration") {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") {
                    self.snapshots = dict["Snapshots"] as! [String]
                }
                if dict.keys.contains("SpriteSnapshots") {
                    self.spriteSnapshots = dict["SpriteSnapshots"] as! [String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeMode") {
                    self.transcodeMode = dict["TranscodeMode"] as! String
                }
                if dict.keys.contains("VideoId") {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var aiData: SearchMediaResponseBody.MediaList.AiData?

        public var aiRoughData: SearchMediaResponseBody.MediaList.AiRoughData?

        public var attachedMedia: SearchMediaResponseBody.MediaList.AttachedMedia?

        public var audio: SearchMediaResponseBody.MediaList.Audio?

        public var creationTime: String?

        public var image: SearchMediaResponseBody.MediaList.Image?

        public var mediaId: String?

        public var mediaType: String?

        public var video: SearchMediaResponseBody.MediaList.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
            try self.aiRoughData?.validate()
            try self.attachedMedia?.validate()
            try self.audio?.validate()
            try self.image?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.attachedMedia != nil {
                map["AttachedMedia"] = self.attachedMedia?.toMap()
            }
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.image != nil {
                map["Image"] = self.image?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") {
                var model = SearchMediaResponseBody.MediaList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AiRoughData") {
                var model = SearchMediaResponseBody.MediaList.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("AttachedMedia") {
                var model = SearchMediaResponseBody.MediaList.AttachedMedia()
                model.fromMap(dict["AttachedMedia"] as! [String: Any])
                self.attachedMedia = model
            }
            if dict.keys.contains("Audio") {
                var model = SearchMediaResponseBody.MediaList.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Image") {
                var model = SearchMediaResponseBody.MediaList.Image()
                model.fromMap(dict["Image"] as! [String: Any])
                self.image = model
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Video") {
                var model = SearchMediaResponseBody.MediaList.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var mediaList: [SearchMediaResponseBody.MediaList]?

    public var requestId: String?

    public var scrollToken: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var tmp : [SearchMediaResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScrollToken") {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAuditSecurityIpRequest : Tea.TeaModel {
    public var ips: String?

    public var operateMode: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ips != nil {
            map["Ips"] = self.ips!
        }
        if self.operateMode != nil {
            map["OperateMode"] = self.operateMode!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ips") {
            self.ips = dict["Ips"] as! String
        }
        if dict.keys.contains("OperateMode") {
            self.operateMode = dict["OperateMode"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class SetAuditSecurityIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAuditSecurityIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAuditSecurityIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetAuditSecurityIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCrossdomainContentRequest : Tea.TeaModel {
    public var content: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var resourceRealOwnerId: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceRealOwnerId != nil {
            map["ResourceRealOwnerId"] = self.resourceRealOwnerId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("ResourceRealOwnerId") {
            self.resourceRealOwnerId = dict["ResourceRealOwnerId"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class SetCrossdomainContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCrossdomainContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCrossdomainContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCrossdomainContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class SetDefaultTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDefaultTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class SetDefaultWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDefaultWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDefaultWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var authKey: String?

    public var authSwitch: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var mnsEndpoint: String?

    public var mnsQueueName: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.mnsEndpoint != nil {
            map["MnsEndpoint"] = self.mnsEndpoint!
        }
        if self.mnsQueueName != nil {
            map["MnsQueueName"] = self.mnsQueueName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthKey") {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackType") {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("MnsEndpoint") {
            self.mnsEndpoint = dict["MnsEndpoint"] as! String
        }
        if dict.keys.contains("MnsQueueName") {
            self.mnsQueueName = dict["MnsQueueName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class SetMessageCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetVodDomainCertificateRequest : Tea.TeaModel {
    public var certName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var SSLPri: String?

    public var SSLProtocol: String?

    public var SSLPub: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.SSLPri != nil {
            map["SSLPri"] = self.SSLPri!
        }
        if self.SSLProtocol != nil {
            map["SSLProtocol"] = self.SSLProtocol!
        }
        if self.SSLPub != nil {
            map["SSLPub"] = self.SSLPub!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertName") {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SSLPri") {
            self.SSLPri = dict["SSLPri"] as! String
        }
        if dict.keys.contains("SSLProtocol") {
            self.SSLProtocol = dict["SSLProtocol"] as! String
        }
        if dict.keys.contains("SSLPub") {
            self.SSLPub = dict["SSLPub"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetVodDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetVodDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetVodDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetVodDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIImageAuditJobRequest : Tea.TeaModel {
    public var mediaAuditConfiguration: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditConfiguration != nil {
            map["MediaAuditConfiguration"] = self.mediaAuditConfiguration!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditConfiguration") {
            self.mediaAuditConfiguration = dict["MediaAuditConfiguration"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitAIImageAuditJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIImageAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIImageAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAIImageAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIImageJobRequest : Tea.TeaModel {
    public var AIPipelineId: String?

    public var AITemplateId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var userData: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIPipelineId != nil {
            map["AIPipelineId"] = self.AIPipelineId!
        }
        if self.AITemplateId != nil {
            map["AITemplateId"] = self.AITemplateId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIPipelineId") {
            self.AIPipelineId = dict["AIPipelineId"] as! String
        }
        if dict.keys.contains("AITemplateId") {
            self.AITemplateId = dict["AITemplateId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitAIImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAIImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIJobRequest : Tea.TeaModel {
    public var config: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var types: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAIJobResponseBody : Tea.TeaModel {
    public class AIJobList : Tea.TeaModel {
        public class AIJob : Tea.TeaModel {
            public var jobId: String?

            public var mediaId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var AIJob: [SubmitAIJobResponseBody.AIJobList.AIJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIJob != nil {
                var tmp : [Any] = []
                for k in self.AIJob! {
                    tmp.append(k.toMap())
                }
                map["AIJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIJob") {
                var tmp : [SubmitAIJobResponseBody.AIJobList.AIJob] = []
                for v in dict["AIJob"] as! [Any] {
                    var model = SubmitAIJobResponseBody.AIJobList.AIJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIJob = tmp
            }
        }
    }
    public var AIJobList: SubmitAIJobResponseBody.AIJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIJobList != nil {
            map["AIJobList"] = self.AIJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIJobList") {
            var model = SubmitAIJobResponseBody.AIJobList()
            model.fromMap(dict["AIJobList"] as! [String: Any])
            self.AIJobList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIMediaAuditJobRequest : Tea.TeaModel {
    public var mediaAuditConfiguration: String?

    public var mediaId: String?

    public var mediaType: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditConfiguration != nil {
            map["MediaAuditConfiguration"] = self.mediaAuditConfiguration!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditConfiguration") {
            self.mediaAuditConfiguration = dict["MediaAuditConfiguration"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAIMediaAuditJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIMediaAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIMediaAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAIMediaAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDigitalWatermarkExtractJobRequest : Tea.TeaModel {
    public var extractType: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extractType != nil {
            map["ExtractType"] = self.extractType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtractType") {
            self.extractType = dict["ExtractType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SubmitDigitalWatermarkExtractJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDigitalWatermarkExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDigitalWatermarkExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDigitalWatermarkExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public var dynamicImageTemplateId: String?

    public var overrideParams: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageTemplateId != nil {
            map["DynamicImageTemplateId"] = self.dynamicImageTemplateId!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageTemplateId") {
            self.dynamicImageTemplateId = dict["DynamicImageTemplateId"] as! String
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var dynamicImageJob: SubmitDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") {
            var model = SubmitDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaDNADeleteJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SubmitMediaDNADeleteJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaDNADeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaDNADeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaDNADeleteJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPreprocessJobsRequest : Tea.TeaModel {
    public var preprocessType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preprocessType != nil {
            map["PreprocessType"] = self.preprocessType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreprocessType") {
            self.preprocessType = dict["PreprocessType"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitPreprocessJobsResponseBody : Tea.TeaModel {
    public class PreprocessJobs : Tea.TeaModel {
        public class PreprocessJob : Tea.TeaModel {
            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public var preprocessJob: [SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preprocessJob != nil {
                var tmp : [Any] = []
                for k in self.preprocessJob! {
                    tmp.append(k.toMap())
                }
                map["PreprocessJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreprocessJob") {
                var tmp : [SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob] = []
                for v in dict["PreprocessJob"] as! [Any] {
                    var model = SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preprocessJob = tmp
            }
        }
    }
    public var preprocessJobs: SubmitPreprocessJobsResponseBody.PreprocessJobs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preprocessJobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preprocessJobs != nil {
            map["PreprocessJobs"] = self.preprocessJobs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreprocessJobs") {
            var model = SubmitPreprocessJobsResponseBody.PreprocessJobs()
            model.fromMap(dict["PreprocessJobs"] as! [String: Any])
            self.preprocessJobs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPreprocessJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPreprocessJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitPreprocessJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public var count: Int64?

    public var height: String?

    public var interval: Int64?

    public var snapshotTemplateId: String?

    public var specifiedOffsetTime: Int64?

    public var specifiedOffsetTimes: [Int64]?

    public var spriteSnapshotConfig: String?

    public var userData: String?

    public var videoId: String?

    public var width: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.snapshotTemplateId != nil {
            map["SnapshotTemplateId"] = self.snapshotTemplateId!
        }
        if self.specifiedOffsetTime != nil {
            map["SpecifiedOffsetTime"] = self.specifiedOffsetTime!
        }
        if self.specifiedOffsetTimes != nil {
            map["SpecifiedOffsetTimes"] = self.specifiedOffsetTimes!
        }
        if self.spriteSnapshotConfig != nil {
            map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("SnapshotTemplateId") {
            self.snapshotTemplateId = dict["SnapshotTemplateId"] as! String
        }
        if dict.keys.contains("SpecifiedOffsetTime") {
            self.specifiedOffsetTime = dict["SpecifiedOffsetTime"] as! Int64
        }
        if dict.keys.contains("SpecifiedOffsetTimes") {
            self.specifiedOffsetTimes = dict["SpecifiedOffsetTimes"] as! [Int64]
        }
        if dict.keys.contains("SpriteSnapshotConfig") {
            self.spriteSnapshotConfig = dict["SpriteSnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
        if dict.keys.contains("Width") {
            self.width = dict["Width"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var count: Int64?

    public var height: String?

    public var interval: Int64?

    public var snapshotTemplateId: String?

    public var specifiedOffsetTime: Int64?

    public var specifiedOffsetTimesShrink: String?

    public var spriteSnapshotConfig: String?

    public var userData: String?

    public var videoId: String?

    public var width: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.snapshotTemplateId != nil {
            map["SnapshotTemplateId"] = self.snapshotTemplateId!
        }
        if self.specifiedOffsetTime != nil {
            map["SpecifiedOffsetTime"] = self.specifiedOffsetTime!
        }
        if self.specifiedOffsetTimesShrink != nil {
            map["SpecifiedOffsetTimes"] = self.specifiedOffsetTimesShrink!
        }
        if self.spriteSnapshotConfig != nil {
            map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("SnapshotTemplateId") {
            self.snapshotTemplateId = dict["SnapshotTemplateId"] as! String
        }
        if dict.keys.contains("SpecifiedOffsetTime") {
            self.specifiedOffsetTime = dict["SpecifiedOffsetTime"] as! Int64
        }
        if dict.keys.contains("SpecifiedOffsetTimes") {
            self.specifiedOffsetTimesShrink = dict["SpecifiedOffsetTimes"] as! String
        }
        if dict.keys.contains("SpriteSnapshotConfig") {
            self.spriteSnapshotConfig = dict["SpriteSnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
        if dict.keys.contains("Width") {
            self.width = dict["Width"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: SubmitSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = SubmitSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobsRequest : Tea.TeaModel {
    public var encryptConfig: String?

    public var overrideParams: String?

    public var pipelineId: String?

    public var priority: String?

    public var templateGroupId: String?

    public var userData: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptConfig != nil {
            map["EncryptConfig"] = self.encryptConfig!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptConfig") {
            self.encryptConfig = dict["EncryptConfig"] as! String
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("TemplateGroupId") {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitTranscodeJobsResponseBody : Tea.TeaModel {
    public class TranscodeJobs : Tea.TeaModel {
        public class TranscodeJob : Tea.TeaModel {
            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public var transcodeJob: [SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeJob != nil {
                var tmp : [Any] = []
                for k in self.transcodeJob! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeJob") {
                var tmp : [SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob] = []
                for v in dict["TranscodeJob"] as! [Any] {
                    var model = SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJob = tmp
            }
        }
    }
    public var requestId: String?

    public var transcodeJobs: SubmitTranscodeJobsResponseBody.TranscodeJobs?

    public var transcodeTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeJobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeJobs != nil {
            map["TranscodeJobs"] = self.transcodeJobs?.toMap()
        }
        if self.transcodeTaskId != nil {
            map["TranscodeTaskId"] = self.transcodeTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeJobs") {
            var model = SubmitTranscodeJobsResponseBody.TranscodeJobs()
            model.fromMap(dict["TranscodeJobs"] as! [String: Any])
            self.transcodeJobs = model
        }
        if dict.keys.contains("TranscodeTaskId") {
            self.transcodeTaskId = dict["TranscodeTaskId"] as! String
        }
    }
}

public class SubmitTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitWorkflowJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class SubmitWorkflowJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitWorkflowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitWorkflowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitWorkflowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAITemplateRequest : Tea.TeaModel {
    public var templateConfig: String?

    public var templateId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class UpdateAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var description_: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateAppInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAttachedMediaInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateAttachedMediaInfosResponseBody : Tea.TeaModel {
    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistMediaIds") {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAttachedMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAttachedMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAttachedMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var coverURL: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Timeline") {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateImageInfosResponseBody : Tea.TeaModel {
    public class NonExistImageIds : Tea.TeaModel {
        public var imageId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! [String]
            }
        }
    }
    public var nonExistImageIds: UpdateImageInfosResponseBody.NonExistImageIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistImageIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistImageIds != nil {
            map["NonExistImageIds"] = self.nonExistImageIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistImageIds") {
            var model = UpdateImageInfosResponseBody.NonExistImageIds()
            model.fromMap(dict["NonExistImageIds"] as! [String: Any])
            self.nonExistImageIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaStorageClassRequest : Tea.TeaModel {
    public var allowUpdateWithoutTimeLimit: Bool?

    public var mediaIds: String?

    public var restoreTier: String?

    public var scope: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowUpdateWithoutTimeLimit != nil {
            map["AllowUpdateWithoutTimeLimit"] = self.allowUpdateWithoutTimeLimit!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.restoreTier != nil {
            map["RestoreTier"] = self.restoreTier!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowUpdateWithoutTimeLimit") {
            self.allowUpdateWithoutTimeLimit = dict["AllowUpdateWithoutTimeLimit"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("RestoreTier") {
            self.restoreTier = dict["RestoreTier"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("StorageClass") {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class UpdateMediaStorageClassResponseBody : Tea.TeaModel {
    public class ForbiddenList : Tea.TeaModel {
        public class MediaForbiddenReasonDTO : Tea.TeaModel {
            public var mediaId: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var mediaForbiddenReasonDTO: [UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaForbiddenReasonDTO != nil {
                var tmp : [Any] = []
                for k in self.mediaForbiddenReasonDTO! {
                    tmp.append(k.toMap())
                }
                map["MediaForbiddenReasonDTO"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaForbiddenReasonDTO") {
                var tmp : [UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO] = []
                for v in dict["MediaForbiddenReasonDTO"] as! [Any] {
                    var model = UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaForbiddenReasonDTO = tmp
            }
        }
    }
    public class IgnoredList : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var forbiddenList: UpdateMediaStorageClassResponseBody.ForbiddenList?

    public var ignoredList: UpdateMediaStorageClassResponseBody.IgnoredList?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forbiddenList?.validate()
        try self.ignoredList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList?.toMap()
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") {
            var model = UpdateMediaStorageClassResponseBody.ForbiddenList()
            model.fromMap(dict["ForbiddenList"] as! [String: Any])
            self.forbiddenList = model
        }
        if dict.keys.contains("IgnoredList") {
            var model = UpdateMediaStorageClassResponseBody.IgnoredList()
            model.fromMap(dict["IgnoredList"] as! [String: Any])
            self.ignoredList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateMediaStorageClassResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaStorageClassResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaStorageClassResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var locked: String?

    public var name: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.locked != nil {
            map["Locked"] = self.locked!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateList != nil {
            map["TranscodeTemplateList"] = self.transcodeTemplateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Locked") {
            self.locked = dict["Locked"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateList") {
            self.transcodeTemplateList = dict["TranscodeTemplateList"] as! String
        }
    }
}

public class UpdateTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class UpdateTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVideoInfoRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var tags: String?

    public var title: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("VideoId") {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class UpdateVideoInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVideoInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVideoInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVideoInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVideoInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateVideoInfosResponseBody : Tea.TeaModel {
    public var forbiddenVideoIds: [String]?

    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenVideoIds != nil {
            map["ForbiddenVideoIds"] = self.forbiddenVideoIds!
        }
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenVideoIds") {
            self.forbiddenVideoIds = dict["ForbiddenVideoIds"] as! [String]
        }
        if dict.keys.contains("NonExistVideoIds") {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVideoInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVideoInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVideoInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVodDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sources: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sources != nil {
            map["Sources"] = self.sources!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sources") {
            self.sources = dict["Sources"] as! String
        }
        if dict.keys.contains("TopLevelDomain") {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class UpdateVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVodTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class UpdateVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class UpdateVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWatermarkRequest : Tea.TeaModel {
    public var name: String?

    public var watermarkConfig: String?

    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.watermarkConfig != nil {
            map["WatermarkConfig"] = self.watermarkConfig!
        }
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("WatermarkConfig") {
            self.watermarkConfig = dict["WatermarkConfig"] as! String
        }
        if dict.keys.contains("WatermarkId") {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class UpdateWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: UpdateWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") {
            var model = UpdateWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class UpdateWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var sessionId: String?

    public var storageLocation: String?

    public var templateGroupId: String?

    public var uploadMetadatas: String?

    public var uploadURLs: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.uploadMetadatas != nil {
            map["UploadMetadatas"] = self.uploadMetadatas!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("TemplateGroupId") {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UploadMetadatas") {
            self.uploadMetadatas = dict["UploadMetadatas"] as! String
        }
        if dict.keys.contains("UploadURLs") {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("SourceURL") {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") {
            var tmp : [UploadMediaByURLResponseBody.UploadJobs] = []
            for v in dict["UploadJobs"] as! [Any] {
                var model = UploadMediaByURLResponseBody.UploadJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadJobs = tmp
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var requestId: String?

    public var sourceURL: String?

    public var streamJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        if self.streamJobId != nil {
            map["StreamJobId"] = self.streamJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") {
            self.sourceURL = dict["SourceURL"] as! String
        }
        if dict.keys.contains("StreamJobId") {
            self.streamJobId = dict["StreamJobId"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyVodDomainOwnerRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var verifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.verifyType != nil {
            map["VerifyType"] = self.verifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("VerifyType") {
            self.verifyType = dict["VerifyType"] as! String
        }
    }
}

public class VerifyVodDomainOwnerResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyVodDomainOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyVodDomainOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyVodDomainOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
