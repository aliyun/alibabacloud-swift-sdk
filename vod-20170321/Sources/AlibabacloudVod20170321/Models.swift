import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddAITemplateRequest : Tea.TeaModel {
    public var templateConfig: String?

    public var templateName: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class AddAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class AddAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") && dict["CateName"] != nil {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectRequest : Tea.TeaModel {
    public var coverURL: String?

    public var description_: String?

    public var division: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.division != nil {
            map["Division"] = self.division!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Division") && dict["Division"] != nil {
            self.division = dict["Division"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class AddEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var creationTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var status: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: AddEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") && dict["Project"] != nil {
            var model = AddEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") && dict["MaterialIds"] != nil {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class MaterialList : Tea.TeaModel {
        public var cateId: Int32?

        public var cateName: String?

        public var coverURL: String?

        public var createTime: String?

        public var customerId: Int64?

        public var description_: String?

        public var duration: Double?

        public var materialId: String?

        public var materialType: String?

        public var modifyTime: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var spriteConfig: String?

        public var sprites: [String]?

        public var status: String?

        public var tags: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.customerId != nil {
                map["CustomerId"] = self.customerId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.materialId != nil {
                map["MaterialId"] = self.materialId!
            }
            if self.materialType != nil {
                map["MaterialType"] = self.materialType!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.spriteConfig != nil {
                map["SpriteConfig"] = self.spriteConfig!
            }
            if self.sprites != nil {
                map["Sprites"] = self.sprites!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int32
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CustomerId") && dict["CustomerId"] != nil {
                self.customerId = dict["CustomerId"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                self.materialId = dict["MaterialId"] as! String
            }
            if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
                self.materialType = dict["MaterialType"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("SpriteConfig") && dict["SpriteConfig"] != nil {
                self.spriteConfig = dict["SpriteConfig"] as! String
            }
            if dict.keys.contains("Sprites") && dict["Sprites"] != nil {
                self.sprites = dict["Sprites"] as! [String]
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var materialList: [AddEditingProjectMaterialsResponseBody.MaterialList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialList != nil {
            var tmp : [Any] = []
            for k in self.materialList! {
                tmp.append(k.toMap())
            }
            map["MaterialList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialList") && dict["MaterialList"] != nil {
            var tmp : [AddEditingProjectMaterialsResponseBody.MaterialList] = []
            for v in dict["MaterialList"] as! [Any] {
                var model = AddEditingProjectMaterialsResponseBody.MaterialList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.materialList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateList != nil {
            map["TranscodeTemplateList"] = self.transcodeTemplateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateList") && dict["TranscodeTemplateList"] != nil {
            self.transcodeTemplateList = dict["TranscodeTemplateList"] as! String
        }
    }
}

public class AddTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class AddTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodDomainRequest : Tea.TeaModel {
    public var checkUrl: String?

    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var scope: String?

    public var securityToken: String?

    public var sources: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkUrl != nil {
            map["CheckUrl"] = self.checkUrl!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sources != nil {
            map["Sources"] = self.sources!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckUrl") && dict["CheckUrl"] != nil {
            self.checkUrl = dict["CheckUrl"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") && dict["Scope"] != nil {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sources") && dict["Sources"] != nil {
            self.sources = dict["Sources"] as! String
        }
        if dict.keys.contains("TopLevelDomain") && dict["TopLevelDomain"] != nil {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class AddVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodStorageForAppRequest : Tea.TeaModel {
    public var appId: String?

    public var storageLocation: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class AddVodStorageForAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class AddVodStorageForAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodStorageForAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddVodStorageForAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVodTemplateRequest : Tea.TeaModel {
    public var appId: String?

    public var name: String?

    public var templateConfig: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class AddVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class AddVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWatermarkRequest : Tea.TeaModel {
    public var appId: String?

    public var fileUrl: String?

    public var name: String?

    public var type: String?

    public var watermarkConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.watermarkConfig != nil {
            map["WatermarkConfig"] = self.watermarkConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
            self.watermarkConfig = dict["WatermarkConfig"] as! String
        }
    }
}

public class AddWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: AddWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") && dict["WatermarkInfo"] != nil {
            var model = AddWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class AddWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachAppPolicyToIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public var policyNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.policyNames != nil {
            map["PolicyNames"] = self.policyNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") && dict["IdentityName"] != nil {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") && dict["IdentityType"] != nil {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("PolicyNames") && dict["PolicyNames"] != nil {
            self.policyNames = dict["PolicyNames"] as! String
        }
    }
}

public class AttachAppPolicyToIdentityResponseBody : Tea.TeaModel {
    public var failedPolicyNames: [String]?

    public var nonExistPolicyNames: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedPolicyNames != nil {
            map["FailedPolicyNames"] = self.failedPolicyNames!
        }
        if self.nonExistPolicyNames != nil {
            map["NonExistPolicyNames"] = self.nonExistPolicyNames!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedPolicyNames") && dict["FailedPolicyNames"] != nil {
            self.failedPolicyNames = dict["FailedPolicyNames"] as! [String]
        }
        if dict.keys.contains("NonExistPolicyNames") && dict["NonExistPolicyNames"] != nil {
            self.nonExistPolicyNames = dict["NonExistPolicyNames"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachAppPolicyToIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachAppPolicyToIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachAppPolicyToIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchSetVodDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") && dict["DomainNames"] != nil {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("Functions") && dict["Functions"] != nil {
            self.functions = dict["Functions"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchSetVodDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchSetVodDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSetVodDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchSetVodDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStartVodDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") && dict["DomainNames"] != nil {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchStartVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchStartVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStartVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchStartVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStopVodDomainRequest : Tea.TeaModel {
    public var domainNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") && dict["DomainNames"] != nil {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchStopVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchStopVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStopVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchStopVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelUrlUploadJobsRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadUrls: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadUrls != nil {
            map["UploadUrls"] = self.uploadUrls!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadUrls") && dict["UploadUrls"] != nil {
            self.uploadUrls = dict["UploadUrls"] as! String
        }
    }
}

public class CancelUrlUploadJobsResponseBody : Tea.TeaModel {
    public var canceledJobs: [String]?

    public var nonExists: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canceledJobs != nil {
            map["CanceledJobs"] = self.canceledJobs!
        }
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanceledJobs") && dict["CanceledJobs"] != nil {
            self.canceledJobs = dict["CanceledJobs"] as! [String]
        }
        if dict.keys.contains("NonExists") && dict["NonExists"] != nil {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelUrlUploadJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelUrlUploadJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelUrlUploadJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
    }
}

public class CreateAppInfoResponseBody : Tea.TeaModel {
    public var appId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAuditRequest : Tea.TeaModel {
    public var auditContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditContent != nil {
            map["AuditContent"] = self.auditContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuditContent") && dict["AuditContent"] != nil {
            self.auditContent = dict["AuditContent"] as! String
        }
    }
}

public class CreateAuditResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadAttachedMediaRequest : Tea.TeaModel {
    public var appId: String?

    public var businessType: String?

    public var cateIds: String?

    public var description_: String?

    public var fileName: String?

    public var fileSize: String?

    public var mediaExt: String?

    public var storageLocation: String?

    public var tags: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.cateIds != nil {
            map["CateIds"] = self.cateIds!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSize != nil {
            map["FileSize"] = self.fileSize!
        }
        if self.mediaExt != nil {
            map["MediaExt"] = self.mediaExt!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("CateIds") && dict["CateIds"] != nil {
            self.cateIds = dict["CateIds"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
            self.fileSize = dict["FileSize"] as! String
        }
        if dict.keys.contains("MediaExt") && dict["MediaExt"] != nil {
            self.mediaExt = dict["MediaExt"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadAttachedMediaResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var mediaId: String?

    public var mediaURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaURL != nil {
            map["MediaURL"] = self.mediaURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaURL") && dict["MediaURL"] != nil {
            self.mediaURL = dict["MediaURL"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadAttachedMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadAttachedMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadAttachedMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadImageRequest : Tea.TeaModel {
    public var appId: String?

    public var cateId: Int64?

    public var description_: String?

    public var imageExt: String?

    public var imageType: String?

    public var originalFileName: String?

    public var storageLocation: String?

    public var tags: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageExt != nil {
            map["ImageExt"] = self.imageExt!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.originalFileName != nil {
            map["OriginalFileName"] = self.originalFileName!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageExt") && dict["ImageExt"] != nil {
            self.imageExt = dict["ImageExt"] as! String
        }
        if dict.keys.contains("ImageType") && dict["ImageType"] != nil {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("OriginalFileName") && dict["OriginalFileName"] != nil {
            self.originalFileName = dict["OriginalFileName"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class CreateUploadImageResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var imageId: String?

    public var imageURL: String?

    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageURL != nil {
            map["ImageURL"] = self.imageURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageURL") && dict["ImageURL"] != nil {
            self.imageURL = dict["ImageURL"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
    }
}

public class CreateUploadImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUploadVideoRequest : Tea.TeaModel {
    public var appId: String?

    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var fileName: String?

    public var fileSize: Int64?

    public var storageLocation: String?

    public var tags: String?

    public var templateGroupId: String?

    public var title: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.fileSize != nil {
            map["FileSize"] = self.fileSize!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
            self.fileSize = dict["FileSize"] as! Int64
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class CreateUploadVideoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class CreateUploadVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUploadVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUploadVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DecryptKMSDataKeyRequest : Tea.TeaModel {
    public var cipherText: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherText != nil {
            map["CipherText"] = self.cipherText!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CipherText") && dict["CipherText"] != nil {
            self.cipherText = dict["CipherText"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponseBody : Tea.TeaModel {
    public var keyId: String?

    public var plaintext: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.plaintext != nil {
            map["Plaintext"] = self.plaintext!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyId") && dict["KeyId"] != nil {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("Plaintext") && dict["Plaintext"] != nil {
            self.plaintext = dict["Plaintext"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DecryptKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DecryptKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DecryptKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAIImageInfosRequest : Tea.TeaModel {
    public var AIImageInfoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageInfoIds != nil {
            map["AIImageInfoIds"] = self.AIImageInfoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageInfoIds") && dict["AIImageInfoIds"] != nil {
            self.AIImageInfoIds = dict["AIImageInfoIds"] as! String
        }
    }
}

public class DeleteAIImageInfosResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAIImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAIImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAIImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteAppInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAttachedMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
    }
}

public class DeleteAttachedMediaResponseBody : Tea.TeaModel {
    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistMediaIds") && dict["NonExistMediaIds"] != nil {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAttachedMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAttachedMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAttachedMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDynamicImageRequest : Tea.TeaModel {
    public var dynamicImageIds: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageIds != nil {
            map["DynamicImageIds"] = self.dynamicImageIds!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageIds") && dict["DynamicImageIds"] != nil {
            self.dynamicImageIds = dict["DynamicImageIds"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteDynamicImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDynamicImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDynamicImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDynamicImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var projectIds: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectIds") && dict["ProjectIds"] != nil {
            self.projectIds = dict["ProjectIds"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DeleteEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") && dict["MaterialIds"] != nil {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var deleteImageType: String?

    public var imageIds: String?

    public var imageType: String?

    public var imageURLs: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteImageType != nil {
            map["DeleteImageType"] = self.deleteImageType!
        }
        if self.imageIds != nil {
            map["ImageIds"] = self.imageIds!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.imageURLs != nil {
            map["ImageURLs"] = self.imageURLs!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteImageType") && dict["DeleteImageType"] != nil {
            self.deleteImageType = dict["DeleteImageType"] as! String
        }
        if dict.keys.contains("ImageIds") && dict["ImageIds"] != nil {
            self.imageIds = dict["ImageIds"] as! String
        }
        if dict.keys.contains("ImageType") && dict["ImageType"] != nil {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("ImageURLs") && dict["ImageURLs"] != nil {
            self.imageURLs = dict["ImageURLs"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class DeleteMessageCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMezzaninesRequest : Tea.TeaModel {
    public var force: Bool?

    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("VideoIds") && dict["VideoIds"] != nil {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class DeleteMezzaninesResponseBody : Tea.TeaModel {
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var unRemoveableVideoIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unRemoveableVideoIds != nil {
            map["UnRemoveableVideoIds"] = self.unRemoveableVideoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") && dict["NonExistVideoIds"] != nil {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnRemoveableVideoIds") && dict["UnRemoveableVideoIds"] != nil {
            self.unRemoveableVideoIds = dict["UnRemoveableVideoIds"] as! [String]
        }
    }
}

public class DeleteMezzaninesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMezzaninesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMezzaninesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMultipartUploadRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaType: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class DeleteMultipartUploadResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMultipartUploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMultipartUploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMultipartUploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStreamRequest : Tea.TeaModel {
    public var jobIds: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DeleteStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var forceDelGroup: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelGroup != nil {
            map["ForceDelGroup"] = self.forceDelGroup!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateIds != nil {
            map["TranscodeTemplateIds"] = self.transcodeTemplateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceDelGroup") && dict["ForceDelGroup"] != nil {
            self.forceDelGroup = dict["ForceDelGroup"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateIds") && dict["TranscodeTemplateIds"] != nil {
            self.transcodeTemplateIds = dict["TranscodeTemplateIds"] as! String
        }
    }
}

public class DeleteTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var nonExistTranscodeTemplateIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistTranscodeTemplateIds != nil {
            map["NonExistTranscodeTemplateIds"] = self.nonExistTranscodeTemplateIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistTranscodeTemplateIds") && dict["NonExistTranscodeTemplateIds"] != nil {
            self.nonExistTranscodeTemplateIds = dict["NonExistTranscodeTemplateIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVideoRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") && dict["VideoIds"] != nil {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class DeleteVideoResponseBody : Tea.TeaModel {
    public var forbiddenVideoIds: [String]?

    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenVideoIds != nil {
            map["ForbiddenVideoIds"] = self.forbiddenVideoIds!
        }
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenVideoIds") && dict["ForbiddenVideoIds"] != nil {
            self.forbiddenVideoIds = dict["ForbiddenVideoIds"] as! [String]
        }
        if dict.keys.contains("NonExistVideoIds") && dict["NonExistVideoIds"] != nil {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodSpecificConfigRequest : Tea.TeaModel {
    public var configId: String?

    public var domainName: String?

    public var env: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Env") && dict["Env"] != nil {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteVodSpecificConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVodSpecificConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodSpecificConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVodSpecificConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVodTemplateRequest : Tea.TeaModel {
    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class DeleteVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class DeleteVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class DeleteWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayTopVideosRequest : Tea.TeaModel {
    public var bizDate: String?

    public var ownerId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizDate") && dict["BizDate"] != nil {
            self.bizDate = dict["BizDate"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribePlayTopVideosResponseBody : Tea.TeaModel {
    public class TopPlayVideos : Tea.TeaModel {
        public class TopPlayVideoStatis : Tea.TeaModel {
            public var playDuration: String?

            public var title: String?

            public var UV: String?

            public var VV: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                if self.VV != nil {
                    map["VV"] = self.VV!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PlayDuration") && dict["PlayDuration"] != nil {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UV") && dict["UV"] != nil {
                    self.UV = dict["UV"] as! String
                }
                if dict.keys.contains("VV") && dict["VV"] != nil {
                    self.VV = dict["VV"] as! String
                }
                if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var topPlayVideoStatis: [DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topPlayVideoStatis != nil {
                var tmp : [Any] = []
                for k in self.topPlayVideoStatis! {
                    tmp.append(k.toMap())
                }
                map["TopPlayVideoStatis"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TopPlayVideoStatis") && dict["TopPlayVideoStatis"] != nil {
                var tmp : [DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis] = []
                for v in dict["TopPlayVideoStatis"] as! [Any] {
                    var model = DescribePlayTopVideosResponseBody.TopPlayVideos.TopPlayVideoStatis()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topPlayVideoStatis = tmp
            }
        }
    }
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var topPlayVideos: DescribePlayTopVideosResponseBody.TopPlayVideos?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topPlayVideos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.topPlayVideos != nil {
            map["TopPlayVideos"] = self.topPlayVideos?.toMap()
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TopPlayVideos") && dict["TopPlayVideos"] != nil {
            var model = DescribePlayTopVideosResponseBody.TopPlayVideos()
            model.fromMap(dict["TopPlayVideos"] as! [String: Any])
            self.topPlayVideos = model
        }
        if dict.keys.contains("TotalNum") && dict["TotalNum"] != nil {
            self.totalNum = dict["TotalNum"] as! Int64
        }
    }
}

public class DescribePlayTopVideosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayTopVideosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayTopVideosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayUserAvgRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribePlayUserAvgResponseBody : Tea.TeaModel {
    public class UserPlayStatisAvgs : Tea.TeaModel {
        public class UserPlayStatisAvg : Tea.TeaModel {
            public var avgPlayCount: String?

            public var avgPlayDuration: String?

            public var date: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgPlayCount != nil {
                    map["AvgPlayCount"] = self.avgPlayCount!
                }
                if self.avgPlayDuration != nil {
                    map["AvgPlayDuration"] = self.avgPlayDuration!
                }
                if self.date != nil {
                    map["Date"] = self.date!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgPlayCount") && dict["AvgPlayCount"] != nil {
                    self.avgPlayCount = dict["AvgPlayCount"] as! String
                }
                if dict.keys.contains("AvgPlayDuration") && dict["AvgPlayDuration"] != nil {
                    self.avgPlayDuration = dict["AvgPlayDuration"] as! String
                }
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
            }
        }
        public var userPlayStatisAvg: [DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPlayStatisAvg != nil {
                var tmp : [Any] = []
                for k in self.userPlayStatisAvg! {
                    tmp.append(k.toMap())
                }
                map["UserPlayStatisAvg"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPlayStatisAvg") && dict["UserPlayStatisAvg"] != nil {
                var tmp : [DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg] = []
                for v in dict["UserPlayStatisAvg"] as! [Any] {
                    var model = DescribePlayUserAvgResponseBody.UserPlayStatisAvgs.UserPlayStatisAvg()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPlayStatisAvg = tmp
            }
        }
    }
    public var requestId: String?

    public var userPlayStatisAvgs: DescribePlayUserAvgResponseBody.UserPlayStatisAvgs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPlayStatisAvgs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userPlayStatisAvgs != nil {
            map["UserPlayStatisAvgs"] = self.userPlayStatisAvgs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserPlayStatisAvgs") && dict["UserPlayStatisAvgs"] != nil {
            var model = DescribePlayUserAvgResponseBody.UserPlayStatisAvgs()
            model.fromMap(dict["UserPlayStatisAvgs"] as! [String: Any])
            self.userPlayStatisAvgs = model
        }
    }
}

public class DescribePlayUserAvgResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayUserAvgResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayUserAvgResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayUserTotalRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribePlayUserTotalResponseBody : Tea.TeaModel {
    public class UserPlayStatisTotals : Tea.TeaModel {
        public class UserPlayStatisTotal : Tea.TeaModel {
            public class UV : Tea.TeaModel {
                public var android: String?

                public var flash: String?

                public var HTML5: String?

                public var iOS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.android != nil {
                        map["Android"] = self.android!
                    }
                    if self.flash != nil {
                        map["Flash"] = self.flash!
                    }
                    if self.HTML5 != nil {
                        map["HTML5"] = self.HTML5!
                    }
                    if self.iOS != nil {
                        map["iOS"] = self.iOS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Android") && dict["Android"] != nil {
                        self.android = dict["Android"] as! String
                    }
                    if dict.keys.contains("Flash") && dict["Flash"] != nil {
                        self.flash = dict["Flash"] as! String
                    }
                    if dict.keys.contains("HTML5") && dict["HTML5"] != nil {
                        self.HTML5 = dict["HTML5"] as! String
                    }
                    if dict.keys.contains("iOS") && dict["iOS"] != nil {
                        self.iOS = dict["iOS"] as! String
                    }
                }
            }
            public class VV : Tea.TeaModel {
                public var android: String?

                public var flash: String?

                public var HTML5: String?

                public var iOS: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.android != nil {
                        map["Android"] = self.android!
                    }
                    if self.flash != nil {
                        map["Flash"] = self.flash!
                    }
                    if self.HTML5 != nil {
                        map["HTML5"] = self.HTML5!
                    }
                    if self.iOS != nil {
                        map["iOS"] = self.iOS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Android") && dict["Android"] != nil {
                        self.android = dict["Android"] as! String
                    }
                    if dict.keys.contains("Flash") && dict["Flash"] != nil {
                        self.flash = dict["Flash"] as! String
                    }
                    if dict.keys.contains("HTML5") && dict["HTML5"] != nil {
                        self.HTML5 = dict["HTML5"] as! String
                    }
                    if dict.keys.contains("iOS") && dict["iOS"] != nil {
                        self.iOS = dict["iOS"] as! String
                    }
                }
            }
            public var date: String?

            public var playDuration: String?

            public var playRange: String?

            public var UV: DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.UV?

            public var VV: DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.VV?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.UV?.validate()
                try self.VV?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.playRange != nil {
                    map["PlayRange"] = self.playRange!
                }
                if self.UV != nil {
                    map["UV"] = self.UV?.toMap()
                }
                if self.VV != nil {
                    map["VV"] = self.VV?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("PlayDuration") && dict["PlayDuration"] != nil {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("PlayRange") && dict["PlayRange"] != nil {
                    self.playRange = dict["PlayRange"] as! String
                }
                if dict.keys.contains("UV") && dict["UV"] != nil {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.UV()
                    model.fromMap(dict["UV"] as! [String: Any])
                    self.UV = model
                }
                if dict.keys.contains("VV") && dict["VV"] != nil {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal.VV()
                    model.fromMap(dict["VV"] as! [String: Any])
                    self.VV = model
                }
            }
        }
        public var userPlayStatisTotal: [DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPlayStatisTotal != nil {
                var tmp : [Any] = []
                for k in self.userPlayStatisTotal! {
                    tmp.append(k.toMap())
                }
                map["UserPlayStatisTotal"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserPlayStatisTotal") && dict["UserPlayStatisTotal"] != nil {
                var tmp : [DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal] = []
                for v in dict["UserPlayStatisTotal"] as! [Any] {
                    var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals.UserPlayStatisTotal()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userPlayStatisTotal = tmp
            }
        }
    }
    public var requestId: String?

    public var userPlayStatisTotals: DescribePlayUserTotalResponseBody.UserPlayStatisTotals?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userPlayStatisTotals?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userPlayStatisTotals != nil {
            map["UserPlayStatisTotals"] = self.userPlayStatisTotals?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserPlayStatisTotals") && dict["UserPlayStatisTotals"] != nil {
            var model = DescribePlayUserTotalResponseBody.UserPlayStatisTotals()
            model.fromMap(dict["UserPlayStatisTotals"] as! [String: Any])
            self.userPlayStatisTotals = model
        }
    }
}

public class DescribePlayUserTotalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayUserTotalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayUserTotalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePlayVideoStatisRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class DescribePlayVideoStatisResponseBody : Tea.TeaModel {
    public class VideoPlayStatisDetails : Tea.TeaModel {
        public class VideoPlayStatisDetail : Tea.TeaModel {
            public var date: String?

            public var playDuration: String?

            public var playRange: String?

            public var title: String?

            public var UV: String?

            public var VV: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.playDuration != nil {
                    map["PlayDuration"] = self.playDuration!
                }
                if self.playRange != nil {
                    map["PlayRange"] = self.playRange!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                if self.VV != nil {
                    map["VV"] = self.VV!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") && dict["Date"] != nil {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("PlayDuration") && dict["PlayDuration"] != nil {
                    self.playDuration = dict["PlayDuration"] as! String
                }
                if dict.keys.contains("PlayRange") && dict["PlayRange"] != nil {
                    self.playRange = dict["PlayRange"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UV") && dict["UV"] != nil {
                    self.UV = dict["UV"] as! String
                }
                if dict.keys.contains("VV") && dict["VV"] != nil {
                    self.VV = dict["VV"] as! String
                }
            }
        }
        public var videoPlayStatisDetail: [DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoPlayStatisDetail != nil {
                var tmp : [Any] = []
                for k in self.videoPlayStatisDetail! {
                    tmp.append(k.toMap())
                }
                map["VideoPlayStatisDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VideoPlayStatisDetail") && dict["VideoPlayStatisDetail"] != nil {
                var tmp : [DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail] = []
                for v in dict["VideoPlayStatisDetail"] as! [Any] {
                    var model = DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails.VideoPlayStatisDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoPlayStatisDetail = tmp
            }
        }
    }
    public var requestId: String?

    public var videoPlayStatisDetails: DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoPlayStatisDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoPlayStatisDetails != nil {
            map["VideoPlayStatisDetails"] = self.videoPlayStatisDetails?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoPlayStatisDetails") && dict["VideoPlayStatisDetails"] != nil {
            var model = DescribePlayVideoStatisResponseBody.VideoPlayStatisDetails()
            model.fromMap(dict["VideoPlayStatisDetails"] as! [String: Any])
            self.videoPlayStatisDetails = model
        }
    }
}

public class DescribePlayVideoStatisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePlayVideoStatisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePlayVideoStatisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodAIDataRequest : Tea.TeaModel {
    public var AIType: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIType != nil {
            map["AIType"] = self.AIType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIType") && dict["AIType"] != nil {
            self.AIType = dict["AIType"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodAIDataResponseBody : Tea.TeaModel {
    public class AIData : Tea.TeaModel {
        public class AIDataItem : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public class DataItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var dataItem: [DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataItem != nil {
                        var tmp : [Any] = []
                        for k in self.dataItem! {
                            tmp.append(k.toMap())
                        }
                        map["DataItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataItem") && dict["DataItem"] != nil {
                        var tmp : [DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem] = []
                        for v in dict["DataItem"] as! [Any] {
                            var model = DescribeVodAIDataResponseBody.AIData.AIDataItem.Data.DataItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataItem = tmp
                    }
                }
            }
            public var data: DescribeVodAIDataResponseBody.AIData.AIDataItem.Data?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    var model = DescribeVodAIDataResponseBody.AIData.AIDataItem.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var AIDataItem: [DescribeVodAIDataResponseBody.AIData.AIDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIDataItem != nil {
                var tmp : [Any] = []
                for k in self.AIDataItem! {
                    tmp.append(k.toMap())
                }
                map["AIDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIDataItem") && dict["AIDataItem"] != nil {
                var tmp : [DescribeVodAIDataResponseBody.AIData.AIDataItem] = []
                for v in dict["AIDataItem"] as! [Any] {
                    var model = DescribeVodAIDataResponseBody.AIData.AIDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIDataItem = tmp
            }
        }
    }
    public var AIData: DescribeVodAIDataResponseBody.AIData?

    public var dataInterval: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIData != nil {
            map["AIData"] = self.AIData?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIData") && dict["AIData"] != nil {
            var model = DescribeVodAIDataResponseBody.AIData()
            model.fromMap(dict["AIData"] as! [String: Any])
            self.AIData = model
        }
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodAIDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodAIDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodAIDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodCertificateListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodCertificateListResponseBody : Tea.TeaModel {
    public class CertificateListModel : Tea.TeaModel {
        public class CertList : Tea.TeaModel {
            public class Cert : Tea.TeaModel {
                public var certId: Int64?

                public var certName: String?

                public var common: String?

                public var fingerprint: String?

                public var issuer: String?

                public var lastTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.certId != nil {
                        map["CertId"] = self.certId!
                    }
                    if self.certName != nil {
                        map["CertName"] = self.certName!
                    }
                    if self.common != nil {
                        map["Common"] = self.common!
                    }
                    if self.fingerprint != nil {
                        map["Fingerprint"] = self.fingerprint!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.lastTime != nil {
                        map["LastTime"] = self.lastTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CertId") && dict["CertId"] != nil {
                        self.certId = dict["CertId"] as! Int64
                    }
                    if dict.keys.contains("CertName") && dict["CertName"] != nil {
                        self.certName = dict["CertName"] as! String
                    }
                    if dict.keys.contains("Common") && dict["Common"] != nil {
                        self.common = dict["Common"] as! String
                    }
                    if dict.keys.contains("Fingerprint") && dict["Fingerprint"] != nil {
                        self.fingerprint = dict["Fingerprint"] as! String
                    }
                    if dict.keys.contains("Issuer") && dict["Issuer"] != nil {
                        self.issuer = dict["Issuer"] as! String
                    }
                    if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                        self.lastTime = dict["LastTime"] as! Int64
                    }
                }
            }
            public var cert: [DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cert != nil {
                    var tmp : [Any] = []
                    for k in self.cert! {
                        tmp.append(k.toMap())
                    }
                    map["Cert"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cert") && dict["Cert"] != nil {
                    var tmp : [DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert] = []
                    for v in dict["Cert"] as! [Any] {
                        var model = DescribeVodCertificateListResponseBody.CertificateListModel.CertList.Cert()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.cert = tmp
                }
            }
        }
        public var certList: DescribeVodCertificateListResponseBody.CertificateListModel.CertList?

        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.certList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certList != nil {
                map["CertList"] = self.certList?.toMap()
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertList") && dict["CertList"] != nil {
                var model = DescribeVodCertificateListResponseBody.CertificateListModel.CertList()
                model.fromMap(dict["CertList"] as! [String: Any])
                self.certList = model
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
        }
    }
    public var certificateListModel: DescribeVodCertificateListResponseBody.CertificateListModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certificateListModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateListModel != nil {
            map["CertificateListModel"] = self.certificateListModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateListModel") && dict["CertificateListModel"] != nil {
            var model = DescribeVodCertificateListResponseBody.CertificateListModel()
            model.fromMap(dict["CertificateListModel"] as! [String: Any])
            self.certificateListModel = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodCertificateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodCertificateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodCertificateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") && dict["IspNameEn"] != nil {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") && dict["LocationNameEn"] != nil {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var domesticValue: String?

            public var httpsDomesticValue: String?

            public var httpsOverseasValue: String?

            public var httpsValue: String?

            public var overseasValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domesticValue != nil {
                    map["DomesticValue"] = self.domesticValue!
                }
                if self.httpsDomesticValue != nil {
                    map["HttpsDomesticValue"] = self.httpsDomesticValue!
                }
                if self.httpsOverseasValue != nil {
                    map["HttpsOverseasValue"] = self.httpsOverseasValue!
                }
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.overseasValue != nil {
                    map["OverseasValue"] = self.overseasValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomesticValue") && dict["DomesticValue"] != nil {
                    self.domesticValue = dict["DomesticValue"] as! String
                }
                if dict.keys.contains("HttpsDomesticValue") && dict["HttpsDomesticValue"] != nil {
                    self.httpsDomesticValue = dict["HttpsDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsOverseasValue") && dict["HttpsOverseasValue"] != nil {
                    self.httpsOverseasValue = dict["HttpsOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsValue") && dict["HttpsValue"] != nil {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("OverseasValue") && dict["OverseasValue"] != nil {
                    self.overseasValue = dict["OverseasValue"] as! String
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") && dict["DataModule"] != nil {
                var tmp : [DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataPerInterval: DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataPerInterval") && dict["BpsDataPerInterval"] != nil {
            var model = DescribeVodDomainBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(dict["BpsDataPerInterval"] as! [String: Any])
            self.bpsDataPerInterval = model
        }
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") && dict["IspNameEn"] != nil {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") && dict["LocationNameEn"] != nil {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainCertificateInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeVodDomainCertificateInfoResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certDomainName: String?

            public var certExpireTime: String?

            public var certLife: String?

            public var certName: String?

            public var certOrg: String?

            public var certType: String?

            public var domainName: String?

            public var serverCertificateStatus: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certDomainName != nil {
                    map["CertDomainName"] = self.certDomainName!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certLife != nil {
                    map["CertLife"] = self.certLife!
                }
                if self.certName != nil {
                    map["CertName"] = self.certName!
                }
                if self.certOrg != nil {
                    map["CertOrg"] = self.certOrg!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.serverCertificateStatus != nil {
                    map["ServerCertificateStatus"] = self.serverCertificateStatus!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CertDomainName") && dict["CertDomainName"] != nil {
                    self.certDomainName = dict["CertDomainName"] as! String
                }
                if dict.keys.contains("CertExpireTime") && dict["CertExpireTime"] != nil {
                    self.certExpireTime = dict["CertExpireTime"] as! String
                }
                if dict.keys.contains("CertLife") && dict["CertLife"] != nil {
                    self.certLife = dict["CertLife"] as! String
                }
                if dict.keys.contains("CertName") && dict["CertName"] != nil {
                    self.certName = dict["CertName"] as! String
                }
                if dict.keys.contains("CertOrg") && dict["CertOrg"] != nil {
                    self.certOrg = dict["CertOrg"] as! String
                }
                if dict.keys.contains("CertType") && dict["CertType"] != nil {
                    self.certType = dict["CertType"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("ServerCertificateStatus") && dict["ServerCertificateStatus"] != nil {
                    self.serverCertificateStatus = dict["ServerCertificateStatus"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certInfo: [DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertInfo") && dict["CertInfo"] != nil {
                var tmp : [DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo] = []
                for v in dict["CertInfo"] as! [Any] {
                    var model = DescribeVodDomainCertificateInfoResponseBody.CertInfos.CertInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certInfo = tmp
            }
        }
    }
    public var certInfos: DescribeVodDomainCertificateInfoResponseBody.CertInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertInfos") && dict["CertInfos"] != nil {
            var model = DescribeVodDomainCertificateInfoResponseBody.CertInfos()
            model.fromMap(dict["CertInfos"] as! [String: Any])
            self.certInfos = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainCertificateInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainCertificateInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainCertificateInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionNames") && dict["FunctionNames"] != nil {
            self.functionNames = dict["FunctionNames"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodDomainConfigsResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class DomainConfig : Tea.TeaModel {
            public class FunctionArgs : Tea.TeaModel {
                public class FunctionArg : Tea.TeaModel {
                    public var argName: String?

                    public var argValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.argName != nil {
                            map["ArgName"] = self.argName!
                        }
                        if self.argValue != nil {
                            map["ArgValue"] = self.argValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArgName") && dict["ArgName"] != nil {
                            self.argName = dict["ArgName"] as! String
                        }
                        if dict.keys.contains("ArgValue") && dict["ArgValue"] != nil {
                            self.argValue = dict["ArgValue"] as! String
                        }
                    }
                }
                public var functionArg: [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.functionArg != nil {
                        var tmp : [Any] = []
                        for k in self.functionArg! {
                            tmp.append(k.toMap())
                        }
                        map["FunctionArg"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FunctionArg") && dict["FunctionArg"] != nil {
                        var tmp : [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg] = []
                        for v in dict["FunctionArg"] as! [Any] {
                            var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.functionArg = tmp
                    }
                }
            }
            public var configId: String?

            public var functionArgs: DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs?

            public var functionName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.functionArgs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.functionArgs != nil {
                    map["FunctionArgs"] = self.functionArgs?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("FunctionArgs") && dict["FunctionArgs"] != nil {
                    var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs()
                    model.fromMap(dict["FunctionArgs"] as! [String: Any])
                    self.functionArgs = model
                }
                if dict.keys.contains("FunctionName") && dict["FunctionName"] != nil {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var domainConfig: [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainConfig != nil {
                var tmp : [Any] = []
                for k in self.domainConfig! {
                    tmp.append(k.toMap())
                }
                map["DomainConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainConfig") && dict["DomainConfig"] != nil {
                var tmp : [DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig] = []
                for v in dict["DomainConfig"] as! [Any] {
                    var model = DescribeVodDomainConfigsResponseBody.DomainConfigs.DomainConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainConfig = tmp
            }
        }
    }
    public var domainConfigs: DescribeVodDomainConfigsResponseBody.DomainConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            map["DomainConfigs"] = self.domainConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainConfigs") && dict["DomainConfigs"] != nil {
            var model = DescribeVodDomainConfigsResponseBody.DomainConfigs()
            model.fromMap(dict["DomainConfigs"] as! [String: Any])
            self.domainConfigs = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainDetailRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodDomainDetailResponseBody : Tea.TeaModel {
    public class DomainDetail : Tea.TeaModel {
        public class Sources : Tea.TeaModel {
            public class Source : Tea.TeaModel {
                public var content: String?

                public var enabled: String?

                public var port: Int32?

                public var priority: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.enabled != nil {
                        map["Enabled"] = self.enabled!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Enabled") && dict["Enabled"] != nil {
                        self.enabled = dict["Enabled"] as! String
                    }
                    if dict.keys.contains("Port") && dict["Port"] != nil {
                        self.port = dict["Port"] as! Int32
                    }
                    if dict.keys.contains("Priority") && dict["Priority"] != nil {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var source: [DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.source != nil {
                    var tmp : [Any] = []
                    for k in self.source! {
                        tmp.append(k.toMap())
                    }
                    map["Source"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    var tmp : [DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source] = []
                    for v in dict["Source"] as! [Any] {
                        var model = DescribeVodDomainDetailResponseBody.DomainDetail.Sources.Source()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.source = tmp
                }
            }
        }
        public var certName: String?

        public var cname: String?

        public var description_: String?

        public var domainName: String?

        public var domainStatus: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var SSLProtocol: String?

        public var SSLPub: String?

        public var scope: String?

        public var sources: DescribeVodDomainDetailResponseBody.DomainDetail.Sources?

        public var weight: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sources?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.cname != nil {
                map["Cname"] = self.cname!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainStatus != nil {
                map["DomainStatus"] = self.domainStatus!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.SSLProtocol != nil {
                map["SSLProtocol"] = self.SSLProtocol!
            }
            if self.SSLPub != nil {
                map["SSLPub"] = self.SSLPub!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.sources != nil {
                map["Sources"] = self.sources?.toMap()
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertName") && dict["CertName"] != nil {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("Cname") && dict["Cname"] != nil {
                self.cname = dict["Cname"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainStatus") && dict["DomainStatus"] != nil {
                self.domainStatus = dict["DomainStatus"] as! String
            }
            if dict.keys.contains("GmtCreated") && dict["GmtCreated"] != nil {
                self.gmtCreated = dict["GmtCreated"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("SSLProtocol") && dict["SSLProtocol"] != nil {
                self.SSLProtocol = dict["SSLProtocol"] as! String
            }
            if dict.keys.contains("SSLPub") && dict["SSLPub"] != nil {
                self.SSLPub = dict["SSLPub"] as! String
            }
            if dict.keys.contains("Scope") && dict["Scope"] != nil {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("Sources") && dict["Sources"] != nil {
                var model = DescribeVodDomainDetailResponseBody.DomainDetail.Sources()
                model.fromMap(dict["Sources"] as! [String: Any])
                self.sources = model
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! String
            }
        }
    }
    public var domainDetail: DescribeVodDomainDetailResponseBody.DomainDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainDetail != nil {
            map["DomainDetail"] = self.domainDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainDetail") && dict["DomainDetail"] != nil {
            var model = DescribeVodDomainDetailResponseBody.DomainDetail()
            model.fromMap(dict["DomainDetail"] as! [String: Any])
            self.domainDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("LogName") && dict["LogName"] != nil {
                            self.logName = dict["LogName"] as! String
                        }
                        if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
                            self.logPath = dict["LogPath"] as! String
                        }
                        if dict.keys.contains("LogSize") && dict["LogSize"] != nil {
                            self.logSize = dict["LogSize"] as! Int64
                        }
                        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var logInfoDetail: [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogInfoDetail") && dict["LogInfoDetail"] != nil {
                        var tmp : [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in dict["LogInfoDetail"] as! [Any] {
                            var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageNumber: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageNumber != nil {
                        map["PageNumber"] = self.pageNumber!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                        self.pageNumber = dict["PageNumber"] as! Int64
                    }
                    if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                        self.pageSize = dict["PageSize"] as! Int64
                    }
                    if dict.keys.contains("Total") && dict["Total"] != nil {
                        self.total = dict["Total"] as! Int64
                    }
                }
            }
            public var domainName: String?

            public var logCount: Int64?

            public var logInfos: DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("LogCount") && dict["LogCount"] != nil {
                    self.logCount = dict["LogCount"] as! Int64
                }
                if dict.keys.contains("LogInfos") && dict["LogInfos"] != nil {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(dict["LogInfos"] as! [String: Any])
                    self.logInfos = model
                }
                if dict.keys.contains("PageInfos") && dict["PageInfos"] != nil {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(dict["PageInfos"] as! [String: Any])
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainLogDetail") && dict["DomainLogDetail"] != nil {
                var tmp : [DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in dict["DomainLogDetail"] as! [Any] {
                    var model = DescribeVodDomainLogResponseBody.DomainLogDetails.DomainLogDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeVodDomainLogResponseBody.DomainLogDetails?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLogDetails") && dict["DomainLogDetails"] != nil {
            var model = DescribeVodDomainLogResponseBody.DomainLogDetails()
            model.fromMap(dict["DomainLogDetails"] as! [String: Any])
            self.domainLogDetails = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodDomainLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainSrcBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcBpsDataResponseBody : Tea.TeaModel {
    public class SrcBpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") && dict["HttpsValue"] != nil {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") && dict["DataModule"] != nil {
                var tmp : [DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var srcBpsDataPerInterval: DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.srcBpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.srcBpsDataPerInterval != nil {
            map["SrcBpsDataPerInterval"] = self.srcBpsDataPerInterval?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SrcBpsDataPerInterval") && dict["SrcBpsDataPerInterval"] != nil {
            var model = DescribeVodDomainSrcBpsDataResponseBody.SrcBpsDataPerInterval()
            model.fromMap(dict["SrcBpsDataPerInterval"] as! [String: Any])
            self.srcBpsDataPerInterval = model
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainSrcBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainSrcBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainSrcTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainSrcTrafficDataResponseBody : Tea.TeaModel {
    public class SrcTrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpsValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsValue") && dict["HttpsValue"] != nil {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") && dict["DataModule"] != nil {
                var tmp : [DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var srcTrafficDataPerInterval: DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval?

    public var startTime: String?

    public var totalTraffic: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.srcTrafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.srcTrafficDataPerInterval != nil {
            map["SrcTrafficDataPerInterval"] = self.srcTrafficDataPerInterval?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTraffic != nil {
            map["TotalTraffic"] = self.totalTraffic!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SrcTrafficDataPerInterval") && dict["SrcTrafficDataPerInterval"] != nil {
            var model = DescribeVodDomainSrcTrafficDataResponseBody.SrcTrafficDataPerInterval()
            model.fromMap(dict["SrcTrafficDataPerInterval"] as! [String: Any])
            self.srcTrafficDataPerInterval = model
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTraffic") && dict["TotalTraffic"] != nil {
            self.totalTraffic = dict["TotalTraffic"] as! String
        }
    }
}

public class DescribeVodDomainSrcTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainSrcTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainSrcTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") && dict["IspNameEn"] != nil {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") && dict["LocationNameEn"] != nil {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeVodDomainTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var domesticValue: String?

            public var httpsDomesticValue: String?

            public var httpsOverseasValue: String?

            public var httpsValue: String?

            public var overseasValue: String?

            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domesticValue != nil {
                    map["DomesticValue"] = self.domesticValue!
                }
                if self.httpsDomesticValue != nil {
                    map["HttpsDomesticValue"] = self.httpsDomesticValue!
                }
                if self.httpsOverseasValue != nil {
                    map["HttpsOverseasValue"] = self.httpsOverseasValue!
                }
                if self.httpsValue != nil {
                    map["HttpsValue"] = self.httpsValue!
                }
                if self.overseasValue != nil {
                    map["OverseasValue"] = self.overseasValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomesticValue") && dict["DomesticValue"] != nil {
                    self.domesticValue = dict["DomesticValue"] as! String
                }
                if dict.keys.contains("HttpsDomesticValue") && dict["HttpsDomesticValue"] != nil {
                    self.httpsDomesticValue = dict["HttpsDomesticValue"] as! String
                }
                if dict.keys.contains("HttpsOverseasValue") && dict["HttpsOverseasValue"] != nil {
                    self.httpsOverseasValue = dict["HttpsOverseasValue"] as! String
                }
                if dict.keys.contains("HttpsValue") && dict["HttpsValue"] != nil {
                    self.httpsValue = dict["HttpsValue"] as! String
                }
                if dict.keys.contains("OverseasValue") && dict["OverseasValue"] != nil {
                    self.overseasValue = dict["OverseasValue"] as! String
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") && dict["DataModule"] != nil {
                var tmp : [DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var totalTraffic: String?

    public var trafficDataPerInterval: DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTraffic != nil {
            map["TotalTraffic"] = self.totalTraffic!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTraffic") && dict["TotalTraffic"] != nil {
            self.totalTraffic = dict["TotalTraffic"] as! String
        }
        if dict.keys.contains("TrafficDataPerInterval") && dict["TrafficDataPerInterval"] != nil {
            var model = DescribeVodDomainTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(dict["TrafficDataPerInterval"] as! [String: Any])
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeVodDomainTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodDomainUsageDataRequest : Tea.TeaModel {
    public var area: String?

    public var domainName: String?

    public var endTime: String?

    public var field: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.field != nil {
            map["Field"] = self.field!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") && dict["Area"] != nil {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Field") && dict["Field"] != nil {
            self.field = dict["Field"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeVodDomainUsageDataResponseBody : Tea.TeaModel {
    public class UsageDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") && dict["DataModule"] != nil {
                var tmp : [DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule] = []
                for v in dict["DataModule"] as! [Any] {
                    var model = DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval.DataModule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataModule = tmp
            }
        }
    }
    public var area: String?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var type: String?

    public var usageDataPerInterval: DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.usageDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.usageDataPerInterval != nil {
            map["UsageDataPerInterval"] = self.usageDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") && dict["Area"] != nil {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UsageDataPerInterval") && dict["UsageDataPerInterval"] != nil {
            var model = DescribeVodDomainUsageDataResponseBody.UsageDataPerInterval()
            model.fromMap(dict["UsageDataPerInterval"] as! [String: Any])
            self.usageDataPerInterval = model
        }
    }
}

public class DescribeVodDomainUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodDomainUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodDomainUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodRefreshQuotaRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeVodRefreshQuotaResponseBody : Tea.TeaModel {
    public var blockQuota: String?

    public var dirQuota: String?

    public var dirRemain: String?

    public var preloadQuota: String?

    public var preloadRemain: String?

    public var requestId: String?

    public var urlQuota: String?

    public var urlRemain: String?

    public var blockRemain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockQuota != nil {
            map["BlockQuota"] = self.blockQuota!
        }
        if self.dirQuota != nil {
            map["DirQuota"] = self.dirQuota!
        }
        if self.dirRemain != nil {
            map["DirRemain"] = self.dirRemain!
        }
        if self.preloadQuota != nil {
            map["PreloadQuota"] = self.preloadQuota!
        }
        if self.preloadRemain != nil {
            map["PreloadRemain"] = self.preloadRemain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.urlQuota != nil {
            map["UrlQuota"] = self.urlQuota!
        }
        if self.urlRemain != nil {
            map["UrlRemain"] = self.urlRemain!
        }
        if self.blockRemain != nil {
            map["blockRemain"] = self.blockRemain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockQuota") && dict["BlockQuota"] != nil {
            self.blockQuota = dict["BlockQuota"] as! String
        }
        if dict.keys.contains("DirQuota") && dict["DirQuota"] != nil {
            self.dirQuota = dict["DirQuota"] as! String
        }
        if dict.keys.contains("DirRemain") && dict["DirRemain"] != nil {
            self.dirRemain = dict["DirRemain"] as! String
        }
        if dict.keys.contains("PreloadQuota") && dict["PreloadQuota"] != nil {
            self.preloadQuota = dict["PreloadQuota"] as! String
        }
        if dict.keys.contains("PreloadRemain") && dict["PreloadRemain"] != nil {
            self.preloadRemain = dict["PreloadRemain"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UrlQuota") && dict["UrlQuota"] != nil {
            self.urlQuota = dict["UrlQuota"] as! String
        }
        if dict.keys.contains("UrlRemain") && dict["UrlRemain"] != nil {
            self.urlRemain = dict["UrlRemain"] as! String
        }
        if dict.keys.contains("blockRemain") && dict["blockRemain"] != nil {
            self.blockRemain = dict["blockRemain"] as! String
        }
    }
}

public class DescribeVodRefreshQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodRefreshQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodRefreshQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodRefreshTasksRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var objectPath: String?

    public var objectType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var startTime: String?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ObjectPath") && dict["ObjectPath"] != nil {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeVodRefreshTasksResponseBody : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var objectPath: String?

            public var objectType: String?

            public var process: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.objectPath != nil {
                    map["ObjectPath"] = self.objectPath!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.process != nil {
                    map["Process"] = self.process!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ObjectPath") && dict["ObjectPath"] != nil {
                    self.objectPath = dict["ObjectPath"] as! String
                }
                if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("Process") && dict["Process"] != nil {
                    self.process = dict["Process"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var task: [DescribeVodRefreshTasksResponseBody.Tasks.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Task") && dict["Task"] != nil {
                var tmp : [DescribeVodRefreshTasksResponseBody.Tasks.Task] = []
                for v in dict["Task"] as! [Any] {
                    var model = DescribeVodRefreshTasksResponseBody.Tasks.Task()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.task = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var tasks: DescribeVodRefreshTasksResponseBody.Tasks?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tasks") && dict["Tasks"] != nil {
            var model = DescribeVodRefreshTasksResponseBody.Tasks()
            model.fromMap(dict["Tasks"] as! [String: Any])
            self.tasks = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeVodRefreshTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodRefreshTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodRefreshTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodStorageDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var startTime: String?

    public var storage: String?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Storage") && dict["Storage"] != nil {
            self.storage = dict["Storage"] as! String
        }
        if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class DescribeVodStorageDataResponseBody : Tea.TeaModel {
    public class StorageData : Tea.TeaModel {
        public class StorageDataItem : Tea.TeaModel {
            public var networkOut: String?

            public var storageUtilization: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkOut != nil {
                    map["NetworkOut"] = self.networkOut!
                }
                if self.storageUtilization != nil {
                    map["StorageUtilization"] = self.storageUtilization!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetworkOut") && dict["NetworkOut"] != nil {
                    self.networkOut = dict["NetworkOut"] as! String
                }
                if dict.keys.contains("StorageUtilization") && dict["StorageUtilization"] != nil {
                    self.storageUtilization = dict["StorageUtilization"] as! String
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var storageDataItem: [DescribeVodStorageDataResponseBody.StorageData.StorageDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageDataItem != nil {
                var tmp : [Any] = []
                for k in self.storageDataItem! {
                    tmp.append(k.toMap())
                }
                map["StorageDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageDataItem") && dict["StorageDataItem"] != nil {
                var tmp : [DescribeVodStorageDataResponseBody.StorageData.StorageDataItem] = []
                for v in dict["StorageDataItem"] as! [Any] {
                    var model = DescribeVodStorageDataResponseBody.StorageData.StorageDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.storageDataItem = tmp
            }
        }
    }
    public var dataInterval: String?

    public var requestId: String?

    public var storageData: DescribeVodStorageDataResponseBody.StorageData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageData != nil {
            map["StorageData"] = self.storageData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageData") && dict["StorageData"] != nil {
            var model = DescribeVodStorageDataResponseBody.StorageData()
            model.fromMap(dict["StorageData"] as! [String: Any])
            self.storageData = model
        }
    }
}

public class DescribeVodStorageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodStorageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodStorageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodTranscodeDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var specification: String?

    public var startTime: String?

    public var storage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.specification != nil {
            map["Specification"] = self.specification!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Specification") && dict["Specification"] != nil {
            self.specification = dict["Specification"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Storage") && dict["Storage"] != nil {
            self.storage = dict["Storage"] as! String
        }
    }
}

public class DescribeVodTranscodeDataResponseBody : Tea.TeaModel {
    public class TranscodeData : Tea.TeaModel {
        public class TranscodeDataItem : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public class DataItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var dataItem: [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataItem != nil {
                        var tmp : [Any] = []
                        for k in self.dataItem! {
                            tmp.append(k.toMap())
                        }
                        map["DataItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataItem") && dict["DataItem"] != nil {
                        var tmp : [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem] = []
                        for v in dict["DataItem"] as! [Any] {
                            var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data.DataItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataItem = tmp
                    }
                }
            }
            public var data: DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data?.toMap()
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem.Data()
                    model.fromMap(dict["Data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var transcodeDataItem: [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeDataItem != nil {
                var tmp : [Any] = []
                for k in self.transcodeDataItem! {
                    tmp.append(k.toMap())
                }
                map["TranscodeDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeDataItem") && dict["TranscodeDataItem"] != nil {
                var tmp : [DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem] = []
                for v in dict["TranscodeDataItem"] as! [Any] {
                    var model = DescribeVodTranscodeDataResponseBody.TranscodeData.TranscodeDataItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeDataItem = tmp
            }
        }
    }
    public var dataInterval: String?

    public var requestId: String?

    public var transcodeData: DescribeVodTranscodeDataResponseBody.TranscodeData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeData != nil {
            map["TranscodeData"] = self.transcodeData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") && dict["DataInterval"] != nil {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeData") && dict["TranscodeData"] != nil {
            var model = DescribeVodTranscodeDataResponseBody.TranscodeData()
            model.fromMap(dict["TranscodeData"] as! [String: Any])
            self.transcodeData = model
        }
    }
}

public class DescribeVodTranscodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodTranscodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodTranscodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodUserDomainsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var domainName: String?

    public var domainSearchType: String?

    public var domainStatus: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var tag: [DescribeVodUserDomainsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSearchType != nil {
            map["DomainSearchType"] = self.domainSearchType!
        }
        if self.domainStatus != nil {
            map["DomainStatus"] = self.domainStatus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSearchType") && dict["DomainSearchType"] != nil {
            self.domainSearchType = dict["DomainSearchType"] as! String
        }
        if dict.keys.contains("DomainStatus") && dict["DomainStatus"] != nil {
            self.domainStatus = dict["DomainStatus"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [DescribeVodUserDomainsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeVodUserDomainsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeVodUserDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class PageData : Tea.TeaModel {
            public class Sources : Tea.TeaModel {
                public class Source : Tea.TeaModel {
                    public var content: String?

                    public var port: Int32?

                    public var priority: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Content") && dict["Content"] != nil {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("Port") && dict["Port"] != nil {
                            self.port = dict["Port"] as! Int32
                        }
                        if dict.keys.contains("Priority") && dict["Priority"] != nil {
                            self.priority = dict["Priority"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var source: [DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.source != nil {
                        var tmp : [Any] = []
                        for k in self.source! {
                            tmp.append(k.toMap())
                        }
                        map["Source"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Source") && dict["Source"] != nil {
                        var tmp : [DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source] = []
                        for v in dict["Source"] as! [Any] {
                            var model = DescribeVodUserDomainsResponseBody.Domains.PageData.Sources.Source()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.source = tmp
                    }
                }
            }
            public var cname: String?

            public var description_: String?

            public var domainName: String?

            public var domainStatus: String?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var sandbox: String?

            public var sources: DescribeVodUserDomainsResponseBody.Domains.PageData.Sources?

            public var sslProtocol: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainStatus != nil {
                    map["DomainStatus"] = self.domainStatus!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.sandbox != nil {
                    map["Sandbox"] = self.sandbox!
                }
                if self.sources != nil {
                    map["Sources"] = self.sources?.toMap()
                }
                if self.sslProtocol != nil {
                    map["SslProtocol"] = self.sslProtocol!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cname") && dict["Cname"] != nil {
                    self.cname = dict["Cname"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainStatus") && dict["DomainStatus"] != nil {
                    self.domainStatus = dict["DomainStatus"] as! String
                }
                if dict.keys.contains("GmtCreated") && dict["GmtCreated"] != nil {
                    self.gmtCreated = dict["GmtCreated"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Sandbox") && dict["Sandbox"] != nil {
                    self.sandbox = dict["Sandbox"] as! String
                }
                if dict.keys.contains("Sources") && dict["Sources"] != nil {
                    var model = DescribeVodUserDomainsResponseBody.Domains.PageData.Sources()
                    model.fromMap(dict["Sources"] as! [String: Any])
                    self.sources = model
                }
                if dict.keys.contains("SslProtocol") && dict["SslProtocol"] != nil {
                    self.sslProtocol = dict["SslProtocol"] as! String
                }
            }
        }
        public var pageData: [DescribeVodUserDomainsResponseBody.Domains.PageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageData != nil {
                var tmp : [Any] = []
                for k in self.pageData! {
                    tmp.append(k.toMap())
                }
                map["PageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageData") && dict["PageData"] != nil {
                var tmp : [DescribeVodUserDomainsResponseBody.Domains.PageData] = []
                for v in dict["PageData"] as! [Any] {
                    var model = DescribeVodUserDomainsResponseBody.Domains.PageData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pageData = tmp
            }
        }
    }
    public var domains: DescribeVodUserDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") && dict["Domains"] != nil {
            var model = DescribeVodUserDomainsResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeVodUserDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodUserDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodUserDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVodVerifyContentRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeVodVerifyContentResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVodVerifyContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVodVerifyContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVodVerifyContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachAppPolicyFromIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public var policyNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        if self.policyNames != nil {
            map["PolicyNames"] = self.policyNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") && dict["IdentityName"] != nil {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") && dict["IdentityType"] != nil {
            self.identityType = dict["IdentityType"] as! String
        }
        if dict.keys.contains("PolicyNames") && dict["PolicyNames"] != nil {
            self.policyNames = dict["PolicyNames"] as! String
        }
    }
}

public class DetachAppPolicyFromIdentityResponseBody : Tea.TeaModel {
    public var failedPolicyNames: [String]?

    public var nonExistPolicyNames: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedPolicyNames != nil {
            map["FailedPolicyNames"] = self.failedPolicyNames!
        }
        if self.nonExistPolicyNames != nil {
            map["NonExistPolicyNames"] = self.nonExistPolicyNames!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedPolicyNames") && dict["FailedPolicyNames"] != nil {
            self.failedPolicyNames = dict["FailedPolicyNames"] as! [String]
        }
        if dict.keys.contains("NonExistPolicyNames") && dict["NonExistPolicyNames"] != nil {
            self.nonExistPolicyNames = dict["NonExistPolicyNames"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachAppPolicyFromIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachAppPolicyFromIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachAppPolicyFromIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateDownloadSecretKeyRequest : Tea.TeaModel {
    public var appDecryptKey: String?

    public var appIdentification: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appDecryptKey != nil {
            map["AppDecryptKey"] = self.appDecryptKey!
        }
        if self.appIdentification != nil {
            map["AppIdentification"] = self.appIdentification!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppDecryptKey") && dict["AppDecryptKey"] != nil {
            self.appDecryptKey = dict["AppDecryptKey"] as! String
        }
        if dict.keys.contains("AppIdentification") && dict["AppIdentification"] != nil {
            self.appIdentification = dict["AppIdentification"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GenerateDownloadSecretKeyResponseBody : Tea.TeaModel {
    public var appEncryptKey: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEncryptKey != nil {
            map["AppEncryptKey"] = self.appEncryptKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppEncryptKey") && dict["AppEncryptKey"] != nil {
            self.appEncryptKey = dict["AppEncryptKey"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateDownloadSecretKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateDownloadSecretKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateDownloadSecretKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateKMSDataKeyRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponseBody : Tea.TeaModel {
    public var ciphertextBlob: String?

    public var keyId: String?

    public var plaintext: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ciphertextBlob != nil {
            map["CiphertextBlob"] = self.ciphertextBlob!
        }
        if self.keyId != nil {
            map["KeyId"] = self.keyId!
        }
        if self.plaintext != nil {
            map["Plaintext"] = self.plaintext!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CiphertextBlob") && dict["CiphertextBlob"] != nil {
            self.ciphertextBlob = dict["CiphertextBlob"] as! String
        }
        if dict.keys.contains("KeyId") && dict["KeyId"] != nil {
            self.keyId = dict["KeyId"] as! String
        }
        if dict.keys.contains("Plaintext") && dict["Plaintext"] != nil {
            self.plaintext = dict["Plaintext"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GenerateKMSDataKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateKMSDataKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateKMSDataKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIImageJobsRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetAIImageJobsResponseBody : Tea.TeaModel {
    public class AIImageJobList : Tea.TeaModel {
        public var AIImageResult: String?

        public var code: String?

        public var creationTime: String?

        public var jobId: String?

        public var message: String?

        public var status: String?

        public var templateConfig: String?

        public var templateId: String?

        public var userData: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIImageResult != nil {
                map["AIImageResult"] = self.AIImageResult!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIImageResult") && dict["AIImageResult"] != nil {
                self.AIImageResult = dict["AIImageResult"] as! String
            }
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var AIImageJobList: [GetAIImageJobsResponseBody.AIImageJobList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageJobList != nil {
            var tmp : [Any] = []
            for k in self.AIImageJobList! {
                tmp.append(k.toMap())
            }
            map["AIImageJobList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageJobList") && dict["AIImageJobList"] != nil {
            var tmp : [GetAIImageJobsResponseBody.AIImageJobList] = []
            for v in dict["AIImageJobList"] as! [Any] {
                var model = GetAIImageJobsResponseBody.AIImageJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.AIImageJobList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAIImageJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIImageJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAIImageJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIMediaAuditJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetAIMediaAuditJobResponseBody : Tea.TeaModel {
    public class MediaAuditJob : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class AudioResult : Tea.TeaModel {
                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") && dict["Score"] != nil {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class ImageResult : Tea.TeaModel {
                public class Result : Tea.TeaModel {
                    public var label: String?

                    public var scene: String?

                    public var score: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Scene") && dict["Scene"] != nil {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var label: String?

                public var result: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result]?

                public var suggestion: String?

                public var type: String?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.result != nil {
                        var tmp : [Any] = []
                        for k in self.result! {
                            tmp.append(k.toMap())
                        }
                        map["Result"] = tmp
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Result") && dict["Result"] != nil {
                        var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result] = []
                        for v in dict["Result"] as! [Any] {
                            var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult.Result()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.result = tmp
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Url") && dict["Url"] != nil {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public class TextResult : Tea.TeaModel {
                public var content: String?

                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") && dict["Score"] != nil {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class VideoResult : Tea.TeaModel {
                public class AdResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") && dict["Count"] != nil {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") && dict["Score"] != nil {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") && dict["Url"] != nil {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") && dict["TopList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class LiveResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") && dict["Count"] != nil {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") && dict["Score"] != nil {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") && dict["Url"] != nil {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") && dict["TopList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class LogoResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") && dict["Count"] != nil {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") && dict["Score"] != nil {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") && dict["Url"] != nil {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") && dict["TopList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class PornResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") && dict["Count"] != nil {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") && dict["Score"] != nil {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") && dict["Url"] != nil {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") && dict["TopList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public class TerrorismResult : Tea.TeaModel {
                    public class CounterList : Tea.TeaModel {
                        public var count: Int32?

                        public var label: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") && dict["Count"] != nil {
                                self.count = dict["Count"] as! Int32
                            }
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                        }
                    }
                    public class TopList : Tea.TeaModel {
                        public var label: String?

                        public var score: String?

                        public var timestamp: String?

                        public var url: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.score != nil {
                                map["Score"] = self.score!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            if self.url != nil {
                                map["Url"] = self.url!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") && dict["Label"] != nil {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Score") && dict["Score"] != nil {
                                self.score = dict["Score"] as! String
                            }
                            if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                            if dict.keys.contains("Url") && dict["Url"] != nil {
                                self.url = dict["Url"] as! String
                            }
                        }
                    }
                    public var averageScore: String?

                    public var counterList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList]?

                    public var label: String?

                    public var maxScore: String?

                    public var suggestion: String?

                    public var topList: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageScore != nil {
                            map["AverageScore"] = self.averageScore!
                        }
                        if self.counterList != nil {
                            var tmp : [Any] = []
                            for k in self.counterList! {
                                tmp.append(k.toMap())
                            }
                            map["CounterList"] = tmp
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.maxScore != nil {
                            map["MaxScore"] = self.maxScore!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        if self.topList != nil {
                            var tmp : [Any] = []
                            for k in self.topList! {
                                tmp.append(k.toMap())
                            }
                            map["TopList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                            self.averageScore = dict["AverageScore"] as! String
                        }
                        if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList] = []
                            for v in dict["CounterList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.CounterList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.counterList = tmp
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                            self.maxScore = dict["MaxScore"] as! String
                        }
                        if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                        if dict.keys.contains("TopList") && dict["TopList"] != nil {
                            var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList] = []
                            for v in dict["TopList"] as! [Any] {
                                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult.TopList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.topList = tmp
                        }
                    }
                }
                public var adResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult?

                public var label: String?

                public var liveResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult?

                public var logoResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult?

                public var pornResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult?

                public var suggestion: String?

                public var terrorismResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.adResult?.validate()
                    try self.liveResult?.validate()
                    try self.logoResult?.validate()
                    try self.pornResult?.validate()
                    try self.terrorismResult?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adResult != nil {
                        map["AdResult"] = self.adResult?.toMap()
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.liveResult != nil {
                        map["LiveResult"] = self.liveResult?.toMap()
                    }
                    if self.logoResult != nil {
                        map["LogoResult"] = self.logoResult?.toMap()
                    }
                    if self.pornResult != nil {
                        map["PornResult"] = self.pornResult?.toMap()
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.terrorismResult != nil {
                        map["TerrorismResult"] = self.terrorismResult?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdResult") && dict["AdResult"] != nil {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.AdResult()
                        model.fromMap(dict["AdResult"] as! [String: Any])
                        self.adResult = model
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("LiveResult") && dict["LiveResult"] != nil {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LiveResult()
                        model.fromMap(dict["LiveResult"] as! [String: Any])
                        self.liveResult = model
                    }
                    if dict.keys.contains("LogoResult") && dict["LogoResult"] != nil {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.LogoResult()
                        model.fromMap(dict["LogoResult"] as! [String: Any])
                        self.logoResult = model
                    }
                    if dict.keys.contains("PornResult") && dict["PornResult"] != nil {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.PornResult()
                        model.fromMap(dict["PornResult"] as! [String: Any])
                        self.pornResult = model
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TerrorismResult") && dict["TerrorismResult"] != nil {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult.TerrorismResult()
                        model.fromMap(dict["TerrorismResult"] as! [String: Any])
                        self.terrorismResult = model
                    }
                }
            }
            public var abnormalModules: String?

            public var audioResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult]?

            public var imageResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult]?

            public var label: String?

            public var suggestion: String?

            public var textResult: [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult]?

            public var videoResult: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.videoResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalModules != nil {
                    map["AbnormalModules"] = self.abnormalModules!
                }
                if self.audioResult != nil {
                    var tmp : [Any] = []
                    for k in self.audioResult! {
                        tmp.append(k.toMap())
                    }
                    map["AudioResult"] = tmp
                }
                if self.imageResult != nil {
                    var tmp : [Any] = []
                    for k in self.imageResult! {
                        tmp.append(k.toMap())
                    }
                    map["ImageResult"] = tmp
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.textResult != nil {
                    var tmp : [Any] = []
                    for k in self.textResult! {
                        tmp.append(k.toMap())
                    }
                    map["TextResult"] = tmp
                }
                if self.videoResult != nil {
                    map["VideoResult"] = self.videoResult?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbnormalModules") && dict["AbnormalModules"] != nil {
                    self.abnormalModules = dict["AbnormalModules"] as! String
                }
                if dict.keys.contains("AudioResult") && dict["AudioResult"] != nil {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult] = []
                    for v in dict["AudioResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.AudioResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.audioResult = tmp
                }
                if dict.keys.contains("ImageResult") && dict["ImageResult"] != nil {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult] = []
                    for v in dict["ImageResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.ImageResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.imageResult = tmp
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TextResult") && dict["TextResult"] != nil {
                    var tmp : [GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult] = []
                    for v in dict["TextResult"] as! [Any] {
                        var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.TextResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.textResult = tmp
                }
                if dict.keys.contains("VideoResult") && dict["VideoResult"] != nil {
                    var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data.VideoResult()
                    model.fromMap(dict["VideoResult"] as! [String: Any])
                    self.videoResult = model
                }
            }
        }
        public var code: String?

        public var completeTime: String?

        public var creationTime: String?

        public var data: GetAIMediaAuditJobResponseBody.MediaAuditJob.Data?

        public var jobId: String?

        public var mediaId: String?

        public var message: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = GetAIMediaAuditJobResponseBody.MediaAuditJob.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var mediaAuditJob: GetAIMediaAuditJobResponseBody.MediaAuditJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditJob != nil {
            map["MediaAuditJob"] = self.mediaAuditJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditJob") && dict["MediaAuditJob"] != nil {
            var model = GetAIMediaAuditJobResponseBody.MediaAuditJob()
            model.fromMap(dict["MediaAuditJob"] as! [String: Any])
            self.mediaAuditJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAIMediaAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIMediaAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAIMediaAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class GetAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfo: GetAITemplateResponseBody.TemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfo != nil {
            map["TemplateInfo"] = self.templateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfo") && dict["TemplateInfo"] != nil {
            var model = GetAITemplateResponseBody.TemplateInfo()
            model.fromMap(dict["TemplateInfo"] as! [String: Any])
            self.templateInfo = model
        }
    }
}

public class GetAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAIVideoTagResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetAIVideoTagResultResponseBody : Tea.TeaModel {
    public class VideoTagResult : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var tag: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
            }
        }
        public class Keyword : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Location : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Person : Tea.TeaModel {
            public var faceUrl: String?

            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.faceUrl != nil {
                    map["FaceUrl"] = self.faceUrl!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FaceUrl") && dict["FaceUrl"] != nil {
                    self.faceUrl = dict["FaceUrl"] as! String
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public class Time : Tea.TeaModel {
            public var tag: String?

            public var times: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.times != nil {
                    map["Times"] = self.times!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("Times") && dict["Times"] != nil {
                    self.times = dict["Times"] as! [String]
                }
            }
        }
        public var category: [GetAIVideoTagResultResponseBody.VideoTagResult.Category]?

        public var keyword: [GetAIVideoTagResultResponseBody.VideoTagResult.Keyword]?

        public var location: [GetAIVideoTagResultResponseBody.VideoTagResult.Location]?

        public var person: [GetAIVideoTagResultResponseBody.VideoTagResult.Person]?

        public var time: [GetAIVideoTagResultResponseBody.VideoTagResult.Time]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            if self.keyword != nil {
                var tmp : [Any] = []
                for k in self.keyword! {
                    tmp.append(k.toMap())
                }
                map["Keyword"] = tmp
            }
            if self.location != nil {
                var tmp : [Any] = []
                for k in self.location! {
                    tmp.append(k.toMap())
                }
                map["Location"] = tmp
            }
            if self.person != nil {
                var tmp : [Any] = []
                for k in self.person! {
                    tmp.append(k.toMap())
                }
                map["Person"] = tmp
            }
            if self.time != nil {
                var tmp : [Any] = []
                for k in self.time! {
                    tmp.append(k.toMap())
                }
                map["Time"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
            if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Keyword] = []
                for v in dict["Keyword"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Keyword()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.keyword = tmp
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Location] = []
                for v in dict["Location"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Location()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.location = tmp
            }
            if dict.keys.contains("Person") && dict["Person"] != nil {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Person] = []
                for v in dict["Person"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Person()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.person = tmp
            }
            if dict.keys.contains("Time") && dict["Time"] != nil {
                var tmp : [GetAIVideoTagResultResponseBody.VideoTagResult.Time] = []
                for v in dict["Time"] as! [Any] {
                    var model = GetAIVideoTagResultResponseBody.VideoTagResult.Time()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.time = tmp
            }
        }
    }
    public var requestId: String?

    public var videoTagResult: GetAIVideoTagResultResponseBody.VideoTagResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoTagResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoTagResult != nil {
            map["VideoTagResult"] = self.videoTagResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoTagResult") && dict["VideoTagResult"] != nil {
            var model = GetAIVideoTagResultResponseBody.VideoTagResult()
            model.fromMap(dict["VideoTagResult"] as! [String: Any])
            self.videoTagResult = model
        }
    }
}

public class GetAIVideoTagResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAIVideoTagResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAIVideoTagResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppInfosRequest : Tea.TeaModel {
    public var appIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") && dict["AppIds"] != nil {
            self.appIds = dict["AppIds"] as! String
        }
    }
}

public class GetAppInfosResponseBody : Tea.TeaModel {
    public class AppInfoList : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var appInfoList: [GetAppInfosResponseBody.AppInfoList]?

    public var code: String?

    public var nonExistAppIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfoList != nil {
            var tmp : [Any] = []
            for k in self.appInfoList! {
                tmp.append(k.toMap())
            }
            map["AppInfoList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.nonExistAppIds != nil {
            map["NonExistAppIds"] = self.nonExistAppIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfoList") && dict["AppInfoList"] != nil {
            var tmp : [GetAppInfosResponseBody.AppInfoList] = []
            for v in dict["AppInfoList"] as! [Any] {
                var model = GetAppInfosResponseBody.AppInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appInfoList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("NonExistAppIds") && dict["NonExistAppIds"] != nil {
            self.nonExistAppIds = dict["NonExistAppIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAppInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAppInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAttachedMediaInfoRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var mediaIds: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetAttachedMediaInfoResponseBody : Tea.TeaModel {
    public class AttachedMediaList : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
            }
        }
        public var appId: String?

        public var categories: [GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories]?

        public var creationTime: String?

        public var description_: String?

        public var mediaId: String?

        public var modificationTime: String?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var type: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Categories") && dict["Categories"] != nil {
                var tmp : [GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories] = []
                for v in dict["Categories"] as! [Any] {
                    var model = GetAttachedMediaInfoResponseBody.AttachedMediaList.Categories()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.categories = tmp
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("URL") && dict["URL"] != nil {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var attachedMediaList: [GetAttachedMediaInfoResponseBody.AttachedMediaList]?

    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachedMediaList != nil {
            var tmp : [Any] = []
            for k in self.attachedMediaList! {
                tmp.append(k.toMap())
            }
            map["AttachedMediaList"] = tmp
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachedMediaList") && dict["AttachedMediaList"] != nil {
            var tmp : [GetAttachedMediaInfoResponseBody.AttachedMediaList] = []
            for v in dict["AttachedMediaList"] as! [Any] {
                var model = GetAttachedMediaInfoResponseBody.AttachedMediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attachedMediaList = tmp
        }
        if dict.keys.contains("NonExistMediaIds") && dict["NonExistMediaIds"] != nil {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAttachedMediaInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAttachedMediaInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAttachedMediaInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuditHistoryRequest : Tea.TeaModel {
    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetAuditHistoryResponseBody : Tea.TeaModel {
    public class Histories : Tea.TeaModel {
        public var auditor: String?

        public var comment: String?

        public var creationTime: String?

        public var reason: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditor != nil {
                map["Auditor"] = self.auditor!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Auditor") && dict["Auditor"] != nil {
                self.auditor = dict["Auditor"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var histories: [GetAuditHistoryResponseBody.Histories]?

    public var requestId: String?

    public var status: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.histories != nil {
            var tmp : [Any] = []
            for k in self.histories! {
                tmp.append(k.toMap())
            }
            map["Histories"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Histories") && dict["Histories"] != nil {
            var tmp : [GetAuditHistoryResponseBody.Histories] = []
            for v in dict["Histories"] as! [Any] {
                var model = GetAuditHistoryResponseBody.Histories()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.histories = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class GetAuditHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuditHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuditHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCategoriesRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCategoriesResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: Int64?

        public var cateName: String?

        public var level: Int64?

        public var parentId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                self.parentId = dict["ParentId"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SubCategories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: Int64?

            public var cateName: String?

            public var level: Int64?

            public var parentId: Int64?

            public var subTotal: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.subTotal != nil {
                    map["SubTotal"] = self.subTotal!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! Int64
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! Int64
                }
                if dict.keys.contains("SubTotal") && dict["SubTotal"] != nil {
                    self.subTotal = dict["SubTotal"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [GetCategoriesResponseBody.SubCategories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                var tmp : [GetCategoriesResponseBody.SubCategories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = GetCategoriesResponseBody.SubCategories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var category: GetCategoriesResponseBody.Category?

    public var requestId: String?

    public var subCategories: GetCategoriesResponseBody.SubCategories?

    public var subTotal: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
        try self.subCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subCategories != nil {
            map["SubCategories"] = self.subCategories?.toMap()
        }
        if self.subTotal != nil {
            map["SubTotal"] = self.subTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            var model = GetCategoriesResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubCategories") && dict["SubCategories"] != nil {
            var model = GetCategoriesResponseBody.SubCategories()
            model.fromMap(dict["SubCategories"] as! [String: Any])
            self.subCategories = model
        }
        if dict.keys.contains("SubTotal") && dict["SubTotal"] != nil {
            self.subTotal = dict["SubTotal"] as! Int64
        }
    }
}

public class GetCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDefaultAITemplateRequest : Tea.TeaModel {
    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class GetDefaultAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfo: GetDefaultAITemplateResponseBody.TemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfo != nil {
            map["TemplateInfo"] = self.templateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfo") && dict["TemplateInfo"] != nil {
            var model = GetDefaultAITemplateResponseBody.TemplateInfo()
            model.fromMap(dict["TemplateInfo"] as! [String: Any])
            self.templateInfo = model
        }
    }
}

public class GetDefaultAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDefaultAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDefaultAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDigitalWatermarkExtractResultRequest : Tea.TeaModel {
    public var extractType: String?

    public var jobId: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extractType != nil {
            map["ExtractType"] = self.extractType!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtractType") && dict["ExtractType"] != nil {
            self.extractType = dict["ExtractType"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetDigitalWatermarkExtractResultResponseBody : Tea.TeaModel {
    public class AiExtractResultList : Tea.TeaModel {
        public var createTime: String?

        public var errorMessage: String?

        public var jobId: String?

        public var modifyTime: String?

        public var status: String?

        public var waterMarkText: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.waterMarkText != nil {
                map["WaterMarkText"] = self.waterMarkText!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("WaterMarkText") && dict["WaterMarkText"] != nil {
                self.waterMarkText = dict["WaterMarkText"] as! String
            }
        }
    }
    public var aiExtractResultList: [GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiExtractResultList != nil {
            var tmp : [Any] = []
            for k in self.aiExtractResultList! {
                tmp.append(k.toMap())
            }
            map["AiExtractResultList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiExtractResultList") && dict["AiExtractResultList"] != nil {
            var tmp : [GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList] = []
            for v in dict["AiExtractResultList"] as! [Any] {
                var model = GetDigitalWatermarkExtractResultResponseBody.AiExtractResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aiExtractResultList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDigitalWatermarkExtractResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDigitalWatermarkExtractResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDigitalWatermarkExtractResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetEditingProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public var projectId: String?

        public var regionId: String?

        public var status: String?

        public var storageLocation: String?

        public var timeline: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
                self.timeline = dict["Timeline"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var project: GetEditingProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") && dict["Project"] != nil {
            var model = GetEditingProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialType: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialType != nil {
            map["MaterialType"] = self.materialType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
            self.materialType = dict["MaterialType"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public class MaterialList : Tea.TeaModel {
        public class Material : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public var snapshot: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") && dict["Snapshot"] != nil {
                        self.snapshot = dict["Snapshot"] as! [String]
                    }
                }
            }
            public class Sprites : Tea.TeaModel {
                public var sprite: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sprite != nil {
                        map["Sprite"] = self.sprite!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Sprite") && dict["Sprite"] != nil {
                        self.sprite = dict["Sprite"] as! [String]
                    }
                }
            }
            public var cateId: Int32?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var materialId: String?

            public var materialType: String?

            public var modifiedTime: String?

            public var size: Int64?

            public var snapshots: GetEditingProjectMaterialsResponseBody.MaterialList.Material.Snapshots?

            public var source: String?

            public var spriteConfig: String?

            public var sprites: GetEditingProjectMaterialsResponseBody.MaterialList.Material.Sprites?

            public var status: String?

            public var tags: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
                try self.sprites?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.materialType != nil {
                    map["MaterialType"] = self.materialType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.spriteConfig != nil {
                    map["SpriteConfig"] = self.spriteConfig!
                }
                if self.sprites != nil {
                    map["Sprites"] = self.sprites?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int32
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MaterialId") && dict["MaterialId"] != nil {
                    self.materialId = dict["MaterialId"] as! String
                }
                if dict.keys.contains("MaterialType") && dict["MaterialType"] != nil {
                    self.materialType = dict["MaterialType"] as! String
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material.Snapshots()
                    model.fromMap(dict["Snapshots"] as! [String: Any])
                    self.snapshots = model
                }
                if dict.keys.contains("Source") && dict["Source"] != nil {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SpriteConfig") && dict["SpriteConfig"] != nil {
                    self.spriteConfig = dict["SpriteConfig"] as! String
                }
                if dict.keys.contains("Sprites") && dict["Sprites"] != nil {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material.Sprites()
                    model.fromMap(dict["Sprites"] as! [String: Any])
                    self.sprites = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var material: [GetEditingProjectMaterialsResponseBody.MaterialList.Material]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.material != nil {
                var tmp : [Any] = []
                for k in self.material! {
                    tmp.append(k.toMap())
                }
                map["Material"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Material") && dict["Material"] != nil {
                var tmp : [GetEditingProjectMaterialsResponseBody.MaterialList.Material] = []
                for v in dict["Material"] as! [Any] {
                    var model = GetEditingProjectMaterialsResponseBody.MaterialList.Material()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.material = tmp
            }
        }
    }
    public var materialList: GetEditingProjectMaterialsResponseBody.MaterialList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.materialList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialList != nil {
            map["MaterialList"] = self.materialList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialList") && dict["MaterialList"] != nil {
            var model = GetEditingProjectMaterialsResponseBody.MaterialList()
            model.fromMap(dict["MaterialList"] as! [String: Any])
            self.materialList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageInfoRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var imageId: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetImageInfoResponseBody : Tea.TeaModel {
    public class ImageInfo : Tea.TeaModel {
        public class Mezzanine : Tea.TeaModel {
            public var fileSize: String?

            public var fileURL: String?

            public var height: Int32?

            public var originalFileName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.fileURL != nil {
                    map["FileURL"] = self.fileURL!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.originalFileName != nil {
                    map["OriginalFileName"] = self.originalFileName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                    self.fileURL = dict["FileURL"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("OriginalFileName") && dict["OriginalFileName"] != nil {
                    self.originalFileName = dict["OriginalFileName"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var creationTime: String?

        public var description_: String?

        public var imageId: String?

        public var imageType: String?

        public var mezzanine: GetImageInfoResponseBody.ImageInfo.Mezzanine?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mezzanine?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageType != nil {
                map["ImageType"] = self.imageType!
            }
            if self.mezzanine != nil {
                map["Mezzanine"] = self.mezzanine?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageType") && dict["ImageType"] != nil {
                self.imageType = dict["ImageType"] as! String
            }
            if dict.keys.contains("Mezzanine") && dict["Mezzanine"] != nil {
                var model = GetImageInfoResponseBody.ImageInfo.Mezzanine()
                model.fromMap(dict["Mezzanine"] as! [String: Any])
                self.mezzanine = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("URL") && dict["URL"] != nil {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var imageInfo: GetImageInfoResponseBody.ImageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfo != nil {
            map["ImageInfo"] = self.imageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfo") && dict["ImageInfo"] != nil {
            var model = GetImageInfoResponseBody.ImageInfo()
            model.fromMap(dict["ImageInfo"] as! [String: Any])
            self.imageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageInfosRequest : Tea.TeaModel {
    public var authTimeout: Int64?

    public var imageIds: String?

    public var outputType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.imageIds != nil {
            map["ImageIds"] = self.imageIds!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("ImageIds") && dict["ImageIds"] != nil {
            self.imageIds = dict["ImageIds"] as! String
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
    }
}

public class GetImageInfosResponseBody : Tea.TeaModel {
    public class ImageInfo : Tea.TeaModel {
        public class Mezzanine : Tea.TeaModel {
            public var fileSize: String?

            public var fileURL: String?

            public var height: Int32?

            public var originalFileName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.fileURL != nil {
                    map["FileURL"] = self.fileURL!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.originalFileName != nil {
                    map["OriginalFileName"] = self.originalFileName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                    self.fileURL = dict["FileURL"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("OriginalFileName") && dict["OriginalFileName"] != nil {
                    self.originalFileName = dict["OriginalFileName"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var creationTime: String?

        public var description_: String?

        public var imageId: String?

        public var imageType: String?

        public var mezzanine: GetImageInfosResponseBody.ImageInfo.Mezzanine?

        public var status: String?

        public var storageLocation: String?

        public var tags: String?

        public var title: String?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mezzanine?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageType != nil {
                map["ImageType"] = self.imageType!
            }
            if self.mezzanine != nil {
                map["Mezzanine"] = self.mezzanine?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageType") && dict["ImageType"] != nil {
                self.imageType = dict["ImageType"] as! String
            }
            if dict.keys.contains("Mezzanine") && dict["Mezzanine"] != nil {
                var model = GetImageInfosResponseBody.ImageInfo.Mezzanine()
                model.fromMap(dict["Mezzanine"] as! [String: Any])
                self.mezzanine = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("URL") && dict["URL"] != nil {
                self.URL = dict["URL"] as! String
            }
        }
    }
    public var imageInfo: [GetImageInfosResponseBody.ImageInfo]?

    public var nonExistImageIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfo != nil {
            var tmp : [Any] = []
            for k in self.imageInfo! {
                tmp.append(k.toMap())
            }
            map["ImageInfo"] = tmp
        }
        if self.nonExistImageIds != nil {
            map["NonExistImageIds"] = self.nonExistImageIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfo") && dict["ImageInfo"] != nil {
            var tmp : [GetImageInfosResponseBody.ImageInfo] = []
            for v in dict["ImageInfo"] as! [Any] {
                var model = GetImageInfosResponseBody.ImageInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInfo = tmp
        }
        if dict.keys.contains("NonExistImageIds") && dict["NonExistImageIds"] != nil {
            self.nonExistImageIds = dict["NonExistImageIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditAudioResultDetailRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var pageNo: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetMediaAuditAudioResultDetailResponseBody : Tea.TeaModel {
    public class MediaAuditAudioResultDetail : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var endTime: Int64?

            public var label: String?

            public var startTime: Int64?

            public var text: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Text") && dict["Text"] != nil {
                    self.text = dict["Text"] as! String
                }
            }
        }
        public var list: [GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List]?

        public var pageTotal: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageTotal != nil {
                map["PageTotal"] = self.pageTotal!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageTotal") && dict["PageTotal"] != nil {
                self.pageTotal = dict["PageTotal"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var mediaAuditAudioResultDetail: GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditAudioResultDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditAudioResultDetail != nil {
            map["MediaAuditAudioResultDetail"] = self.mediaAuditAudioResultDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditAudioResultDetail") && dict["MediaAuditAudioResultDetail"] != nil {
            var model = GetMediaAuditAudioResultDetailResponseBody.MediaAuditAudioResultDetail()
            model.fromMap(dict["MediaAuditAudioResultDetail"] as! [String: Any])
            self.mediaAuditAudioResultDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditAudioResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditAudioResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaAuditAudioResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetMediaAuditResultResponseBody : Tea.TeaModel {
    public class MediaAuditResult : Tea.TeaModel {
        public class AudioResult : Tea.TeaModel {
            public var label: String?

            public var scene: String?

            public var score: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class ImageResult : Tea.TeaModel {
            public class Result : Tea.TeaModel {
                public var label: String?

                public var scene: String?

                public var score: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.score != nil {
                        map["Score"] = self.score!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Scene") && dict["Scene"] != nil {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Score") && dict["Score"] != nil {
                        self.score = dict["Score"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public var label: String?

            public var result: [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result]?

            public var suggestion: String?

            public var type: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.result != nil {
                    var tmp : [Any] = []
                    for k in self.result! {
                        tmp.append(k.toMap())
                    }
                    map["Result"] = tmp
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Result") && dict["Result"] != nil {
                    var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result] = []
                    for v in dict["Result"] as! [Any] {
                        var model = GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult.Result()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.result = tmp
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public class TextResult : Tea.TeaModel {
            public var content: String?

            public var label: String?

            public var scene: String?

            public var score: String?

            public var suggestion: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Scene") && dict["Scene"] != nil {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class VideoResult : Tea.TeaModel {
            public class AdResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") && dict["Count"] != nil {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") && dict["Url"] != nil {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") && dict["TopList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class LiveResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") && dict["Count"] != nil {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") && dict["Url"] != nil {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") && dict["TopList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class LogoResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") && dict["Count"] != nil {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") && dict["Url"] != nil {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") && dict["TopList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class PornResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") && dict["Count"] != nil {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") && dict["Url"] != nil {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") && dict["TopList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public class TerrorismResult : Tea.TeaModel {
                public class CounterList : Tea.TeaModel {
                    public var count: Int32?

                    public var label: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") && dict["Count"] != nil {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                    }
                }
                public class TopList : Tea.TeaModel {
                    public var label: String?

                    public var score: String?

                    public var timestamp: String?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.url != nil {
                            map["Url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") && dict["Label"] != nil {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! String
                        }
                        if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                        if dict.keys.contains("Url") && dict["Url"] != nil {
                            self.url = dict["Url"] as! String
                        }
                    }
                }
                public var averageScore: String?

                public var counterList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList]?

                public var label: String?

                public var maxScore: String?

                public var suggestion: String?

                public var topList: [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageScore != nil {
                        map["AverageScore"] = self.averageScore!
                    }
                    if self.counterList != nil {
                        var tmp : [Any] = []
                        for k in self.counterList! {
                            tmp.append(k.toMap())
                        }
                        map["CounterList"] = tmp
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.maxScore != nil {
                        map["MaxScore"] = self.maxScore!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.topList != nil {
                        var tmp : [Any] = []
                        for k in self.topList! {
                            tmp.append(k.toMap())
                        }
                        map["TopList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageScore") && dict["AverageScore"] != nil {
                        self.averageScore = dict["AverageScore"] as! String
                    }
                    if dict.keys.contains("CounterList") && dict["CounterList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList] = []
                        for v in dict["CounterList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.CounterList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.counterList = tmp
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("MaxScore") && dict["MaxScore"] != nil {
                        self.maxScore = dict["MaxScore"] as! String
                    }
                    if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("TopList") && dict["TopList"] != nil {
                        var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList] = []
                        for v in dict["TopList"] as! [Any] {
                            var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult.TopList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.topList = tmp
                    }
                }
            }
            public var adResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult?

            public var label: String?

            public var liveResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult?

            public var logoResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult?

            public var pornResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult?

            public var suggestion: String?

            public var terrorismResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.adResult?.validate()
                try self.liveResult?.validate()
                try self.logoResult?.validate()
                try self.pornResult?.validate()
                try self.terrorismResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adResult != nil {
                    map["AdResult"] = self.adResult?.toMap()
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.liveResult != nil {
                    map["LiveResult"] = self.liveResult?.toMap()
                }
                if self.logoResult != nil {
                    map["LogoResult"] = self.logoResult?.toMap()
                }
                if self.pornResult != nil {
                    map["PornResult"] = self.pornResult?.toMap()
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.terrorismResult != nil {
                    map["TerrorismResult"] = self.terrorismResult?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdResult") && dict["AdResult"] != nil {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.AdResult()
                    model.fromMap(dict["AdResult"] as! [String: Any])
                    self.adResult = model
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("LiveResult") && dict["LiveResult"] != nil {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LiveResult()
                    model.fromMap(dict["LiveResult"] as! [String: Any])
                    self.liveResult = model
                }
                if dict.keys.contains("LogoResult") && dict["LogoResult"] != nil {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.LogoResult()
                    model.fromMap(dict["LogoResult"] as! [String: Any])
                    self.logoResult = model
                }
                if dict.keys.contains("PornResult") && dict["PornResult"] != nil {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.PornResult()
                    model.fromMap(dict["PornResult"] as! [String: Any])
                    self.pornResult = model
                }
                if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TerrorismResult") && dict["TerrorismResult"] != nil {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult.TerrorismResult()
                    model.fromMap(dict["TerrorismResult"] as! [String: Any])
                    self.terrorismResult = model
                }
            }
        }
        public var abnormalModules: String?

        public var audioResult: [GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult]?

        public var imageResult: [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult]?

        public var label: String?

        public var suggestion: String?

        public var textResult: [GetMediaAuditResultResponseBody.MediaAuditResult.TextResult]?

        public var videoResult: GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.videoResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalModules != nil {
                map["AbnormalModules"] = self.abnormalModules!
            }
            if self.audioResult != nil {
                var tmp : [Any] = []
                for k in self.audioResult! {
                    tmp.append(k.toMap())
                }
                map["AudioResult"] = tmp
            }
            if self.imageResult != nil {
                var tmp : [Any] = []
                for k in self.imageResult! {
                    tmp.append(k.toMap())
                }
                map["ImageResult"] = tmp
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.textResult != nil {
                var tmp : [Any] = []
                for k in self.textResult! {
                    tmp.append(k.toMap())
                }
                map["TextResult"] = tmp
            }
            if self.videoResult != nil {
                map["VideoResult"] = self.videoResult?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalModules") && dict["AbnormalModules"] != nil {
                self.abnormalModules = dict["AbnormalModules"] as! String
            }
            if dict.keys.contains("AudioResult") && dict["AudioResult"] != nil {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult] = []
                for v in dict["AudioResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.AudioResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioResult = tmp
            }
            if dict.keys.contains("ImageResult") && dict["ImageResult"] != nil {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult] = []
                for v in dict["ImageResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.ImageResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageResult = tmp
            }
            if dict.keys.contains("Label") && dict["Label"] != nil {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("Suggestion") && dict["Suggestion"] != nil {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TextResult") && dict["TextResult"] != nil {
                var tmp : [GetMediaAuditResultResponseBody.MediaAuditResult.TextResult] = []
                for v in dict["TextResult"] as! [Any] {
                    var model = GetMediaAuditResultResponseBody.MediaAuditResult.TextResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.textResult = tmp
            }
            if dict.keys.contains("VideoResult") && dict["VideoResult"] != nil {
                var model = GetMediaAuditResultResponseBody.MediaAuditResult.VideoResult()
                model.fromMap(dict["VideoResult"] as! [String: Any])
                self.videoResult = model
            }
        }
    }
    public var mediaAuditResult: GetMediaAuditResultResponseBody.MediaAuditResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResult != nil {
            map["MediaAuditResult"] = self.mediaAuditResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResult") && dict["MediaAuditResult"] != nil {
            var model = GetMediaAuditResultResponseBody.MediaAuditResult()
            model.fromMap(dict["MediaAuditResult"] as! [String: Any])
            self.mediaAuditResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaAuditResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultDetailRequest : Tea.TeaModel {
    public var mediaId: String?

    public var pageNo: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
    }
}

public class GetMediaAuditResultDetailResponseBody : Tea.TeaModel {
    public class MediaAuditResultDetail : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var adLabel: String?

            public var adScore: String?

            public var liveLabel: String?

            public var liveScore: String?

            public var logoLabel: String?

            public var logoScore: String?

            public var pornLabel: String?

            public var pornScore: String?

            public var terrorismLabel: String?

            public var terrorismScore: String?

            public var timestamp: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adLabel != nil {
                    map["AdLabel"] = self.adLabel!
                }
                if self.adScore != nil {
                    map["AdScore"] = self.adScore!
                }
                if self.liveLabel != nil {
                    map["LiveLabel"] = self.liveLabel!
                }
                if self.liveScore != nil {
                    map["LiveScore"] = self.liveScore!
                }
                if self.logoLabel != nil {
                    map["LogoLabel"] = self.logoLabel!
                }
                if self.logoScore != nil {
                    map["LogoScore"] = self.logoScore!
                }
                if self.pornLabel != nil {
                    map["PornLabel"] = self.pornLabel!
                }
                if self.pornScore != nil {
                    map["PornScore"] = self.pornScore!
                }
                if self.terrorismLabel != nil {
                    map["TerrorismLabel"] = self.terrorismLabel!
                }
                if self.terrorismScore != nil {
                    map["TerrorismScore"] = self.terrorismScore!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdLabel") && dict["AdLabel"] != nil {
                    self.adLabel = dict["AdLabel"] as! String
                }
                if dict.keys.contains("AdScore") && dict["AdScore"] != nil {
                    self.adScore = dict["AdScore"] as! String
                }
                if dict.keys.contains("LiveLabel") && dict["LiveLabel"] != nil {
                    self.liveLabel = dict["LiveLabel"] as! String
                }
                if dict.keys.contains("LiveScore") && dict["LiveScore"] != nil {
                    self.liveScore = dict["LiveScore"] as! String
                }
                if dict.keys.contains("LogoLabel") && dict["LogoLabel"] != nil {
                    self.logoLabel = dict["LogoLabel"] as! String
                }
                if dict.keys.contains("LogoScore") && dict["LogoScore"] != nil {
                    self.logoScore = dict["LogoScore"] as! String
                }
                if dict.keys.contains("PornLabel") && dict["PornLabel"] != nil {
                    self.pornLabel = dict["PornLabel"] as! String
                }
                if dict.keys.contains("PornScore") && dict["PornScore"] != nil {
                    self.pornScore = dict["PornScore"] as! String
                }
                if dict.keys.contains("TerrorismLabel") && dict["TerrorismLabel"] != nil {
                    self.terrorismLabel = dict["TerrorismLabel"] as! String
                }
                if dict.keys.contains("TerrorismScore") && dict["TerrorismScore"] != nil {
                    self.terrorismScore = dict["TerrorismScore"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var list: [GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List]?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var mediaAuditResultDetail: GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResultDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResultDetail != nil {
            map["MediaAuditResultDetail"] = self.mediaAuditResultDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResultDetail") && dict["MediaAuditResultDetail"] != nil {
            var model = GetMediaAuditResultDetailResponseBody.MediaAuditResultDetail()
            model.fromMap(dict["MediaAuditResultDetail"] as! [String: Any])
            self.mediaAuditResultDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaAuditResultDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaAuditResultTimelineRequest : Tea.TeaModel {
    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class GetMediaAuditResultTimelineResponseBody : Tea.TeaModel {
    public class MediaAuditResultTimeline : Tea.TeaModel {
        public class Ad : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Live : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Logo : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Porn : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public class Terrorism : Tea.TeaModel {
            public var label: String?

            public var score: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var ad: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad]?

        public var live: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live]?

        public var logo: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo]?

        public var porn: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn]?

        public var terrorism: [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ad != nil {
                var tmp : [Any] = []
                for k in self.ad! {
                    tmp.append(k.toMap())
                }
                map["Ad"] = tmp
            }
            if self.live != nil {
                var tmp : [Any] = []
                for k in self.live! {
                    tmp.append(k.toMap())
                }
                map["Live"] = tmp
            }
            if self.logo != nil {
                var tmp : [Any] = []
                for k in self.logo! {
                    tmp.append(k.toMap())
                }
                map["Logo"] = tmp
            }
            if self.porn != nil {
                var tmp : [Any] = []
                for k in self.porn! {
                    tmp.append(k.toMap())
                }
                map["Porn"] = tmp
            }
            if self.terrorism != nil {
                var tmp : [Any] = []
                for k in self.terrorism! {
                    tmp.append(k.toMap())
                }
                map["Terrorism"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ad") && dict["Ad"] != nil {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad] = []
                for v in dict["Ad"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Ad()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ad = tmp
            }
            if dict.keys.contains("Live") && dict["Live"] != nil {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live] = []
                for v in dict["Live"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Live()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.live = tmp
            }
            if dict.keys.contains("Logo") && dict["Logo"] != nil {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo] = []
                for v in dict["Logo"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Logo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logo = tmp
            }
            if dict.keys.contains("Porn") && dict["Porn"] != nil {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn] = []
                for v in dict["Porn"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Porn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.porn = tmp
            }
            if dict.keys.contains("Terrorism") && dict["Terrorism"] != nil {
                var tmp : [GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism] = []
                for v in dict["Terrorism"] as! [Any] {
                    var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline.Terrorism()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.terrorism = tmp
            }
        }
    }
    public var mediaAuditResultTimeline: GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaAuditResultTimeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditResultTimeline != nil {
            map["MediaAuditResultTimeline"] = self.mediaAuditResultTimeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditResultTimeline") && dict["MediaAuditResultTimeline"] != nil {
            var model = GetMediaAuditResultTimelineResponseBody.MediaAuditResultTimeline()
            model.fromMap(dict["MediaAuditResultTimeline"] as! [String: Any])
            self.mediaAuditResultTimeline = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaAuditResultTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaAuditResultTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaAuditResultTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaDNAResultRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class GetMediaDNAResultResponseBody : Tea.TeaModel {
    public class DNAResult : Tea.TeaModel {
        public class VideoDNA : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public class Duplication : Tea.TeaModel {
                    public var duration: String?

                    public var start: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! String
                        }
                    }
                }
                public class Input : Tea.TeaModel {
                    public var duration: String?

                    public var start: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.start != nil {
                            map["Start"] = self.start!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") && dict["Duration"] != nil {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Start") && dict["Start"] != nil {
                            self.start = dict["Start"] as! String
                        }
                    }
                }
                public var duplication: GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Duplication?

                public var input: GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Input?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.duplication?.validate()
                    try self.input?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duplication != nil {
                        map["Duplication"] = self.duplication?.toMap()
                    }
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duplication") && dict["Duplication"] != nil {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Duplication()
                        model.fromMap(dict["Duplication"] as! [String: Any])
                        self.duplication = model
                    }
                    if dict.keys.contains("Input") && dict["Input"] != nil {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                }
            }
            public var detail: [GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail]?

            public var primaryKey: String?

            public var similarity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.primaryKey != nil {
                    map["PrimaryKey"] = self.primaryKey!
                }
                if self.similarity != nil {
                    map["Similarity"] = self.similarity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") && dict["Detail"] != nil {
                    var tmp : [GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("PrimaryKey") && dict["PrimaryKey"] != nil {
                    self.primaryKey = dict["PrimaryKey"] as! String
                }
                if dict.keys.contains("Similarity") && dict["Similarity"] != nil {
                    self.similarity = dict["Similarity"] as! String
                }
            }
        }
        public var videoDNA: [GetMediaDNAResultResponseBody.DNAResult.VideoDNA]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoDNA != nil {
                var tmp : [Any] = []
                for k in self.videoDNA! {
                    tmp.append(k.toMap())
                }
                map["VideoDNA"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VideoDNA") && dict["VideoDNA"] != nil {
                var tmp : [GetMediaDNAResultResponseBody.DNAResult.VideoDNA] = []
                for v in dict["VideoDNA"] as! [Any] {
                    var model = GetMediaDNAResultResponseBody.DNAResult.VideoDNA()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoDNA = tmp
            }
        }
    }
    public var DNAResult: GetMediaDNAResultResponseBody.DNAResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DNAResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DNAResult != nil {
            map["DNAResult"] = self.DNAResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DNAResult") && dict["DNAResult"] != nil {
            var model = GetMediaDNAResultResponseBody.DNAResult()
            model.fromMap(dict["DNAResult"] as! [String: Any])
            self.DNAResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaDNAResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaDNAResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaDNAResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMediaRefreshJobsRequest : Tea.TeaModel {
    public var mediaId: String?

    public var mediaRefreshJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaRefreshJobId != nil {
            map["MediaRefreshJobId"] = self.mediaRefreshJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaRefreshJobId") && dict["MediaRefreshJobId"] != nil {
            self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
        }
    }
}

public class GetMediaRefreshJobsResponseBody : Tea.TeaModel {
    public class MediaRefreshJobs : Tea.TeaModel {
        public var errorCode: String?

        public var errorMessage: String?

        public var filterPolicy: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var mediaId: String?

        public var mediaRefreshJobId: String?

        public var status: String?

        public var successPlayUrls: String?

        public var taskIds: String?

        public var taskType: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.filterPolicy != nil {
                map["FilterPolicy"] = self.filterPolicy!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaRefreshJobId != nil {
                map["MediaRefreshJobId"] = self.mediaRefreshJobId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.successPlayUrls != nil {
                map["SuccessPlayUrls"] = self.successPlayUrls!
            }
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FilterPolicy") && dict["FilterPolicy"] != nil {
                self.filterPolicy = dict["FilterPolicy"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaRefreshJobId") && dict["MediaRefreshJobId"] != nil {
                self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SuccessPlayUrls") && dict["SuccessPlayUrls"] != nil {
                self.successPlayUrls = dict["SuccessPlayUrls"] as! String
            }
            if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
                self.taskIds = dict["TaskIds"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaRefreshJobs: [GetMediaRefreshJobsResponseBody.MediaRefreshJobs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaRefreshJobs != nil {
            var tmp : [Any] = []
            for k in self.mediaRefreshJobs! {
                tmp.append(k.toMap())
            }
            map["MediaRefreshJobs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaRefreshJobs") && dict["MediaRefreshJobs"] != nil {
            var tmp : [GetMediaRefreshJobsResponseBody.MediaRefreshJobs] = []
            for v in dict["MediaRefreshJobs"] as! [Any] {
                var model = GetMediaRefreshJobsResponseBody.MediaRefreshJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaRefreshJobs = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMediaRefreshJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMediaRefreshJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMediaRefreshJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class GetMessageCallbackResponseBody : Tea.TeaModel {
    public class MessageCallback : Tea.TeaModel {
        public var appId: String?

        public var authKey: String?

        public var authSwitch: String?

        public var callbackType: String?

        public var callbackURL: String?

        public var eventTypeList: String?

        public var mnsEndpoint: String?

        public var mnsQueueName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.authKey != nil {
                map["AuthKey"] = self.authKey!
            }
            if self.authSwitch != nil {
                map["AuthSwitch"] = self.authSwitch!
            }
            if self.callbackType != nil {
                map["CallbackType"] = self.callbackType!
            }
            if self.callbackURL != nil {
                map["CallbackURL"] = self.callbackURL!
            }
            if self.eventTypeList != nil {
                map["EventTypeList"] = self.eventTypeList!
            }
            if self.mnsEndpoint != nil {
                map["MnsEndpoint"] = self.mnsEndpoint!
            }
            if self.mnsQueueName != nil {
                map["MnsQueueName"] = self.mnsQueueName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AuthKey") && dict["AuthKey"] != nil {
                self.authKey = dict["AuthKey"] as! String
            }
            if dict.keys.contains("AuthSwitch") && dict["AuthSwitch"] != nil {
                self.authSwitch = dict["AuthSwitch"] as! String
            }
            if dict.keys.contains("CallbackType") && dict["CallbackType"] != nil {
                self.callbackType = dict["CallbackType"] as! String
            }
            if dict.keys.contains("CallbackURL") && dict["CallbackURL"] != nil {
                self.callbackURL = dict["CallbackURL"] as! String
            }
            if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
                self.eventTypeList = dict["EventTypeList"] as! String
            }
            if dict.keys.contains("MnsEndpoint") && dict["MnsEndpoint"] != nil {
                self.mnsEndpoint = dict["MnsEndpoint"] as! String
            }
            if dict.keys.contains("MnsQueueName") && dict["MnsQueueName"] != nil {
                self.mnsQueueName = dict["MnsQueueName"] as! String
            }
        }
    }
    public var messageCallback: GetMessageCallbackResponseBody.MessageCallback?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.messageCallback?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageCallback != nil {
            map["MessageCallback"] = self.messageCallback?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MessageCallback") && dict["MessageCallback"] != nil {
            var model = GetMessageCallbackResponseBody.MessageCallback()
            model.fromMap(dict["MessageCallback"] as! [String: Any])
            self.messageCallback = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMezzanineInfoRequest : Tea.TeaModel {
    public var additionType: String?

    public var authTimeout: Int64?

    public var outputType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") && dict["AdditionType"] != nil {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetMezzanineInfoResponseBody : Tea.TeaModel {
    public class Mezzanine : Tea.TeaModel {
        public class AudioStreamList : Tea.TeaModel {
            public var bitrate: String?

            public var channelLayout: String?

            public var channels: String?

            public var codecLongName: String?

            public var codecName: String?

            public var codecTag: String?

            public var codecTagString: String?

            public var codecTimeBase: String?

            public var duration: String?

            public var index: String?

            public var lang: String?

            public var numFrames: String?

            public var sampleFmt: String?

            public var sampleRate: String?

            public var startTime: String?

            public var timebase: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channelLayout != nil {
                    map["ChannelLayout"] = self.channelLayout!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codecLongName != nil {
                    map["CodecLongName"] = self.codecLongName!
                }
                if self.codecName != nil {
                    map["CodecName"] = self.codecName!
                }
                if self.codecTag != nil {
                    map["CodecTag"] = self.codecTag!
                }
                if self.codecTagString != nil {
                    map["CodecTagString"] = self.codecTagString!
                }
                if self.codecTimeBase != nil {
                    map["CodecTimeBase"] = self.codecTimeBase!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.lang != nil {
                    map["Lang"] = self.lang!
                }
                if self.numFrames != nil {
                    map["NumFrames"] = self.numFrames!
                }
                if self.sampleFmt != nil {
                    map["SampleFmt"] = self.sampleFmt!
                }
                if self.sampleRate != nil {
                    map["SampleRate"] = self.sampleRate!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.timebase != nil {
                    map["Timebase"] = self.timebase!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("ChannelLayout") && dict["ChannelLayout"] != nil {
                    self.channelLayout = dict["ChannelLayout"] as! String
                }
                if dict.keys.contains("Channels") && dict["Channels"] != nil {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                    self.codecLongName = dict["CodecLongName"] as! String
                }
                if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                    self.codecName = dict["CodecName"] as! String
                }
                if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                    self.codecTag = dict["CodecTag"] as! String
                }
                if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                    self.codecTagString = dict["CodecTagString"] as! String
                }
                if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Lang") && dict["Lang"] != nil {
                    self.lang = dict["Lang"] as! String
                }
                if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                    self.numFrames = dict["NumFrames"] as! String
                }
                if dict.keys.contains("SampleFmt") && dict["SampleFmt"] != nil {
                    self.sampleFmt = dict["SampleFmt"] as! String
                }
                if dict.keys.contains("SampleRate") && dict["SampleRate"] != nil {
                    self.sampleRate = dict["SampleRate"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                    self.timebase = dict["Timebase"] as! String
                }
            }
        }
        public class VideoStreamList : Tea.TeaModel {
            public var avgFPS: String?

            public var bitrate: String?

            public var codecLongName: String?

            public var codecName: String?

            public var codecTag: String?

            public var codecTagString: String?

            public var codecTimeBase: String?

            public var dar: String?

            public var duration: String?

            public var fps: String?

            public var HDRType: String?

            public var hasBFrames: String?

            public var height: String?

            public var index: String?

            public var lang: String?

            public var level: String?

            public var numFrames: String?

            public var pixFmt: String?

            public var profile: String?

            public var rotate: String?

            public var sar: String?

            public var startTime: String?

            public var timebase: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgFPS != nil {
                    map["AvgFPS"] = self.avgFPS!
                }
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codecLongName != nil {
                    map["CodecLongName"] = self.codecLongName!
                }
                if self.codecName != nil {
                    map["CodecName"] = self.codecName!
                }
                if self.codecTag != nil {
                    map["CodecTag"] = self.codecTag!
                }
                if self.codecTagString != nil {
                    map["CodecTagString"] = self.codecTagString!
                }
                if self.codecTimeBase != nil {
                    map["CodecTimeBase"] = self.codecTimeBase!
                }
                if self.dar != nil {
                    map["Dar"] = self.dar!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.HDRType != nil {
                    map["HDRType"] = self.HDRType!
                }
                if self.hasBFrames != nil {
                    map["HasBFrames"] = self.hasBFrames!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.lang != nil {
                    map["Lang"] = self.lang!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.numFrames != nil {
                    map["NumFrames"] = self.numFrames!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.rotate != nil {
                    map["Rotate"] = self.rotate!
                }
                if self.sar != nil {
                    map["Sar"] = self.sar!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.timebase != nil {
                    map["Timebase"] = self.timebase!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgFPS") && dict["AvgFPS"] != nil {
                    self.avgFPS = dict["AvgFPS"] as! String
                }
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CodecLongName") && dict["CodecLongName"] != nil {
                    self.codecLongName = dict["CodecLongName"] as! String
                }
                if dict.keys.contains("CodecName") && dict["CodecName"] != nil {
                    self.codecName = dict["CodecName"] as! String
                }
                if dict.keys.contains("CodecTag") && dict["CodecTag"] != nil {
                    self.codecTag = dict["CodecTag"] as! String
                }
                if dict.keys.contains("CodecTagString") && dict["CodecTagString"] != nil {
                    self.codecTagString = dict["CodecTagString"] as! String
                }
                if dict.keys.contains("CodecTimeBase") && dict["CodecTimeBase"] != nil {
                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                }
                if dict.keys.contains("Dar") && dict["Dar"] != nil {
                    self.dar = dict["Dar"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
                    self.HDRType = dict["HDRType"] as! String
                }
                if dict.keys.contains("HasBFrames") && dict["HasBFrames"] != nil {
                    self.hasBFrames = dict["HasBFrames"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Index") && dict["Index"] != nil {
                    self.index = dict["Index"] as! String
                }
                if dict.keys.contains("Lang") && dict["Lang"] != nil {
                    self.lang = dict["Lang"] as! String
                }
                if dict.keys.contains("Level") && dict["Level"] != nil {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("NumFrames") && dict["NumFrames"] != nil {
                    self.numFrames = dict["NumFrames"] as! String
                }
                if dict.keys.contains("PixFmt") && dict["PixFmt"] != nil {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Profile") && dict["Profile"] != nil {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                    self.rotate = dict["Rotate"] as! String
                }
                if dict.keys.contains("Sar") && dict["Sar"] != nil {
                    self.sar = dict["Sar"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Timebase") && dict["Timebase"] != nil {
                    self.timebase = dict["Timebase"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audioStreamList: [GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList]?

        public var bitrate: String?

        public var creationTime: String?

        public var duration: String?

        public var fileName: String?

        public var fileURL: String?

        public var fps: String?

        public var height: Int64?

        public var outputType: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var status: String?

        public var storageClass: String?

        public var videoId: String?

        public var videoStreamList: [GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList]?

        public var width: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioStreamList != nil {
                var tmp : [Any] = []
                for k in self.audioStreamList! {
                    tmp.append(k.toMap())
                }
                map["AudioStreamList"] = tmp
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.outputType != nil {
                map["OutputType"] = self.outputType!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            if self.videoStreamList != nil {
                var tmp : [Any] = []
                for k in self.videoStreamList! {
                    tmp.append(k.toMap())
                }
                map["VideoStreamList"] = tmp
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioStreamList") && dict["AudioStreamList"] != nil {
                var tmp : [GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList] = []
                for v in dict["AudioStreamList"] as! [Any] {
                    var model = GetMezzanineInfoResponseBody.Mezzanine.AudioStreamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.audioStreamList = tmp
            }
            if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Fps") && dict["Fps"] != nil {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") && dict["Height"] != nil {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
                self.outputType = dict["OutputType"] as! String
            }
            if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
            if dict.keys.contains("VideoStreamList") && dict["VideoStreamList"] != nil {
                var tmp : [GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList] = []
                for v in dict["VideoStreamList"] as! [Any] {
                    var model = GetMezzanineInfoResponseBody.Mezzanine.VideoStreamList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.videoStreamList = tmp
            }
            if dict.keys.contains("Width") && dict["Width"] != nil {
                self.width = dict["Width"] as! Int64
            }
        }
    }
    public var mezzanine: GetMezzanineInfoResponseBody.Mezzanine?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mezzanine?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mezzanine != nil {
            map["Mezzanine"] = self.mezzanine?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mezzanine") && dict["Mezzanine"] != nil {
            var model = GetMezzanineInfoResponseBody.Mezzanine()
            model.fromMap(dict["Mezzanine"] as! [String: Any])
            self.mezzanine = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMezzanineInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMezzanineInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMezzanineInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPlayInfoRequest : Tea.TeaModel {
    public var additionType: String?

    public var authTimeout: Int64?

    public var definition: String?

    public var digitalWatermarkType: String?

    public var formats: String?

    public var outputType: String?

    public var playConfig: String?

    public var reAuthInfo: String?

    public var resultType: String?

    public var streamType: String?

    public var trace: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionType != nil {
            map["AdditionType"] = self.additionType!
        }
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.digitalWatermarkType != nil {
            map["DigitalWatermarkType"] = self.digitalWatermarkType!
        }
        if self.formats != nil {
            map["Formats"] = self.formats!
        }
        if self.outputType != nil {
            map["OutputType"] = self.outputType!
        }
        if self.playConfig != nil {
            map["PlayConfig"] = self.playConfig!
        }
        if self.reAuthInfo != nil {
            map["ReAuthInfo"] = self.reAuthInfo!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        if self.trace != nil {
            map["Trace"] = self.trace!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionType") && dict["AdditionType"] != nil {
            self.additionType = dict["AdditionType"] as! String
        }
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! Int64
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("DigitalWatermarkType") && dict["DigitalWatermarkType"] != nil {
            self.digitalWatermarkType = dict["DigitalWatermarkType"] as! String
        }
        if dict.keys.contains("Formats") && dict["Formats"] != nil {
            self.formats = dict["Formats"] as! String
        }
        if dict.keys.contains("OutputType") && dict["OutputType"] != nil {
            self.outputType = dict["OutputType"] as! String
        }
        if dict.keys.contains("PlayConfig") && dict["PlayConfig"] != nil {
            self.playConfig = dict["PlayConfig"] as! String
        }
        if dict.keys.contains("ReAuthInfo") && dict["ReAuthInfo"] != nil {
            self.reAuthInfo = dict["ReAuthInfo"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
            self.streamType = dict["StreamType"] as! String
        }
        if dict.keys.contains("Trace") && dict["Trace"] != nil {
            self.trace = dict["Trace"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetPlayInfoResponseBody : Tea.TeaModel {
    public class PlayInfoList : Tea.TeaModel {
        public class PlayInfo : Tea.TeaModel {
            public var bitDepth: Int32?

            public var bitrate: String?

            public var creationTime: String?

            public var definition: String?

            public var duration: String?

            public var encrypt: Int64?

            public var encryptType: String?

            public var format: String?

            public var fps: String?

            public var HDRType: String?

            public var height: Int64?

            public var jobExt: String?

            public var jobId: String?

            public var jobType: Int32?

            public var modificationTime: String?

            public var narrowBandType: String?

            public var playURL: String?

            public var size: Int64?

            public var specification: String?

            public var status: String?

            public var streamType: String?

            public var watermarkId: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitDepth != nil {
                    map["BitDepth"] = self.bitDepth!
                }
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.encrypt != nil {
                    map["Encrypt"] = self.encrypt!
                }
                if self.encryptType != nil {
                    map["EncryptType"] = self.encryptType!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.HDRType != nil {
                    map["HDRType"] = self.HDRType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.jobExt != nil {
                    map["JobExt"] = self.jobExt!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.narrowBandType != nil {
                    map["NarrowBandType"] = self.narrowBandType!
                }
                if self.playURL != nil {
                    map["PlayURL"] = self.playURL!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.specification != nil {
                    map["Specification"] = self.specification!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.watermarkId != nil {
                    map["WatermarkId"] = self.watermarkId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BitDepth") && dict["BitDepth"] != nil {
                    self.bitDepth = dict["BitDepth"] as! Int32
                }
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Definition") && dict["Definition"] != nil {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                    self.encrypt = dict["Encrypt"] as! Int64
                }
                if dict.keys.contains("EncryptType") && dict["EncryptType"] != nil {
                    self.encryptType = dict["EncryptType"] as! String
                }
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
                    self.HDRType = dict["HDRType"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("JobExt") && dict["JobExt"] != nil {
                    self.jobExt = dict["JobExt"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobType") && dict["JobType"] != nil {
                    self.jobType = dict["JobType"] as! Int32
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("NarrowBandType") && dict["NarrowBandType"] != nil {
                    self.narrowBandType = dict["NarrowBandType"] as! String
                }
                if dict.keys.contains("PlayURL") && dict["PlayURL"] != nil {
                    self.playURL = dict["PlayURL"] as! String
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Specification") && dict["Specification"] != nil {
                    self.specification = dict["Specification"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
                    self.streamType = dict["StreamType"] as! String
                }
                if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                    self.watermarkId = dict["WatermarkId"] as! String
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var playInfo: [GetPlayInfoResponseBody.PlayInfoList.PlayInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.playInfo != nil {
                var tmp : [Any] = []
                for k in self.playInfo! {
                    tmp.append(k.toMap())
                }
                map["PlayInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PlayInfo") && dict["PlayInfo"] != nil {
                var tmp : [GetPlayInfoResponseBody.PlayInfoList.PlayInfo] = []
                for v in dict["PlayInfo"] as! [Any] {
                    var model = GetPlayInfoResponseBody.PlayInfoList.PlayInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.playInfo = tmp
            }
        }
    }
    public class VideoBase : Tea.TeaModel {
        public var coverURL: String?

        public var creationTime: String?

        public var danMuURL: String?

        public var duration: String?

        public var mediaType: String?

        public var status: String?

        public var storageClass: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.danMuURL != nil {
                map["DanMuURL"] = self.danMuURL!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DanMuURL") && dict["DanMuURL"] != nil {
                self.danMuURL = dict["DanMuURL"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var playInfoList: GetPlayInfoResponseBody.PlayInfoList?

    public var requestId: String?

    public var videoBase: GetPlayInfoResponseBody.VideoBase?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.playInfoList?.validate()
        try self.videoBase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playInfoList != nil {
            map["PlayInfoList"] = self.playInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoBase != nil {
            map["VideoBase"] = self.videoBase?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayInfoList") && dict["PlayInfoList"] != nil {
            var model = GetPlayInfoResponseBody.PlayInfoList()
            model.fromMap(dict["PlayInfoList"] as! [String: Any])
            self.playInfoList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoBase") && dict["VideoBase"] != nil {
            var model = GetPlayInfoResponseBody.VideoBase()
            model.fromMap(dict["VideoBase"] as! [String: Any])
            self.videoBase = model
        }
    }
}

public class GetPlayInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPlayInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPlayInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeSummaryRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") && dict["VideoIds"] != nil {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class GetTranscodeSummaryResponseBody : Tea.TeaModel {
    public class TranscodeSummaryList : Tea.TeaModel {
        public class TranscodeJobInfoSummaryList : Tea.TeaModel {
            public var bitrate: String?

            public var completeTime: String?

            public var creationTime: String?

            public var duration: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var filesize: Int64?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var transcodeJobStatus: String?

            public var transcodeProgress: Int64?

            public var transcodeTemplateId: String?

            public var watermarkIdList: [String]?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.filesize != nil {
                    map["Filesize"] = self.filesize!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.transcodeJobStatus != nil {
                    map["TranscodeJobStatus"] = self.transcodeJobStatus!
                }
                if self.transcodeProgress != nil {
                    map["TranscodeProgress"] = self.transcodeProgress!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                if self.watermarkIdList != nil {
                    map["WatermarkIdList"] = self.watermarkIdList!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Filesize") && dict["Filesize"] != nil {
                    self.filesize = dict["Filesize"] as! Int64
                }
                if dict.keys.contains("Format") && dict["Format"] != nil {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") && dict["Fps"] != nil {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") && dict["Height"] != nil {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("TranscodeJobStatus") && dict["TranscodeJobStatus"] != nil {
                    self.transcodeJobStatus = dict["TranscodeJobStatus"] as! String
                }
                if dict.keys.contains("TranscodeProgress") && dict["TranscodeProgress"] != nil {
                    self.transcodeProgress = dict["TranscodeProgress"] as! Int64
                }
                if dict.keys.contains("TranscodeTemplateId") && dict["TranscodeTemplateId"] != nil {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
                if dict.keys.contains("WatermarkIdList") && dict["WatermarkIdList"] != nil {
                    self.watermarkIdList = dict["WatermarkIdList"] as! [String]
                }
                if dict.keys.contains("Width") && dict["Width"] != nil {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var completeTime: String?

        public var creationTime: String?

        public var transcodeJobInfoSummaryList: [GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList]?

        public var transcodeStatus: String?

        public var transcodeTemplateGroupId: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.transcodeJobInfoSummaryList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobInfoSummaryList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobInfoSummaryList"] = tmp
            }
            if self.transcodeStatus != nil {
                map["TranscodeStatus"] = self.transcodeStatus!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TranscodeJobInfoSummaryList") && dict["TranscodeJobInfoSummaryList"] != nil {
                var tmp : [GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList] = []
                for v in dict["TranscodeJobInfoSummaryList"] as! [Any] {
                    var model = GetTranscodeSummaryResponseBody.TranscodeSummaryList.TranscodeJobInfoSummaryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobInfoSummaryList = tmp
            }
            if dict.keys.contains("TranscodeStatus") && dict["TranscodeStatus"] != nil {
                self.transcodeStatus = dict["TranscodeStatus"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var transcodeSummaryList: [GetTranscodeSummaryResponseBody.TranscodeSummaryList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeSummaryList != nil {
            var tmp : [Any] = []
            for k in self.transcodeSummaryList! {
                tmp.append(k.toMap())
            }
            map["TranscodeSummaryList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") && dict["NonExistVideoIds"] != nil {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeSummaryList") && dict["TranscodeSummaryList"] != nil {
            var tmp : [GetTranscodeSummaryResponseBody.TranscodeSummaryList] = []
            for v in dict["TranscodeSummaryList"] as! [Any] {
                var model = GetTranscodeSummaryResponseBody.TranscodeSummaryList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeSummaryList = tmp
        }
    }
}

public class GetTranscodeSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTranscodeSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeTaskRequest : Tea.TeaModel {
    public var transcodeTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTaskId != nil {
            map["TranscodeTaskId"] = self.transcodeTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTaskId") && dict["TranscodeTaskId"] != nil {
            self.transcodeTaskId = dict["TranscodeTaskId"] as! String
        }
    }
}

public class GetTranscodeTaskResponseBody : Tea.TeaModel {
    public class TranscodeTask : Tea.TeaModel {
        public class TranscodeJobInfoList : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var audioStreamList: String?

                public var bitrate: String?

                public var duration: String?

                public var encryption: String?

                public var filesize: Int64?

                public var format: String?

                public var fps: String?

                public var height: String?

                public var outputFileUrl: String?

                public var subtitleStreamList: String?

                public var videoStreamList: String?

                public var watermarkIdList: [String]?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamList != nil {
                        map["AudioStreamList"] = self.audioStreamList!
                    }
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption!
                    }
                    if self.filesize != nil {
                        map["Filesize"] = self.filesize!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.outputFileUrl != nil {
                        map["OutputFileUrl"] = self.outputFileUrl!
                    }
                    if self.subtitleStreamList != nil {
                        map["SubtitleStreamList"] = self.subtitleStreamList!
                    }
                    if self.videoStreamList != nil {
                        map["VideoStreamList"] = self.videoStreamList!
                    }
                    if self.watermarkIdList != nil {
                        map["WatermarkIdList"] = self.watermarkIdList!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamList") && dict["AudioStreamList"] != nil {
                        self.audioStreamList = dict["AudioStreamList"] as! String
                    }
                    if dict.keys.contains("Bitrate") && dict["Bitrate"] != nil {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Encryption") && dict["Encryption"] != nil {
                        self.encryption = dict["Encryption"] as! String
                    }
                    if dict.keys.contains("Filesize") && dict["Filesize"] != nil {
                        self.filesize = dict["Filesize"] as! Int64
                    }
                    if dict.keys.contains("Format") && dict["Format"] != nil {
                        self.format = dict["Format"] as! String
                    }
                    if dict.keys.contains("Fps") && dict["Fps"] != nil {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Height") && dict["Height"] != nil {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("OutputFileUrl") && dict["OutputFileUrl"] != nil {
                        self.outputFileUrl = dict["OutputFileUrl"] as! String
                    }
                    if dict.keys.contains("SubtitleStreamList") && dict["SubtitleStreamList"] != nil {
                        self.subtitleStreamList = dict["SubtitleStreamList"] as! String
                    }
                    if dict.keys.contains("VideoStreamList") && dict["VideoStreamList"] != nil {
                        self.videoStreamList = dict["VideoStreamList"] as! String
                    }
                    if dict.keys.contains("WatermarkIdList") && dict["WatermarkIdList"] != nil {
                        self.watermarkIdList = dict["WatermarkIdList"] as! [String]
                    }
                    if dict.keys.contains("Width") && dict["Width"] != nil {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var completeTime: String?

            public var creationTime: String?

            public var definition: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var inputFileUrl: String?

            public var outputFile: GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList.OutputFile?

            public var priority: String?

            public var transcodeJobId: String?

            public var transcodeJobStatus: String?

            public var transcodeProgress: Int64?

            public var transcodeTemplateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.inputFileUrl != nil {
                    map["InputFileUrl"] = self.inputFileUrl!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.transcodeJobId != nil {
                    map["TranscodeJobId"] = self.transcodeJobId!
                }
                if self.transcodeJobStatus != nil {
                    map["TranscodeJobStatus"] = self.transcodeJobStatus!
                }
                if self.transcodeProgress != nil {
                    map["TranscodeProgress"] = self.transcodeProgress!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Definition") && dict["Definition"] != nil {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InputFileUrl") && dict["InputFileUrl"] != nil {
                    self.inputFileUrl = dict["InputFileUrl"] as! String
                }
                if dict.keys.contains("OutputFile") && dict["OutputFile"] != nil {
                    var model = GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("TranscodeJobId") && dict["TranscodeJobId"] != nil {
                    self.transcodeJobId = dict["TranscodeJobId"] as! String
                }
                if dict.keys.contains("TranscodeJobStatus") && dict["TranscodeJobStatus"] != nil {
                    self.transcodeJobStatus = dict["TranscodeJobStatus"] as! String
                }
                if dict.keys.contains("TranscodeProgress") && dict["TranscodeProgress"] != nil {
                    self.transcodeProgress = dict["TranscodeProgress"] as! Int64
                }
                if dict.keys.contains("TranscodeTemplateId") && dict["TranscodeTemplateId"] != nil {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
            }
        }
        public var completeTime: String?

        public var creationTime: String?

        public var taskStatus: String?

        public var transcodeJobInfoList: [GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList]?

        public var transcodeTaskId: String?

        public var transcodeTemplateGroupId: String?

        public var trigger: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.transcodeJobInfoList != nil {
                var tmp : [Any] = []
                for k in self.transcodeJobInfoList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJobInfoList"] = tmp
            }
            if self.transcodeTaskId != nil {
                map["TranscodeTaskId"] = self.transcodeTaskId!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                self.taskStatus = dict["TaskStatus"] as! String
            }
            if dict.keys.contains("TranscodeJobInfoList") && dict["TranscodeJobInfoList"] != nil {
                var tmp : [GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList] = []
                for v in dict["TranscodeJobInfoList"] as! [Any] {
                    var model = GetTranscodeTaskResponseBody.TranscodeTask.TranscodeJobInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJobInfoList = tmp
            }
            if dict.keys.contains("TranscodeTaskId") && dict["TranscodeTaskId"] != nil {
                self.transcodeTaskId = dict["TranscodeTaskId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                self.trigger = dict["Trigger"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTask: GetTranscodeTaskResponseBody.TranscodeTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTask != nil {
            map["TranscodeTask"] = self.transcodeTask?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTask") && dict["TranscodeTask"] != nil {
            var model = GetTranscodeTaskResponseBody.TranscodeTask()
            model.fromMap(dict["TranscodeTask"] as! [String: Any])
            self.transcodeTask = model
        }
    }
}

public class GetTranscodeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTranscodeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class GetTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public class TranscodeTemplateGroup : Tea.TeaModel {
        public class TranscodeTemplateList : Tea.TeaModel {
            public var audio: String?

            public var clip: String?

            public var container: String?

            public var copyrightMark: String?

            public var definition: String?

            public var encryptSetting: String?

            public var muxConfig: String?

            public var packageSetting: String?

            public var rotate: String?

            public var subtitleList: String?

            public var templateName: String?

            public var traceMark: String?

            public var transConfig: String?

            public var transcodeFileRegular: String?

            public var transcodeTemplateId: String?

            public var type: String?

            public var video: String?

            public var watermarkIds: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio!
                }
                if self.clip != nil {
                    map["Clip"] = self.clip!
                }
                if self.container != nil {
                    map["Container"] = self.container!
                }
                if self.copyrightMark != nil {
                    map["CopyrightMark"] = self.copyrightMark!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.encryptSetting != nil {
                    map["EncryptSetting"] = self.encryptSetting!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig!
                }
                if self.packageSetting != nil {
                    map["PackageSetting"] = self.packageSetting!
                }
                if self.rotate != nil {
                    map["Rotate"] = self.rotate!
                }
                if self.subtitleList != nil {
                    map["SubtitleList"] = self.subtitleList!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.traceMark != nil {
                    map["TraceMark"] = self.traceMark!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig!
                }
                if self.transcodeFileRegular != nil {
                    map["TranscodeFileRegular"] = self.transcodeFileRegular!
                }
                if self.transcodeTemplateId != nil {
                    map["TranscodeTemplateId"] = self.transcodeTemplateId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.video != nil {
                    map["Video"] = self.video!
                }
                if self.watermarkIds != nil {
                    map["WatermarkIds"] = self.watermarkIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") && dict["Audio"] != nil {
                    self.audio = dict["Audio"] as! String
                }
                if dict.keys.contains("Clip") && dict["Clip"] != nil {
                    self.clip = dict["Clip"] as! String
                }
                if dict.keys.contains("Container") && dict["Container"] != nil {
                    self.container = dict["Container"] as! String
                }
                if dict.keys.contains("CopyrightMark") && dict["CopyrightMark"] != nil {
                    self.copyrightMark = dict["CopyrightMark"] as! String
                }
                if dict.keys.contains("Definition") && dict["Definition"] != nil {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("EncryptSetting") && dict["EncryptSetting"] != nil {
                    self.encryptSetting = dict["EncryptSetting"] as! String
                }
                if dict.keys.contains("MuxConfig") && dict["MuxConfig"] != nil {
                    self.muxConfig = dict["MuxConfig"] as! String
                }
                if dict.keys.contains("PackageSetting") && dict["PackageSetting"] != nil {
                    self.packageSetting = dict["PackageSetting"] as! String
                }
                if dict.keys.contains("Rotate") && dict["Rotate"] != nil {
                    self.rotate = dict["Rotate"] as! String
                }
                if dict.keys.contains("SubtitleList") && dict["SubtitleList"] != nil {
                    self.subtitleList = dict["SubtitleList"] as! String
                }
                if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("TraceMark") && dict["TraceMark"] != nil {
                    self.traceMark = dict["TraceMark"] as! String
                }
                if dict.keys.contains("TransConfig") && dict["TransConfig"] != nil {
                    self.transConfig = dict["TransConfig"] as! String
                }
                if dict.keys.contains("TranscodeFileRegular") && dict["TranscodeFileRegular"] != nil {
                    self.transcodeFileRegular = dict["TranscodeFileRegular"] as! String
                }
                if dict.keys.contains("TranscodeTemplateId") && dict["TranscodeTemplateId"] != nil {
                    self.transcodeTemplateId = dict["TranscodeTemplateId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Video") && dict["Video"] != nil {
                    self.video = dict["Video"] as! String
                }
                if dict.keys.contains("WatermarkIds") && dict["WatermarkIds"] != nil {
                    self.watermarkIds = dict["WatermarkIds"] as! [String]
                }
            }
        }
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var locked: String?

        public var modifyTime: String?

        public var name: String?

        public var transcodeTemplateGroupId: String?

        public var transcodeTemplateList: [GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.locked != nil {
                map["Locked"] = self.locked!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.transcodeTemplateList != nil {
                var tmp : [Any] = []
                for k in self.transcodeTemplateList! {
                    tmp.append(k.toMap())
                }
                map["TranscodeTemplateList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Locked") && dict["Locked"] != nil {
                self.locked = dict["Locked"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateList") && dict["TranscodeTemplateList"] != nil {
                var tmp : [GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList] = []
                for v in dict["TranscodeTemplateList"] as! [Any] {
                    var model = GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup.TranscodeTemplateList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeTemplateList = tmp
            }
        }
    }
    public var requestId: String?

    public var transcodeTemplateGroup: GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeTemplateGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroup != nil {
            map["TranscodeTemplateGroup"] = self.transcodeTemplateGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroup") && dict["TranscodeTemplateGroup"] != nil {
            var model = GetTranscodeTemplateGroupResponseBody.TranscodeTemplateGroup()
            model.fromMap(dict["TranscodeTemplateGroup"] as! [String: Any])
            self.transcodeTemplateGroup = model
        }
    }
}

public class GetTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetURLUploadInfosRequest : Tea.TeaModel {
    public var jobIds: String?

    public var uploadURLs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("UploadURLs") && dict["UploadURLs"] != nil {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
    }
}

public class GetURLUploadInfosResponseBody : Tea.TeaModel {
    public class URLUploadInfoList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var fileSize: String?

        public var jobId: String?

        public var mediaId: String?

        public var status: String?

        public var uploadURL: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uploadURL != nil {
                map["UploadURL"] = self.uploadURL!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UploadURL") && dict["UploadURL"] != nil {
                self.uploadURL = dict["UploadURL"] as! String
            }
            if dict.keys.contains("UserData") && dict["UserData"] != nil {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var nonExists: [String]?

    public var requestId: String?

    public var URLUploadInfoList: [GetURLUploadInfosResponseBody.URLUploadInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExists != nil {
            map["NonExists"] = self.nonExists!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.URLUploadInfoList != nil {
            var tmp : [Any] = []
            for k in self.URLUploadInfoList! {
                tmp.append(k.toMap())
            }
            map["URLUploadInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExists") && dict["NonExists"] != nil {
            self.nonExists = dict["NonExists"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("URLUploadInfoList") && dict["URLUploadInfoList"] != nil {
            var tmp : [GetURLUploadInfosResponseBody.URLUploadInfoList] = []
            for v in dict["URLUploadInfoList"] as! [Any] {
                var model = GetURLUploadInfosResponseBody.URLUploadInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.URLUploadInfoList = tmp
        }
    }
}

public class GetURLUploadInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetURLUploadInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetURLUploadInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUploadDetailsRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var mediaType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
            self.mediaType = dict["MediaType"] as! String
        }
    }
}

public class GetUploadDetailsResponseBody : Tea.TeaModel {
    public class UploadDetails : Tea.TeaModel {
        public var completionTime: String?

        public var creationTime: String?

        public var deviceModel: String?

        public var fileSize: Int64?

        public var mediaId: String?

        public var modificationTime: String?

        public var status: String?

        public var title: String?

        public var uploadIP: String?

        public var uploadRatio: Double?

        public var uploadSize: Int64?

        public var uploadSource: String?

        public var uploadStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completionTime != nil {
                map["CompletionTime"] = self.completionTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deviceModel != nil {
                map["DeviceModel"] = self.deviceModel!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.uploadIP != nil {
                map["UploadIP"] = self.uploadIP!
            }
            if self.uploadRatio != nil {
                map["UploadRatio"] = self.uploadRatio!
            }
            if self.uploadSize != nil {
                map["UploadSize"] = self.uploadSize!
            }
            if self.uploadSource != nil {
                map["UploadSource"] = self.uploadSource!
            }
            if self.uploadStatus != nil {
                map["UploadStatus"] = self.uploadStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompletionTime") && dict["CompletionTime"] != nil {
                self.completionTime = dict["CompletionTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeviceModel") && dict["DeviceModel"] != nil {
                self.deviceModel = dict["DeviceModel"] as! String
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UploadIP") && dict["UploadIP"] != nil {
                self.uploadIP = dict["UploadIP"] as! String
            }
            if dict.keys.contains("UploadRatio") && dict["UploadRatio"] != nil {
                self.uploadRatio = dict["UploadRatio"] as! Double
            }
            if dict.keys.contains("UploadSize") && dict["UploadSize"] != nil {
                self.uploadSize = dict["UploadSize"] as! Int64
            }
            if dict.keys.contains("UploadSource") && dict["UploadSource"] != nil {
                self.uploadSource = dict["UploadSource"] as! String
            }
            if dict.keys.contains("UploadStatus") && dict["UploadStatus"] != nil {
                self.uploadStatus = dict["UploadStatus"] as! String
            }
        }
    }
    public var forbiddenMediaIds: [String]?

    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public var uploadDetails: [GetUploadDetailsResponseBody.UploadDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenMediaIds != nil {
            map["ForbiddenMediaIds"] = self.forbiddenMediaIds!
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadDetails != nil {
            var tmp : [Any] = []
            for k in self.uploadDetails! {
                tmp.append(k.toMap())
            }
            map["UploadDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenMediaIds") && dict["ForbiddenMediaIds"] != nil {
            self.forbiddenMediaIds = dict["ForbiddenMediaIds"] as! [String]
        }
        if dict.keys.contains("NonExistMediaIds") && dict["NonExistMediaIds"] != nil {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadDetails") && dict["UploadDetails"] != nil {
            var tmp : [GetUploadDetailsResponseBody.UploadDetails] = []
            for v in dict["UploadDetails"] as! [Any] {
                var model = GetUploadDetailsResponseBody.UploadDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadDetails = tmp
        }
    }
}

public class GetUploadDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUploadDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUploadDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoInfoRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetVideoInfoResponseBody : Tea.TeaModel {
    public class Video : Tea.TeaModel {
        public class Snapshots : Tea.TeaModel {
            public var snapshot: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.snapshot != nil {
                    map["Snapshot"] = self.snapshot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Snapshot") && dict["Snapshot"] != nil {
                    self.snapshot = dict["Snapshot"] as! [String]
                }
            }
        }
        public var appId: String?

        public var auditStatus: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverURL: String?

        public var creationTime: String?

        public var customMediaInfo: String?

        public var description_: String?

        public var duration: Double?

        public var modificationTime: String?

        public var regionId: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var snapshots: GetVideoInfoResponseBody.Video.Snapshots?

        public var status: String?

        public var storageClass: String?

        public var storageLocation: String?

        public var tags: String?

        public var templateGroupId: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshots?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.auditStatus != nil {
                map["AuditStatus"] = self.auditStatus!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.customMediaInfo != nil {
                map["CustomMediaInfo"] = self.customMediaInfo!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.templateGroupId != nil {
                map["TemplateGroupId"] = self.templateGroupId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AuditStatus") && dict["AuditStatus"] != nil {
                self.auditStatus = dict["AuditStatus"] as! String
            }
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("CustomMediaInfo") && dict["CustomMediaInfo"] != nil {
                self.customMediaInfo = dict["CustomMediaInfo"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                var model = GetVideoInfoResponseBody.Video.Snapshots()
                model.fromMap(dict["Snapshots"] as! [String: Any])
                self.snapshots = model
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
                self.templateGroupId = dict["TemplateGroupId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var video: GetVideoInfoResponseBody.Video?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.video?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.video != nil {
            map["Video"] = self.video?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Video") && dict["Video"] != nil {
            var model = GetVideoInfoResponseBody.Video()
            model.fromMap(dict["Video"] as! [String: Any])
            self.video = model
        }
    }
}

public class GetVideoInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVideoInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoInfosRequest : Tea.TeaModel {
    public var videoIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoIds != nil {
            map["VideoIds"] = self.videoIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoIds") && dict["VideoIds"] != nil {
            self.videoIds = dict["VideoIds"] as! String
        }
    }
}

public class GetVideoInfosResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public var appId: String?

        public var cateId: Int64?

        public var cateName: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: Double?

        public var modificationTime: String?

        public var restoreExpiration: String?

        public var restoreStatus: String?

        public var size: Int64?

        public var snapshots: [String]?

        public var status: String?

        public var storageClass: String?

        public var storageLocation: String?

        public var tags: String?

        public var templateGroupId: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.restoreExpiration != nil {
                map["RestoreExpiration"] = self.restoreExpiration!
            }
            if self.restoreStatus != nil {
                map["RestoreStatus"] = self.restoreStatus!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClass != nil {
                map["StorageClass"] = self.storageClass!
            }
            if self.storageLocation != nil {
                map["StorageLocation"] = self.storageLocation!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.templateGroupId != nil {
                map["TemplateGroupId"] = self.templateGroupId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CateId") && dict["CateId"] != nil {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CateName") && dict["CateName"] != nil {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                self.restoreExpiration = dict["RestoreExpiration"] as! String
            }
            if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                self.restoreStatus = dict["RestoreStatus"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                self.snapshots = dict["Snapshots"] as! [String]
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                self.storageClass = dict["StorageClass"] as! String
            }
            if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                self.storageLocation = dict["StorageLocation"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
                self.templateGroupId = dict["TemplateGroupId"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public var videoList: [GetVideoInfosResponseBody.VideoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoList != nil {
            var tmp : [Any] = []
            for k in self.videoList! {
                tmp.append(k.toMap())
            }
            map["VideoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistVideoIds") && dict["NonExistVideoIds"] != nil {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoList") && dict["VideoList"] != nil {
            var tmp : [GetVideoInfosResponseBody.VideoList] = []
            for v in dict["VideoList"] as! [Any] {
                var model = GetVideoInfosResponseBody.VideoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.videoList = tmp
        }
    }
}

public class GetVideoInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVideoInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoListRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class GetVideoListResponseBody : Tea.TeaModel {
    public class VideoList : Tea.TeaModel {
        public class Video : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public var snapshot: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") && dict["Snapshot"] != nil {
                        self.snapshot = dict["Snapshot"] as! [String]
                    }
                }
            }
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var modificationTime: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: GetVideoListResponseBody.VideoList.Video.Snapshots?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    var model = GetVideoListResponseBody.VideoList.Video.Snapshots()
                    model.fromMap(dict["Snapshots"] as! [String: Any])
                    self.snapshots = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var video: [GetVideoListResponseBody.VideoList.Video]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.video != nil {
                var tmp : [Any] = []
                for k in self.video! {
                    tmp.append(k.toMap())
                }
                map["Video"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Video") && dict["Video"] != nil {
                var tmp : [GetVideoListResponseBody.VideoList.Video] = []
                for v in dict["Video"] as! [Any] {
                    var model = GetVideoListResponseBody.VideoList.Video()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.video = tmp
            }
        }
    }
    public var requestId: String?

    public var total: Int32?

    public var videoList: GetVideoListResponseBody.VideoList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.videoList != nil {
            map["VideoList"] = self.videoList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("VideoList") && dict["VideoList"] != nil {
            var model = GetVideoListResponseBody.VideoList()
            model.fromMap(dict["VideoList"] as! [String: Any])
            self.videoList = model
        }
    }
}

public class GetVideoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVideoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoPlayAuthRequest : Tea.TeaModel {
    public var apiVersion: String?

    public var authInfoTimeout: Int64?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiVersion != nil {
            map["ApiVersion"] = self.apiVersion!
        }
        if self.authInfoTimeout != nil {
            map["AuthInfoTimeout"] = self.authInfoTimeout!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiVersion") && dict["ApiVersion"] != nil {
            self.apiVersion = dict["ApiVersion"] as! String
        }
        if dict.keys.contains("AuthInfoTimeout") && dict["AuthInfoTimeout"] != nil {
            self.authInfoTimeout = dict["AuthInfoTimeout"] as! Int64
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class GetVideoPlayAuthResponseBody : Tea.TeaModel {
    public class VideoMeta : Tea.TeaModel {
        public var coverURL: String?

        public var duration: Double?

        public var status: String?

        public var title: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var playAuth: String?

    public var requestId: String?

    public var videoMeta: GetVideoPlayAuthResponseBody.VideoMeta?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoMeta?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playAuth != nil {
            map["PlayAuth"] = self.playAuth!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.videoMeta != nil {
            map["VideoMeta"] = self.videoMeta?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PlayAuth") && dict["PlayAuth"] != nil {
            self.playAuth = dict["PlayAuth"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VideoMeta") && dict["VideoMeta"] != nil {
            var model = GetVideoPlayAuthResponseBody.VideoMeta()
            model.fromMap(dict["VideoMeta"] as! [String: Any])
            self.videoMeta = model
        }
    }
}

public class GetVideoPlayAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoPlayAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVideoPlayAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVodTemplateRequest : Tea.TeaModel {
    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class GetVodTemplateResponseBody : Tea.TeaModel {
    public class VodTemplateInfo : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var name: String?

        public var templateConfig: String?

        public var templateType: String?

        public var vodTemplateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.vodTemplateId != nil {
                map["VodTemplateId"] = self.vodTemplateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
                self.vodTemplateId = dict["VodTemplateId"] as! String
            }
        }
    }
    public var requestId: String?

    public var vodTemplateInfo: GetVodTemplateResponseBody.VodTemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vodTemplateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateInfo != nil {
            map["VodTemplateInfo"] = self.vodTemplateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateInfo") && dict["VodTemplateInfo"] != nil {
            var model = GetVodTemplateResponseBody.VodTemplateInfo()
            model.fromMap(dict["VodTemplateInfo"] as! [String: Any])
            self.vodTemplateInfo = model
        }
    }
}

public class GetVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class GetWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: GetWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") && dict["WatermarkInfo"] != nil {
            var model = GetWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class GetWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIImageInfoRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListAIImageInfoResponseBody : Tea.TeaModel {
    public class AIImageInfoList : Tea.TeaModel {
        public var AIImageInfoId: String?

        public var creationTime: String?

        public var fileURL: String?

        public var format: String?

        public var jobId: String?

        public var score: String?

        public var version: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIImageInfoId != nil {
                map["AIImageInfoId"] = self.AIImageInfoId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIImageInfoId") && dict["AIImageInfoId"] != nil {
                self.AIImageInfoId = dict["AIImageInfoId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Score") && dict["Score"] != nil {
                self.score = dict["Score"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var AIImageInfoList: [ListAIImageInfoResponseBody.AIImageInfoList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIImageInfoList != nil {
            var tmp : [Any] = []
            for k in self.AIImageInfoList! {
                tmp.append(k.toMap())
            }
            map["AIImageInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIImageInfoList") && dict["AIImageInfoList"] != nil {
            var tmp : [ListAIImageInfoResponseBody.AIImageInfoList] = []
            for v in dict["AIImageInfoList"] as! [Any] {
                var model = ListAIImageInfoResponseBody.AIImageInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.AIImageInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAIImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAIJobRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") && dict["JobIds"] != nil {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class ListAIJobResponseBody : Tea.TeaModel {
    public class AIJobList : Tea.TeaModel {
        public class AIJob : Tea.TeaModel {
            public var code: String?

            public var completeTime: String?

            public var creationTime: String?

            public var data: String?

            public var jobId: String?

            public var mediaId: String?

            public var message: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.completeTime != nil {
                    map["CompleteTime"] = self.completeTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                    self.completeTime = dict["CompleteTime"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var AIJob: [ListAIJobResponseBody.AIJobList.AIJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIJob != nil {
                var tmp : [Any] = []
                for k in self.AIJob! {
                    tmp.append(k.toMap())
                }
                map["AIJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIJob") && dict["AIJob"] != nil {
                var tmp : [ListAIJobResponseBody.AIJobList.AIJob] = []
                for v in dict["AIJob"] as! [Any] {
                    var model = ListAIJobResponseBody.AIJobList.AIJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIJob = tmp
            }
        }
    }
    public class NonExistAIJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") && dict["String"] != nil {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var AIJobList: ListAIJobResponseBody.AIJobList?

    public var nonExistAIJobIds: ListAIJobResponseBody.NonExistAIJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIJobList?.validate()
        try self.nonExistAIJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIJobList != nil {
            map["AIJobList"] = self.AIJobList?.toMap()
        }
        if self.nonExistAIJobIds != nil {
            map["NonExistAIJobIds"] = self.nonExistAIJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIJobList") && dict["AIJobList"] != nil {
            var model = ListAIJobResponseBody.AIJobList()
            model.fromMap(dict["AIJobList"] as! [String: Any])
            self.AIJobList = model
        }
        if dict.keys.contains("NonExistAIJobIds") && dict["NonExistAIJobIds"] != nil {
            var model = ListAIJobResponseBody.NonExistAIJobIds()
            model.fromMap(dict["NonExistAIJobIds"] as! [String: Any])
            self.nonExistAIJobIds = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAITemplateRequest : Tea.TeaModel {
    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class ListAITemplateResponseBody : Tea.TeaModel {
    public class TemplateInfoList : Tea.TeaModel {
        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var source: String?

        public var templateConfig: String?

        public var templateId: String?

        public var templateName: String?

        public var templateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfoList: [ListAITemplateResponseBody.TemplateInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfoList != nil {
            var tmp : [Any] = []
            for k in self.templateInfoList! {
                tmp.append(k.toMap())
            }
            map["TemplateInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfoList") && dict["TemplateInfoList"] != nil {
            var tmp : [ListAITemplateResponseBody.TemplateInfoList] = []
            for v in dict["TemplateInfoList"] as! [Any] {
                var model = ListAITemplateResponseBody.TemplateInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateInfoList = tmp
        }
    }
}

public class ListAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppInfoRequest : Tea.TeaModel {
    public var pageNo: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListAppInfoResponseBody : Tea.TeaModel {
    public class AppInfoList : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var appInfoList: [ListAppInfoResponseBody.AppInfoList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appInfoList != nil {
            var tmp : [Any] = []
            for k in self.appInfoList! {
                tmp.append(k.toMap())
            }
            map["AppInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppInfoList") && dict["AppInfoList"] != nil {
            var tmp : [ListAppInfoResponseBody.AppInfoList] = []
            for v in dict["AppInfoList"] as! [Any] {
                var model = ListAppInfoResponseBody.AppInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppPoliciesForIdentityRequest : Tea.TeaModel {
    public var appId: String?

    public var identityName: String?

    public var identityType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.identityName != nil {
            map["IdentityName"] = self.identityName!
        }
        if self.identityType != nil {
            map["IdentityType"] = self.identityType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("IdentityName") && dict["IdentityName"] != nil {
            self.identityName = dict["IdentityName"] as! String
        }
        if dict.keys.contains("IdentityType") && dict["IdentityType"] != nil {
            self.identityType = dict["IdentityType"] as! String
        }
    }
}

public class ListAppPoliciesForIdentityResponseBody : Tea.TeaModel {
    public class AppPolicyList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var description_: String?

        public var modificationTime: String?

        public var policyName: String?

        public var policyType: String?

        public var policyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policyType != nil {
                map["PolicyType"] = self.policyType!
            }
            if self.policyValue != nil {
                map["PolicyValue"] = self.policyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicyType") && dict["PolicyType"] != nil {
                self.policyType = dict["PolicyType"] as! String
            }
            if dict.keys.contains("PolicyValue") && dict["PolicyValue"] != nil {
                self.policyValue = dict["PolicyValue"] as! String
            }
        }
    }
    public var appPolicyList: [ListAppPoliciesForIdentityResponseBody.AppPolicyList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appPolicyList != nil {
            var tmp : [Any] = []
            for k in self.appPolicyList! {
                tmp.append(k.toMap())
            }
            map["AppPolicyList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppPolicyList") && dict["AppPolicyList"] != nil {
            var tmp : [ListAppPoliciesForIdentityResponseBody.AppPolicyList] = []
            for v in dict["AppPolicyList"] as! [Any] {
                var model = ListAppPoliciesForIdentityResponseBody.AppPolicyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.appPolicyList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAppPoliciesForIdentityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppPoliciesForIdentityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAppPoliciesForIdentityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAuditSecurityIpRequest : Tea.TeaModel {
    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class ListAuditSecurityIpResponseBody : Tea.TeaModel {
    public class SecurityIpList : Tea.TeaModel {
        public var creationTime: String?

        public var ips: String?

        public var modificationTime: String?

        public var securityGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Ips") && dict["Ips"] != nil {
                self.ips = dict["Ips"] as! String
            }
            if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                self.modificationTime = dict["ModificationTime"] as! String
            }
            if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityIpList: [ListAuditSecurityIpResponseBody.SecurityIpList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIpList != nil {
            var tmp : [Any] = []
            for k in self.securityIpList! {
                tmp.append(k.toMap())
            }
            map["SecurityIpList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityIpList") && dict["SecurityIpList"] != nil {
            var tmp : [ListAuditSecurityIpResponseBody.SecurityIpList] = []
            for v in dict["SecurityIpList"] as! [Any] {
                var model = ListAuditSecurityIpResponseBody.SecurityIpList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityIpList = tmp
        }
    }
}

public class ListAuditSecurityIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAuditSecurityIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAuditSecurityIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDynamicImageRequest : Tea.TeaModel {
    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListDynamicImageResponseBody : Tea.TeaModel {
    public class DynamicImageList : Tea.TeaModel {
        public var creationTime: String?

        public var duration: String?

        public var dynamicImageId: String?

        public var fileSize: String?

        public var fileURL: String?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var jobId: String?

        public var videoId: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.dynamicImageId != nil {
                map["DynamicImageId"] = self.dynamicImageId!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("DynamicImageId") && dict["DynamicImageId"] != nil {
                self.dynamicImageId = dict["DynamicImageId"] as! String
            }
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! String
            }
            if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("Format") && dict["Format"] != nil {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") && dict["Fps"] != nil {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") && dict["Height"] != nil {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
            if dict.keys.contains("Width") && dict["Width"] != nil {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var dynamicImageList: [ListDynamicImageResponseBody.DynamicImageList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageList != nil {
            var tmp : [Any] = []
            for k in self.dynamicImageList! {
                tmp.append(k.toMap())
            }
            map["DynamicImageList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageList") && dict["DynamicImageList"] != nil {
            var tmp : [ListDynamicImageResponseBody.DynamicImageList] = []
            for v in dict["DynamicImageList"] as! [Any] {
                var model = ListDynamicImageResponseBody.DynamicImageList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dynamicImageList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDynamicImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDynamicImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDynamicImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRecordVideoRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class ListLiveRecordVideoResponseBody : Tea.TeaModel {
    public class LiveRecordVideoList : Tea.TeaModel {
        public class LiveRecordVideo : Tea.TeaModel {
            public class Video : Tea.TeaModel {
                public class Snapshots : Tea.TeaModel {
                    public var snapshot: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.snapshot != nil {
                            map["Snapshot"] = self.snapshot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Snapshot") && dict["Snapshot"] != nil {
                            self.snapshot = dict["Snapshot"] as! [String]
                        }
                    }
                }
                public var cateId: Int32?

                public var cateName: String?

                public var coverURL: String?

                public var creationTime: String?

                public var description_: String?

                public var duration: Double?

                public var modifyTime: String?

                public var size: Int64?

                public var snapshots: ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video.Snapshots?

                public var status: String?

                public var tags: String?

                public var templateGroupId: String?

                public var title: String?

                public var videoId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.snapshots?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cateId != nil {
                        map["CateId"] = self.cateId!
                    }
                    if self.cateName != nil {
                        map["CateName"] = self.cateName!
                    }
                    if self.coverURL != nil {
                        map["CoverURL"] = self.coverURL!
                    }
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.snapshots != nil {
                        map["Snapshots"] = self.snapshots?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags!
                    }
                    if self.templateGroupId != nil {
                        map["TemplateGroupId"] = self.templateGroupId!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    if self.videoId != nil {
                        map["VideoId"] = self.videoId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CateId") && dict["CateId"] != nil {
                        self.cateId = dict["CateId"] as! Int32
                    }
                    if dict.keys.contains("CateName") && dict["CateName"] != nil {
                        self.cateName = dict["CateName"] as! String
                    }
                    if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                        self.coverURL = dict["CoverURL"] as! String
                    }
                    if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! Double
                    }
                    if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                        self.modifyTime = dict["ModifyTime"] as! String
                    }
                    if dict.keys.contains("Size") && dict["Size"] != nil {
                        self.size = dict["Size"] as! Int64
                    }
                    if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                        var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video.Snapshots()
                        model.fromMap(dict["Snapshots"] as! [String: Any])
                        self.snapshots = model
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Tags") && dict["Tags"] != nil {
                        self.tags = dict["Tags"] as! String
                    }
                    if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
                        self.templateGroupId = dict["TemplateGroupId"] as! String
                    }
                    if dict.keys.contains("Title") && dict["Title"] != nil {
                        self.title = dict["Title"] as! String
                    }
                    if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                        self.videoId = dict["VideoId"] as! String
                    }
                }
            }
            public var appName: String?

            public var domainName: String?

            public var playlistId: String?

            public var recordEndTime: String?

            public var recordStartTime: String?

            public var streamName: String?

            public var video: ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.playlistId != nil {
                    map["PlaylistId"] = self.playlistId!
                }
                if self.recordEndTime != nil {
                    map["RecordEndTime"] = self.recordEndTime!
                }
                if self.recordStartTime != nil {
                    map["RecordStartTime"] = self.recordStartTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("PlaylistId") && dict["PlaylistId"] != nil {
                    self.playlistId = dict["PlaylistId"] as! String
                }
                if dict.keys.contains("RecordEndTime") && dict["RecordEndTime"] != nil {
                    self.recordEndTime = dict["RecordEndTime"] as! String
                }
                if dict.keys.contains("RecordStartTime") && dict["RecordStartTime"] != nil {
                    self.recordStartTime = dict["RecordStartTime"] as! String
                }
                if dict.keys.contains("StreamName") && dict["StreamName"] != nil {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("Video") && dict["Video"] != nil {
                    var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var liveRecordVideo: [ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveRecordVideo != nil {
                var tmp : [Any] = []
                for k in self.liveRecordVideo! {
                    tmp.append(k.toMap())
                }
                map["LiveRecordVideo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveRecordVideo") && dict["LiveRecordVideo"] != nil {
                var tmp : [ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo] = []
                for v in dict["LiveRecordVideo"] as! [Any] {
                    var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList.LiveRecordVideo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.liveRecordVideo = tmp
            }
        }
    }
    public var liveRecordVideoList: ListLiveRecordVideoResponseBody.LiveRecordVideoList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordVideoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordVideoList != nil {
            map["LiveRecordVideoList"] = self.liveRecordVideoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordVideoList") && dict["LiveRecordVideoList"] != nil {
            var model = ListLiveRecordVideoResponseBody.LiveRecordVideoList()
            model.fromMap(dict["LiveRecordVideoList"] as! [String: Any])
            self.liveRecordVideoList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListLiveRecordVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRecordVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLiveRecordVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotsRequest : Tea.TeaModel {
    public var authTimeout: String?

    public var pageNo: String?

    public var pageSize: String?

    public var snapshotType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authTimeout != nil {
            map["AuthTimeout"] = self.authTimeout!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotType != nil {
            map["SnapshotType"] = self.snapshotType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthTimeout") && dict["AuthTimeout"] != nil {
            self.authTimeout = dict["AuthTimeout"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotType") && dict["SnapshotType"] != nil {
            self.snapshotType = dict["SnapshotType"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListSnapshotsResponseBody : Tea.TeaModel {
    public class MediaSnapshot : Tea.TeaModel {
        public class Snapshots : Tea.TeaModel {
            public class Snapshot : Tea.TeaModel {
                public var index: Int64?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int64
                    }
                    if dict.keys.contains("Url") && dict["Url"] != nil {
                        self.url = dict["Url"] as! String
                    }
                }
            }
            public var snapshot: [ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.snapshot != nil {
                    var tmp : [Any] = []
                    for k in self.snapshot! {
                        tmp.append(k.toMap())
                    }
                    map["Snapshot"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Snapshot") && dict["Snapshot"] != nil {
                    var tmp : [ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot] = []
                    for v in dict["Snapshot"] as! [Any] {
                        var model = ListSnapshotsResponseBody.MediaSnapshot.Snapshots.Snapshot()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.snapshot = tmp
                }
            }
        }
        public var creationTime: String?

        public var jobId: String?

        public var regular: String?

        public var snapshots: ListSnapshotsResponseBody.MediaSnapshot.Snapshots?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.snapshots?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.regular != nil {
                map["Regular"] = self.regular!
            }
            if self.snapshots != nil {
                map["Snapshots"] = self.snapshots?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Regular") && dict["Regular"] != nil {
                self.regular = dict["Regular"] as! String
            }
            if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                var model = ListSnapshotsResponseBody.MediaSnapshot.Snapshots()
                model.fromMap(dict["Snapshots"] as! [String: Any])
                self.snapshots = model
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var mediaSnapshot: ListSnapshotsResponseBody.MediaSnapshot?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaSnapshot?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaSnapshot != nil {
            map["MediaSnapshot"] = self.mediaSnapshot?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaSnapshot") && dict["MediaSnapshot"] != nil {
            var model = ListSnapshotsResponseBody.MediaSnapshot()
            model.fromMap(dict["MediaSnapshot"] as! [String: Any])
            self.mediaSnapshot = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeTaskRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class ListTranscodeTaskResponseBody : Tea.TeaModel {
    public class TranscodeTaskList : Tea.TeaModel {
        public var completeTime: String?

        public var creationTime: String?

        public var taskStatus: String?

        public var transcodeTaskId: String?

        public var transcodeTemplateGroupId: String?

        public var trigger: String?

        public var videoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.transcodeTaskId != nil {
                map["TranscodeTaskId"] = self.transcodeTaskId!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger!
            }
            if self.videoId != nil {
                map["VideoId"] = self.videoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                self.taskStatus = dict["TaskStatus"] as! String
            }
            if dict.keys.contains("TranscodeTaskId") && dict["TranscodeTaskId"] != nil {
                self.transcodeTaskId = dict["TranscodeTaskId"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
            if dict.keys.contains("Trigger") && dict["Trigger"] != nil {
                self.trigger = dict["Trigger"] as! String
            }
            if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                self.videoId = dict["VideoId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTaskList: [ListTranscodeTaskResponseBody.TranscodeTaskList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTaskList != nil {
            var tmp : [Any] = []
            for k in self.transcodeTaskList! {
                tmp.append(k.toMap())
            }
            map["TranscodeTaskList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTaskList") && dict["TranscodeTaskList"] != nil {
            var tmp : [ListTranscodeTaskResponseBody.TranscodeTaskList] = []
            for v in dict["TranscodeTaskList"] as! [Any] {
                var model = ListTranscodeTaskResponseBody.TranscodeTaskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeTaskList = tmp
        }
    }
}

public class ListTranscodeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTranscodeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public class TranscodeTemplateGroupList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var locked: String?

        public var modifyTime: String?

        public var name: String?

        public var transcodeTemplateGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.locked != nil {
                map["Locked"] = self.locked!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.transcodeTemplateGroupId != nil {
                map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Locked") && dict["Locked"] != nil {
                self.locked = dict["Locked"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
                self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
            }
        }
    }
    public var requestId: String?

    public var transcodeTemplateGroupList: [ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupList != nil {
            var tmp : [Any] = []
            for k in self.transcodeTemplateGroupList! {
                tmp.append(k.toMap())
            }
            map["TranscodeTemplateGroupList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupList") && dict["TranscodeTemplateGroupList"] != nil {
            var tmp : [ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList] = []
            for v in dict["TranscodeTemplateGroupList"] as! [Any] {
                var model = ListTranscodeTemplateGroupResponseBody.TranscodeTemplateGroupList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transcodeTemplateGroupList = tmp
        }
    }
}

public class ListTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVodTemplateRequest : Tea.TeaModel {
    public var appId: String?

    public var templateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
            self.templateType = dict["TemplateType"] as! String
        }
    }
}

public class ListVodTemplateResponseBody : Tea.TeaModel {
    public class VodTemplateInfoList : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var isDefault: String?

        public var modifyTime: String?

        public var name: String?

        public var templateConfig: String?

        public var templateType: String?

        public var vodTemplateId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.templateConfig != nil {
                map["TemplateConfig"] = self.templateConfig!
            }
            if self.templateType != nil {
                map["TemplateType"] = self.templateType!
            }
            if self.vodTemplateId != nil {
                map["VodTemplateId"] = self.vodTemplateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
                self.templateConfig = dict["TemplateConfig"] as! String
            }
            if dict.keys.contains("TemplateType") && dict["TemplateType"] != nil {
                self.templateType = dict["TemplateType"] as! String
            }
            if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
                self.vodTemplateId = dict["VodTemplateId"] as! String
            }
        }
    }
    public var requestId: String?

    public var vodTemplateInfoList: [ListVodTemplateResponseBody.VodTemplateInfoList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateInfoList != nil {
            var tmp : [Any] = []
            for k in self.vodTemplateInfoList! {
                tmp.append(k.toMap())
            }
            map["VodTemplateInfoList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateInfoList") && dict["VodTemplateInfoList"] != nil {
            var tmp : [ListVodTemplateResponseBody.VodTemplateInfoList] = []
            for v in dict["VodTemplateInfoList"] as! [Any] {
                var model = ListVodTemplateResponseBody.VodTemplateInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vodTemplateInfoList = tmp
        }
    }
}

public class ListVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWatermarkRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfos : Tea.TeaModel {
        public var appId: String?

        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfos: [ListWatermarkResponseBody.WatermarkInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfos != nil {
            var tmp : [Any] = []
            for k in self.watermarkInfos! {
                tmp.append(k.toMap())
            }
            map["WatermarkInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfos") && dict["WatermarkInfos"] != nil {
            var tmp : [ListWatermarkResponseBody.WatermarkInfos] = []
            for v in dict["WatermarkInfos"] as! [Any] {
                var model = ListWatermarkResponseBody.WatermarkInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.watermarkInfos = tmp
        }
    }
}

public class ListWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveAppResourceRequest : Tea.TeaModel {
    public var resourceIds: String?

    public var resourceType: String?

    public var targetAppId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.targetAppId != nil {
            map["TargetAppId"] = self.targetAppId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") && dict["ResourceIds"] != nil {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TargetAppId") && dict["TargetAppId"] != nil {
            self.targetAppId = dict["TargetAppId"] as! String
        }
    }
}

public class MoveAppResourceResponseBody : Tea.TeaModel {
    public var failedResourceIds: [String]?

    public var nonExistResourceIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedResourceIds != nil {
            map["FailedResourceIds"] = self.failedResourceIds!
        }
        if self.nonExistResourceIds != nil {
            map["NonExistResourceIds"] = self.nonExistResourceIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedResourceIds") && dict["FailedResourceIds"] != nil {
            self.failedResourceIds = dict["FailedResourceIds"] as! [String]
        }
        if dict.keys.contains("NonExistResourceIds") && dict["NonExistResourceIds"] != nil {
            self.nonExistResourceIds = dict["NonExistResourceIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MoveAppResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveAppResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MoveAppResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreloadVodObjectCachesRequest : Tea.TeaModel {
    public var objectPath: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ObjectPath") && dict["ObjectPath"] != nil {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class PreloadVodObjectCachesResponseBody : Tea.TeaModel {
    public var preloadTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preloadTaskId != nil {
            map["PreloadTaskId"] = self.preloadTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreloadTaskId") && dict["PreloadTaskId"] != nil {
            self.preloadTaskId = dict["PreloadTaskId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PreloadVodObjectCachesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreloadVodObjectCachesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PreloadVodObjectCachesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ProduceEditingProjectVideoRequest : Tea.TeaModel {
    public var appId: String?

    public var coverURL: String?

    public var description_: String?

    public var mediaMetadata: String?

    public var ownerId: Int64?

    public var produceConfig: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timeline: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mediaMetadata != nil {
            map["MediaMetadata"] = self.mediaMetadata!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.produceConfig != nil {
            map["ProduceConfig"] = self.produceConfig!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MediaMetadata") && dict["MediaMetadata"] != nil {
            self.mediaMetadata = dict["MediaMetadata"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProduceConfig") && dict["ProduceConfig"] != nil {
            self.produceConfig = dict["ProduceConfig"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ProduceEditingProjectVideoResponseBody : Tea.TeaModel {
    public var mediaId: String?

    public var projectId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ProduceEditingProjectVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ProduceEditingProjectVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ProduceEditingProjectVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshMediaPlayUrlsRequest : Tea.TeaModel {
    public var definitions: String?

    public var formats: String?

    public var mediaIds: String?

    public var resultType: String?

    public var sliceCount: Int32?

    public var sliceFlag: Bool?

    public var streamType: String?

    public var taskType: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definitions != nil {
            map["Definitions"] = self.definitions!
        }
        if self.formats != nil {
            map["Formats"] = self.formats!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.sliceCount != nil {
            map["SliceCount"] = self.sliceCount!
        }
        if self.sliceFlag != nil {
            map["SliceFlag"] = self.sliceFlag!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definitions") && dict["Definitions"] != nil {
            self.definitions = dict["Definitions"] as! String
        }
        if dict.keys.contains("Formats") && dict["Formats"] != nil {
            self.formats = dict["Formats"] as! String
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("ResultType") && dict["ResultType"] != nil {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SliceCount") && dict["SliceCount"] != nil {
            self.sliceCount = dict["SliceCount"] as! Int32
        }
        if dict.keys.contains("SliceFlag") && dict["SliceFlag"] != nil {
            self.sliceFlag = dict["SliceFlag"] as! Bool
        }
        if dict.keys.contains("StreamType") && dict["StreamType"] != nil {
            self.streamType = dict["StreamType"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class RefreshMediaPlayUrlsResponseBody : Tea.TeaModel {
    public var forbiddenMediaIds: String?

    public var mediaRefreshJobId: String?

    public var nonExistMediaIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenMediaIds != nil {
            map["ForbiddenMediaIds"] = self.forbiddenMediaIds!
        }
        if self.mediaRefreshJobId != nil {
            map["MediaRefreshJobId"] = self.mediaRefreshJobId!
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenMediaIds") && dict["ForbiddenMediaIds"] != nil {
            self.forbiddenMediaIds = dict["ForbiddenMediaIds"] as! String
        }
        if dict.keys.contains("MediaRefreshJobId") && dict["MediaRefreshJobId"] != nil {
            self.mediaRefreshJobId = dict["MediaRefreshJobId"] as! String
        }
        if dict.keys.contains("NonExistMediaIds") && dict["NonExistMediaIds"] != nil {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshMediaPlayUrlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshMediaPlayUrlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshMediaPlayUrlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshUploadVideoRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class RefreshUploadVideoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var uploadAddress: String?

    public var uploadAuth: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadAddress != nil {
            map["UploadAddress"] = self.uploadAddress!
        }
        if self.uploadAuth != nil {
            map["UploadAuth"] = self.uploadAuth!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadAddress") && dict["UploadAddress"] != nil {
            self.uploadAddress = dict["UploadAddress"] as! String
        }
        if dict.keys.contains("UploadAuth") && dict["UploadAuth"] != nil {
            self.uploadAuth = dict["UploadAuth"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class RefreshUploadVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshUploadVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshUploadVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshVodObjectCachesRequest : Tea.TeaModel {
    public var objectPath: String?

    public var objectType: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.objectPath != nil {
            map["ObjectPath"] = self.objectPath!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ObjectPath") && dict["ObjectPath"] != nil {
            self.objectPath = dict["ObjectPath"] as! String
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RefreshVodObjectCachesResponseBody : Tea.TeaModel {
    public var refreshTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.refreshTaskId != nil {
            map["RefreshTaskId"] = self.refreshTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RefreshTaskId") && dict["RefreshTaskId"] != nil {
            self.refreshTaskId = dict["RefreshTaskId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshVodObjectCachesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshVodObjectCachesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshVodObjectCachesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterMediaRequest : Tea.TeaModel {
    public var registerMetadatas: String?

    public var templateGroupId: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registerMetadatas != nil {
            map["RegisterMetadatas"] = self.registerMetadatas!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegisterMetadatas") && dict["RegisterMetadatas"] != nil {
            self.registerMetadatas = dict["RegisterMetadatas"] as! String
        }
        if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class RegisterMediaResponseBody : Tea.TeaModel {
    public class RegisteredMediaList : Tea.TeaModel {
        public var fileURL: String?

        public var mediaId: String?

        public var newRegister: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.newRegister != nil {
                map["NewRegister"] = self.newRegister!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
                self.fileURL = dict["FileURL"] as! String
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("NewRegister") && dict["NewRegister"] != nil {
                self.newRegister = dict["NewRegister"] as! Bool
            }
        }
    }
    public var failedFileURLs: [String]?

    public var registeredMediaList: [RegisterMediaResponseBody.RegisteredMediaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedFileURLs != nil {
            map["FailedFileURLs"] = self.failedFileURLs!
        }
        if self.registeredMediaList != nil {
            var tmp : [Any] = []
            for k in self.registeredMediaList! {
                tmp.append(k.toMap())
            }
            map["RegisteredMediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailedFileURLs") && dict["FailedFileURLs"] != nil {
            self.failedFileURLs = dict["FailedFileURLs"] as! [String]
        }
        if dict.keys.contains("RegisteredMediaList") && dict["RegisteredMediaList"] != nil {
            var tmp : [RegisterMediaResponseBody.RegisteredMediaList] = []
            for v in dict["RegisteredMediaList"] as! [Any] {
                var model = RegisterMediaResponseBody.RegisteredMediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.registeredMediaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestoreMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var restoreDays: String?

    public var restoreTier: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.restoreDays != nil {
            map["RestoreDays"] = self.restoreDays!
        }
        if self.restoreTier != nil {
            map["RestoreTier"] = self.restoreTier!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("RestoreDays") && dict["RestoreDays"] != nil {
            self.restoreDays = dict["RestoreDays"] as! String
        }
        if dict.keys.contains("RestoreTier") && dict["RestoreTier"] != nil {
            self.restoreTier = dict["RestoreTier"] as! String
        }
        if dict.keys.contains("Scope") && dict["Scope"] != nil {
            self.scope = dict["Scope"] as! String
        }
    }
}

public class RestoreMediaResponseBody : Tea.TeaModel {
    public class ForbiddenList : Tea.TeaModel {
        public class MediaForbiddenReasonDTO : Tea.TeaModel {
            public var mediaId: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Reason") && dict["Reason"] != nil {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var mediaForbiddenReasonDTO: [RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaForbiddenReasonDTO != nil {
                var tmp : [Any] = []
                for k in self.mediaForbiddenReasonDTO! {
                    tmp.append(k.toMap())
                }
                map["MediaForbiddenReasonDTO"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaForbiddenReasonDTO") && dict["MediaForbiddenReasonDTO"] != nil {
                var tmp : [RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO] = []
                for v in dict["MediaForbiddenReasonDTO"] as! [Any] {
                    var model = RestoreMediaResponseBody.ForbiddenList.MediaForbiddenReasonDTO()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaForbiddenReasonDTO = tmp
            }
        }
    }
    public class IgnoredList : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var forbiddenList: RestoreMediaResponseBody.ForbiddenList?

    public var ignoredList: RestoreMediaResponseBody.IgnoredList?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forbiddenList?.validate()
        try self.ignoredList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList?.toMap()
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") && dict["ForbiddenList"] != nil {
            var model = RestoreMediaResponseBody.ForbiddenList()
            model.fromMap(dict["ForbiddenList"] as! [String: Any])
            self.forbiddenList = model
        }
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            var model = RestoreMediaResponseBody.IgnoredList()
            model.fromMap(dict["IgnoredList"] as! [String: Any])
            self.ignoredList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RestoreMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestoreMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchEditingProjectRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var sortBy: String?

    public var startTime: String?

    public var status: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class SearchEditingProjectResponseBody : Tea.TeaModel {
    public class ProjectList : Tea.TeaModel {
        public class Project : Tea.TeaModel {
            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: Double?

            public var modifiedTime: String?

            public var projectId: String?

            public var regionId: String?

            public var status: String?

            public var storageLocation: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("ModifiedTime") && dict["ModifiedTime"] != nil {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var project: [SearchEditingProjectResponseBody.ProjectList.Project]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.project != nil {
                var tmp : [Any] = []
                for k in self.project! {
                    tmp.append(k.toMap())
                }
                map["Project"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Project") && dict["Project"] != nil {
                var tmp : [SearchEditingProjectResponseBody.ProjectList.Project] = []
                for v in dict["Project"] as! [Any] {
                    var model = SearchEditingProjectResponseBody.ProjectList.Project()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.project = tmp
            }
        }
    }
    public var projectList: SearchEditingProjectResponseBody.ProjectList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectList != nil {
            map["ProjectList"] = self.projectList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectList") && dict["ProjectList"] != nil {
            var model = SearchEditingProjectResponseBody.ProjectList()
            model.fromMap(dict["ProjectList"] as! [String: Any])
            self.projectList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class SearchEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaRequest : Tea.TeaModel {
    public var fields: String?

    public var match: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var scrollToken: String?

    public var searchType: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fields != nil {
            map["Fields"] = self.fields!
        }
        if self.match != nil {
            map["Match"] = self.match!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.searchType != nil {
            map["SearchType"] = self.searchType!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Fields") && dict["Fields"] != nil {
            self.fields = dict["Fields"] as! String
        }
        if dict.keys.contains("Match") && dict["Match"] != nil {
            self.match = dict["Match"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScrollToken") && dict["ScrollToken"] != nil {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("SearchType") && dict["SearchType"] != nil {
            self.searchType = dict["SearchType"] as! String
        }
        if dict.keys.contains("SortBy") && dict["SortBy"] != nil {
            self.sortBy = dict["SortBy"] as! String
        }
    }
}

public class SearchMediaResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class AiData : Tea.TeaModel {
            public class AiLabelInfo : Tea.TeaModel {
                public class Occurrences : Tea.TeaModel {
                    public var from: Double?

                    public var score: Double?

                    public var to: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.from != nil {
                            map["From"] = self.from!
                        }
                        if self.score != nil {
                            map["Score"] = self.score!
                        }
                        if self.to != nil {
                            map["To"] = self.to!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("From") && dict["From"] != nil {
                            self.from = dict["From"] as! Double
                        }
                        if dict.keys.contains("Score") && dict["Score"] != nil {
                            self.score = dict["Score"] as! Double
                        }
                        if dict.keys.contains("To") && dict["To"] != nil {
                            self.to = dict["To"] as! Double
                        }
                    }
                }
                public var category: String?

                public var labelId: String?

                public var labelName: String?

                public var occurrences: [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.labelId != nil {
                        map["LabelId"] = self.labelId!
                    }
                    if self.labelName != nil {
                        map["LabelName"] = self.labelName!
                    }
                    if self.occurrences != nil {
                        var tmp : [Any] = []
                        for k in self.occurrences! {
                            tmp.append(k.toMap())
                        }
                        map["Occurrences"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("LabelId") && dict["LabelId"] != nil {
                        self.labelId = dict["LabelId"] as! String
                    }
                    if dict.keys.contains("LabelName") && dict["LabelName"] != nil {
                        self.labelName = dict["LabelName"] as! String
                    }
                    if dict.keys.contains("Occurrences") && dict["Occurrences"] != nil {
                        var tmp : [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences] = []
                        for v in dict["Occurrences"] as! [Any] {
                            var model = SearchMediaResponseBody.MediaList.AiData.AiLabelInfo.Occurrences()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.occurrences = tmp
                    }
                }
            }
            public class OcrInfo : Tea.TeaModel {
                public var content: String?

                public var from: Double?

                public var to: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.from != nil {
                        map["From"] = self.from!
                    }
                    if self.to != nil {
                        map["To"] = self.to!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Content") && dict["Content"] != nil {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("From") && dict["From"] != nil {
                        self.from = dict["From"] as! Double
                    }
                    if dict.keys.contains("To") && dict["To"] != nil {
                        self.to = dict["To"] as! Double
                    }
                }
            }
            public var aiLabelInfo: [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo]?

            public var ocrInfo: [SearchMediaResponseBody.MediaList.AiData.OcrInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiLabelInfo != nil {
                    var tmp : [Any] = []
                    for k in self.aiLabelInfo! {
                        tmp.append(k.toMap())
                    }
                    map["AiLabelInfo"] = tmp
                }
                if self.ocrInfo != nil {
                    var tmp : [Any] = []
                    for k in self.ocrInfo! {
                        tmp.append(k.toMap())
                    }
                    map["OcrInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiLabelInfo") && dict["AiLabelInfo"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaList.AiData.AiLabelInfo] = []
                    for v in dict["AiLabelInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AiData.AiLabelInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aiLabelInfo = tmp
                }
                if dict.keys.contains("OcrInfo") && dict["OcrInfo"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaList.AiData.OcrInfo] = []
                    for v in dict["OcrInfo"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AiData.OcrInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ocrInfo = tmp
                }
            }
        }
        public class AiRoughData : Tea.TeaModel {
            public var aiCategory: String?

            public var aiJobId: String?

            public var saveType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aiCategory != nil {
                    map["AiCategory"] = self.aiCategory!
                }
                if self.aiJobId != nil {
                    map["AiJobId"] = self.aiJobId!
                }
                if self.saveType != nil {
                    map["SaveType"] = self.saveType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AiCategory") && dict["AiCategory"] != nil {
                    self.aiCategory = dict["AiCategory"] as! String
                }
                if dict.keys.contains("AiJobId") && dict["AiJobId"] != nil {
                    self.aiJobId = dict["AiJobId"] as! String
                }
                if dict.keys.contains("SaveType") && dict["SaveType"] != nil {
                    self.saveType = dict["SaveType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class AttachedMedia : Tea.TeaModel {
            public class Categories : Tea.TeaModel {
                public var cateId: Int64?

                public var cateName: String?

                public var level: Int64?

                public var parentId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cateId != nil {
                        map["CateId"] = self.cateId!
                    }
                    if self.cateName != nil {
                        map["CateName"] = self.cateName!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.parentId != nil {
                        map["ParentId"] = self.parentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CateId") && dict["CateId"] != nil {
                        self.cateId = dict["CateId"] as! Int64
                    }
                    if dict.keys.contains("CateName") && dict["CateName"] != nil {
                        self.cateName = dict["CateName"] as! String
                    }
                    if dict.keys.contains("Level") && dict["Level"] != nil {
                        self.level = dict["Level"] as! Int64
                    }
                    if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                        self.parentId = dict["ParentId"] as! Int64
                    }
                }
            }
            public var appId: String?

            public var businessType: String?

            public var categories: [SearchMediaResponseBody.MediaList.AttachedMedia.Categories]?

            public var creationTime: String?

            public var description_: String?

            public var mediaId: String?

            public var modificationTime: String?

            public var status: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.businessType != nil {
                    map["BusinessType"] = self.businessType!
                }
                if self.categories != nil {
                    var tmp : [Any] = []
                    for k in self.categories! {
                        tmp.append(k.toMap())
                    }
                    map["Categories"] = tmp
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                    self.businessType = dict["BusinessType"] as! String
                }
                if dict.keys.contains("Categories") && dict["Categories"] != nil {
                    var tmp : [SearchMediaResponseBody.MediaList.AttachedMedia.Categories] = []
                    for v in dict["Categories"] as! [Any] {
                        var model = SearchMediaResponseBody.MediaList.AttachedMedia.Categories()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.categories = tmp
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("URL") && dict["URL"] != nil {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class Audio : Tea.TeaModel {
            public var appId: String?

            public var audioId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var downloadSwitch: String?

            public var duration: Double?

            public var mediaSource: String?

            public var modificationTime: String?

            public var preprocessStatus: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: [String]?

            public var spriteSnapshots: [String]?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var transcodeMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.audioId != nil {
                    map["AudioId"] = self.audioId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadSwitch != nil {
                    map["DownloadSwitch"] = self.downloadSwitch!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.mediaSource != nil {
                    map["MediaSource"] = self.mediaSource!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.preprocessStatus != nil {
                    map["PreprocessStatus"] = self.preprocessStatus!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.spriteSnapshots != nil {
                    map["SpriteSnapshots"] = self.spriteSnapshots!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeMode != nil {
                    map["TranscodeMode"] = self.transcodeMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AudioId") && dict["AudioId"] != nil {
                    self.audioId = dict["AudioId"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DownloadSwitch") && dict["DownloadSwitch"] != nil {
                    self.downloadSwitch = dict["DownloadSwitch"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MediaSource") && dict["MediaSource"] != nil {
                    self.mediaSource = dict["MediaSource"] as! String
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("PreprocessStatus") && dict["PreprocessStatus"] != nil {
                    self.preprocessStatus = dict["PreprocessStatus"] as! String
                }
                if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! [String]
                }
                if dict.keys.contains("SpriteSnapshots") && dict["SpriteSnapshots"] != nil {
                    self.spriteSnapshots = dict["SpriteSnapshots"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeMode") && dict["TranscodeMode"] != nil {
                    self.transcodeMode = dict["TranscodeMode"] as! String
                }
            }
        }
        public class Image : Tea.TeaModel {
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var creationTime: String?

            public var description_: String?

            public var imageId: String?

            public var modificationTime: String?

            public var status: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("URL") && dict["URL"] != nil {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public var appId: String?

            public var cateId: Int64?

            public var cateName: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var downloadSwitch: String?

            public var duration: Double?

            public var mediaSource: String?

            public var modificationTime: String?

            public var preprocessStatus: String?

            public var restoreExpiration: String?

            public var restoreStatus: String?

            public var size: Int64?

            public var snapshots: [String]?

            public var spriteSnapshots: [String]?

            public var status: String?

            public var storageClass: String?

            public var storageLocation: String?

            public var tags: String?

            public var title: String?

            public var transcodeMode: String?

            public var videoId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.downloadSwitch != nil {
                    map["DownloadSwitch"] = self.downloadSwitch!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.mediaSource != nil {
                    map["MediaSource"] = self.mediaSource!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.preprocessStatus != nil {
                    map["PreprocessStatus"] = self.preprocessStatus!
                }
                if self.restoreExpiration != nil {
                    map["RestoreExpiration"] = self.restoreExpiration!
                }
                if self.restoreStatus != nil {
                    map["RestoreStatus"] = self.restoreStatus!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots!
                }
                if self.spriteSnapshots != nil {
                    map["SpriteSnapshots"] = self.spriteSnapshots!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.transcodeMode != nil {
                    map["TranscodeMode"] = self.transcodeMode!
                }
                if self.videoId != nil {
                    map["VideoId"] = self.videoId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CateId") && dict["CateId"] != nil {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CateName") && dict["CateName"] != nil {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DownloadSwitch") && dict["DownloadSwitch"] != nil {
                    self.downloadSwitch = dict["DownloadSwitch"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("MediaSource") && dict["MediaSource"] != nil {
                    self.mediaSource = dict["MediaSource"] as! String
                }
                if dict.keys.contains("ModificationTime") && dict["ModificationTime"] != nil {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("PreprocessStatus") && dict["PreprocessStatus"] != nil {
                    self.preprocessStatus = dict["PreprocessStatus"] as! String
                }
                if dict.keys.contains("RestoreExpiration") && dict["RestoreExpiration"] != nil {
                    self.restoreExpiration = dict["RestoreExpiration"] as! String
                }
                if dict.keys.contains("RestoreStatus") && dict["RestoreStatus"] != nil {
                    self.restoreStatus = dict["RestoreStatus"] as! String
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
                    self.snapshots = dict["Snapshots"] as! [String]
                }
                if dict.keys.contains("SpriteSnapshots") && dict["SpriteSnapshots"] != nil {
                    self.spriteSnapshots = dict["SpriteSnapshots"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
                    self.storageClass = dict["StorageClass"] as! String
                }
                if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
                    self.storageLocation = dict["StorageLocation"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("TranscodeMode") && dict["TranscodeMode"] != nil {
                    self.transcodeMode = dict["TranscodeMode"] as! String
                }
                if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
                    self.videoId = dict["VideoId"] as! String
                }
            }
        }
        public var aiData: SearchMediaResponseBody.MediaList.AiData?

        public var aiRoughData: SearchMediaResponseBody.MediaList.AiRoughData?

        public var attachedMedia: SearchMediaResponseBody.MediaList.AttachedMedia?

        public var audio: SearchMediaResponseBody.MediaList.Audio?

        public var creationTime: String?

        public var image: SearchMediaResponseBody.MediaList.Image?

        public var mediaId: String?

        public var mediaType: String?

        public var video: SearchMediaResponseBody.MediaList.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.aiData?.validate()
            try self.aiRoughData?.validate()
            try self.attachedMedia?.validate()
            try self.audio?.validate()
            try self.image?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiData != nil {
                map["AiData"] = self.aiData?.toMap()
            }
            if self.aiRoughData != nil {
                map["AiRoughData"] = self.aiRoughData?.toMap()
            }
            if self.attachedMedia != nil {
                map["AttachedMedia"] = self.attachedMedia?.toMap()
            }
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.image != nil {
                map["Image"] = self.image?.toMap()
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiData") && dict["AiData"] != nil {
                var model = SearchMediaResponseBody.MediaList.AiData()
                model.fromMap(dict["AiData"] as! [String: Any])
                self.aiData = model
            }
            if dict.keys.contains("AiRoughData") && dict["AiRoughData"] != nil {
                var model = SearchMediaResponseBody.MediaList.AiRoughData()
                model.fromMap(dict["AiRoughData"] as! [String: Any])
                self.aiRoughData = model
            }
            if dict.keys.contains("AttachedMedia") && dict["AttachedMedia"] != nil {
                var model = SearchMediaResponseBody.MediaList.AttachedMedia()
                model.fromMap(dict["AttachedMedia"] as! [String: Any])
                self.attachedMedia = model
            }
            if dict.keys.contains("Audio") && dict["Audio"] != nil {
                var model = SearchMediaResponseBody.MediaList.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var model = SearchMediaResponseBody.MediaList.Image()
                model.fromMap(dict["Image"] as! [String: Any])
                self.image = model
            }
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Video") && dict["Video"] != nil {
                var model = SearchMediaResponseBody.MediaList.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var mediaList: [SearchMediaResponseBody.MediaList]?

    public var requestId: String?

    public var scrollToken: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            var tmp : [Any] = []
            for k in self.mediaList! {
                tmp.append(k.toMap())
            }
            map["MediaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scrollToken != nil {
            map["ScrollToken"] = self.scrollToken!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") && dict["MediaList"] != nil {
            var tmp : [SearchMediaResponseBody.MediaList] = []
            for v in dict["MediaList"] as! [Any] {
                var model = SearchMediaResponseBody.MediaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mediaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScrollToken") && dict["ScrollToken"] != nil {
            self.scrollToken = dict["ScrollToken"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SearchMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAuditSecurityIpRequest : Tea.TeaModel {
    public var ips: String?

    public var operateMode: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ips != nil {
            map["Ips"] = self.ips!
        }
        if self.operateMode != nil {
            map["OperateMode"] = self.operateMode!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ips") && dict["Ips"] != nil {
            self.ips = dict["Ips"] as! String
        }
        if dict.keys.contains("OperateMode") && dict["OperateMode"] != nil {
            self.operateMode = dict["OperateMode"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class SetAuditSecurityIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAuditSecurityIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAuditSecurityIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetAuditSecurityIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCrossdomainContentRequest : Tea.TeaModel {
    public var content: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var resourceRealOwnerId: String?

    public var storageLocation: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceRealOwnerId != nil {
            map["ResourceRealOwnerId"] = self.resourceRealOwnerId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("ResourceRealOwnerId") && dict["ResourceRealOwnerId"] != nil {
            self.resourceRealOwnerId = dict["ResourceRealOwnerId"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
    }
}

public class SetCrossdomainContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCrossdomainContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCrossdomainContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetCrossdomainContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultAITemplateRequest : Tea.TeaModel {
    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SetDefaultAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDefaultAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class SetDefaultTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDefaultTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDefaultTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDefaultWatermarkRequest : Tea.TeaModel {
    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class SetDefaultWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDefaultWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetDefaultWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEditingProjectMaterialsRequest : Tea.TeaModel {
    public var materialIds: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.materialIds != nil {
            map["MaterialIds"] = self.materialIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaterialIds") && dict["MaterialIds"] != nil {
            self.materialIds = dict["MaterialIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SetEditingProjectMaterialsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetEditingProjectMaterialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEditingProjectMaterialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetEditingProjectMaterialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetMessageCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var authKey: String?

    public var authSwitch: String?

    public var callbackType: String?

    public var callbackURL: String?

    public var eventTypeList: String?

    public var mnsEndpoint: String?

    public var mnsQueueName: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.authSwitch != nil {
            map["AuthSwitch"] = self.authSwitch!
        }
        if self.callbackType != nil {
            map["CallbackType"] = self.callbackType!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.eventTypeList != nil {
            map["EventTypeList"] = self.eventTypeList!
        }
        if self.mnsEndpoint != nil {
            map["MnsEndpoint"] = self.mnsEndpoint!
        }
        if self.mnsQueueName != nil {
            map["MnsQueueName"] = self.mnsQueueName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AuthKey") && dict["AuthKey"] != nil {
            self.authKey = dict["AuthKey"] as! String
        }
        if dict.keys.contains("AuthSwitch") && dict["AuthSwitch"] != nil {
            self.authSwitch = dict["AuthSwitch"] as! String
        }
        if dict.keys.contains("CallbackType") && dict["CallbackType"] != nil {
            self.callbackType = dict["CallbackType"] as! String
        }
        if dict.keys.contains("CallbackURL") && dict["CallbackURL"] != nil {
            self.callbackURL = dict["CallbackURL"] as! String
        }
        if dict.keys.contains("EventTypeList") && dict["EventTypeList"] != nil {
            self.eventTypeList = dict["EventTypeList"] as! String
        }
        if dict.keys.contains("MnsEndpoint") && dict["MnsEndpoint"] != nil {
            self.mnsEndpoint = dict["MnsEndpoint"] as! String
        }
        if dict.keys.contains("MnsQueueName") && dict["MnsQueueName"] != nil {
            self.mnsQueueName = dict["MnsQueueName"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
    }
}

public class SetMessageCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetMessageCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetMessageCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetMessageCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetVodDomainCertificateRequest : Tea.TeaModel {
    public var certName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var SSLPri: String?

    public var SSLProtocol: String?

    public var SSLPub: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.SSLPri != nil {
            map["SSLPri"] = self.SSLPri!
        }
        if self.SSLProtocol != nil {
            map["SSLProtocol"] = self.SSLProtocol!
        }
        if self.SSLPub != nil {
            map["SSLPub"] = self.SSLPub!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertName") && dict["CertName"] != nil {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SSLPri") && dict["SSLPri"] != nil {
            self.SSLPri = dict["SSLPri"] as! String
        }
        if dict.keys.contains("SSLProtocol") && dict["SSLProtocol"] != nil {
            self.SSLProtocol = dict["SSLProtocol"] as! String
        }
        if dict.keys.contains("SSLPub") && dict["SSLPub"] != nil {
            self.SSLPub = dict["SSLPub"] as! String
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetVodDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetVodDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetVodDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetVodDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIImageAuditJobRequest : Tea.TeaModel {
    public var mediaAuditConfiguration: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditConfiguration != nil {
            map["MediaAuditConfiguration"] = self.mediaAuditConfiguration!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditConfiguration") && dict["MediaAuditConfiguration"] != nil {
            self.mediaAuditConfiguration = dict["MediaAuditConfiguration"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class SubmitAIImageAuditJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIImageAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIImageAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAIImageAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIImageJobRequest : Tea.TeaModel {
    public var AIPipelineId: String?

    public var AITemplateId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var userData: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIPipelineId != nil {
            map["AIPipelineId"] = self.AIPipelineId!
        }
        if self.AITemplateId != nil {
            map["AITemplateId"] = self.AITemplateId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIPipelineId") && dict["AIPipelineId"] != nil {
            self.AIPipelineId = dict["AIPipelineId"] as! String
        }
        if dict.keys.contains("AITemplateId") && dict["AITemplateId"] != nil {
            self.AITemplateId = dict["AITemplateId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitAIImageJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAIImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIJobRequest : Tea.TeaModel {
    public var config: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var types: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAIJobResponseBody : Tea.TeaModel {
    public class AIJobList : Tea.TeaModel {
        public class AIJob : Tea.TeaModel {
            public var jobId: String?

            public var mediaId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var AIJob: [SubmitAIJobResponseBody.AIJobList.AIJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AIJob != nil {
                var tmp : [Any] = []
                for k in self.AIJob! {
                    tmp.append(k.toMap())
                }
                map["AIJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AIJob") && dict["AIJob"] != nil {
                var tmp : [SubmitAIJobResponseBody.AIJobList.AIJob] = []
                for v in dict["AIJob"] as! [Any] {
                    var model = SubmitAIJobResponseBody.AIJobList.AIJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AIJob = tmp
            }
        }
    }
    public var AIJobList: SubmitAIJobResponseBody.AIJobList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.AIJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AIJobList != nil {
            map["AIJobList"] = self.AIJobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AIJobList") && dict["AIJobList"] != nil {
            var model = SubmitAIJobResponseBody.AIJobList()
            model.fromMap(dict["AIJobList"] as! [String: Any])
            self.AIJobList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAIMediaAuditJobRequest : Tea.TeaModel {
    public var mediaAuditConfiguration: String?

    public var mediaId: String?

    public var mediaType: String?

    public var templateId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaAuditConfiguration != nil {
            map["MediaAuditConfiguration"] = self.mediaAuditConfiguration!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaAuditConfiguration") && dict["MediaAuditConfiguration"] != nil {
            self.mediaAuditConfiguration = dict["MediaAuditConfiguration"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("MediaType") && dict["MediaType"] != nil {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAIMediaAuditJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAIMediaAuditJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAIMediaAuditJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitAIMediaAuditJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDigitalWatermarkExtractJobRequest : Tea.TeaModel {
    public var extractType: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extractType != nil {
            map["ExtractType"] = self.extractType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtractType") && dict["ExtractType"] != nil {
            self.extractType = dict["ExtractType"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SubmitDigitalWatermarkExtractJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDigitalWatermarkExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDigitalWatermarkExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitDigitalWatermarkExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitDynamicImageJobRequest : Tea.TeaModel {
    public var dynamicImageTemplateId: String?

    public var overrideParams: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageTemplateId != nil {
            map["DynamicImageTemplateId"] = self.dynamicImageTemplateId!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageTemplateId") && dict["DynamicImageTemplateId"] != nil {
            self.dynamicImageTemplateId = dict["DynamicImageTemplateId"] as! String
        }
        if dict.keys.contains("OverrideParams") && dict["OverrideParams"] != nil {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponseBody : Tea.TeaModel {
    public class DynamicImageJob : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var dynamicImageJob: SubmitDynamicImageJobResponseBody.DynamicImageJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dynamicImageJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicImageJob != nil {
            map["DynamicImageJob"] = self.dynamicImageJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicImageJob") && dict["DynamicImageJob"] != nil {
            var model = SubmitDynamicImageJobResponseBody.DynamicImageJob()
            model.fromMap(dict["DynamicImageJob"] as! [String: Any])
            self.dynamicImageJob = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitDynamicImageJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitDynamicImageJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitDynamicImageJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaDNADeleteJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
    }
}

public class SubmitMediaDNADeleteJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaDNADeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaDNADeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitMediaDNADeleteJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitPreprocessJobsRequest : Tea.TeaModel {
    public var preprocessType: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preprocessType != nil {
            map["PreprocessType"] = self.preprocessType!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreprocessType") && dict["PreprocessType"] != nil {
            self.preprocessType = dict["PreprocessType"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitPreprocessJobsResponseBody : Tea.TeaModel {
    public class PreprocessJobs : Tea.TeaModel {
        public class PreprocessJob : Tea.TeaModel {
            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public var preprocessJob: [SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preprocessJob != nil {
                var tmp : [Any] = []
                for k in self.preprocessJob! {
                    tmp.append(k.toMap())
                }
                map["PreprocessJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreprocessJob") && dict["PreprocessJob"] != nil {
                var tmp : [SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob] = []
                for v in dict["PreprocessJob"] as! [Any] {
                    var model = SubmitPreprocessJobsResponseBody.PreprocessJobs.PreprocessJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preprocessJob = tmp
            }
        }
    }
    public var preprocessJobs: SubmitPreprocessJobsResponseBody.PreprocessJobs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preprocessJobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preprocessJobs != nil {
            map["PreprocessJobs"] = self.preprocessJobs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PreprocessJobs") && dict["PreprocessJobs"] != nil {
            var model = SubmitPreprocessJobsResponseBody.PreprocessJobs()
            model.fromMap(dict["PreprocessJobs"] as! [String: Any])
            self.preprocessJobs = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitPreprocessJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitPreprocessJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitPreprocessJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public var count: Int64?

    public var height: String?

    public var interval: Int64?

    public var snapshotTemplateId: String?

    public var specifiedOffsetTime: Int64?

    public var specifiedOffsetTimes: [Int64]?

    public var spriteSnapshotConfig: String?

    public var userData: String?

    public var videoId: String?

    public var width: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.snapshotTemplateId != nil {
            map["SnapshotTemplateId"] = self.snapshotTemplateId!
        }
        if self.specifiedOffsetTime != nil {
            map["SpecifiedOffsetTime"] = self.specifiedOffsetTime!
        }
        if self.specifiedOffsetTimes != nil {
            map["SpecifiedOffsetTimes"] = self.specifiedOffsetTimes!
        }
        if self.spriteSnapshotConfig != nil {
            map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("Height") && dict["Height"] != nil {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("SnapshotTemplateId") && dict["SnapshotTemplateId"] != nil {
            self.snapshotTemplateId = dict["SnapshotTemplateId"] as! String
        }
        if dict.keys.contains("SpecifiedOffsetTime") && dict["SpecifiedOffsetTime"] != nil {
            self.specifiedOffsetTime = dict["SpecifiedOffsetTime"] as! Int64
        }
        if dict.keys.contains("SpecifiedOffsetTimes") && dict["SpecifiedOffsetTimes"] != nil {
            self.specifiedOffsetTimes = dict["SpecifiedOffsetTimes"] as! [Int64]
        }
        if dict.keys.contains("SpriteSnapshotConfig") && dict["SpriteSnapshotConfig"] != nil {
            self.spriteSnapshotConfig = dict["SpriteSnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
        if dict.keys.contains("Width") && dict["Width"] != nil {
            self.width = dict["Width"] as! String
        }
    }
}

public class SubmitSnapshotJobShrinkRequest : Tea.TeaModel {
    public var count: Int64?

    public var height: String?

    public var interval: Int64?

    public var snapshotTemplateId: String?

    public var specifiedOffsetTime: Int64?

    public var specifiedOffsetTimesShrink: String?

    public var spriteSnapshotConfig: String?

    public var userData: String?

    public var videoId: String?

    public var width: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.snapshotTemplateId != nil {
            map["SnapshotTemplateId"] = self.snapshotTemplateId!
        }
        if self.specifiedOffsetTime != nil {
            map["SpecifiedOffsetTime"] = self.specifiedOffsetTime!
        }
        if self.specifiedOffsetTimesShrink != nil {
            map["SpecifiedOffsetTimes"] = self.specifiedOffsetTimesShrink!
        }
        if self.spriteSnapshotConfig != nil {
            map["SpriteSnapshotConfig"] = self.spriteSnapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int64
        }
        if dict.keys.contains("Height") && dict["Height"] != nil {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("SnapshotTemplateId") && dict["SnapshotTemplateId"] != nil {
            self.snapshotTemplateId = dict["SnapshotTemplateId"] as! String
        }
        if dict.keys.contains("SpecifiedOffsetTime") && dict["SpecifiedOffsetTime"] != nil {
            self.specifiedOffsetTime = dict["SpecifiedOffsetTime"] as! Int64
        }
        if dict.keys.contains("SpecifiedOffsetTimes") && dict["SpecifiedOffsetTimes"] != nil {
            self.specifiedOffsetTimesShrink = dict["SpecifiedOffsetTimes"] as! String
        }
        if dict.keys.contains("SpriteSnapshotConfig") && dict["SpriteSnapshotConfig"] != nil {
            self.spriteSnapshotConfig = dict["SpriteSnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
        if dict.keys.contains("Width") && dict["Width"] != nil {
            self.width = dict["Width"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: SubmitSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") && dict["SnapshotJob"] != nil {
            var model = SubmitSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTranscodeJobsRequest : Tea.TeaModel {
    public var encryptConfig: String?

    public var overrideParams: String?

    public var pipelineId: String?

    public var priority: String?

    public var templateGroupId: String?

    public var userData: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encryptConfig != nil {
            map["EncryptConfig"] = self.encryptConfig!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EncryptConfig") && dict["EncryptConfig"] != nil {
            self.encryptConfig = dict["EncryptConfig"] as! String
        }
        if dict.keys.contains("OverrideParams") && dict["OverrideParams"] != nil {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("PipelineId") && dict["PipelineId"] != nil {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class SubmitTranscodeJobsResponseBody : Tea.TeaModel {
    public class TranscodeJobs : Tea.TeaModel {
        public class TranscodeJob : Tea.TeaModel {
            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public var transcodeJob: [SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeJob != nil {
                var tmp : [Any] = []
                for k in self.transcodeJob! {
                    tmp.append(k.toMap())
                }
                map["TranscodeJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeJob") && dict["TranscodeJob"] != nil {
                var tmp : [SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob] = []
                for v in dict["TranscodeJob"] as! [Any] {
                    var model = SubmitTranscodeJobsResponseBody.TranscodeJobs.TranscodeJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transcodeJob = tmp
            }
        }
    }
    public var requestId: String?

    public var transcodeJobs: SubmitTranscodeJobsResponseBody.TranscodeJobs?

    public var transcodeTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeJobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeJobs != nil {
            map["TranscodeJobs"] = self.transcodeJobs?.toMap()
        }
        if self.transcodeTaskId != nil {
            map["TranscodeTaskId"] = self.transcodeTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeJobs") && dict["TranscodeJobs"] != nil {
            var model = SubmitTranscodeJobsResponseBody.TranscodeJobs()
            model.fromMap(dict["TranscodeJobs"] as! [String: Any])
            self.transcodeJobs = model
        }
        if dict.keys.contains("TranscodeTaskId") && dict["TranscodeTaskId"] != nil {
            self.transcodeTaskId = dict["TranscodeTaskId"] as! String
        }
    }
}

public class SubmitTranscodeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTranscodeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitTranscodeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitWorkflowJobRequest : Tea.TeaModel {
    public var mediaId: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class SubmitWorkflowJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitWorkflowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitWorkflowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitWorkflowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAITemplateRequest : Tea.TeaModel {
    public var templateConfig: String?

    public var templateId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class UpdateAITemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateAITemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAITemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAITemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var description_: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateAppInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAttachedMediaInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") && dict["UpdateContent"] != nil {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateAttachedMediaInfosResponseBody : Tea.TeaModel {
    public var nonExistMediaIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistMediaIds") && dict["NonExistMediaIds"] != nil {
            self.nonExistMediaIds = dict["NonExistMediaIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAttachedMediaInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAttachedMediaInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAttachedMediaInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var cateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CateName") && dict["CateName"] != nil {
            self.cateName = dict["CateName"] as! String
        }
    }
}

public class UpdateCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEditingProjectRequest : Tea.TeaModel {
    public var coverURL: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var projectId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: String?

    public var timeline: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeline != nil {
            map["Timeline"] = self.timeline!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") && dict["OwnerAccount"] != nil {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") && dict["ResourceOwnerAccount"] != nil {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! String
        }
        if dict.keys.contains("Timeline") && dict["Timeline"] != nil {
            self.timeline = dict["Timeline"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateEditingProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEditingProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEditingProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEditingProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") && dict["UpdateContent"] != nil {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateImageInfosResponseBody : Tea.TeaModel {
    public class NonExistImageIds : Tea.TeaModel {
        public var imageId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! [String]
            }
        }
    }
    public var nonExistImageIds: UpdateImageInfosResponseBody.NonExistImageIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistImageIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistImageIds != nil {
            map["NonExistImageIds"] = self.nonExistImageIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistImageIds") && dict["NonExistImageIds"] != nil {
            var model = UpdateImageInfosResponseBody.NonExistImageIds()
            model.fromMap(dict["NonExistImageIds"] as! [String: Any])
            self.nonExistImageIds = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaStorageClassRequest : Tea.TeaModel {
    public var allowUpdateWithoutTimeLimit: Bool?

    public var mediaIds: String?

    public var restoreTier: String?

    public var scope: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowUpdateWithoutTimeLimit != nil {
            map["AllowUpdateWithoutTimeLimit"] = self.allowUpdateWithoutTimeLimit!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.restoreTier != nil {
            map["RestoreTier"] = self.restoreTier!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowUpdateWithoutTimeLimit") && dict["AllowUpdateWithoutTimeLimit"] != nil {
            self.allowUpdateWithoutTimeLimit = dict["AllowUpdateWithoutTimeLimit"] as! Bool
        }
        if dict.keys.contains("MediaIds") && dict["MediaIds"] != nil {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("RestoreTier") && dict["RestoreTier"] != nil {
            self.restoreTier = dict["RestoreTier"] as! String
        }
        if dict.keys.contains("Scope") && dict["Scope"] != nil {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class UpdateMediaStorageClassResponseBody : Tea.TeaModel {
    public class ForbiddenList : Tea.TeaModel {
        public class MediaForbiddenReasonDTO : Tea.TeaModel {
            public var mediaId: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("Reason") && dict["Reason"] != nil {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var mediaForbiddenReasonDTO: [UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaForbiddenReasonDTO != nil {
                var tmp : [Any] = []
                for k in self.mediaForbiddenReasonDTO! {
                    tmp.append(k.toMap())
                }
                map["MediaForbiddenReasonDTO"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaForbiddenReasonDTO") && dict["MediaForbiddenReasonDTO"] != nil {
                var tmp : [UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO] = []
                for v in dict["MediaForbiddenReasonDTO"] as! [Any] {
                    var model = UpdateMediaStorageClassResponseBody.ForbiddenList.MediaForbiddenReasonDTO()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaForbiddenReasonDTO = tmp
            }
        }
    }
    public class IgnoredList : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var forbiddenList: UpdateMediaStorageClassResponseBody.ForbiddenList?

    public var ignoredList: UpdateMediaStorageClassResponseBody.IgnoredList?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forbiddenList?.validate()
        try self.ignoredList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenList != nil {
            map["ForbiddenList"] = self.forbiddenList?.toMap()
        }
        if self.ignoredList != nil {
            map["IgnoredList"] = self.ignoredList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenList") && dict["ForbiddenList"] != nil {
            var model = UpdateMediaStorageClassResponseBody.ForbiddenList()
            model.fromMap(dict["ForbiddenList"] as! [String: Any])
            self.forbiddenList = model
        }
        if dict.keys.contains("IgnoredList") && dict["IgnoredList"] != nil {
            var model = UpdateMediaStorageClassResponseBody.IgnoredList()
            model.fromMap(dict["IgnoredList"] as! [String: Any])
            self.ignoredList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateMediaStorageClassResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaStorageClassResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMediaStorageClassResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTranscodeTemplateGroupRequest : Tea.TeaModel {
    public var locked: String?

    public var name: String?

    public var transcodeTemplateGroupId: String?

    public var transcodeTemplateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.locked != nil {
            map["Locked"] = self.locked!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        if self.transcodeTemplateList != nil {
            map["TranscodeTemplateList"] = self.transcodeTemplateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Locked") && dict["Locked"] != nil {
            self.locked = dict["Locked"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateList") && dict["TranscodeTemplateList"] != nil {
            self.transcodeTemplateList = dict["TranscodeTemplateList"] as! String
        }
    }
}

public class UpdateTranscodeTemplateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var transcodeTemplateGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeTemplateGroupId != nil {
            map["TranscodeTemplateGroupId"] = self.transcodeTemplateGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeTemplateGroupId") && dict["TranscodeTemplateGroupId"] != nil {
            self.transcodeTemplateGroupId = dict["TranscodeTemplateGroupId"] as! String
        }
    }
}

public class UpdateTranscodeTemplateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTranscodeTemplateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateTranscodeTemplateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVideoInfoRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var tags: String?

    public var title: String?

    public var videoId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.videoId != nil {
            map["VideoId"] = self.videoId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") && dict["CateId"] != nil {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") && dict["CoverURL"] != nil {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("VideoId") && dict["VideoId"] != nil {
            self.videoId = dict["VideoId"] as! String
        }
    }
}

public class UpdateVideoInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVideoInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVideoInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateVideoInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVideoInfosRequest : Tea.TeaModel {
    public var updateContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateContent != nil {
            map["UpdateContent"] = self.updateContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateContent") && dict["UpdateContent"] != nil {
            self.updateContent = dict["UpdateContent"] as! String
        }
    }
}

public class UpdateVideoInfosResponseBody : Tea.TeaModel {
    public var forbiddenVideoIds: [String]?

    public var nonExistVideoIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forbiddenVideoIds != nil {
            map["ForbiddenVideoIds"] = self.forbiddenVideoIds!
        }
        if self.nonExistVideoIds != nil {
            map["NonExistVideoIds"] = self.nonExistVideoIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForbiddenVideoIds") && dict["ForbiddenVideoIds"] != nil {
            self.forbiddenVideoIds = dict["ForbiddenVideoIds"] as! [String]
        }
        if dict.keys.contains("NonExistVideoIds") && dict["NonExistVideoIds"] != nil {
            self.nonExistVideoIds = dict["NonExistVideoIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVideoInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVideoInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateVideoInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVodDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sources: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sources != nil {
            map["Sources"] = self.sources!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") && dict["SecurityToken"] != nil {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sources") && dict["Sources"] != nil {
            self.sources = dict["Sources"] as! String
        }
        if dict.keys.contains("TopLevelDomain") && dict["TopLevelDomain"] != nil {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class UpdateVodDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateVodDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVodDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateVodDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVodTemplateRequest : Tea.TeaModel {
    public var name: String?

    public var templateConfig: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("TemplateConfig") && dict["TemplateConfig"] != nil {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class UpdateVodTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vodTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vodTemplateId != nil {
            map["VodTemplateId"] = self.vodTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VodTemplateId") && dict["VodTemplateId"] != nil {
            self.vodTemplateId = dict["VodTemplateId"] as! String
        }
    }
}

public class UpdateVodTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVodTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateVodTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWatermarkRequest : Tea.TeaModel {
    public var name: String?

    public var watermarkConfig: String?

    public var watermarkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.watermarkConfig != nil {
            map["WatermarkConfig"] = self.watermarkConfig!
        }
        if self.watermarkId != nil {
            map["WatermarkId"] = self.watermarkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
            self.watermarkConfig = dict["WatermarkConfig"] as! String
        }
        if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
            self.watermarkId = dict["WatermarkId"] as! String
        }
    }
}

public class UpdateWatermarkResponseBody : Tea.TeaModel {
    public class WatermarkInfo : Tea.TeaModel {
        public var creationTime: String?

        public var fileUrl: String?

        public var isDefault: String?

        public var name: String?

        public var type: String?

        public var watermarkConfig: String?

        public var watermarkId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.watermarkConfig != nil {
                map["WatermarkConfig"] = self.watermarkConfig!
            }
            if self.watermarkId != nil {
                map["WatermarkId"] = self.watermarkId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WatermarkConfig") && dict["WatermarkConfig"] != nil {
                self.watermarkConfig = dict["WatermarkConfig"] as! String
            }
            if dict.keys.contains("WatermarkId") && dict["WatermarkId"] != nil {
                self.watermarkId = dict["WatermarkId"] as! String
            }
        }
    }
    public var requestId: String?

    public var watermarkInfo: UpdateWatermarkResponseBody.WatermarkInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkInfo != nil {
            map["WatermarkInfo"] = self.watermarkInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkInfo") && dict["WatermarkInfo"] != nil {
            var model = UpdateWatermarkResponseBody.WatermarkInfo()
            model.fromMap(dict["WatermarkInfo"] as! [String: Any])
            self.watermarkInfo = model
        }
    }
}

public class UpdateWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMediaByURLRequest : Tea.TeaModel {
    public var appId: String?

    public var sessionId: String?

    public var storageLocation: String?

    public var templateGroupId: String?

    public var uploadMetadatas: String?

    public var uploadURLs: String?

    public var userData: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.templateGroupId != nil {
            map["TemplateGroupId"] = self.templateGroupId!
        }
        if self.uploadMetadatas != nil {
            map["UploadMetadatas"] = self.uploadMetadatas!
        }
        if self.uploadURLs != nil {
            map["UploadURLs"] = self.uploadURLs!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("SessionId") && dict["SessionId"] != nil {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("StorageLocation") && dict["StorageLocation"] != nil {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("TemplateGroupId") && dict["TemplateGroupId"] != nil {
            self.templateGroupId = dict["TemplateGroupId"] as! String
        }
        if dict.keys.contains("UploadMetadatas") && dict["UploadMetadatas"] != nil {
            self.uploadMetadatas = dict["UploadMetadatas"] as! String
        }
        if dict.keys.contains("UploadURLs") && dict["UploadURLs"] != nil {
            self.uploadURLs = dict["UploadURLs"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class UploadMediaByURLResponseBody : Tea.TeaModel {
    public class UploadJobs : Tea.TeaModel {
        public var jobId: String?

        public var sourceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.sourceURL != nil {
                map["SourceURL"] = self.sourceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("SourceURL") && dict["SourceURL"] != nil {
                self.sourceURL = dict["SourceURL"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadJobs: [UploadMediaByURLResponseBody.UploadJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadJobs != nil {
            var tmp : [Any] = []
            for k in self.uploadJobs! {
                tmp.append(k.toMap())
            }
            map["UploadJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadJobs") && dict["UploadJobs"] != nil {
            var tmp : [UploadMediaByURLResponseBody.UploadJobs] = []
            for v in dict["UploadJobs"] as! [Any] {
                var model = UploadMediaByURLResponseBody.UploadJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadJobs = tmp
        }
    }
}

public class UploadMediaByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMediaByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMediaByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadStreamByURLRequest : Tea.TeaModel {
    public var definition: String?

    public var fileExtension: String?

    public var HDRType: String?

    public var mediaId: String?

    public var streamURL: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.fileExtension != nil {
            map["FileExtension"] = self.fileExtension!
        }
        if self.HDRType != nil {
            map["HDRType"] = self.HDRType!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("FileExtension") && dict["FileExtension"] != nil {
            self.fileExtension = dict["FileExtension"] as! String
        }
        if dict.keys.contains("HDRType") && dict["HDRType"] != nil {
            self.HDRType = dict["HDRType"] as! String
        }
        if dict.keys.contains("MediaId") && dict["MediaId"] != nil {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("StreamURL") && dict["StreamURL"] != nil {
            self.streamURL = dict["StreamURL"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class UploadStreamByURLResponseBody : Tea.TeaModel {
    public var fileURL: String?

    public var requestId: String?

    public var sourceURL: String?

    public var streamJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceURL != nil {
            map["SourceURL"] = self.sourceURL!
        }
        if self.streamJobId != nil {
            map["StreamJobId"] = self.streamJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURL") && dict["FileURL"] != nil {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceURL") && dict["SourceURL"] != nil {
            self.sourceURL = dict["SourceURL"] as! String
        }
        if dict.keys.contains("StreamJobId") && dict["StreamJobId"] != nil {
            self.streamJobId = dict["StreamJobId"] as! String
        }
    }
}

public class UploadStreamByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadStreamByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadStreamByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyVodDomainOwnerRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var verifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.verifyType != nil {
            map["VerifyType"] = self.verifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("VerifyType") && dict["VerifyType"] != nil {
            self.verifyType = dict["VerifyType"] as! String
        }
    }
}

public class VerifyVodDomainOwnerResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyVodDomainOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyVodDomainOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyVodDomainOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
