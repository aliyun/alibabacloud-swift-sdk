import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AiotDevice : Tea.TeaModel {
    public var IPAddr: String?

    public var latitude: Double?

    public var longitude: Double?

    public var name: String?

    public var place: String?

    public var port: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IPAddr != nil {
            map["IPAddr"] = self.IPAddr!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.place != nil {
            map["Place"] = self.place!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IPAddr") {
            self.IPAddr = dict["IPAddr"] as! String
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! Double
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! Double
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Place") {
            self.place = dict["Place"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int64
        }
    }
}

public class AddAiotDevicesRequest : Tea.TeaModel {
    public class AiotDeviceList : Tea.TeaModel {
        public var corpId: String?

        public var deviceId: String?

        public var IPAddr: String?

        public var latitude: Double?

        public var longitude: Double?

        public var name: String?

        public var place: String?

        public var port: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.IPAddr != nil {
                map["IPAddr"] = self.IPAddr!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.place != nil {
                map["Place"] = self.place!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("IPAddr") {
                self.IPAddr = dict["IPAddr"] as! String
            }
            if dict.keys.contains("Latitude") {
                self.latitude = dict["Latitude"] as! Double
            }
            if dict.keys.contains("Longitude") {
                self.longitude = dict["Longitude"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Place") {
                self.place = dict["Place"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int64
            }
        }
    }
    public var aiotDeviceList: [AddAiotDevicesRequest.AiotDeviceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDeviceList != nil {
            var tmp : [Any] = []
            for k in self.aiotDeviceList! {
                tmp.append(k.toMap())
            }
            map["AiotDeviceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDeviceList") {
            self.aiotDeviceList = dict["AiotDeviceList"] as! [AddAiotDevicesRequest.AiotDeviceList]
        }
    }
}

public class AddAiotDevicesShrinkRequest : Tea.TeaModel {
    public var aiotDeviceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDeviceListShrink != nil {
            map["AiotDeviceList"] = self.aiotDeviceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDeviceList") {
            self.aiotDeviceListShrink = dict["AiotDeviceList"] as! String
        }
    }
}

public class AddAiotDevicesResponseBody : Tea.TeaModel {
    public class ResultList : Tea.TeaModel {
        public var code: String?

        public var deviceId: String?

        public var id: String?

        public var message: String?

        public var password: String?

        public var serverHost: String?

        public var serverHostInternal: String?

        public var serverId: String?

        public var serverIp: String?

        public var serverIpInternal: String?

        public var serverPort: String?

        public var serverWssPort: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.serverHost != nil {
                map["ServerHost"] = self.serverHost!
            }
            if self.serverHostInternal != nil {
                map["ServerHostInternal"] = self.serverHostInternal!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverIpInternal != nil {
                map["ServerIpInternal"] = self.serverIpInternal!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.serverWssPort != nil {
                map["ServerWssPort"] = self.serverWssPort!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("ServerHost") {
                self.serverHost = dict["ServerHost"] as! String
            }
            if dict.keys.contains("ServerHostInternal") {
                self.serverHostInternal = dict["ServerHostInternal"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerIpInternal") {
                self.serverIpInternal = dict["ServerIpInternal"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! String
            }
            if dict.keys.contains("ServerWssPort") {
                self.serverWssPort = dict["ServerWssPort"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resultList: [AddAiotDevicesResponseBody.ResultList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultList != nil {
            var tmp : [Any] = []
            for k in self.resultList! {
                tmp.append(k.toMap())
            }
            map["ResultList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultList") {
            self.resultList = dict["ResultList"] as! [AddAiotDevicesResponseBody.ResultList]
        }
    }
}

public class AddAiotDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAiotDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAiotDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAiotPersonTableRequest : Tea.TeaModel {
    public class PersonTable : Tea.TeaModel {
        public var name: String?

        public var personTableId: String?

        public var type: Int64?

        public var verificationModelList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.verificationModelList != nil {
                map["VerificationModelList"] = self.verificationModelList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
            if dict.keys.contains("VerificationModelList") {
                self.verificationModelList = dict["VerificationModelList"] as! [Int64]
            }
        }
    }
    public var id: String?

    public var personTable: AddAiotPersonTableRequest.PersonTable?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTable?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTable != nil {
            map["PersonTable"] = self.personTable?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTable") {
            var model = AddAiotPersonTableRequest.PersonTable()
            model.fromMap(dict["PersonTable"] as! [String: Any])
            self.personTable = model
        }
    }
}

public class AddAiotPersonTableResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var personTableId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAiotPersonTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAiotPersonTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAiotPersonTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAiotPersonTableItemsRequest : Tea.TeaModel {
    public class PersonTableItemList : Tea.TeaModel {
        public class IdentificationList : Tea.TeaModel {
            public var number: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public class ImageList : Tea.TeaModel {
            public class FeatureInfo : Tea.TeaModel {
                public var algorithmType: String?

                public var algorithmVersion: String?

                public var featureData: String?

                public var imageId: String?

                public var objectId: String?

                public var tabIed: String?

                public var vendor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithmType != nil {
                        map["AlgorithmType"] = self.algorithmType!
                    }
                    if self.algorithmVersion != nil {
                        map["AlgorithmVersion"] = self.algorithmVersion!
                    }
                    if self.featureData != nil {
                        map["FeatureData"] = self.featureData!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.objectId != nil {
                        map["ObjectId"] = self.objectId!
                    }
                    if self.tabIed != nil {
                        map["TabIed"] = self.tabIed!
                    }
                    if self.vendor != nil {
                        map["Vendor"] = self.vendor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlgorithmType") {
                        self.algorithmType = dict["AlgorithmType"] as! String
                    }
                    if dict.keys.contains("AlgorithmVersion") {
                        self.algorithmVersion = dict["AlgorithmVersion"] as! String
                    }
                    if dict.keys.contains("FeatureData") {
                        self.featureData = dict["FeatureData"] as! String
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ObjectId") {
                        self.objectId = dict["ObjectId"] as! String
                    }
                    if dict.keys.contains("TabIed") {
                        self.tabIed = dict["TabIed"] as! String
                    }
                    if dict.keys.contains("Vendor") {
                        self.vendor = dict["Vendor"] as! String
                    }
                }
            }
            public var data: String?

            public var deviceId: String?

            public var eventSort: String?

            public var featureInfo: AddAiotPersonTableItemsRequest.PersonTableItemList.ImageList.FeatureInfo?

            public var fileFormat: String?

            public var height: Int64?

            public var imageId: String?

            public var shotTime: String?

            public var size: Int64?

            public var storagePath: String?

            public var type: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.featureInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.eventSort != nil {
                    map["EventSort"] = self.eventSort!
                }
                if self.featureInfo != nil {
                    map["FeatureInfo"] = self.featureInfo?.toMap()
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.storagePath != nil {
                    map["StoragePath"] = self.storagePath!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("EventSort") {
                    self.eventSort = dict["EventSort"] as! String
                }
                if dict.keys.contains("FeatureInfo") {
                    var model = AddAiotPersonTableItemsRequest.PersonTableItemList.ImageList.FeatureInfo()
                    model.fromMap(dict["FeatureInfo"] as! [String: Any])
                    self.featureInfo = model
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("StoragePath") {
                    self.storagePath = dict["StoragePath"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var identificationList: [AddAiotPersonTableItemsRequest.PersonTableItemList.IdentificationList]?

        public var identificationNum: Int64?

        public var imageList: [AddAiotPersonTableItemsRequest.PersonTableItemList.ImageList]?

        public var imageNum: Int64?

        public var personCode: String?

        public var personId: String?

        public var personName: String?

        public var remarks: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identificationList != nil {
                var tmp : [Any] = []
                for k in self.identificationList! {
                    tmp.append(k.toMap())
                }
                map["IdentificationList"] = tmp
            }
            if self.identificationNum != nil {
                map["IdentificationNum"] = self.identificationNum!
            }
            if self.imageList != nil {
                var tmp : [Any] = []
                for k in self.imageList! {
                    tmp.append(k.toMap())
                }
                map["ImageList"] = tmp
            }
            if self.imageNum != nil {
                map["ImageNum"] = self.imageNum!
            }
            if self.personCode != nil {
                map["PersonCode"] = self.personCode!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.personName != nil {
                map["PersonName"] = self.personName!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdentificationList") {
                self.identificationList = dict["IdentificationList"] as! [AddAiotPersonTableItemsRequest.PersonTableItemList.IdentificationList]
            }
            if dict.keys.contains("IdentificationNum") {
                self.identificationNum = dict["IdentificationNum"] as! Int64
            }
            if dict.keys.contains("ImageList") {
                self.imageList = dict["ImageList"] as! [AddAiotPersonTableItemsRequest.PersonTableItemList.ImageList]
            }
            if dict.keys.contains("ImageNum") {
                self.imageNum = dict["ImageNum"] as! Int64
            }
            if dict.keys.contains("PersonCode") {
                self.personCode = dict["PersonCode"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PersonName") {
                self.personName = dict["PersonName"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
        }
    }
    public var id: String?

    public var personTableId: String?

    public var personTableItemList: [AddAiotPersonTableItemsRequest.PersonTableItemList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        if self.personTableItemList != nil {
            var tmp : [Any] = []
            for k in self.personTableItemList! {
                tmp.append(k.toMap())
            }
            map["PersonTableItemList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
        if dict.keys.contains("PersonTableItemList") {
            self.personTableItemList = dict["PersonTableItemList"] as! [AddAiotPersonTableItemsRequest.PersonTableItemList]
        }
    }
}

public class AddAiotPersonTableItemsResponseBody : Tea.TeaModel {
    public class ResultList : Tea.TeaModel {
        public var code: String?

        public var message: String?

        public var personTableItemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.personTableItemId != nil {
                map["PersonTableItemId"] = self.personTableItemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PersonTableItemId") {
                self.personTableItemId = dict["PersonTableItemId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resultList: [AddAiotPersonTableItemsResponseBody.ResultList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultList != nil {
            var tmp : [Any] = []
            for k in self.resultList! {
                tmp.append(k.toMap())
            }
            map["ResultList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultList") {
            self.resultList = dict["ResultList"] as! [AddAiotPersonTableItemsResponseBody.ResultList]
        }
    }
}

public class AddAiotPersonTableItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAiotPersonTableItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAiotPersonTableItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAiotPersonTableItemsForTablesRequest : Tea.TeaModel {
    public class PersonTableItemList : Tea.TeaModel {
        public class IdentificationList : Tea.TeaModel {
            public var number: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public class ImageList : Tea.TeaModel {
            public class FeatureInfo : Tea.TeaModel {
                public var algorithmType: String?

                public var algorithmVersion: String?

                public var featureData: String?

                public var imageId: String?

                public var objectId: String?

                public var tabIed: String?

                public var vendor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithmType != nil {
                        map["AlgorithmType"] = self.algorithmType!
                    }
                    if self.algorithmVersion != nil {
                        map["AlgorithmVersion"] = self.algorithmVersion!
                    }
                    if self.featureData != nil {
                        map["FeatureData"] = self.featureData!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.objectId != nil {
                        map["ObjectId"] = self.objectId!
                    }
                    if self.tabIed != nil {
                        map["TabIed"] = self.tabIed!
                    }
                    if self.vendor != nil {
                        map["Vendor"] = self.vendor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlgorithmType") {
                        self.algorithmType = dict["AlgorithmType"] as! String
                    }
                    if dict.keys.contains("AlgorithmVersion") {
                        self.algorithmVersion = dict["AlgorithmVersion"] as! String
                    }
                    if dict.keys.contains("FeatureData") {
                        self.featureData = dict["FeatureData"] as! String
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ObjectId") {
                        self.objectId = dict["ObjectId"] as! String
                    }
                    if dict.keys.contains("TabIed") {
                        self.tabIed = dict["TabIed"] as! String
                    }
                    if dict.keys.contains("Vendor") {
                        self.vendor = dict["Vendor"] as! String
                    }
                }
            }
            public var data: String?

            public var deviceId: String?

            public var eventSort: String?

            public var featureInfo: AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.ImageList.FeatureInfo?

            public var fileFormat: String?

            public var height: Int64?

            public var imageId: String?

            public var shotTime: String?

            public var size: Int64?

            public var storagePath: String?

            public var type: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.featureInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.eventSort != nil {
                    map["EventSort"] = self.eventSort!
                }
                if self.featureInfo != nil {
                    map["FeatureInfo"] = self.featureInfo?.toMap()
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.storagePath != nil {
                    map["StoragePath"] = self.storagePath!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("EventSort") {
                    self.eventSort = dict["EventSort"] as! String
                }
                if dict.keys.contains("FeatureInfo") {
                    var model = AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.ImageList.FeatureInfo()
                    model.fromMap(dict["FeatureInfo"] as! [String: Any])
                    self.featureInfo = model
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("StoragePath") {
                    self.storagePath = dict["StoragePath"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var identificationList: [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.IdentificationList]?

        public var identificationNum: Int64?

        public var imageList: [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.ImageList]?

        public var imageNum: Int64?

        public var personCode: String?

        public var personId: String?

        public var personName: String?

        public var remarks: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identificationList != nil {
                var tmp : [Any] = []
                for k in self.identificationList! {
                    tmp.append(k.toMap())
                }
                map["IdentificationList"] = tmp
            }
            if self.identificationNum != nil {
                map["IdentificationNum"] = self.identificationNum!
            }
            if self.imageList != nil {
                var tmp : [Any] = []
                for k in self.imageList! {
                    tmp.append(k.toMap())
                }
                map["ImageList"] = tmp
            }
            if self.imageNum != nil {
                map["ImageNum"] = self.imageNum!
            }
            if self.personCode != nil {
                map["PersonCode"] = self.personCode!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.personName != nil {
                map["PersonName"] = self.personName!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdentificationList") {
                self.identificationList = dict["IdentificationList"] as! [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.IdentificationList]
            }
            if dict.keys.contains("IdentificationNum") {
                self.identificationNum = dict["IdentificationNum"] as! Int64
            }
            if dict.keys.contains("ImageList") {
                self.imageList = dict["ImageList"] as! [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList.ImageList]
            }
            if dict.keys.contains("ImageNum") {
                self.imageNum = dict["ImageNum"] as! Int64
            }
            if dict.keys.contains("PersonCode") {
                self.personCode = dict["PersonCode"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PersonName") {
                self.personName = dict["PersonName"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
        }
    }
    public class PersonTableList : Tea.TeaModel {
        public var id: String?

        public var personTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
        }
    }
    public var personTableItemList: [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList]?

    public var personTableList: [AddAiotPersonTableItemsForTablesRequest.PersonTableList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.personTableItemList != nil {
            var tmp : [Any] = []
            for k in self.personTableItemList! {
                tmp.append(k.toMap())
            }
            map["PersonTableItemList"] = tmp
        }
        if self.personTableList != nil {
            var tmp : [Any] = []
            for k in self.personTableList! {
                tmp.append(k.toMap())
            }
            map["PersonTableList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PersonTableItemList") {
            self.personTableItemList = dict["PersonTableItemList"] as! [AddAiotPersonTableItemsForTablesRequest.PersonTableItemList]
        }
        if dict.keys.contains("PersonTableList") {
            self.personTableList = dict["PersonTableList"] as! [AddAiotPersonTableItemsForTablesRequest.PersonTableList]
        }
    }
}

public class AddAiotPersonTableItemsForTablesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAiotPersonTableItemsForTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAiotPersonTableItemsForTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAiotPersonTableItemsForTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAiotVehicleTableItemsRequest : Tea.TeaModel {
    public class VehicleTableItem : Tea.TeaModel {
        public var beginTime: String?

        public var endTime: String?

        public var ownerName: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var remarks: String?

        public var vehicleTableItemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginTime != nil {
                map["BeginTime"] = self.beginTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            if self.vehicleTableItemId != nil {
                map["VehicleTableItemId"] = self.vehicleTableItemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginTime") {
                self.beginTime = dict["BeginTime"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
            if dict.keys.contains("VehicleTableItemId") {
                self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
            }
        }
    }
    public var id: String?

    public var vehicleTableId: String?

    public var vehicleTableItem: AddAiotVehicleTableItemsRequest.VehicleTableItem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vehicleTableItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItem != nil {
            map["VehicleTableItem"] = self.vehicleTableItem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItem") {
            var model = AddAiotVehicleTableItemsRequest.VehicleTableItem()
            model.fromMap(dict["VehicleTableItem"] as! [String: Any])
            self.vehicleTableItem = model
        }
    }
}

public class AddAiotVehicleTableItemsShrinkRequest : Tea.TeaModel {
    public var id: String?

    public var vehicleTableId: String?

    public var vehicleTableItemShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItemShrink != nil {
            map["VehicleTableItem"] = self.vehicleTableItemShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItem") {
            self.vehicleTableItemShrink = dict["VehicleTableItem"] as! String
        }
    }
}

public class AddAiotVehicleTableItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAiotVehicleTableItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAiotVehicleTableItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAiotVehicleTableItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCameraForInstanceRequest : Tea.TeaModel {
    public var cameraIds: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cameraIds != nil {
            map["CameraIds"] = self.cameraIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CameraIds") {
            self.cameraIds = dict["CameraIds"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCameraForInstanceShrinkRequest : Tea.TeaModel {
    public var cameraIdsShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cameraIdsShrink != nil {
            map["CameraIds"] = self.cameraIdsShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CameraIds") {
            self.cameraIdsShrink = dict["CameraIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCameraForInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCameraForInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCameraForInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCameraForInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddChannelRequest : Tea.TeaModel {
    public var parentDeviceGbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parentDeviceGbId != nil {
            map["ParentDeviceGbId"] = self.parentDeviceGbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ParentDeviceGbId") {
            self.parentDeviceGbId = dict["ParentDeviceGbId"] as! String
        }
    }
}

public class AddChannelResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDataSourceRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceName: String?

    public var dataSourceType: String?

    public var description_: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceName != nil {
            map["DataSourceName"] = self.dataSourceName!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceName") {
            self.dataSourceName = dict["DataSourceName"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class AddDataSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dataSourceId: String?

        public var kafkaTopic: String?

        public var ossPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.kafkaTopic != nil {
                map["KafkaTopic"] = self.kafkaTopic!
            }
            if self.ossPath != nil {
                map["OssPath"] = self.ossPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! String
            }
            if dict.keys.contains("KafkaTopic") {
                self.kafkaTopic = dict["KafkaTopic"] as! String
            }
            if dict.keys.contains("OssPath") {
                self.ossPath = dict["OssPath"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddDataSourceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddDataSourceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDeviceRequest : Tea.TeaModel {
    public var bitRate: String?

    public var corpId: String?

    public var deviceAddress: String?

    public var deviceDirection: String?

    public var deviceName: String?

    public var deviceResolution: String?

    public var deviceSite: String?

    public var deviceType: String?

    public var gbId: String?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bitRate != nil {
            map["BitRate"] = self.bitRate!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceDirection != nil {
            map["DeviceDirection"] = self.deviceDirection!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceResolution != nil {
            map["DeviceResolution"] = self.deviceResolution!
        }
        if self.deviceSite != nil {
            map["DeviceSite"] = self.deviceSite!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BitRate") {
            self.bitRate = dict["BitRate"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceDirection") {
            self.deviceDirection = dict["DeviceDirection"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceResolution") {
            self.deviceResolution = dict["DeviceResolution"] as! String
        }
        if dict.keys.contains("DeviceSite") {
            self.deviceSite = dict["DeviceSite"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class AddDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDoubleVerificationGroupsRequest : Tea.TeaModel {
    public class DoubleVerificationGroupList : Tea.TeaModel {
        public class PersonIdList : Tea.TeaModel {
            public var personId: String?

            public var personTableId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.personTableId != nil {
                    map["PersonTableId"] = self.personTableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PersonTableId") {
                    self.personTableId = dict["PersonTableId"] as! String
                }
            }
        }
        public var groupId: String?

        public var interval: Int64?

        public var memberNumber: Int64?

        public var personIdList: [AddDoubleVerificationGroupsRequest.DoubleVerificationGroupList.PersonIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.memberNumber != nil {
                map["MemberNumber"] = self.memberNumber!
            }
            if self.personIdList != nil {
                var tmp : [Any] = []
                for k in self.personIdList! {
                    tmp.append(k.toMap())
                }
                map["PersonIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int64
            }
            if dict.keys.contains("MemberNumber") {
                self.memberNumber = dict["MemberNumber"] as! Int64
            }
            if dict.keys.contains("PersonIdList") {
                self.personIdList = dict["PersonIdList"] as! [AddDoubleVerificationGroupsRequest.DoubleVerificationGroupList.PersonIdList]
            }
        }
    }
    public var doubleVerificationGroupList: [AddDoubleVerificationGroupsRequest.DoubleVerificationGroupList]?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.doubleVerificationGroupList != nil {
            var tmp : [Any] = []
            for k in self.doubleVerificationGroupList! {
                tmp.append(k.toMap())
            }
            map["DoubleVerificationGroupList"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DoubleVerificationGroupList") {
            self.doubleVerificationGroupList = dict["DoubleVerificationGroupList"] as! [AddDoubleVerificationGroupsRequest.DoubleVerificationGroupList]
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class AddDoubleVerificationGroupsResponseBody : Tea.TeaModel {
    public class ResultList : Tea.TeaModel {
        public var code: String?

        public var groupId: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var resultList: [AddDoubleVerificationGroupsResponseBody.ResultList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultList != nil {
            var tmp : [Any] = []
            for k in self.resultList! {
                tmp.append(k.toMap())
            }
            map["ResultList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultList") {
            self.resultList = dict["ResultList"] as! [AddDoubleVerificationGroupsResponseBody.ResultList]
        }
    }
}

public class AddDoubleVerificationGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDoubleVerificationGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddDoubleVerificationGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMonitorRequest : Tea.TeaModel {
    public var algorithmVendor: String?

    public var batchIndicator: Int32?

    public var corpId: String?

    public var description_: String?

    public var monitorType: String?

    public var notifierAppSecret: String?

    public var notifierExtendValues: String?

    public var notifierTimeOut: Int32?

    public var notifierType: String?

    public var notifierUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmVendor != nil {
            map["AlgorithmVendor"] = self.algorithmVendor!
        }
        if self.batchIndicator != nil {
            map["BatchIndicator"] = self.batchIndicator!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.monitorType != nil {
            map["MonitorType"] = self.monitorType!
        }
        if self.notifierAppSecret != nil {
            map["NotifierAppSecret"] = self.notifierAppSecret!
        }
        if self.notifierExtendValues != nil {
            map["NotifierExtendValues"] = self.notifierExtendValues!
        }
        if self.notifierTimeOut != nil {
            map["NotifierTimeOut"] = self.notifierTimeOut!
        }
        if self.notifierType != nil {
            map["NotifierType"] = self.notifierType!
        }
        if self.notifierUrl != nil {
            map["NotifierUrl"] = self.notifierUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmVendor") {
            self.algorithmVendor = dict["AlgorithmVendor"] as! String
        }
        if dict.keys.contains("BatchIndicator") {
            self.batchIndicator = dict["BatchIndicator"] as! Int32
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MonitorType") {
            self.monitorType = dict["MonitorType"] as! String
        }
        if dict.keys.contains("NotifierAppSecret") {
            self.notifierAppSecret = dict["NotifierAppSecret"] as! String
        }
        if dict.keys.contains("NotifierExtendValues") {
            self.notifierExtendValues = dict["NotifierExtendValues"] as! String
        }
        if dict.keys.contains("NotifierTimeOut") {
            self.notifierTimeOut = dict["NotifierTimeOut"] as! Int32
        }
        if dict.keys.contains("NotifierType") {
            self.notifierType = dict["NotifierType"] as! String
        }
        if dict.keys.contains("NotifierUrl") {
            self.notifierUrl = dict["NotifierUrl"] as! String
        }
    }
}

public class AddMonitorResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddMonitorResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddMonitorResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddProfileRequest : Tea.TeaModel {
    public var bizId: String?

    public var catalogId: Int64?

    public var corpId: String?

    public var faceUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var liveAddress: String?

    public var name: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var sceneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.liveAddress != nil {
            map["LiveAddress"] = self.liveAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.sceneType != nil {
            map["SceneType"] = self.sceneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! Int64
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("LiveAddress") {
            self.liveAddress = dict["LiveAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("SceneType") {
            self.sceneType = dict["SceneType"] as! String
        }
    }
}

public class AddProfileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizId: String?

        public var catalogId: Int32?

        public var faceUrl: String?

        public var gender: String?

        public var idNumber: String?

        public var isvSubId: String?

        public var liveAddress: String?

        public var name: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var profileId: Int32?

        public var sceneType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.catalogId != nil {
                map["CatalogId"] = self.catalogId!
            }
            if self.faceUrl != nil {
                map["FaceUrl"] = self.faceUrl!
            }
            if self.gender != nil {
                map["Gender"] = self.gender!
            }
            if self.idNumber != nil {
                map["IdNumber"] = self.idNumber!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.liveAddress != nil {
                map["LiveAddress"] = self.liveAddress!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.profileId != nil {
                map["ProfileId"] = self.profileId!
            }
            if self.sceneType != nil {
                map["SceneType"] = self.sceneType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CatalogId") {
                self.catalogId = dict["CatalogId"] as! Int32
            }
            if dict.keys.contains("FaceUrl") {
                self.faceUrl = dict["FaceUrl"] as! String
            }
            if dict.keys.contains("Gender") {
                self.gender = dict["Gender"] as! String
            }
            if dict.keys.contains("IdNumber") {
                self.idNumber = dict["IdNumber"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("LiveAddress") {
                self.liveAddress = dict["LiveAddress"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("ProfileId") {
                self.profileId = dict["ProfileId"] as! Int32
            }
            if dict.keys.contains("SceneType") {
                self.sceneType = dict["SceneType"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddProfileResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddProfileResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddProfileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddProfileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddProfileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddProfileCatalogRequest : Tea.TeaModel {
    public var catalogName: String?

    public var corpId: String?

    public var isvSubId: String?

    public var parentCatalogId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.parentCatalogId != nil {
            map["ParentCatalogId"] = self.parentCatalogId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ParentCatalogId") {
            self.parentCatalogId = dict["ParentCatalogId"] as! Int64
        }
    }
}

public class AddProfileCatalogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var catalogId: Int64?

        public var catalogName: String?

        public var isvSubId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogId != nil {
                map["CatalogId"] = self.catalogId!
            }
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogId") {
                self.catalogId = dict["CatalogId"] as! Int64
            }
            if dict.keys.contains("CatalogName") {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddProfileCatalogResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddProfileCatalogResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddProfileCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddProfileCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddProfileCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSearchItemsRequest : Tea.TeaModel {
    public class SearchItemList : Tea.TeaModel {
        public var itemImageUrl: String?

        public var searchItemId: String?

        public var searchItemName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemImageUrl != nil {
                map["ItemImageUrl"] = self.itemImageUrl!
            }
            if self.searchItemId != nil {
                map["SearchItemId"] = self.searchItemId!
            }
            if self.searchItemName != nil {
                map["SearchItemName"] = self.searchItemName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemImageUrl") {
                self.itemImageUrl = dict["ItemImageUrl"] as! String
            }
            if dict.keys.contains("SearchItemId") {
                self.searchItemId = dict["SearchItemId"] as! String
            }
            if dict.keys.contains("SearchItemName") {
                self.searchItemName = dict["SearchItemName"] as! String
            }
        }
    }
    public var searchItemList: [AddSearchItemsRequest.SearchItemList]?

    public var searchTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchItemList != nil {
            var tmp : [Any] = []
            for k in self.searchItemList! {
                tmp.append(k.toMap())
            }
            map["SearchItemList"] = tmp
        }
        if self.searchTableId != nil {
            map["SearchTableId"] = self.searchTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchItemList") {
            self.searchItemList = dict["SearchItemList"] as! [AddSearchItemsRequest.SearchItemList]
        }
        if dict.keys.contains("SearchTableId") {
            self.searchTableId = dict["SearchTableId"] as! String
        }
    }
}

public class AddSearchItemsShrinkRequest : Tea.TeaModel {
    public var searchItemListShrink: String?

    public var searchTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchItemListShrink != nil {
            map["SearchItemList"] = self.searchItemListShrink!
        }
        if self.searchTableId != nil {
            map["SearchTableId"] = self.searchTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchItemList") {
            self.searchItemListShrink = dict["SearchItemList"] as! String
        }
        if dict.keys.contains("SearchTableId") {
            self.searchTableId = dict["SearchTableId"] as! String
        }
    }
}

public class AddSearchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addedItemIds: String?

        public var failedItemIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addedItemIds != nil {
                map["AddedItemIds"] = self.addedItemIds!
            }
            if self.failedItemIds != nil {
                map["FailedItemIds"] = self.failedItemIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddedItemIds") {
                self.addedItemIds = dict["AddedItemIds"] as! String
            }
            if dict.keys.contains("FailedItemIds") {
                self.failedItemIds = dict["FailedItemIds"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddSearchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddSearchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class AddSearchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSearchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSearchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWatchItemsRequest : Tea.TeaModel {
    public class WatchItemList : Tea.TeaModel {
        public var itemAttributes: String?

        public var itemImageUrl: String?

        public var watchItemId: String?

        public var watchItemName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemAttributes != nil {
                map["ItemAttributes"] = self.itemAttributes!
            }
            if self.itemImageUrl != nil {
                map["ItemImageUrl"] = self.itemImageUrl!
            }
            if self.watchItemId != nil {
                map["WatchItemId"] = self.watchItemId!
            }
            if self.watchItemName != nil {
                map["WatchItemName"] = self.watchItemName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemAttributes") {
                self.itemAttributes = dict["ItemAttributes"] as! String
            }
            if dict.keys.contains("ItemImageUrl") {
                self.itemImageUrl = dict["ItemImageUrl"] as! String
            }
            if dict.keys.contains("WatchItemId") {
                self.watchItemId = dict["WatchItemId"] as! String
            }
            if dict.keys.contains("WatchItemName") {
                self.watchItemName = dict["WatchItemName"] as! String
            }
        }
    }
    public var watchItemList: [AddWatchItemsRequest.WatchItemList]?

    public var watchPolicyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watchItemList != nil {
            var tmp : [Any] = []
            for k in self.watchItemList! {
                tmp.append(k.toMap())
            }
            map["WatchItemList"] = tmp
        }
        if self.watchPolicyId != nil {
            map["WatchPolicyId"] = self.watchPolicyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatchItemList") {
            self.watchItemList = dict["WatchItemList"] as! [AddWatchItemsRequest.WatchItemList]
        }
        if dict.keys.contains("WatchPolicyId") {
            self.watchPolicyId = dict["WatchPolicyId"] as! String
        }
    }
}

public class AddWatchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var addedItemIds: String?

        public var failedItemIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addedItemIds != nil {
                map["AddedItemIds"] = self.addedItemIds!
            }
            if self.failedItemIds != nil {
                map["FailedItemIds"] = self.failedItemIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddedItemIds") {
                self.addedItemIds = dict["AddedItemIds"] as! String
            }
            if dict.keys.contains("FailedItemIds") {
                self.failedItemIds = dict["FailedItemIds"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddWatchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddWatchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddWatchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWatchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWatchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchDeleteInstanceRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class BatchDeleteInstanceShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class BatchDeleteInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BatchDeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchDeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindCorpGroupRequest : Tea.TeaModel {
    public var corpGroupId: String?

    public var corpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpGroupId != nil {
            map["CorpGroupId"] = self.corpGroupId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpGroupId") {
            self.corpGroupId = dict["CorpGroupId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
    }
}

public class BindCorpGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BindCorpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindCorpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindCorpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindDevicesRequest : Tea.TeaModel {
    public class SubDeviceList : Tea.TeaModel {
        public var accessProtocol: String?

        public var loginName: String?

        public var PIN: String?

        public var subDeviceIp: String?

        public var subDeviceName: String?

        public var subDevicePort: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessProtocol != nil {
                map["AccessProtocol"] = self.accessProtocol!
            }
            if self.loginName != nil {
                map["LoginName"] = self.loginName!
            }
            if self.PIN != nil {
                map["PIN"] = self.PIN!
            }
            if self.subDeviceIp != nil {
                map["SubDeviceIp"] = self.subDeviceIp!
            }
            if self.subDeviceName != nil {
                map["SubDeviceName"] = self.subDeviceName!
            }
            if self.subDevicePort != nil {
                map["SubDevicePort"] = self.subDevicePort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessProtocol") {
                self.accessProtocol = dict["AccessProtocol"] as! String
            }
            if dict.keys.contains("LoginName") {
                self.loginName = dict["LoginName"] as! String
            }
            if dict.keys.contains("PIN") {
                self.PIN = dict["PIN"] as! String
            }
            if dict.keys.contains("SubDeviceIp") {
                self.subDeviceIp = dict["SubDeviceIp"] as! String
            }
            if dict.keys.contains("SubDeviceName") {
                self.subDeviceName = dict["SubDeviceName"] as! String
            }
            if dict.keys.contains("SubDevicePort") {
                self.subDevicePort = dict["SubDevicePort"] as! String
            }
        }
    }
    public var corpId: String?

    public var deviceId: String?

    public var subDeviceList: [BindDevicesRequest.SubDeviceList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.subDeviceList != nil {
            var tmp : [Any] = []
            for k in self.subDeviceList! {
                tmp.append(k.toMap())
            }
            map["SubDeviceList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("SubDeviceList") {
            self.subDeviceList = dict["SubDeviceList"] as! [BindDevicesRequest.SubDeviceList]
        }
    }
}

public class BindDevicesShrinkRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public var subDeviceListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.subDeviceListShrink != nil {
            map["SubDeviceList"] = self.subDeviceListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("SubDeviceList") {
            self.subDeviceListShrink = dict["SubDeviceList"] as! String
        }
    }
}

public class BindDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceList : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public var subDeviceId: String?

            public var subDeviceIp: String?

            public var subDeviceName: String?

            public var subDeviceNum: String?

            public var subDevicePort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.subDeviceId != nil {
                    map["SubDeviceId"] = self.subDeviceId!
                }
                if self.subDeviceIp != nil {
                    map["SubDeviceIp"] = self.subDeviceIp!
                }
                if self.subDeviceName != nil {
                    map["SubDeviceName"] = self.subDeviceName!
                }
                if self.subDeviceNum != nil {
                    map["SubDeviceNum"] = self.subDeviceNum!
                }
                if self.subDevicePort != nil {
                    map["SubDevicePort"] = self.subDevicePort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("SubDeviceId") {
                    self.subDeviceId = dict["SubDeviceId"] as! String
                }
                if dict.keys.contains("SubDeviceIp") {
                    self.subDeviceIp = dict["SubDeviceIp"] as! String
                }
                if dict.keys.contains("SubDeviceName") {
                    self.subDeviceName = dict["SubDeviceName"] as! String
                }
                if dict.keys.contains("SubDeviceNum") {
                    self.subDeviceNum = dict["SubDeviceNum"] as! String
                }
                if dict.keys.contains("SubDevicePort") {
                    self.subDevicePort = dict["SubDevicePort"] as! String
                }
            }
        }
        public var subDeviceList: [BindDevicesResponseBody.Data.SubDeviceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subDeviceList != nil {
                var tmp : [Any] = []
                for k in self.subDeviceList! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SubDeviceList") {
                self.subDeviceList = dict["SubDeviceList"] as! [BindDevicesResponseBody.Data.SubDeviceList]
            }
        }
    }
    public var code: String?

    public var data: BindDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BindDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindPersonRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var personId: String?

    public var personMatchingRate: String?

    public var profileId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.personMatchingRate != nil {
            map["PersonMatchingRate"] = self.personMatchingRate!
        }
        if self.profileId != nil {
            map["ProfileId"] = self.profileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("PersonMatchingRate") {
            self.personMatchingRate = dict["PersonMatchingRate"] as! String
        }
        if dict.keys.contains("ProfileId") {
            self.profileId = dict["ProfileId"] as! Int64
        }
    }
}

public class BindPersonResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindPersonResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindPersonResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindPersonResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindUserRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var matchingRate: String?

    public var personId: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.matchingRate != nil {
            map["MatchingRate"] = self.matchingRate!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("MatchingRate") {
            self.matchingRate = dict["MatchingRate"] as! String
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class BindUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckAIInstanceNameRequest : Tea.TeaModel {
    public var instanceName: String?

    public var instanceType: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class CheckAIInstanceNameResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var available: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["Available"] = self.available!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Available") {
                self.available = dict["Available"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: CheckAIInstanceNameResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CheckAIInstanceNameResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckAIInstanceNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckAIInstanceNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckAIInstanceNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ControlAiotDeviceRequest : Tea.TeaModel {
    public class MiFareCard : Tea.TeaModel {
        public var areaCode: Int64?

        public var areaDeviate: Int64?

        public var areaLen: Int64?

        public var enabled: String?

        public var keyType: Int64?

        public var lastChange: String?

        public var secretKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaCode != nil {
                map["AreaCode"] = self.areaCode!
            }
            if self.areaDeviate != nil {
                map["AreaDeviate"] = self.areaDeviate!
            }
            if self.areaLen != nil {
                map["AreaLen"] = self.areaLen!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.keyType != nil {
                map["KeyType"] = self.keyType!
            }
            if self.lastChange != nil {
                map["LastChange"] = self.lastChange!
            }
            if self.secretKey != nil {
                map["SecretKey"] = self.secretKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaCode") {
                self.areaCode = dict["AreaCode"] as! Int64
            }
            if dict.keys.contains("AreaDeviate") {
                self.areaDeviate = dict["AreaDeviate"] as! Int64
            }
            if dict.keys.contains("AreaLen") {
                self.areaLen = dict["AreaLen"] as! Int64
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! String
            }
            if dict.keys.contains("KeyType") {
                self.keyType = dict["KeyType"] as! Int64
            }
            if dict.keys.contains("LastChange") {
                self.lastChange = dict["LastChange"] as! String
            }
            if dict.keys.contains("SecretKey") {
                self.secretKey = dict["SecretKey"] as! String
            }
        }
    }
    public var associatedDeviceId: String?

    public var associatedIPAddr: String?

    public var associatedPort: Int64?

    public var associatedVerificationEnable: String?

    public var barrierCommand: Int64?

    public var checkEnabled: String?

    public var commandType: Int64?

    public var doubleVerificationGroupEnabled: String?

    public var gateCtlStatus: Int64?

    public var id: String?

    public var identityNumber: String?

    public var isProxy: Bool?

    public var miFareCard: ControlAiotDeviceRequest.MiFareCard?

    public var name: String?

    public var rebootDevice: String?

    public var singleInterval: Int64?

    public var superPassword: String?

    public var upgradeFileURL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.miFareCard?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedDeviceId != nil {
            map["AssociatedDeviceId"] = self.associatedDeviceId!
        }
        if self.associatedIPAddr != nil {
            map["AssociatedIPAddr"] = self.associatedIPAddr!
        }
        if self.associatedPort != nil {
            map["AssociatedPort"] = self.associatedPort!
        }
        if self.associatedVerificationEnable != nil {
            map["AssociatedVerificationEnable"] = self.associatedVerificationEnable!
        }
        if self.barrierCommand != nil {
            map["BarrierCommand"] = self.barrierCommand!
        }
        if self.checkEnabled != nil {
            map["CheckEnabled"] = self.checkEnabled!
        }
        if self.commandType != nil {
            map["CommandType"] = self.commandType!
        }
        if self.doubleVerificationGroupEnabled != nil {
            map["DoubleVerificationGroupEnabled"] = self.doubleVerificationGroupEnabled!
        }
        if self.gateCtlStatus != nil {
            map["GateCtlStatus"] = self.gateCtlStatus!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.identityNumber != nil {
            map["IdentityNumber"] = self.identityNumber!
        }
        if self.isProxy != nil {
            map["IsProxy"] = self.isProxy!
        }
        if self.miFareCard != nil {
            map["MiFareCard"] = self.miFareCard?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.rebootDevice != nil {
            map["RebootDevice"] = self.rebootDevice!
        }
        if self.singleInterval != nil {
            map["SingleInterval"] = self.singleInterval!
        }
        if self.superPassword != nil {
            map["SuperPassword"] = self.superPassword!
        }
        if self.upgradeFileURL != nil {
            map["UpgradeFileURL"] = self.upgradeFileURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociatedDeviceId") {
            self.associatedDeviceId = dict["AssociatedDeviceId"] as! String
        }
        if dict.keys.contains("AssociatedIPAddr") {
            self.associatedIPAddr = dict["AssociatedIPAddr"] as! String
        }
        if dict.keys.contains("AssociatedPort") {
            self.associatedPort = dict["AssociatedPort"] as! Int64
        }
        if dict.keys.contains("AssociatedVerificationEnable") {
            self.associatedVerificationEnable = dict["AssociatedVerificationEnable"] as! String
        }
        if dict.keys.contains("BarrierCommand") {
            self.barrierCommand = dict["BarrierCommand"] as! Int64
        }
        if dict.keys.contains("CheckEnabled") {
            self.checkEnabled = dict["CheckEnabled"] as! String
        }
        if dict.keys.contains("CommandType") {
            self.commandType = dict["CommandType"] as! Int64
        }
        if dict.keys.contains("DoubleVerificationGroupEnabled") {
            self.doubleVerificationGroupEnabled = dict["DoubleVerificationGroupEnabled"] as! String
        }
        if dict.keys.contains("GateCtlStatus") {
            self.gateCtlStatus = dict["GateCtlStatus"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("IdentityNumber") {
            self.identityNumber = dict["IdentityNumber"] as! String
        }
        if dict.keys.contains("IsProxy") {
            self.isProxy = dict["IsProxy"] as! Bool
        }
        if dict.keys.contains("MiFareCard") {
            var model = ControlAiotDeviceRequest.MiFareCard()
            model.fromMap(dict["MiFareCard"] as! [String: Any])
            self.miFareCard = model
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RebootDevice") {
            self.rebootDevice = dict["RebootDevice"] as! String
        }
        if dict.keys.contains("SingleInterval") {
            self.singleInterval = dict["SingleInterval"] as! Int64
        }
        if dict.keys.contains("SuperPassword") {
            self.superPassword = dict["SuperPassword"] as! String
        }
        if dict.keys.contains("UpgradeFileURL") {
            self.upgradeFileURL = dict["UpgradeFileURL"] as! String
        }
    }
}

public class ControlAiotDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ControlAiotDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ControlAiotDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ControlAiotDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAIInstanceRequest : Tea.TeaModel {
    public class DataSourceTimes : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class ScheduleTimes : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var algorithmId: String?

    public var algorithmName: String?

    public var computeType: String?

    public var containerType: String?

    public var dataSource: String?

    public var dataSourceTimes: [CreateAIInstanceRequest.DataSourceTimes]?

    public var dataType: String?

    public var fps: Int64?

    public var instanceName: String?

    public var instanceType: String?

    public var projectId: String?

    public var scheduleCycleDates: [Int64]?

    public var scheduleTimes: [CreateAIInstanceRequest.ScheduleTimes]?

    public var scheduleType: String?

    public var spf: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.algorithmName != nil {
            map["AlgorithmName"] = self.algorithmName!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.containerType != nil {
            map["ContainerType"] = self.containerType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.dataSourceTimes != nil {
            var tmp : [Any] = []
            for k in self.dataSourceTimes! {
                tmp.append(k.toMap())
            }
            map["DataSourceTimes"] = tmp
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.fps != nil {
            map["Fps"] = self.fps!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scheduleCycleDates != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDates!
        }
        if self.scheduleTimes != nil {
            var tmp : [Any] = []
            for k in self.scheduleTimes! {
                tmp.append(k.toMap())
            }
            map["ScheduleTimes"] = tmp
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.spf != nil {
            map["Spf"] = self.spf!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("AlgorithmName") {
            self.algorithmName = dict["AlgorithmName"] as! String
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("ContainerType") {
            self.containerType = dict["ContainerType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("DataSourceTimes") {
            self.dataSourceTimes = dict["DataSourceTimes"] as! [CreateAIInstanceRequest.DataSourceTimes]
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Fps") {
            self.fps = dict["Fps"] as! Int64
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDates = dict["ScheduleCycleDates"] as! [Int64]
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! [CreateAIInstanceRequest.ScheduleTimes]
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("Spf") {
            self.spf = dict["Spf"] as! Int64
        }
    }
}

public class CreateAIInstanceShrinkRequest : Tea.TeaModel {
    public var algorithmId: String?

    public var algorithmName: String?

    public var computeType: String?

    public var containerType: String?

    public var dataSource: String?

    public var dataSourceTimesShrink: String?

    public var dataType: String?

    public var fps: Int64?

    public var instanceName: String?

    public var instanceType: String?

    public var projectId: String?

    public var scheduleCycleDatesShrink: String?

    public var scheduleTimesShrink: String?

    public var scheduleType: String?

    public var spf: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.algorithmName != nil {
            map["AlgorithmName"] = self.algorithmName!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.containerType != nil {
            map["ContainerType"] = self.containerType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.dataSourceTimesShrink != nil {
            map["DataSourceTimes"] = self.dataSourceTimesShrink!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.fps != nil {
            map["Fps"] = self.fps!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scheduleCycleDatesShrink != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDatesShrink!
        }
        if self.scheduleTimesShrink != nil {
            map["ScheduleTimes"] = self.scheduleTimesShrink!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.spf != nil {
            map["Spf"] = self.spf!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("AlgorithmName") {
            self.algorithmName = dict["AlgorithmName"] as! String
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("ContainerType") {
            self.containerType = dict["ContainerType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("DataSourceTimes") {
            self.dataSourceTimesShrink = dict["DataSourceTimes"] as! String
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Fps") {
            self.fps = dict["Fps"] as! Int64
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDatesShrink = dict["ScheduleCycleDates"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimesShrink = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("Spf") {
            self.spf = dict["Spf"] as! Int64
        }
    }
}

public class CreateAIInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var acuUsed: Int64?

        public var instanceId: Double?

        public var storage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuUsed != nil {
                map["AcuUsed"] = self.acuUsed!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.storage != nil {
                map["Storage"] = self.storage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcuUsed") {
                self.acuUsed = dict["AcuUsed"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! Double
            }
            if dict.keys.contains("Storage") {
                self.storage = dict["Storage"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateAIInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateAIInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAIInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAIInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAIInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateComputeInstanceRequest : Tea.TeaModel {
    public class Algorithms : Tea.TeaModel {
        public var algorithmId: String?

        public var algorithmName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.algorithmId != nil {
                map["AlgorithmId"] = self.algorithmId!
            }
            if self.algorithmName != nil {
                map["AlgorithmName"] = self.algorithmName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlgorithmId") {
                self.algorithmId = dict["AlgorithmId"] as! String
            }
            if dict.keys.contains("AlgorithmName") {
                self.algorithmName = dict["AlgorithmName"] as! String
            }
        }
    }
    public class Devices : Tea.TeaModel {
        public var bitRate: String?

        public var codingFormat: String?

        public var deviceId: String?

        public var regionId: String?

        public var resolvingPower: String?

        public var startStream: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitRate != nil {
                map["BitRate"] = self.bitRate!
            }
            if self.codingFormat != nil {
                map["CodingFormat"] = self.codingFormat!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resolvingPower != nil {
                map["ResolvingPower"] = self.resolvingPower!
            }
            if self.startStream != nil {
                map["StartStream"] = self.startStream!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BitRate") {
                self.bitRate = dict["BitRate"] as! String
            }
            if dict.keys.contains("CodingFormat") {
                self.codingFormat = dict["CodingFormat"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResolvingPower") {
                self.resolvingPower = dict["ResolvingPower"] as! String
            }
            if dict.keys.contains("StartStream") {
                self.startStream = dict["StartStream"] as! Bool
            }
        }
    }
    public var acuUsed: Int64?

    public var algorithmType: String?

    public var algorithms: [CreateComputeInstanceRequest.Algorithms]?

    public var computePictureType: String?

    public var computePictureValue: String?

    public var datasourceType: String?

    public var devices: [CreateComputeInstanceRequest.Devices]?

    public var instanceName: String?

    public var isFrameExtraction: String?

    public var isPolling: Bool?

    public var overallExecutionTime: String?

    public var picTopic: String?

    public var picType: String?

    public var pollingConfigs: String?

    public var projectId: String?

    public var scheduleCycleDate: String?

    public var scheduleDay: String?

    public var scheduleDaySize: String?

    public var scheduleTimes: String?

    public var scheduleType: String?

    public var sliceExecutionTime: String?

    public var storageUsed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acuUsed != nil {
            map["AcuUsed"] = self.acuUsed!
        }
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.algorithms != nil {
            var tmp : [Any] = []
            for k in self.algorithms! {
                tmp.append(k.toMap())
            }
            map["Algorithms"] = tmp
        }
        if self.computePictureType != nil {
            map["ComputePictureType"] = self.computePictureType!
        }
        if self.computePictureValue != nil {
            map["ComputePictureValue"] = self.computePictureValue!
        }
        if self.datasourceType != nil {
            map["DatasourceType"] = self.datasourceType!
        }
        if self.devices != nil {
            var tmp : [Any] = []
            for k in self.devices! {
                tmp.append(k.toMap())
            }
            map["Devices"] = tmp
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isFrameExtraction != nil {
            map["IsFrameExtraction"] = self.isFrameExtraction!
        }
        if self.isPolling != nil {
            map["IsPolling"] = self.isPolling!
        }
        if self.overallExecutionTime != nil {
            map["OverallExecutionTime"] = self.overallExecutionTime!
        }
        if self.picTopic != nil {
            map["PicTopic"] = self.picTopic!
        }
        if self.picType != nil {
            map["PicType"] = self.picType!
        }
        if self.pollingConfigs != nil {
            map["PollingConfigs"] = self.pollingConfigs!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scheduleCycleDate != nil {
            map["ScheduleCycleDate"] = self.scheduleCycleDate!
        }
        if self.scheduleDay != nil {
            map["ScheduleDay"] = self.scheduleDay!
        }
        if self.scheduleDaySize != nil {
            map["ScheduleDaySize"] = self.scheduleDaySize!
        }
        if self.scheduleTimes != nil {
            map["ScheduleTimes"] = self.scheduleTimes!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.sliceExecutionTime != nil {
            map["SliceExecutionTime"] = self.sliceExecutionTime!
        }
        if self.storageUsed != nil {
            map["StorageUsed"] = self.storageUsed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcuUsed") {
            self.acuUsed = dict["AcuUsed"] as! Int64
        }
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("Algorithms") {
            self.algorithms = dict["Algorithms"] as! [CreateComputeInstanceRequest.Algorithms]
        }
        if dict.keys.contains("ComputePictureType") {
            self.computePictureType = dict["ComputePictureType"] as! String
        }
        if dict.keys.contains("ComputePictureValue") {
            self.computePictureValue = dict["ComputePictureValue"] as! String
        }
        if dict.keys.contains("DatasourceType") {
            self.datasourceType = dict["DatasourceType"] as! String
        }
        if dict.keys.contains("Devices") {
            self.devices = dict["Devices"] as! [CreateComputeInstanceRequest.Devices]
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IsFrameExtraction") {
            self.isFrameExtraction = dict["IsFrameExtraction"] as! String
        }
        if dict.keys.contains("IsPolling") {
            self.isPolling = dict["IsPolling"] as! Bool
        }
        if dict.keys.contains("OverallExecutionTime") {
            self.overallExecutionTime = dict["OverallExecutionTime"] as! String
        }
        if dict.keys.contains("PicTopic") {
            self.picTopic = dict["PicTopic"] as! String
        }
        if dict.keys.contains("PicType") {
            self.picType = dict["PicType"] as! String
        }
        if dict.keys.contains("PollingConfigs") {
            self.pollingConfigs = dict["PollingConfigs"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ScheduleCycleDate") {
            self.scheduleCycleDate = dict["ScheduleCycleDate"] as! String
        }
        if dict.keys.contains("ScheduleDay") {
            self.scheduleDay = dict["ScheduleDay"] as! String
        }
        if dict.keys.contains("ScheduleDaySize") {
            self.scheduleDaySize = dict["ScheduleDaySize"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("SliceExecutionTime") {
            self.sliceExecutionTime = dict["SliceExecutionTime"] as! String
        }
        if dict.keys.contains("StorageUsed") {
            self.storageUsed = dict["StorageUsed"] as! String
        }
    }
}

public class CreateComputeInstanceShrinkRequest : Tea.TeaModel {
    public var acuUsed: Int64?

    public var algorithmType: String?

    public var algorithmsShrink: String?

    public var computePictureType: String?

    public var computePictureValue: String?

    public var datasourceType: String?

    public var devicesShrink: String?

    public var instanceName: String?

    public var isFrameExtraction: String?

    public var isPolling: Bool?

    public var overallExecutionTime: String?

    public var picTopic: String?

    public var picType: String?

    public var pollingConfigs: String?

    public var projectId: String?

    public var scheduleCycleDate: String?

    public var scheduleDay: String?

    public var scheduleDaySize: String?

    public var scheduleTimes: String?

    public var scheduleType: String?

    public var sliceExecutionTime: String?

    public var storageUsed: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acuUsed != nil {
            map["AcuUsed"] = self.acuUsed!
        }
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.algorithmsShrink != nil {
            map["Algorithms"] = self.algorithmsShrink!
        }
        if self.computePictureType != nil {
            map["ComputePictureType"] = self.computePictureType!
        }
        if self.computePictureValue != nil {
            map["ComputePictureValue"] = self.computePictureValue!
        }
        if self.datasourceType != nil {
            map["DatasourceType"] = self.datasourceType!
        }
        if self.devicesShrink != nil {
            map["Devices"] = self.devicesShrink!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.isFrameExtraction != nil {
            map["IsFrameExtraction"] = self.isFrameExtraction!
        }
        if self.isPolling != nil {
            map["IsPolling"] = self.isPolling!
        }
        if self.overallExecutionTime != nil {
            map["OverallExecutionTime"] = self.overallExecutionTime!
        }
        if self.picTopic != nil {
            map["PicTopic"] = self.picTopic!
        }
        if self.picType != nil {
            map["PicType"] = self.picType!
        }
        if self.pollingConfigs != nil {
            map["PollingConfigs"] = self.pollingConfigs!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scheduleCycleDate != nil {
            map["ScheduleCycleDate"] = self.scheduleCycleDate!
        }
        if self.scheduleDay != nil {
            map["ScheduleDay"] = self.scheduleDay!
        }
        if self.scheduleDaySize != nil {
            map["ScheduleDaySize"] = self.scheduleDaySize!
        }
        if self.scheduleTimes != nil {
            map["ScheduleTimes"] = self.scheduleTimes!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.sliceExecutionTime != nil {
            map["SliceExecutionTime"] = self.sliceExecutionTime!
        }
        if self.storageUsed != nil {
            map["StorageUsed"] = self.storageUsed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcuUsed") {
            self.acuUsed = dict["AcuUsed"] as! Int64
        }
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("Algorithms") {
            self.algorithmsShrink = dict["Algorithms"] as! String
        }
        if dict.keys.contains("ComputePictureType") {
            self.computePictureType = dict["ComputePictureType"] as! String
        }
        if dict.keys.contains("ComputePictureValue") {
            self.computePictureValue = dict["ComputePictureValue"] as! String
        }
        if dict.keys.contains("DatasourceType") {
            self.datasourceType = dict["DatasourceType"] as! String
        }
        if dict.keys.contains("Devices") {
            self.devicesShrink = dict["Devices"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IsFrameExtraction") {
            self.isFrameExtraction = dict["IsFrameExtraction"] as! String
        }
        if dict.keys.contains("IsPolling") {
            self.isPolling = dict["IsPolling"] as! Bool
        }
        if dict.keys.contains("OverallExecutionTime") {
            self.overallExecutionTime = dict["OverallExecutionTime"] as! String
        }
        if dict.keys.contains("PicTopic") {
            self.picTopic = dict["PicTopic"] as! String
        }
        if dict.keys.contains("PicType") {
            self.picType = dict["PicType"] as! String
        }
        if dict.keys.contains("PollingConfigs") {
            self.pollingConfigs = dict["PollingConfigs"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ScheduleCycleDate") {
            self.scheduleCycleDate = dict["ScheduleCycleDate"] as! String
        }
        if dict.keys.contains("ScheduleDay") {
            self.scheduleDay = dict["ScheduleDay"] as! String
        }
        if dict.keys.contains("ScheduleDaySize") {
            self.scheduleDaySize = dict["ScheduleDaySize"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("SliceExecutionTime") {
            self.sliceExecutionTime = dict["SliceExecutionTime"] as! String
        }
        if dict.keys.contains("StorageUsed") {
            self.storageUsed = dict["StorageUsed"] as! String
        }
    }
}

public class CreateComputeInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var acuUsed: Int64?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuUsed != nil {
                map["AcuUsed"] = self.acuUsed!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcuUsed") {
                self.acuUsed = dict["AcuUsed"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateComputeInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateComputeInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateComputeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateComputeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateComputeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCorpRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var appName: String?

    public var corpName: String?

    public var description_: String?

    public var iconPath: String?

    public var isvSubId: String?

    public var parentCorpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.corpName != nil {
            map["CorpName"] = self.corpName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.iconPath != nil {
            map["IconPath"] = self.iconPath!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.parentCorpId != nil {
            map["ParentCorpId"] = self.parentCorpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CorpName") {
            self.corpName = dict["CorpName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IconPath") {
            self.iconPath = dict["IconPath"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ParentCorpId") {
            self.parentCorpId = dict["ParentCorpId"] as! String
        }
    }
}

public class CreateCorpResponseBody : Tea.TeaModel {
    public var code: String?

    public var corpId: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCorpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCorpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCorpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCorpGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var corpId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class CreateCorpGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCorpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCorpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCorpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeviceRequest : Tea.TeaModel {
    public var activateCode: String?

    public var audioEnable: String?

    public var cityCode: String?

    public var corpId: String?

    public var dataSourceType: String?

    public var deviceAddress: String?

    public var deviceDirection: String?

    public var deviceId: String?

    public var deviceModel: String?

    public var deviceName: String?

    public var deviceRate: String?

    public var deviceResolution: String?

    public var deviceSite: String?

    public var deviceSn: String?

    public var deviceType: String?

    public var encodeFormat: String?

    public var frameRate: String?

    public var govLength: String?

    public var inProtocol: String?

    public var latitude: String?

    public var longitude: String?

    public var OSDTimeEnable: String?

    public var OSDTimeType: String?

    public var OSDTimeX: String?

    public var OSDTimeY: String?

    public var parentDeviceId: String?

    public var subDeviceCount: Int64?

    public var subDeviceIdList: String?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activateCode != nil {
            map["ActivateCode"] = self.activateCode!
        }
        if self.audioEnable != nil {
            map["AudioEnable"] = self.audioEnable!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceDirection != nil {
            map["DeviceDirection"] = self.deviceDirection!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceModel != nil {
            map["DeviceModel"] = self.deviceModel!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceRate != nil {
            map["DeviceRate"] = self.deviceRate!
        }
        if self.deviceResolution != nil {
            map["DeviceResolution"] = self.deviceResolution!
        }
        if self.deviceSite != nil {
            map["DeviceSite"] = self.deviceSite!
        }
        if self.deviceSn != nil {
            map["DeviceSn"] = self.deviceSn!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.encodeFormat != nil {
            map["EncodeFormat"] = self.encodeFormat!
        }
        if self.frameRate != nil {
            map["FrameRate"] = self.frameRate!
        }
        if self.govLength != nil {
            map["GovLength"] = self.govLength!
        }
        if self.inProtocol != nil {
            map["InProtocol"] = self.inProtocol!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.OSDTimeEnable != nil {
            map["OSDTimeEnable"] = self.OSDTimeEnable!
        }
        if self.OSDTimeType != nil {
            map["OSDTimeType"] = self.OSDTimeType!
        }
        if self.OSDTimeX != nil {
            map["OSDTimeX"] = self.OSDTimeX!
        }
        if self.OSDTimeY != nil {
            map["OSDTimeY"] = self.OSDTimeY!
        }
        if self.parentDeviceId != nil {
            map["ParentDeviceId"] = self.parentDeviceId!
        }
        if self.subDeviceCount != nil {
            map["SubDeviceCount"] = self.subDeviceCount!
        }
        if self.subDeviceIdList != nil {
            map["SubDeviceIdList"] = self.subDeviceIdList!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivateCode") {
            self.activateCode = dict["ActivateCode"] as! String
        }
        if dict.keys.contains("AudioEnable") {
            self.audioEnable = dict["AudioEnable"] as! String
        }
        if dict.keys.contains("CityCode") {
            self.cityCode = dict["CityCode"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceDirection") {
            self.deviceDirection = dict["DeviceDirection"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceModel") {
            self.deviceModel = dict["DeviceModel"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceRate") {
            self.deviceRate = dict["DeviceRate"] as! String
        }
        if dict.keys.contains("DeviceResolution") {
            self.deviceResolution = dict["DeviceResolution"] as! String
        }
        if dict.keys.contains("DeviceSite") {
            self.deviceSite = dict["DeviceSite"] as! String
        }
        if dict.keys.contains("DeviceSn") {
            self.deviceSn = dict["DeviceSn"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("EncodeFormat") {
            self.encodeFormat = dict["EncodeFormat"] as! String
        }
        if dict.keys.contains("FrameRate") {
            self.frameRate = dict["FrameRate"] as! String
        }
        if dict.keys.contains("GovLength") {
            self.govLength = dict["GovLength"] as! String
        }
        if dict.keys.contains("InProtocol") {
            self.inProtocol = dict["InProtocol"] as! String
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! String
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! String
        }
        if dict.keys.contains("OSDTimeEnable") {
            self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
        }
        if dict.keys.contains("OSDTimeType") {
            self.OSDTimeType = dict["OSDTimeType"] as! String
        }
        if dict.keys.contains("OSDTimeX") {
            self.OSDTimeX = dict["OSDTimeX"] as! String
        }
        if dict.keys.contains("OSDTimeY") {
            self.OSDTimeY = dict["OSDTimeY"] as! String
        }
        if dict.keys.contains("ParentDeviceId") {
            self.parentDeviceId = dict["ParentDeviceId"] as! String
        }
        if dict.keys.contains("SubDeviceCount") {
            self.subDeviceCount = dict["SubDeviceCount"] as! Int64
        }
        if dict.keys.contains("SubDeviceIdList") {
            self.subDeviceIdList = dict["SubDeviceIdList"] as! String
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class CreateDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceInfo : Tea.TeaModel {
            public var subDeviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.subDeviceId != nil {
                    map["SubDeviceId"] = self.subDeviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SubDeviceId") {
                    self.subDeviceId = dict["SubDeviceId"] as! String
                }
            }
        }
        public var deviceId: String?

        public var password: String?

        public var serverId: String?

        public var serverIp: String?

        public var serverPort: String?

        public var serverRealm: String?

        public var subDeviceInfo: [CreateDeviceResponseBody.Data.SubDeviceInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.serverRealm != nil {
                map["ServerRealm"] = self.serverRealm!
            }
            if self.subDeviceInfo != nil {
                var tmp : [Any] = []
                for k in self.subDeviceInfo! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! String
            }
            if dict.keys.contains("ServerRealm") {
                self.serverRealm = dict["ServerRealm"] as! String
            }
            if dict.keys.contains("SubDeviceInfo") {
                self.subDeviceInfo = dict["SubDeviceInfo"] as! [CreateDeviceResponseBody.Data.SubDeviceInfo]
            }
        }
    }
    public var code: String?

    public var data: CreateDeviceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateDeviceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateModelServiceRequest : Tea.TeaModel {
    public var algorithmCode: String?

    public var clientToken: String?

    public var instanceName: String?

    public var QPSRequired: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmCode != nil {
            map["AlgorithmCode"] = self.algorithmCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.QPSRequired != nil {
            map["QPSRequired"] = self.QPSRequired!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmCode") {
            self.algorithmCode = dict["AlgorithmCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("QPSRequired") {
            self.QPSRequired = dict["QPSRequired"] as! Int32
        }
    }
}

public class CreateModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModelApiList : Tea.TeaModel {
            public var algorithmApiCode: String?

            public var apiId: String?

            public var apiName: String?

            public var apiPath: String?

            public var createTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.algorithmApiCode != nil {
                    map["AlgorithmApiCode"] = self.algorithmApiCode!
                }
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlgorithmApiCode") {
                    self.algorithmApiCode = dict["AlgorithmApiCode"] as! String
                }
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
            }
        }
        public var appCode: String?

        public var modelApiList: [CreateModelServiceResponseBody.Data.ModelApiList]?

        public var modelServiceInstanceId: String?

        public var modelServiceStatus: String?

        public var qpsRequired: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appCode != nil {
                map["AppCode"] = self.appCode!
            }
            if self.modelApiList != nil {
                var tmp : [Any] = []
                for k in self.modelApiList! {
                    tmp.append(k.toMap())
                }
                map["ModelApiList"] = tmp
            }
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            if self.qpsRequired != nil {
                map["QpsRequired"] = self.qpsRequired!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppCode") {
                self.appCode = dict["AppCode"] as! String
            }
            if dict.keys.contains("ModelApiList") {
                self.modelApiList = dict["ModelApiList"] as! [CreateModelServiceResponseBody.Data.ModelApiList]
            }
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
            if dict.keys.contains("QpsRequired") {
                self.qpsRequired = dict["QpsRequired"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: CreateModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNewDeviceRequest : Tea.TeaModel {
    public var cityCode: String?

    public var corpId: String?

    public var dataSourceType: String?

    public var deviceAddress: String?

    public var deviceId: String?

    public var deviceModel: String?

    public var deviceName: String?

    public var deviceType: String?

    public var filePath: String?

    public var inProtocol: String?

    public var latitude: String?

    public var longitude: String?

    public var subDeviceCount: Int64?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceModel != nil {
            map["DeviceModel"] = self.deviceModel!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.inProtocol != nil {
            map["InProtocol"] = self.inProtocol!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.subDeviceCount != nil {
            map["SubDeviceCount"] = self.subDeviceCount!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CityCode") {
            self.cityCode = dict["CityCode"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceModel") {
            self.deviceModel = dict["DeviceModel"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("InProtocol") {
            self.inProtocol = dict["InProtocol"] as! String
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! String
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! String
        }
        if dict.keys.contains("SubDeviceCount") {
            self.subDeviceCount = dict["SubDeviceCount"] as! Int64
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class CreateNewDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceInfo : Tea.TeaModel {
            public var channelDeviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelDeviceId != nil {
                    map["ChannelDeviceId"] = self.channelDeviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelDeviceId") {
                    self.channelDeviceId = dict["ChannelDeviceId"] as! String
                }
            }
        }
        public var deviceId: String?

        public var password: String?

        public var serverId: String?

        public var serverIp: String?

        public var serverPort: String?

        public var sipRealm: String?

        public var subDeviceInfo: [CreateNewDeviceResponseBody.Data.SubDeviceInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.sipRealm != nil {
                map["SipRealm"] = self.sipRealm!
            }
            if self.subDeviceInfo != nil {
                var tmp : [Any] = []
                for k in self.subDeviceInfo! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! String
            }
            if dict.keys.contains("SipRealm") {
                self.sipRealm = dict["SipRealm"] as! String
            }
            if dict.keys.contains("SubDeviceInfo") {
                self.subDeviceInfo = dict["SubDeviceInfo"] as! [CreateNewDeviceResponseBody.Data.SubDeviceInfo]
            }
        }
    }
    public var code: String?

    public var data: CreateNewDeviceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateNewDeviceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNewDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNewDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNewDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScanDeviceRequest : Tea.TeaModel {
    public var audioEnable: String?

    public var cityCode: String?

    public var corpId: String?

    public var dataSourceType: String?

    public var deviceAddress: String?

    public var deviceDirection: String?

    public var deviceId: String?

    public var deviceModel: String?

    public var deviceName: String?

    public var deviceRate: String?

    public var deviceResolution: String?

    public var deviceSite: String?

    public var deviceSn: String?

    public var deviceType: String?

    public var encodeFormat: String?

    public var frameRate: String?

    public var govLength: String?

    public var inProtocol: String?

    public var latitude: String?

    public var longitude: String?

    public var OSDTimeEnable: String?

    public var OSDTimeType: String?

    public var OSDTimeX: String?

    public var OSDTimeY: String?

    public var subDeviceCount: Int64?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioEnable != nil {
            map["AudioEnable"] = self.audioEnable!
        }
        if self.cityCode != nil {
            map["CityCode"] = self.cityCode!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceDirection != nil {
            map["DeviceDirection"] = self.deviceDirection!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceModel != nil {
            map["DeviceModel"] = self.deviceModel!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceRate != nil {
            map["DeviceRate"] = self.deviceRate!
        }
        if self.deviceResolution != nil {
            map["DeviceResolution"] = self.deviceResolution!
        }
        if self.deviceSite != nil {
            map["DeviceSite"] = self.deviceSite!
        }
        if self.deviceSn != nil {
            map["DeviceSn"] = self.deviceSn!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.encodeFormat != nil {
            map["EncodeFormat"] = self.encodeFormat!
        }
        if self.frameRate != nil {
            map["FrameRate"] = self.frameRate!
        }
        if self.govLength != nil {
            map["GovLength"] = self.govLength!
        }
        if self.inProtocol != nil {
            map["InProtocol"] = self.inProtocol!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.OSDTimeEnable != nil {
            map["OSDTimeEnable"] = self.OSDTimeEnable!
        }
        if self.OSDTimeType != nil {
            map["OSDTimeType"] = self.OSDTimeType!
        }
        if self.OSDTimeX != nil {
            map["OSDTimeX"] = self.OSDTimeX!
        }
        if self.OSDTimeY != nil {
            map["OSDTimeY"] = self.OSDTimeY!
        }
        if self.subDeviceCount != nil {
            map["SubDeviceCount"] = self.subDeviceCount!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioEnable") {
            self.audioEnable = dict["AudioEnable"] as! String
        }
        if dict.keys.contains("CityCode") {
            self.cityCode = dict["CityCode"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceDirection") {
            self.deviceDirection = dict["DeviceDirection"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceModel") {
            self.deviceModel = dict["DeviceModel"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceRate") {
            self.deviceRate = dict["DeviceRate"] as! String
        }
        if dict.keys.contains("DeviceResolution") {
            self.deviceResolution = dict["DeviceResolution"] as! String
        }
        if dict.keys.contains("DeviceSite") {
            self.deviceSite = dict["DeviceSite"] as! String
        }
        if dict.keys.contains("DeviceSn") {
            self.deviceSn = dict["DeviceSn"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("EncodeFormat") {
            self.encodeFormat = dict["EncodeFormat"] as! String
        }
        if dict.keys.contains("FrameRate") {
            self.frameRate = dict["FrameRate"] as! String
        }
        if dict.keys.contains("GovLength") {
            self.govLength = dict["GovLength"] as! String
        }
        if dict.keys.contains("InProtocol") {
            self.inProtocol = dict["InProtocol"] as! String
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! String
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! String
        }
        if dict.keys.contains("OSDTimeEnable") {
            self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
        }
        if dict.keys.contains("OSDTimeType") {
            self.OSDTimeType = dict["OSDTimeType"] as! String
        }
        if dict.keys.contains("OSDTimeX") {
            self.OSDTimeX = dict["OSDTimeX"] as! String
        }
        if dict.keys.contains("OSDTimeY") {
            self.OSDTimeY = dict["OSDTimeY"] as! String
        }
        if dict.keys.contains("SubDeviceCount") {
            self.subDeviceCount = dict["SubDeviceCount"] as! Int64
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class CreateScanDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceInfo : Tea.TeaModel {
            public var channelDeviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelDeviceId != nil {
                    map["ChannelDeviceId"] = self.channelDeviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelDeviceId") {
                    self.channelDeviceId = dict["ChannelDeviceId"] as! String
                }
            }
        }
        public var corpId: String?

        public var deviceId: String?

        public var deviceSn: String?

        public var password: String?

        public var serverId: String?

        public var serverIp: String?

        public var serverPort: String?

        public var serverRealm: String?

        public var sipDeviceGbId: String?

        public var subDeviceInfo: [CreateScanDeviceResponseBody.Data.SubDeviceInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceSn != nil {
                map["DeviceSn"] = self.deviceSn!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.serverIp != nil {
                map["ServerIp"] = self.serverIp!
            }
            if self.serverPort != nil {
                map["ServerPort"] = self.serverPort!
            }
            if self.serverRealm != nil {
                map["ServerRealm"] = self.serverRealm!
            }
            if self.sipDeviceGbId != nil {
                map["SipDeviceGbId"] = self.sipDeviceGbId!
            }
            if self.subDeviceInfo != nil {
                var tmp : [Any] = []
                for k in self.subDeviceInfo! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceSn") {
                self.deviceSn = dict["DeviceSn"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("ServerIp") {
                self.serverIp = dict["ServerIp"] as! String
            }
            if dict.keys.contains("ServerPort") {
                self.serverPort = dict["ServerPort"] as! String
            }
            if dict.keys.contains("ServerRealm") {
                self.serverRealm = dict["ServerRealm"] as! String
            }
            if dict.keys.contains("SipDeviceGbId") {
                self.sipDeviceGbId = dict["SipDeviceGbId"] as! String
            }
            if dict.keys.contains("SubDeviceInfo") {
                self.subDeviceInfo = dict["SubDeviceInfo"] as! [CreateScanDeviceResponseBody.Data.SubDeviceInfo]
            }
        }
    }
    public var code: String?

    public var data: CreateScanDeviceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateScanDeviceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateScanDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScanDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScanDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSearchTableRequest : Tea.TeaModel {
    public var algorithmId: String?

    public var searchTableName: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.searchTableName != nil {
            map["SearchTableName"] = self.searchTableName!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("SearchTableName") {
            self.searchTableName = dict["SearchTableName"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class CreateSearchTableResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var searchTableId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.searchTableId != nil {
                map["SearchTableId"] = self.searchTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SearchTableId") {
                self.searchTableId = dict["SearchTableId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateSearchTableResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateSearchTableResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateSearchTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSearchTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSearchTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserRequest : Tea.TeaModel {
    public var address: String?

    public var age: Int32?

    public var attachment: String?

    public var bizId: String?

    public var corpId: String?

    public var faceImageUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var userGroupId: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.age != nil {
            map["Age"] = self.age!
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageUrl != nil {
            map["FaceImageUrl"] = self.faceImageUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Age") {
            self.age = dict["Age"] as! Int32
        }
        if dict.keys.contains("Attachment") {
            self.attachment = dict["Attachment"] as! String
        }
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageUrl") {
            self.faceImageUrl = dict["FaceImageUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! Int64
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class CreateUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var address: String?

        public var age: String?

        public var attachment: String?

        public var bizId: String?

        public var faceImageUrl: String?

        public var gender: String?

        public var idNumber: String?

        public var isvSubId: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var userGroupId: Int32?

        public var userId: Int32?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.age != nil {
                map["Age"] = self.age!
            }
            if self.attachment != nil {
                map["Attachment"] = self.attachment!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.faceImageUrl != nil {
                map["FaceImageUrl"] = self.faceImageUrl!
            }
            if self.gender != nil {
                map["Gender"] = self.gender!
            }
            if self.idNumber != nil {
                map["IdNumber"] = self.idNumber!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("Age") {
                self.age = dict["Age"] as! String
            }
            if dict.keys.contains("Attachment") {
                self.attachment = dict["Attachment"] as! String
            }
            if dict.keys.contains("BizId") {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("FaceImageUrl") {
                self.faceImageUrl = dict["FaceImageUrl"] as! String
            }
            if dict.keys.contains("Gender") {
                self.gender = dict["Gender"] as! String
            }
            if dict.keys.contains("IdNumber") {
                self.idNumber = dict["IdNumber"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! Int32
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int32
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateUserResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserGroupRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var parentUserGroupId: Int64?

    public var userGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.parentUserGroupId != nil {
            map["ParentUserGroupId"] = self.parentUserGroupId!
        }
        if self.userGroupName != nil {
            map["UserGroupName"] = self.userGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ParentUserGroupId") {
            self.parentUserGroupId = dict["ParentUserGroupId"] as! Int64
        }
        if dict.keys.contains("UserGroupName") {
            self.userGroupName = dict["UserGroupName"] as! String
        }
    }
}

public class CreateUserGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isvSubId: String?

        public var userGroupId: Int64?

        public var userGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            if self.userGroupName != nil {
                map["UserGroupName"] = self.userGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! Int64
            }
            if dict.keys.contains("UserGroupName") {
                self.userGroupName = dict["UserGroupName"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateUserGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateUserGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVideoComposeTaskRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var bucketName: String?

    public var corpId: String?

    public var domainName: String?

    public var imageFileNames: String?

    public var imageParameters: String?

    public var videoFormat: String?

    public var videoFrameRate: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.imageFileNames != nil {
            map["ImageFileNames"] = self.imageFileNames!
        }
        if self.imageParameters != nil {
            map["ImageParameters"] = self.imageParameters!
        }
        if self.videoFormat != nil {
            map["VideoFormat"] = self.videoFormat!
        }
        if self.videoFrameRate != nil {
            map["VideoFrameRate"] = self.videoFrameRate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ImageFileNames") {
            self.imageFileNames = dict["ImageFileNames"] as! String
        }
        if dict.keys.contains("ImageParameters") {
            self.imageParameters = dict["ImageParameters"] as! String
        }
        if dict.keys.contains("VideoFormat") {
            self.videoFormat = dict["VideoFormat"] as! String
        }
        if dict.keys.contains("VideoFrameRate") {
            self.videoFrameRate = dict["VideoFrameRate"] as! Int32
        }
    }
}

public class CreateVideoComposeTaskResponseBody : Tea.TeaModel {
    public var bucketName: String?

    public var code: String?

    public var domainName: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateVideoComposeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVideoComposeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVideoComposeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVideoSummaryTaskRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public var endTimeStamp: Int64?

    public var liveVideoSummary: String?

    public var optionList: String?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.liveVideoSummary != nil {
            map["LiveVideoSummary"] = self.liveVideoSummary!
        }
        if self.optionList != nil {
            map["OptionList"] = self.optionList!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("EndTimeStamp") {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("LiveVideoSummary") {
            self.liveVideoSummary = dict["LiveVideoSummary"] as! String
        }
        if dict.keys.contains("OptionList") {
            self.optionList = dict["OptionList"] as! String
        }
        if dict.keys.contains("StartTimeStamp") {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class CreateVideoSummaryTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateVideoSummaryTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVideoSummaryTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVideoSummaryTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWatchPolicyRequest : Tea.TeaModel {
    public var itemMatchType: String?

    public var similarityThreshold: Double?

    public var targetType: String?

    public var watchMode: String?

    public var watchPolicyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemMatchType != nil {
            map["ItemMatchType"] = self.itemMatchType!
        }
        if self.similarityThreshold != nil {
            map["SimilarityThreshold"] = self.similarityThreshold!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.watchMode != nil {
            map["WatchMode"] = self.watchMode!
        }
        if self.watchPolicyName != nil {
            map["WatchPolicyName"] = self.watchPolicyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemMatchType") {
            self.itemMatchType = dict["ItemMatchType"] as! String
        }
        if dict.keys.contains("SimilarityThreshold") {
            self.similarityThreshold = dict["SimilarityThreshold"] as! Double
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("WatchMode") {
            self.watchMode = dict["WatchMode"] as! String
        }
        if dict.keys.contains("WatchPolicyName") {
            self.watchPolicyName = dict["WatchPolicyName"] as! String
        }
    }
}

public class CreateWatchPolicyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var watchPolicyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.watchPolicyId != nil {
                map["WatchPolicyId"] = self.watchPolicyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WatchPolicyId") {
                self.watchPolicyId = dict["WatchPolicyId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateWatchPolicyResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateWatchPolicyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateWatchPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWatchPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWatchPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWatchTaskRequest : Tea.TeaModel {
    public var corpId: String?

    public var description_: String?

    public var deviceList: String?

    public var messageReceiver: String?

    public var scheduleCycleDates: String?

    public var scheduleTimes: String?

    public var scheduleType: String?

    public var taskName: String?

    public var watchPolicyIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceList != nil {
            map["DeviceList"] = self.deviceList!
        }
        if self.messageReceiver != nil {
            map["MessageReceiver"] = self.messageReceiver!
        }
        if self.scheduleCycleDates != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDates!
        }
        if self.scheduleTimes != nil {
            map["ScheduleTimes"] = self.scheduleTimes!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.watchPolicyIds != nil {
            map["WatchPolicyIds"] = self.watchPolicyIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceList = dict["DeviceList"] as! String
        }
        if dict.keys.contains("MessageReceiver") {
            self.messageReceiver = dict["MessageReceiver"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDates = dict["ScheduleCycleDates"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("WatchPolicyIds") {
            self.watchPolicyIds = dict["WatchPolicyIds"] as! String
        }
    }
}

public class CreateWatchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var watchTaskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.watchTaskId != nil {
                map["WatchTaskId"] = self.watchTaskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WatchTaskId") {
                self.watchTaskId = dict["WatchTaskId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateWatchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateWatchTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateWatchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWatchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWatchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAIInstanceRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class DeleteAIInstanceShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class DeleteAIInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAIInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAIInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAIInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAiotDeviceRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteAiotDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAiotDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAiotDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAiotDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAiotPersonTableRequest : Tea.TeaModel {
    public var id: String?

    public var personTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
    }
}

public class DeleteAiotPersonTableResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAiotPersonTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAiotPersonTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAiotPersonTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAiotPersonTableItemRequest : Tea.TeaModel {
    public var id: String?

    public var personTableId: String?

    public var personTableItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        if self.personTableItemId != nil {
            map["PersonTableItemId"] = self.personTableItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
        if dict.keys.contains("PersonTableItemId") {
            self.personTableItemId = dict["PersonTableItemId"] as! String
        }
    }
}

public class DeleteAiotPersonTableItemResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAiotPersonTableItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAiotPersonTableItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAiotPersonTableItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAiotVehicleTableItemRequest : Tea.TeaModel {
    public var id: String?

    public var vehicleTableId: String?

    public var vehicleTableItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItemId != nil {
            map["VehicleTableItemId"] = self.vehicleTableItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItemId") {
            self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
        }
    }
}

public class DeleteAiotVehicleTableItemResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAiotVehicleTableItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAiotVehicleTableItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAiotVehicleTableItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteChannelRequest : Tea.TeaModel {
    public var deviceCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCodes != nil {
            map["DeviceCodes"] = self.deviceCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCodes") {
            self.deviceCodes = dict["DeviceCodes"] as! String
        }
    }
}

public class DeleteChannelResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCorpGroupRequest : Tea.TeaModel {
    public var corpId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class DeleteCorpGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteCorpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCorpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCorpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourcesRequest : Tea.TeaModel {
    public var dataSourceIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceIdList != nil {
            map["DataSourceIdList"] = self.dataSourceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceIdList") {
            self.dataSourceIdList = dict["DataSourceIdList"] as! String
        }
    }
}

public class DeleteDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var dataSourceId: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DeleteDataSourcesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DeleteDataSourcesResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeviceRequest : Tea.TeaModel {
    public var corpId: String?

    public var gbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
    }
}

public class DeleteDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeviceForInstanceRequest : Tea.TeaModel {
    public class Devices : Tea.TeaModel {
        public var deviceId: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var algorithmId: String?

    public var deleteInstanceFlag: Bool?

    public var deviceCount: String?

    public var devices: [DeleteDeviceForInstanceRequest.Devices]?

    public var instanceId: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.deleteInstanceFlag != nil {
            map["DeleteInstanceFlag"] = self.deleteInstanceFlag!
        }
        if self.deviceCount != nil {
            map["DeviceCount"] = self.deviceCount!
        }
        if self.devices != nil {
            var tmp : [Any] = []
            for k in self.devices! {
                tmp.append(k.toMap())
            }
            map["Devices"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("DeleteInstanceFlag") {
            self.deleteInstanceFlag = dict["DeleteInstanceFlag"] as! Bool
        }
        if dict.keys.contains("DeviceCount") {
            self.deviceCount = dict["DeviceCount"] as! String
        }
        if dict.keys.contains("Devices") {
            self.devices = dict["Devices"] as! [DeleteDeviceForInstanceRequest.Devices]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteDeviceForInstanceShrinkRequest : Tea.TeaModel {
    public var algorithmId: String?

    public var deleteInstanceFlag: Bool?

    public var deviceCount: String?

    public var devicesShrink: String?

    public var instanceId: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.deleteInstanceFlag != nil {
            map["DeleteInstanceFlag"] = self.deleteInstanceFlag!
        }
        if self.deviceCount != nil {
            map["DeviceCount"] = self.deviceCount!
        }
        if self.devicesShrink != nil {
            map["Devices"] = self.devicesShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("DeleteInstanceFlag") {
            self.deleteInstanceFlag = dict["DeleteInstanceFlag"] as! Bool
        }
        if dict.keys.contains("DeviceCount") {
            self.deviceCount = dict["DeviceCount"] as! String
        }
        if dict.keys.contains("Devices") {
            self.devicesShrink = dict["Devices"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteDeviceForInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDeviceForInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeviceForInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDeviceForInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDevicesRequest : Tea.TeaModel {
    public var deviceIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
    }
}

public class DeleteDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var description_: String?

        public var deviceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DeleteDevicesResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DeleteDevicesResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDoubleVerificationGroupRequest : Tea.TeaModel {
    public var doubleVerificationGroupId: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.doubleVerificationGroupId != nil {
            map["DoubleVerificationGroupId"] = self.doubleVerificationGroupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DoubleVerificationGroupId") {
            self.doubleVerificationGroupId = dict["DoubleVerificationGroupId"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteDoubleVerificationGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDoubleVerificationGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDoubleVerificationGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDoubleVerificationGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIPCDeviceRequest : Tea.TeaModel {
    public var deviceCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCodes != nil {
            map["DeviceCodes"] = self.deviceCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCodes") {
            self.deviceCodes = dict["DeviceCodes"] as! String
        }
    }
}

public class DeleteIPCDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIPCDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIPCDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIPCDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteModelServiceRequest : Tea.TeaModel {
    public var modelServiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelServiceId != nil {
            map["ModelServiceId"] = self.modelServiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelServiceId") {
            self.modelServiceId = dict["ModelServiceId"] as! String
        }
    }
}

public class DeleteModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var modelServiceInstanceId: String?

        public var modelServiceInstanceName: Int32?

        public var modelServiceStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceInstanceName != nil {
                map["ModelServiceInstanceName"] = self.modelServiceInstanceName!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceName") {
                self.modelServiceInstanceName = dict["ModelServiceInstanceName"] as! Int32
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: DeleteModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNVRDeviceRequest : Tea.TeaModel {
    public var deviceCodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCodes != nil {
            map["DeviceCodes"] = self.deviceCodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCodes") {
            self.deviceCodes = dict["DeviceCodes"] as! String
        }
    }
}

public class DeleteNVRDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNVRDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNVRDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNVRDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProfileRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var profileId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.profileId != nil {
            map["ProfileId"] = self.profileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ProfileId") {
            self.profileId = dict["ProfileId"] as! Int64
        }
    }
}

public class DeleteProfileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteProfileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProfileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProfileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProfileCatalogRequest : Tea.TeaModel {
    public var catalogId: String?

    public var corpId: String?

    public var isvSubId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
    }
}

public class DeleteProfileCatalogResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteProfileCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProfileCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProfileCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var projectIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectIds != nil {
            map["ProjectIds"] = self.projectIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectIds") {
            self.projectIds = dict["ProjectIds"] as! String
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRecordsRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var attributeName: String?

    public var corpId: String?

    public var operatorType: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.operatorType != nil {
            map["OperatorType"] = self.operatorType!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("AttributeName") {
            self.attributeName = dict["AttributeName"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("OperatorType") {
            self.operatorType = dict["OperatorType"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DeleteRecordsResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSearchTablesRequest : Tea.TeaModel {
    public var searchTableIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchTableIds != nil {
            map["SearchTableIds"] = self.searchTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchTableIds") {
            self.searchTableIds = dict["SearchTableIds"] as! String
        }
    }
}

public class DeleteSearchTablesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteSearchTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSearchTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSearchTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class DeleteUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserGroupRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var userGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! String
        }
    }
}

public class DeleteUserGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVideoSummaryTaskRequest : Tea.TeaModel {
    public var corpId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteVideoSummaryTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVideoSummaryTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVideoSummaryTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVideoSummaryTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWatchPoliciesRequest : Tea.TeaModel {
    public var watchPolicyIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watchPolicyIds != nil {
            map["WatchPolicyIds"] = self.watchPolicyIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatchPolicyIds") {
            self.watchPolicyIds = dict["WatchPolicyIds"] as! String
        }
    }
}

public class DeleteWatchPoliciesResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteWatchPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWatchPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWatchPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWatchTasksRequest : Tea.TeaModel {
    public var watchTaskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watchTaskIds != nil {
            map["WatchTaskIds"] = self.watchTaskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatchTaskIds") {
            self.watchTaskIds = dict["WatchTaskIds"] as! String
        }
    }
}

public class DeleteWatchTasksResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteWatchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWatchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWatchTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAIInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var instanceType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DescribeAIInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var acuUsed: Int64?

            public var algorithmId: String?

            public var algorithmName: String?

            public var cameraNumber: Int64?

            public var computeType: String?

            public var containerType: String?

            public var createDateTime: String?

            public var dataSource: String?

            public var dataSourceTimes: String?

            public var dataType: String?

            public var fps: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceType: String?

            public var scheduleCycleDates: String?

            public var scheduleTimes: String?

            public var scheduleType: String?

            public var spf: Int64?

            public var status: String?

            public var storage: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acuUsed != nil {
                    map["AcuUsed"] = self.acuUsed!
                }
                if self.algorithmId != nil {
                    map["AlgorithmId"] = self.algorithmId!
                }
                if self.algorithmName != nil {
                    map["AlgorithmName"] = self.algorithmName!
                }
                if self.cameraNumber != nil {
                    map["CameraNumber"] = self.cameraNumber!
                }
                if self.computeType != nil {
                    map["ComputeType"] = self.computeType!
                }
                if self.containerType != nil {
                    map["ContainerType"] = self.containerType!
                }
                if self.createDateTime != nil {
                    map["CreateDateTime"] = self.createDateTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource!
                }
                if self.dataSourceTimes != nil {
                    map["DataSourceTimes"] = self.dataSourceTimes!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.scheduleCycleDates != nil {
                    map["ScheduleCycleDates"] = self.scheduleCycleDates!
                }
                if self.scheduleTimes != nil {
                    map["ScheduleTimes"] = self.scheduleTimes!
                }
                if self.scheduleType != nil {
                    map["ScheduleType"] = self.scheduleType!
                }
                if self.spf != nil {
                    map["Spf"] = self.spf!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storage != nil {
                    map["Storage"] = self.storage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcuUsed") {
                    self.acuUsed = dict["AcuUsed"] as! Int64
                }
                if dict.keys.contains("AlgorithmId") {
                    self.algorithmId = dict["AlgorithmId"] as! String
                }
                if dict.keys.contains("AlgorithmName") {
                    self.algorithmName = dict["AlgorithmName"] as! String
                }
                if dict.keys.contains("CameraNumber") {
                    self.cameraNumber = dict["CameraNumber"] as! Int64
                }
                if dict.keys.contains("ComputeType") {
                    self.computeType = dict["ComputeType"] as! String
                }
                if dict.keys.contains("ContainerType") {
                    self.containerType = dict["ContainerType"] as! String
                }
                if dict.keys.contains("CreateDateTime") {
                    self.createDateTime = dict["CreateDateTime"] as! String
                }
                if dict.keys.contains("DataSource") {
                    self.dataSource = dict["DataSource"] as! String
                }
                if dict.keys.contains("DataSourceTimes") {
                    self.dataSourceTimes = dict["DataSourceTimes"] as! String
                }
                if dict.keys.contains("DataType") {
                    self.dataType = dict["DataType"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("ScheduleCycleDates") {
                    self.scheduleCycleDates = dict["ScheduleCycleDates"] as! String
                }
                if dict.keys.contains("ScheduleTimes") {
                    self.scheduleTimes = dict["ScheduleTimes"] as! String
                }
                if dict.keys.contains("ScheduleType") {
                    self.scheduleType = dict["ScheduleType"] as! String
                }
                if dict.keys.contains("Spf") {
                    self.spf = dict["Spf"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Storage") {
                    self.storage = dict["Storage"] as! Double
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [DescribeAIInstanceResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeAIInstanceResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeAIInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeAIInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAIInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAIInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAIInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAiotDevicesRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var idList: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("IdList") {
            self.idList = dict["IdList"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeAiotDevicesResponseBody : Tea.TeaModel {
    public class AiotDevices : Tea.TeaModel {
        public class AiotDeviceList : Tea.TeaModel {
            public var capDirection: String?

            public var corpId: String?

            public var deviceId: String?

            public var deviceType: String?

            public var firmwareVersion: String?

            public var IPAddr: String?

            public var IPV6Addr: String?

            public var IPv4Gateway: String?

            public var IPv4Netmask: String?

            public var id: String?

            public var isOnline: String?

            public var latitude: Double?

            public var longitude: Double?

            public var MAC: String?

            public var manufacturer: String?

            public var model: String?

            public var monitorAreaDesc: String?

            public var monitorDirection: String?

            public var name: String?

            public var orgCode: String?

            public var ownerApsID: String?

            public var password: String?

            public var place: String?

            public var placeCode: String?

            public var port: Int64?

            public var serialNuber: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capDirection != nil {
                    map["CapDirection"] = self.capDirection!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.firmwareVersion != nil {
                    map["FirmwareVersion"] = self.firmwareVersion!
                }
                if self.IPAddr != nil {
                    map["IPAddr"] = self.IPAddr!
                }
                if self.IPV6Addr != nil {
                    map["IPV6Addr"] = self.IPV6Addr!
                }
                if self.IPv4Gateway != nil {
                    map["IPv4Gateway"] = self.IPv4Gateway!
                }
                if self.IPv4Netmask != nil {
                    map["IPv4Netmask"] = self.IPv4Netmask!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isOnline != nil {
                    map["IsOnline"] = self.isOnline!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.MAC != nil {
                    map["MAC"] = self.MAC!
                }
                if self.manufacturer != nil {
                    map["Manufacturer"] = self.manufacturer!
                }
                if self.model != nil {
                    map["Model"] = self.model!
                }
                if self.monitorAreaDesc != nil {
                    map["MonitorAreaDesc"] = self.monitorAreaDesc!
                }
                if self.monitorDirection != nil {
                    map["MonitorDirection"] = self.monitorDirection!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.orgCode != nil {
                    map["OrgCode"] = self.orgCode!
                }
                if self.ownerApsID != nil {
                    map["OwnerApsID"] = self.ownerApsID!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.place != nil {
                    map["Place"] = self.place!
                }
                if self.placeCode != nil {
                    map["PlaceCode"] = self.placeCode!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serialNuber != nil {
                    map["SerialNuber"] = self.serialNuber!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapDirection") {
                    self.capDirection = dict["CapDirection"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("FirmwareVersion") {
                    self.firmwareVersion = dict["FirmwareVersion"] as! String
                }
                if dict.keys.contains("IPAddr") {
                    self.IPAddr = dict["IPAddr"] as! String
                }
                if dict.keys.contains("IPV6Addr") {
                    self.IPV6Addr = dict["IPV6Addr"] as! String
                }
                if dict.keys.contains("IPv4Gateway") {
                    self.IPv4Gateway = dict["IPv4Gateway"] as! String
                }
                if dict.keys.contains("IPv4Netmask") {
                    self.IPv4Netmask = dict["IPv4Netmask"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IsOnline") {
                    self.isOnline = dict["IsOnline"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! Double
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! Double
                }
                if dict.keys.contains("MAC") {
                    self.MAC = dict["MAC"] as! String
                }
                if dict.keys.contains("Manufacturer") {
                    self.manufacturer = dict["Manufacturer"] as! String
                }
                if dict.keys.contains("Model") {
                    self.model = dict["Model"] as! String
                }
                if dict.keys.contains("MonitorAreaDesc") {
                    self.monitorAreaDesc = dict["MonitorAreaDesc"] as! String
                }
                if dict.keys.contains("MonitorDirection") {
                    self.monitorDirection = dict["MonitorDirection"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OrgCode") {
                    self.orgCode = dict["OrgCode"] as! String
                }
                if dict.keys.contains("OwnerApsID") {
                    self.ownerApsID = dict["OwnerApsID"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Place") {
                    self.place = dict["Place"] as! String
                }
                if dict.keys.contains("PlaceCode") {
                    self.placeCode = dict["PlaceCode"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int64
                }
                if dict.keys.contains("SerialNuber") {
                    self.serialNuber = dict["SerialNuber"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var aiotDeviceList: [DescribeAiotDevicesResponseBody.AiotDevices.AiotDeviceList]?

        public var pageNum: Int64?

        public var pageSize: Int64?

        public var totalNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aiotDeviceList != nil {
                var tmp : [Any] = []
                for k in self.aiotDeviceList! {
                    tmp.append(k.toMap())
                }
                map["AiotDeviceList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalNum != nil {
                map["TotalNum"] = self.totalNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AiotDeviceList") {
                self.aiotDeviceList = dict["AiotDeviceList"] as! [DescribeAiotDevicesResponseBody.AiotDevices.AiotDeviceList]
            }
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalNum") {
                self.totalNum = dict["TotalNum"] as! Int64
            }
        }
    }
    public var aiotDevices: DescribeAiotDevicesResponseBody.AiotDevices?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aiotDevices?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDevices != nil {
            map["AiotDevices"] = self.aiotDevices?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDevices") {
            var model = DescribeAiotDevicesResponseBody.AiotDevices()
            model.fromMap(dict["AiotDevices"] as! [String: Any])
            self.aiotDevices = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAiotDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAiotDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAiotDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAiotPersonTableItemsRequest : Tea.TeaModel {
    public var id: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var personTableId: String?

    public var personTableItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        if self.personTableItemId != nil {
            map["PersonTableItemId"] = self.personTableItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
        if dict.keys.contains("PersonTableItemId") {
            self.personTableItemId = dict["PersonTableItemId"] as! String
        }
    }
}

public class DescribeAiotPersonTableItemsResponseBody : Tea.TeaModel {
    public class PersonTableItems : Tea.TeaModel {
        public class PersonTableItemList : Tea.TeaModel {
            public class IdentificationList : Tea.TeaModel {
                public var number: String?

                public var type: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Number") {
                        self.number = dict["Number"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! Int64
                    }
                }
            }
            public class ImageList : Tea.TeaModel {
                public class FeatureInfo : Tea.TeaModel {
                    public var algorithmType: String?

                    public var algorithmVersion: String?

                    public var featureData: String?

                    public var imageId: String?

                    public var objectId: String?

                    public var tableId: String?

                    public var vendor: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.algorithmType != nil {
                            map["AlgorithmType"] = self.algorithmType!
                        }
                        if self.algorithmVersion != nil {
                            map["AlgorithmVersion"] = self.algorithmVersion!
                        }
                        if self.featureData != nil {
                            map["FeatureData"] = self.featureData!
                        }
                        if self.imageId != nil {
                            map["ImageId"] = self.imageId!
                        }
                        if self.objectId != nil {
                            map["ObjectId"] = self.objectId!
                        }
                        if self.tableId != nil {
                            map["TableId"] = self.tableId!
                        }
                        if self.vendor != nil {
                            map["Vendor"] = self.vendor!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AlgorithmType") {
                            self.algorithmType = dict["AlgorithmType"] as! String
                        }
                        if dict.keys.contains("AlgorithmVersion") {
                            self.algorithmVersion = dict["AlgorithmVersion"] as! String
                        }
                        if dict.keys.contains("FeatureData") {
                            self.featureData = dict["FeatureData"] as! String
                        }
                        if dict.keys.contains("ImageId") {
                            self.imageId = dict["ImageId"] as! String
                        }
                        if dict.keys.contains("ObjectId") {
                            self.objectId = dict["ObjectId"] as! String
                        }
                        if dict.keys.contains("TableId") {
                            self.tableId = dict["TableId"] as! String
                        }
                        if dict.keys.contains("Vendor") {
                            self.vendor = dict["Vendor"] as! String
                        }
                    }
                }
                public var data: String?

                public var deviceId: String?

                public var eventSort: String?

                public var featureInfo: DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.ImageList.FeatureInfo?

                public var fileFormat: String?

                public var height: Int64?

                public var imageId: String?

                public var shotTime: String?

                public var size: Int64?

                public var storagePath: String?

                public var type: String?

                public var width: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.featureInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["Data"] = self.data!
                    }
                    if self.deviceId != nil {
                        map["DeviceId"] = self.deviceId!
                    }
                    if self.eventSort != nil {
                        map["EventSort"] = self.eventSort!
                    }
                    if self.featureInfo != nil {
                        map["FeatureInfo"] = self.featureInfo?.toMap()
                    }
                    if self.fileFormat != nil {
                        map["FileFormat"] = self.fileFormat!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.shotTime != nil {
                        map["ShotTime"] = self.shotTime!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.storagePath != nil {
                        map["StoragePath"] = self.storagePath!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Data") {
                        self.data = dict["Data"] as! String
                    }
                    if dict.keys.contains("DeviceId") {
                        self.deviceId = dict["DeviceId"] as! String
                    }
                    if dict.keys.contains("EventSort") {
                        self.eventSort = dict["EventSort"] as! String
                    }
                    if dict.keys.contains("FeatureInfo") {
                        var model = DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.ImageList.FeatureInfo()
                        model.fromMap(dict["FeatureInfo"] as! [String: Any])
                        self.featureInfo = model
                    }
                    if dict.keys.contains("FileFormat") {
                        self.fileFormat = dict["FileFormat"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! Int64
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ShotTime") {
                        self.shotTime = dict["ShotTime"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! Int64
                    }
                    if dict.keys.contains("StoragePath") {
                        self.storagePath = dict["StoragePath"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! Int64
                    }
                }
            }
            public var identificationList: [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.IdentificationList]?

            public var identificationNum: Int64?

            public var imageList: [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.ImageList]?

            public var imageNum: Int64?

            public var lastChange: String?

            public var personCode: String?

            public var personId: String?

            public var personName: String?

            public var personTableId: String?

            public var remarks: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identificationList != nil {
                    var tmp : [Any] = []
                    for k in self.identificationList! {
                        tmp.append(k.toMap())
                    }
                    map["IdentificationList"] = tmp
                }
                if self.identificationNum != nil {
                    map["IdentificationNum"] = self.identificationNum!
                }
                if self.imageList != nil {
                    var tmp : [Any] = []
                    for k in self.imageList! {
                        tmp.append(k.toMap())
                    }
                    map["ImageList"] = tmp
                }
                if self.imageNum != nil {
                    map["ImageNum"] = self.imageNum!
                }
                if self.lastChange != nil {
                    map["LastChange"] = self.lastChange!
                }
                if self.personCode != nil {
                    map["PersonCode"] = self.personCode!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.personName != nil {
                    map["PersonName"] = self.personName!
                }
                if self.personTableId != nil {
                    map["PersonTableId"] = self.personTableId!
                }
                if self.remarks != nil {
                    map["Remarks"] = self.remarks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IdentificationList") {
                    self.identificationList = dict["IdentificationList"] as! [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.IdentificationList]
                }
                if dict.keys.contains("IdentificationNum") {
                    self.identificationNum = dict["IdentificationNum"] as! Int64
                }
                if dict.keys.contains("ImageList") {
                    self.imageList = dict["ImageList"] as! [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList.ImageList]
                }
                if dict.keys.contains("ImageNum") {
                    self.imageNum = dict["ImageNum"] as! Int64
                }
                if dict.keys.contains("LastChange") {
                    self.lastChange = dict["LastChange"] as! String
                }
                if dict.keys.contains("PersonCode") {
                    self.personCode = dict["PersonCode"] as! String
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PersonName") {
                    self.personName = dict["PersonName"] as! String
                }
                if dict.keys.contains("PersonTableId") {
                    self.personTableId = dict["PersonTableId"] as! String
                }
                if dict.keys.contains("Remarks") {
                    self.remarks = dict["Remarks"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var personTableItemList: [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList]?

        public var totalNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.personTableItemList != nil {
                var tmp : [Any] = []
                for k in self.personTableItemList! {
                    tmp.append(k.toMap())
                }
                map["PersonTableItemList"] = tmp
            }
            if self.totalNum != nil {
                map["TotalNum"] = self.totalNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("PersonTableItemList") {
                self.personTableItemList = dict["PersonTableItemList"] as! [DescribeAiotPersonTableItemsResponseBody.PersonTableItems.PersonTableItemList]
            }
            if dict.keys.contains("TotalNum") {
                self.totalNum = dict["TotalNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var message: String?

    public var personTableItems: DescribeAiotPersonTableItemsResponseBody.PersonTableItems?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTableItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.personTableItems != nil {
            map["PersonTableItems"] = self.personTableItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PersonTableItems") {
            var model = DescribeAiotPersonTableItemsResponseBody.PersonTableItems()
            model.fromMap(dict["PersonTableItems"] as! [String: Any])
            self.personTableItems = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAiotPersonTableItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAiotPersonTableItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAiotPersonTableItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAiotPersonTablesRequest : Tea.TeaModel {
    public var id: String?

    public var personTableIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTableIdList != nil {
            map["PersonTableIdList"] = self.personTableIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTableIdList") {
            self.personTableIdList = dict["PersonTableIdList"] as! String
        }
    }
}

public class DescribeAiotPersonTablesResponseBody : Tea.TeaModel {
    public class PersonTableList : Tea.TeaModel {
        public var deviceId: String?

        public var faceNum: Int64?

        public var lastChange: String?

        public var name: String?

        public var personNum: Int64?

        public var personTableId: String?

        public var totalPersonNum: Int64?

        public var type: Int64?

        public var verificationModelList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.faceNum != nil {
                map["FaceNum"] = self.faceNum!
            }
            if self.lastChange != nil {
                map["LastChange"] = self.lastChange!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personNum != nil {
                map["PersonNum"] = self.personNum!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            if self.totalPersonNum != nil {
                map["TotalPersonNum"] = self.totalPersonNum!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.verificationModelList != nil {
                map["VerificationModelList"] = self.verificationModelList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("FaceNum") {
                self.faceNum = dict["FaceNum"] as! Int64
            }
            if dict.keys.contains("LastChange") {
                self.lastChange = dict["LastChange"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonNum") {
                self.personNum = dict["PersonNum"] as! Int64
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
            if dict.keys.contains("TotalPersonNum") {
                self.totalPersonNum = dict["TotalPersonNum"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
            if dict.keys.contains("VerificationModelList") {
                self.verificationModelList = dict["VerificationModelList"] as! [Int64]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var personTableList: [DescribeAiotPersonTablesResponseBody.PersonTableList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.personTableList != nil {
            var tmp : [Any] = []
            for k in self.personTableList! {
                tmp.append(k.toMap())
            }
            map["PersonTableList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PersonTableList") {
            self.personTableList = dict["PersonTableList"] as! [DescribeAiotPersonTablesResponseBody.PersonTableList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAiotPersonTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAiotPersonTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAiotPersonTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAiotVehicleTableItemsRequest : Tea.TeaModel {
    public var id: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var vehicleTableId: String?

    public var vehicleTableItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItemId != nil {
            map["VehicleTableItemId"] = self.vehicleTableItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItemId") {
            self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
        }
    }
}

public class DescribeAiotVehicleTableItemsResponseBody : Tea.TeaModel {
    public class VehicleTableItems : Tea.TeaModel {
        public class VehicleTableItemList : Tea.TeaModel {
            public var beginTime: String?

            public var endTime: String?

            public var ownerName: String?

            public var phoneNo: String?

            public var plateNo: String?

            public var remarks: String?

            public var vehicleTableId: String?

            public var vehicleTableItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.ownerName != nil {
                    map["OwnerName"] = self.ownerName!
                }
                if self.phoneNo != nil {
                    map["PhoneNo"] = self.phoneNo!
                }
                if self.plateNo != nil {
                    map["PlateNo"] = self.plateNo!
                }
                if self.remarks != nil {
                    map["Remarks"] = self.remarks!
                }
                if self.vehicleTableId != nil {
                    map["VehicleTableId"] = self.vehicleTableId!
                }
                if self.vehicleTableItemId != nil {
                    map["VehicleTableItemId"] = self.vehicleTableItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginTime") {
                    self.beginTime = dict["BeginTime"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("OwnerName") {
                    self.ownerName = dict["OwnerName"] as! String
                }
                if dict.keys.contains("PhoneNo") {
                    self.phoneNo = dict["PhoneNo"] as! String
                }
                if dict.keys.contains("PlateNo") {
                    self.plateNo = dict["PlateNo"] as! String
                }
                if dict.keys.contains("Remarks") {
                    self.remarks = dict["Remarks"] as! String
                }
                if dict.keys.contains("VehicleTableId") {
                    self.vehicleTableId = dict["VehicleTableId"] as! String
                }
                if dict.keys.contains("VehicleTableItemId") {
                    self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var totalNum: Int64?

        public var vehicleTableItemList: [DescribeAiotVehicleTableItemsResponseBody.VehicleTableItems.VehicleTableItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalNum != nil {
                map["TotalNum"] = self.totalNum!
            }
            if self.vehicleTableItemList != nil {
                var tmp : [Any] = []
                for k in self.vehicleTableItemList! {
                    tmp.append(k.toMap())
                }
                map["VehicleTableItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalNum") {
                self.totalNum = dict["TotalNum"] as! Int64
            }
            if dict.keys.contains("VehicleTableItemList") {
                self.vehicleTableItemList = dict["VehicleTableItemList"] as! [DescribeAiotVehicleTableItemsResponseBody.VehicleTableItems.VehicleTableItemList]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var vehicleTableItems: DescribeAiotVehicleTableItemsResponseBody.VehicleTableItems?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vehicleTableItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vehicleTableItems != nil {
            map["VehicleTableItems"] = self.vehicleTableItems?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VehicleTableItems") {
            var model = DescribeAiotVehicleTableItemsResponseBody.VehicleTableItems()
            model.fromMap(dict["VehicleTableItems"] as! [String: Any])
            self.vehicleTableItems = model
        }
    }
}

public class DescribeAiotVehicleTableItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAiotVehicleTableItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAiotVehicleTableItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAiotVehicleTablesRequest : Tea.TeaModel {
    public var id: String?

    public var vehicleTableIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableIdList != nil {
            map["VehicleTableIdList"] = self.vehicleTableIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableIdList") {
            self.vehicleTableIdList = dict["VehicleTableIdList"] as! String
        }
    }
}

public class DescribeAiotVehicleTablesResponseBody : Tea.TeaModel {
    public class VehicleTableList : Tea.TeaModel {
        public var vehicleTableId: String?

        public var vehicleTableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vehicleTableId != nil {
                map["VehicleTableId"] = self.vehicleTableId!
            }
            if self.vehicleTableName != nil {
                map["VehicleTableName"] = self.vehicleTableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VehicleTableId") {
                self.vehicleTableId = dict["VehicleTableId"] as! String
            }
            if dict.keys.contains("VehicleTableName") {
                self.vehicleTableName = dict["VehicleTableName"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var vehicleTableList: [DescribeAiotVehicleTablesResponseBody.VehicleTableList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vehicleTableList != nil {
            var tmp : [Any] = []
            for k in self.vehicleTableList! {
                tmp.append(k.toMap())
            }
            map["VehicleTableList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VehicleTableList") {
            self.vehicleTableList = dict["VehicleTableList"] as! [DescribeAiotVehicleTablesResponseBody.VehicleTableList]
        }
    }
}

public class DescribeAiotVehicleTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAiotVehicleTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAiotVehicleTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCameraForInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeCameraForInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var cameraAddress: String?

            public var cameraId: String?

            public var cameraName: String?

            public var cameraStatus: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cameraAddress != nil {
                    map["CameraAddress"] = self.cameraAddress!
                }
                if self.cameraId != nil {
                    map["CameraId"] = self.cameraId!
                }
                if self.cameraName != nil {
                    map["CameraName"] = self.cameraName!
                }
                if self.cameraStatus != nil {
                    map["CameraStatus"] = self.cameraStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CameraAddress") {
                    self.cameraAddress = dict["CameraAddress"] as! String
                }
                if dict.keys.contains("CameraId") {
                    self.cameraId = dict["CameraId"] as! String
                }
                if dict.keys.contains("CameraName") {
                    self.cameraName = dict["CameraName"] as! String
                }
                if dict.keys.contains("CameraStatus") {
                    self.cameraStatus = dict["CameraStatus"] as! Int64
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [DescribeCameraForInstanceResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeCameraForInstanceResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeCameraForInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCameraForInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCameraForInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCameraForInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCameraForInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChannelsRequest : Tea.TeaModel {
    public var deviceFilter: String?

    public var deviceStatus: String?

    public var nvrId: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var showUnConfig: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceFilter != nil {
            map["DeviceFilter"] = self.deviceFilter!
        }
        if self.deviceStatus != nil {
            map["DeviceStatus"] = self.deviceStatus!
        }
        if self.nvrId != nil {
            map["NvrId"] = self.nvrId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.showUnConfig != nil {
            map["ShowUnConfig"] = self.showUnConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceFilter") {
            self.deviceFilter = dict["DeviceFilter"] as! String
        }
        if dict.keys.contains("DeviceStatus") {
            self.deviceStatus = dict["DeviceStatus"] as! String
        }
        if dict.keys.contains("NvrId") {
            self.nvrId = dict["NvrId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ShowUnConfig") {
            self.showUnConfig = dict["ShowUnConfig"] as! Int64
        }
    }
}

public class DescribeChannelsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var audioEnable: String?

            public var corpId: String?

            public var createTime: String?

            public var datasourceType: String?

            public var deviceAddress: String?

            public var deviceDirection: String?

            public var deviceId: String?

            public var deviceIp: String?

            public var deviceModel: String?

            public var deviceName: String?

            public var deviceRate: String?

            public var deviceResolution: String?

            public var deviceSite: String?

            public var deviceSn: String?

            public var deviceStatus: String?

            public var deviceSubType: String?

            public var deviceType: String?

            public var encodeFormat: String?

            public var frameRate: String?

            public var govLength: String?

            public var inProtocol: String?

            public var latitude: String?

            public var longitude: String?

            public var modifyTime: String?

            public var OSDTimeEnable: String?

            public var OSDTimeType: String?

            public var OSDTimeX: String?

            public var OSDTimeY: String?

            public var parentDeviceId: String?

            public var password: String?

            public var serverId: String?

            public var serverIp: String?

            public var serverPort: String?

            public var serverRealm: String?

            public var streamAction: String?

            public var streamStatus: String?

            public var vap: String?

            public var vendor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioEnable != nil {
                    map["AudioEnable"] = self.audioEnable!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.datasourceType != nil {
                    map["DatasourceType"] = self.datasourceType!
                }
                if self.deviceAddress != nil {
                    map["DeviceAddress"] = self.deviceAddress!
                }
                if self.deviceDirection != nil {
                    map["DeviceDirection"] = self.deviceDirection!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceIp != nil {
                    map["DeviceIp"] = self.deviceIp!
                }
                if self.deviceModel != nil {
                    map["DeviceModel"] = self.deviceModel!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceRate != nil {
                    map["DeviceRate"] = self.deviceRate!
                }
                if self.deviceResolution != nil {
                    map["DeviceResolution"] = self.deviceResolution!
                }
                if self.deviceSite != nil {
                    map["DeviceSite"] = self.deviceSite!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.deviceStatus != nil {
                    map["DeviceStatus"] = self.deviceStatus!
                }
                if self.deviceSubType != nil {
                    map["DeviceSubType"] = self.deviceSubType!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.encodeFormat != nil {
                    map["EncodeFormat"] = self.encodeFormat!
                }
                if self.frameRate != nil {
                    map["FrameRate"] = self.frameRate!
                }
                if self.govLength != nil {
                    map["GovLength"] = self.govLength!
                }
                if self.inProtocol != nil {
                    map["InProtocol"] = self.inProtocol!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.OSDTimeEnable != nil {
                    map["OSDTimeEnable"] = self.OSDTimeEnable!
                }
                if self.OSDTimeType != nil {
                    map["OSDTimeType"] = self.OSDTimeType!
                }
                if self.OSDTimeX != nil {
                    map["OSDTimeX"] = self.OSDTimeX!
                }
                if self.OSDTimeY != nil {
                    map["OSDTimeY"] = self.OSDTimeY!
                }
                if self.parentDeviceId != nil {
                    map["ParentDeviceId"] = self.parentDeviceId!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.serverPort != nil {
                    map["ServerPort"] = self.serverPort!
                }
                if self.serverRealm != nil {
                    map["ServerRealm"] = self.serverRealm!
                }
                if self.streamAction != nil {
                    map["StreamAction"] = self.streamAction!
                }
                if self.streamStatus != nil {
                    map["StreamStatus"] = self.streamStatus!
                }
                if self.vap != nil {
                    map["Vap"] = self.vap!
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioEnable") {
                    self.audioEnable = dict["AudioEnable"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DatasourceType") {
                    self.datasourceType = dict["DatasourceType"] as! String
                }
                if dict.keys.contains("DeviceAddress") {
                    self.deviceAddress = dict["DeviceAddress"] as! String
                }
                if dict.keys.contains("DeviceDirection") {
                    self.deviceDirection = dict["DeviceDirection"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceIp") {
                    self.deviceIp = dict["DeviceIp"] as! String
                }
                if dict.keys.contains("DeviceModel") {
                    self.deviceModel = dict["DeviceModel"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceRate") {
                    self.deviceRate = dict["DeviceRate"] as! String
                }
                if dict.keys.contains("DeviceResolution") {
                    self.deviceResolution = dict["DeviceResolution"] as! String
                }
                if dict.keys.contains("DeviceSite") {
                    self.deviceSite = dict["DeviceSite"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("DeviceStatus") {
                    self.deviceStatus = dict["DeviceStatus"] as! String
                }
                if dict.keys.contains("DeviceSubType") {
                    self.deviceSubType = dict["DeviceSubType"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("EncodeFormat") {
                    self.encodeFormat = dict["EncodeFormat"] as! String
                }
                if dict.keys.contains("FrameRate") {
                    self.frameRate = dict["FrameRate"] as! String
                }
                if dict.keys.contains("GovLength") {
                    self.govLength = dict["GovLength"] as! String
                }
                if dict.keys.contains("InProtocol") {
                    self.inProtocol = dict["InProtocol"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("OSDTimeEnable") {
                    self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
                }
                if dict.keys.contains("OSDTimeType") {
                    self.OSDTimeType = dict["OSDTimeType"] as! String
                }
                if dict.keys.contains("OSDTimeX") {
                    self.OSDTimeX = dict["OSDTimeX"] as! String
                }
                if dict.keys.contains("OSDTimeY") {
                    self.OSDTimeY = dict["OSDTimeY"] as! String
                }
                if dict.keys.contains("ParentDeviceId") {
                    self.parentDeviceId = dict["ParentDeviceId"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("ServerPort") {
                    self.serverPort = dict["ServerPort"] as! String
                }
                if dict.keys.contains("ServerRealm") {
                    self.serverRealm = dict["ServerRealm"] as! String
                }
                if dict.keys.contains("StreamAction") {
                    self.streamAction = dict["StreamAction"] as! String
                }
                if dict.keys.contains("StreamStatus") {
                    self.streamStatus = dict["StreamStatus"] as! String
                }
                if dict.keys.contains("Vap") {
                    self.vap = dict["Vap"] as! String
                }
                if dict.keys.contains("Vendor") {
                    self.vendor = dict["Vendor"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var records: [DescribeChannelsResponseBody.Data.Records]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public var unConfigList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            if self.unConfigList != nil {
                map["UnConfigList"] = self.unConfigList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeChannelsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
            if dict.keys.contains("UnConfigList") {
                self.unConfigList = dict["UnConfigList"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: DescribeChannelsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeChannelsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataSourcesRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var dataSourceCategory: String?

    public var dataSourceFilter: String?

    public var dataSourceIdList: String?

    public var dataSourceType: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var streamStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.dataSourceCategory != nil {
            map["DataSourceCategory"] = self.dataSourceCategory!
        }
        if self.dataSourceFilter != nil {
            map["DataSourceFilter"] = self.dataSourceFilter!
        }
        if self.dataSourceIdList != nil {
            map["DataSourceIdList"] = self.dataSourceIdList!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.streamStatus != nil {
            map["StreamStatus"] = self.streamStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DataSourceCategory") {
            self.dataSourceCategory = dict["DataSourceCategory"] as! String
        }
        if dict.keys.contains("DataSourceFilter") {
            self.dataSourceFilter = dict["DataSourceFilter"] as! String
        }
        if dict.keys.contains("DataSourceIdList") {
            self.dataSourceIdList = dict["DataSourceIdList"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StreamStatus") {
            self.streamStatus = dict["StreamStatus"] as! String
        }
    }
}

public class DescribeDataSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var action: String?

            public var corpId: String?

            public var createTime: String?

            public var dataSourceId: String?

            public var dataSourceName: String?

            public var dataSourceType: String?

            public var description_: String?

            public var kafkaTopic: String?

            public var ossPath: String?

            public var streamStatus: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.kafkaTopic != nil {
                    map["KafkaTopic"] = self.kafkaTopic!
                }
                if self.ossPath != nil {
                    map["OssPath"] = self.ossPath!
                }
                if self.streamStatus != nil {
                    map["StreamStatus"] = self.streamStatus!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DataSourceId") {
                    self.dataSourceId = dict["DataSourceId"] as! String
                }
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("DataSourceType") {
                    self.dataSourceType = dict["DataSourceType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("KafkaTopic") {
                    self.kafkaTopic = dict["KafkaTopic"] as! String
                }
                if dict.keys.contains("OssPath") {
                    self.ossPath = dict["OssPath"] as! String
                }
                if dict.keys.contains("StreamStatus") {
                    self.streamStatus = dict["StreamStatus"] as! String
                }
                if dict.keys.contains("Url") {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var records: [DescribeDataSourcesResponseBody.Data.Records]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeDataSourcesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeDataSourcesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeDataSourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDevicesRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceIdList: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var capturedPictureId: String?

            public var corpId: String?

            public var createTime: String?

            public var deviceAddress: String?

            public var deviceId: String?

            public var deviceName: String?

            public var deviceType: String?

            public var inProtocol: String?

            public var latitude: String?

            public var longitude: String?

            public var password: String?

            public var status: String?

            public var vendor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capturedPictureId != nil {
                    map["CapturedPictureId"] = self.capturedPictureId!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deviceAddress != nil {
                    map["DeviceAddress"] = self.deviceAddress!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.inProtocol != nil {
                    map["InProtocol"] = self.inProtocol!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapturedPictureId") {
                    self.capturedPictureId = dict["CapturedPictureId"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeviceAddress") {
                    self.deviceAddress = dict["DeviceAddress"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("InProtocol") {
                    self.inProtocol = dict["InProtocol"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Vendor") {
                    self.vendor = dict["Vendor"] as! String
                }
            }
        }
        public var pageNum: Int32?

        public var pageSize: Int32?

        public var records: [DescribeDevicesResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeDevicesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DescribeDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpcsRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceFilter: String?

    public var deviceIdList: String?

    public var deviceStatus: String?

    public var nvrIdList: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var parentDeviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceFilter != nil {
            map["DeviceFilter"] = self.deviceFilter!
        }
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        if self.deviceStatus != nil {
            map["DeviceStatus"] = self.deviceStatus!
        }
        if self.nvrIdList != nil {
            map["NvrIdList"] = self.nvrIdList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentDeviceType != nil {
            map["ParentDeviceType"] = self.parentDeviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceFilter") {
            self.deviceFilter = dict["DeviceFilter"] as! String
        }
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
        if dict.keys.contains("DeviceStatus") {
            self.deviceStatus = dict["DeviceStatus"] as! String
        }
        if dict.keys.contains("NvrIdList") {
            self.nvrIdList = dict["NvrIdList"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ParentDeviceType") {
            self.parentDeviceType = dict["ParentDeviceType"] as! String
        }
    }
}

public class DescribeIpcsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var audioEnable: String?

            public var corpId: String?

            public var createTime: String?

            public var datasourceType: String?

            public var deviceAddress: String?

            public var deviceDirection: String?

            public var deviceId: String?

            public var deviceIp: String?

            public var deviceModel: String?

            public var deviceName: String?

            public var deviceRate: String?

            public var deviceResolution: String?

            public var deviceSite: String?

            public var deviceSn: String?

            public var deviceStatus: String?

            public var deviceSubType: String?

            public var deviceType: String?

            public var encodeFormat: String?

            public var frameRate: String?

            public var govLength: String?

            public var inProtocol: String?

            public var latitude: String?

            public var longitude: String?

            public var modifyTime: String?

            public var OSDTimeEnable: String?

            public var OSDTimeType: String?

            public var OSDTimeX: String?

            public var OSDTimeY: String?

            public var parentDeviceId: String?

            public var password: String?

            public var serverId: String?

            public var serverIp: String?

            public var serverPort: String?

            public var serverRealm: String?

            public var streamAction: String?

            public var streamStatus: String?

            public var vap: String?

            public var vendor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioEnable != nil {
                    map["AudioEnable"] = self.audioEnable!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.datasourceType != nil {
                    map["DatasourceType"] = self.datasourceType!
                }
                if self.deviceAddress != nil {
                    map["DeviceAddress"] = self.deviceAddress!
                }
                if self.deviceDirection != nil {
                    map["DeviceDirection"] = self.deviceDirection!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceIp != nil {
                    map["DeviceIp"] = self.deviceIp!
                }
                if self.deviceModel != nil {
                    map["DeviceModel"] = self.deviceModel!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceRate != nil {
                    map["DeviceRate"] = self.deviceRate!
                }
                if self.deviceResolution != nil {
                    map["DeviceResolution"] = self.deviceResolution!
                }
                if self.deviceSite != nil {
                    map["DeviceSite"] = self.deviceSite!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.deviceStatus != nil {
                    map["DeviceStatus"] = self.deviceStatus!
                }
                if self.deviceSubType != nil {
                    map["DeviceSubType"] = self.deviceSubType!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.encodeFormat != nil {
                    map["EncodeFormat"] = self.encodeFormat!
                }
                if self.frameRate != nil {
                    map["FrameRate"] = self.frameRate!
                }
                if self.govLength != nil {
                    map["GovLength"] = self.govLength!
                }
                if self.inProtocol != nil {
                    map["InProtocol"] = self.inProtocol!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.OSDTimeEnable != nil {
                    map["OSDTimeEnable"] = self.OSDTimeEnable!
                }
                if self.OSDTimeType != nil {
                    map["OSDTimeType"] = self.OSDTimeType!
                }
                if self.OSDTimeX != nil {
                    map["OSDTimeX"] = self.OSDTimeX!
                }
                if self.OSDTimeY != nil {
                    map["OSDTimeY"] = self.OSDTimeY!
                }
                if self.parentDeviceId != nil {
                    map["ParentDeviceId"] = self.parentDeviceId!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.serverPort != nil {
                    map["ServerPort"] = self.serverPort!
                }
                if self.serverRealm != nil {
                    map["ServerRealm"] = self.serverRealm!
                }
                if self.streamAction != nil {
                    map["StreamAction"] = self.streamAction!
                }
                if self.streamStatus != nil {
                    map["StreamStatus"] = self.streamStatus!
                }
                if self.vap != nil {
                    map["Vap"] = self.vap!
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioEnable") {
                    self.audioEnable = dict["AudioEnable"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DatasourceType") {
                    self.datasourceType = dict["DatasourceType"] as! String
                }
                if dict.keys.contains("DeviceAddress") {
                    self.deviceAddress = dict["DeviceAddress"] as! String
                }
                if dict.keys.contains("DeviceDirection") {
                    self.deviceDirection = dict["DeviceDirection"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceIp") {
                    self.deviceIp = dict["DeviceIp"] as! String
                }
                if dict.keys.contains("DeviceModel") {
                    self.deviceModel = dict["DeviceModel"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceRate") {
                    self.deviceRate = dict["DeviceRate"] as! String
                }
                if dict.keys.contains("DeviceResolution") {
                    self.deviceResolution = dict["DeviceResolution"] as! String
                }
                if dict.keys.contains("DeviceSite") {
                    self.deviceSite = dict["DeviceSite"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("DeviceStatus") {
                    self.deviceStatus = dict["DeviceStatus"] as! String
                }
                if dict.keys.contains("DeviceSubType") {
                    self.deviceSubType = dict["DeviceSubType"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("EncodeFormat") {
                    self.encodeFormat = dict["EncodeFormat"] as! String
                }
                if dict.keys.contains("FrameRate") {
                    self.frameRate = dict["FrameRate"] as! String
                }
                if dict.keys.contains("GovLength") {
                    self.govLength = dict["GovLength"] as! String
                }
                if dict.keys.contains("InProtocol") {
                    self.inProtocol = dict["InProtocol"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("OSDTimeEnable") {
                    self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
                }
                if dict.keys.contains("OSDTimeType") {
                    self.OSDTimeType = dict["OSDTimeType"] as! String
                }
                if dict.keys.contains("OSDTimeX") {
                    self.OSDTimeX = dict["OSDTimeX"] as! String
                }
                if dict.keys.contains("OSDTimeY") {
                    self.OSDTimeY = dict["OSDTimeY"] as! String
                }
                if dict.keys.contains("ParentDeviceId") {
                    self.parentDeviceId = dict["ParentDeviceId"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("ServerPort") {
                    self.serverPort = dict["ServerPort"] as! String
                }
                if dict.keys.contains("ServerRealm") {
                    self.serverRealm = dict["ServerRealm"] as! String
                }
                if dict.keys.contains("StreamAction") {
                    self.streamAction = dict["StreamAction"] as! String
                }
                if dict.keys.contains("StreamStatus") {
                    self.streamStatus = dict["StreamStatus"] as! String
                }
                if dict.keys.contains("Vap") {
                    self.vap = dict["Vap"] as! String
                }
                if dict.keys.contains("Vendor") {
                    self.vendor = dict["Vendor"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var records: [DescribeIpcsResponseBody.Data.Records]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeIpcsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeIpcsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeIpcsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeIpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpcsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModelServiceRequest : Tea.TeaModel {
    public var modelServiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelServiceId != nil {
            map["ModelServiceId"] = self.modelServiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelServiceId") {
            self.modelServiceId = dict["ModelServiceId"] as! String
        }
    }
}

public class DescribeModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModelApiList : Tea.TeaModel {
            public var algorithmApiCode: String?

            public var apiId: String?

            public var apiName: String?

            public var apiPath: String?

            public var createTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.algorithmApiCode != nil {
                    map["AlgorithmApiCode"] = self.algorithmApiCode!
                }
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlgorithmApiCode") {
                    self.algorithmApiCode = dict["AlgorithmApiCode"] as! String
                }
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
            }
        }
        public var algorithmCode: String?

        public var appCode: String?

        public var createTime: String?

        public var modelApiList: [DescribeModelServiceResponseBody.Data.ModelApiList]?

        public var modelServiceInstanceId: String?

        public var modelServiceInstanceName: String?

        public var modelServiceStatus: String?

        public var qps: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.algorithmCode != nil {
                map["AlgorithmCode"] = self.algorithmCode!
            }
            if self.appCode != nil {
                map["AppCode"] = self.appCode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.modelApiList != nil {
                var tmp : [Any] = []
                for k in self.modelApiList! {
                    tmp.append(k.toMap())
                }
                map["ModelApiList"] = tmp
            }
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceInstanceName != nil {
                map["ModelServiceInstanceName"] = self.modelServiceInstanceName!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            if self.qps != nil {
                map["Qps"] = self.qps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlgorithmCode") {
                self.algorithmCode = dict["AlgorithmCode"] as! String
            }
            if dict.keys.contains("AppCode") {
                self.appCode = dict["AppCode"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ModelApiList") {
                self.modelApiList = dict["ModelApiList"] as! [DescribeModelServiceResponseBody.Data.ModelApiList]
            }
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceName") {
                self.modelServiceInstanceName = dict["ModelServiceInstanceName"] as! String
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
            if dict.keys.contains("Qps") {
                self.qps = dict["Qps"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModelServiceListRequest : Tea.TeaModel {
    public var algorithmCode: String?

    public var includeDeleted: Bool?

    public var modelServiceName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmCode != nil {
            map["AlgorithmCode"] = self.algorithmCode!
        }
        if self.includeDeleted != nil {
            map["IncludeDeleted"] = self.includeDeleted!
        }
        if self.modelServiceName != nil {
            map["ModelServiceName"] = self.modelServiceName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmCode") {
            self.algorithmCode = dict["AlgorithmCode"] as! String
        }
        if dict.keys.contains("IncludeDeleted") {
            self.includeDeleted = dict["IncludeDeleted"] as! Bool
        }
        if dict.keys.contains("ModelServiceName") {
            self.modelServiceName = dict["ModelServiceName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeModelServiceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ModelList : Tea.TeaModel {
            public var algorithmCode: String?

            public var appCode: String?

            public var createTime: String?

            public var modelServiceInstanceId: String?

            public var modelServiceName: String?

            public var modelServiceStatus: String?

            public var qpsRequired: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.algorithmCode != nil {
                    map["AlgorithmCode"] = self.algorithmCode!
                }
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modelServiceInstanceId != nil {
                    map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
                }
                if self.modelServiceName != nil {
                    map["ModelServiceName"] = self.modelServiceName!
                }
                if self.modelServiceStatus != nil {
                    map["ModelServiceStatus"] = self.modelServiceStatus!
                }
                if self.qpsRequired != nil {
                    map["QpsRequired"] = self.qpsRequired!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlgorithmCode") {
                    self.algorithmCode = dict["AlgorithmCode"] as! String
                }
                if dict.keys.contains("AppCode") {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModelServiceInstanceId") {
                    self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
                }
                if dict.keys.contains("ModelServiceName") {
                    self.modelServiceName = dict["ModelServiceName"] as! String
                }
                if dict.keys.contains("ModelServiceStatus") {
                    self.modelServiceStatus = dict["ModelServiceStatus"] as! String
                }
                if dict.keys.contains("QpsRequired") {
                    self.qpsRequired = dict["QpsRequired"] as! Int32
                }
            }
        }
        public var modelList: [DescribeModelServiceListResponseBody.Data.ModelList]?

        public var total: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelList != nil {
                var tmp : [Any] = []
                for k in self.modelList! {
                    tmp.append(k.toMap())
                }
                map["ModelList"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelList") {
                self.modelList = dict["ModelList"] as! [DescribeModelServiceListResponseBody.Data.ModelList]
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeModelServiceListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeModelServiceListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeModelServiceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModelServiceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeModelServiceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNvrDevicesRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceFilter: String?

    public var nvrDeviceIdList: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceFilter != nil {
            map["DeviceFilter"] = self.deviceFilter!
        }
        if self.nvrDeviceIdList != nil {
            map["NvrDeviceIdList"] = self.nvrDeviceIdList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceFilter") {
            self.deviceFilter = dict["DeviceFilter"] as! String
        }
        if dict.keys.contains("NvrDeviceIdList") {
            self.nvrDeviceIdList = dict["NvrDeviceIdList"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeNvrDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var channel: String?

            public var corpId: String?

            public var createTime: String?

            public var datasourceType: String?

            public var deviceId: String?

            public var deviceModel: String?

            public var deviceName: String?

            public var deviceSn: String?

            public var deviceStatus: String?

            public var deviceType: String?

            public var modifyTime: String?

            public var projectName: String?

            public var regionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channel != nil {
                    map["Channel"] = self.channel!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.datasourceType != nil {
                    map["DatasourceType"] = self.datasourceType!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceModel != nil {
                    map["DeviceModel"] = self.deviceModel!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.deviceStatus != nil {
                    map["DeviceStatus"] = self.deviceStatus!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channel") {
                    self.channel = dict["Channel"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DatasourceType") {
                    self.datasourceType = dict["DatasourceType"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceModel") {
                    self.deviceModel = dict["DeviceModel"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("DeviceStatus") {
                    self.deviceStatus = dict["DeviceStatus"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("RegionName") {
                    self.regionName = dict["RegionName"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var records: [DescribeNvrDevicesResponseBody.Data.Records]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeNvrDevicesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeNvrDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeNvrDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNvrDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNvrDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNvrDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNvrsRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceFilter: String?

    public var nvrDeviceIdList: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceFilter != nil {
            map["DeviceFilter"] = self.deviceFilter!
        }
        if self.nvrDeviceIdList != nil {
            map["NvrDeviceIdList"] = self.nvrDeviceIdList!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceFilter") {
            self.deviceFilter = dict["DeviceFilter"] as! String
        }
        if dict.keys.contains("NvrDeviceIdList") {
            self.nvrDeviceIdList = dict["NvrDeviceIdList"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribeNvrsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public class SubDeviceInfo : Tea.TeaModel {
                public var subDeviceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.subDeviceId != nil {
                        map["SubDeviceId"] = self.subDeviceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SubDeviceId") {
                        self.subDeviceId = dict["SubDeviceId"] as! String
                    }
                }
            }
            public var corpId: String?

            public var createTime: String?

            public var datasourceType: String?

            public var deviceAddress: String?

            public var deviceId: String?

            public var deviceModel: String?

            public var deviceName: String?

            public var deviceSn: String?

            public var deviceStatus: String?

            public var deviceType: String?

            public var inProtocol: String?

            public var latitude: String?

            public var longitude: String?

            public var modifyTime: String?

            public var password: String?

            public var serverId: String?

            public var serverIp: String?

            public var serverPort: String?

            public var serverRealm: String?

            public var subDeviceCount: String?

            public var subDeviceInfo: [DescribeNvrsResponseBody.Data.Records.SubDeviceInfo]?

            public var vendor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.datasourceType != nil {
                    map["DatasourceType"] = self.datasourceType!
                }
                if self.deviceAddress != nil {
                    map["DeviceAddress"] = self.deviceAddress!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceModel != nil {
                    map["DeviceModel"] = self.deviceModel!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.deviceStatus != nil {
                    map["DeviceStatus"] = self.deviceStatus!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.inProtocol != nil {
                    map["InProtocol"] = self.inProtocol!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.password != nil {
                    map["Password"] = self.password!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.serverPort != nil {
                    map["ServerPort"] = self.serverPort!
                }
                if self.serverRealm != nil {
                    map["ServerRealm"] = self.serverRealm!
                }
                if self.subDeviceCount != nil {
                    map["SubDeviceCount"] = self.subDeviceCount!
                }
                if self.subDeviceInfo != nil {
                    var tmp : [Any] = []
                    for k in self.subDeviceInfo! {
                        tmp.append(k.toMap())
                    }
                    map["SubDeviceInfo"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DatasourceType") {
                    self.datasourceType = dict["DatasourceType"] as! String
                }
                if dict.keys.contains("DeviceAddress") {
                    self.deviceAddress = dict["DeviceAddress"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceModel") {
                    self.deviceModel = dict["DeviceModel"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("DeviceStatus") {
                    self.deviceStatus = dict["DeviceStatus"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("InProtocol") {
                    self.inProtocol = dict["InProtocol"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("Password") {
                    self.password = dict["Password"] as! String
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("ServerPort") {
                    self.serverPort = dict["ServerPort"] as! String
                }
                if dict.keys.contains("ServerRealm") {
                    self.serverRealm = dict["ServerRealm"] as! String
                }
                if dict.keys.contains("SubDeviceCount") {
                    self.subDeviceCount = dict["SubDeviceCount"] as! String
                }
                if dict.keys.contains("SubDeviceInfo") {
                    self.subDeviceInfo = dict["SubDeviceInfo"] as! [DescribeNvrsResponseBody.Data.Records.SubDeviceInfo]
                }
                if dict.keys.contains("Vendor") {
                    self.vendor = dict["Vendor"] as! String
                }
            }
        }
        public var pageNum: Int64?

        public var pageSize: Int64?

        public var records: [DescribeNvrsResponseBody.Data.Records]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeNvrsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeNvrsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeNvrsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNvrsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNvrsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNvrsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSearchItemsRequest : Tea.TeaModel {
    public var pageNumber: String?

    public var pageSize: String?

    public var searchItemIds: String?

    public var searchTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchItemIds != nil {
            map["SearchItemIds"] = self.searchItemIds!
        }
        if self.searchTableId != nil {
            map["SearchTableId"] = self.searchTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchItemIds") {
            self.searchItemIds = dict["SearchItemIds"] as! String
        }
        if dict.keys.contains("SearchTableId") {
            self.searchTableId = dict["SearchTableId"] as! String
        }
    }
}

public class DescribeSearchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var itemImageUrl: String?

            public var searchItemId: String?

            public var searchItemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemImageUrl != nil {
                    map["ItemImageUrl"] = self.itemImageUrl!
                }
                if self.searchItemId != nil {
                    map["SearchItemId"] = self.searchItemId!
                }
                if self.searchItemName != nil {
                    map["SearchItemName"] = self.searchItemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemImageUrl") {
                    self.itemImageUrl = dict["ItemImageUrl"] as! String
                }
                if dict.keys.contains("SearchItemId") {
                    self.searchItemId = dict["SearchItemId"] as! String
                }
                if dict.keys.contains("SearchItemName") {
                    self.searchItemName = dict["SearchItemName"] as! String
                }
            }
        }
        public var pageNumber: String?

        public var pageSize: String?

        public var records: [DescribeSearchItemsResponseBody.Data.Records]?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeSearchItemsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeSearchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSearchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSearchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSearchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSearchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSearchTablesRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchTableIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchTableIds != nil {
            map["SearchTableIds"] = self.searchTableIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchTableIds") {
            self.searchTableIds = dict["SearchTableIds"] as! String
        }
    }
}

public class DescribeSearchTablesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var algorithmId: String?

            public var searchTableId: String?

            public var searchTableName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.algorithmId != nil {
                    map["AlgorithmId"] = self.algorithmId!
                }
                if self.searchTableId != nil {
                    map["SearchTableId"] = self.searchTableId!
                }
                if self.searchTableName != nil {
                    map["SearchTableName"] = self.searchTableName!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlgorithmId") {
                    self.algorithmId = dict["AlgorithmId"] as! String
                }
                if dict.keys.contains("SearchTableId") {
                    self.searchTableId = dict["SearchTableId"] as! String
                }
                if dict.keys.contains("SearchTableName") {
                    self.searchTableName = dict["SearchTableName"] as! String
                }
                if dict.keys.contains("TargetType") {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var pageNumbei: Int64?

        public var pageSize: Int64?

        public var records: [DescribeSearchTablesResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumbei != nil {
                map["PageNumbei"] = self.pageNumbei!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumbei") {
                self.pageNumbei = dict["PageNumbei"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeSearchTablesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSearchTablesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSearchTablesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSearchTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSearchTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSearchTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWatchItemsRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var watchItemIds: String?

    public var watchPolicyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.watchItemIds != nil {
            map["WatchItemIds"] = self.watchItemIds!
        }
        if self.watchPolicyId != nil {
            map["WatchPolicyId"] = self.watchPolicyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("WatchItemIds") {
            self.watchItemIds = dict["WatchItemIds"] as! String
        }
        if dict.keys.contains("WatchPolicyId") {
            self.watchPolicyId = dict["WatchPolicyId"] as! String
        }
    }
}

public class DescribeWatchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var itemAttributes: String?

            public var itemImageUrl: String?

            public var watchItemId: String?

            public var watchItemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemAttributes != nil {
                    map["ItemAttributes"] = self.itemAttributes!
                }
                if self.itemImageUrl != nil {
                    map["ItemImageUrl"] = self.itemImageUrl!
                }
                if self.watchItemId != nil {
                    map["WatchItemId"] = self.watchItemId!
                }
                if self.watchItemName != nil {
                    map["WatchItemName"] = self.watchItemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemAttributes") {
                    self.itemAttributes = dict["ItemAttributes"] as! String
                }
                if dict.keys.contains("ItemImageUrl") {
                    self.itemImageUrl = dict["ItemImageUrl"] as! String
                }
                if dict.keys.contains("WatchItemId") {
                    self.watchItemId = dict["WatchItemId"] as! String
                }
                if dict.keys.contains("WatchItemName") {
                    self.watchItemName = dict["WatchItemName"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [DescribeWatchItemsResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeWatchItemsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeWatchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeWatchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeWatchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWatchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeWatchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWatchPoliciesRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var watchPolicyIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.watchPolicyIds != nil {
            map["WatchPolicyIds"] = self.watchPolicyIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("WatchPolicyIds") {
            self.watchPolicyIds = dict["WatchPolicyIds"] as! String
        }
    }
}

public class DescribeWatchPoliciesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var itemMatchType: String?

            public var similarityThreshold: Double?

            public var targetType: String?

            public var watchMode: String?

            public var watchPolicyId: String?

            public var watchPolicyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemMatchType != nil {
                    map["ItemMatchType"] = self.itemMatchType!
                }
                if self.similarityThreshold != nil {
                    map["SimilarityThreshold"] = self.similarityThreshold!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                if self.watchMode != nil {
                    map["WatchMode"] = self.watchMode!
                }
                if self.watchPolicyId != nil {
                    map["WatchPolicyId"] = self.watchPolicyId!
                }
                if self.watchPolicyName != nil {
                    map["WatchPolicyName"] = self.watchPolicyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemMatchType") {
                    self.itemMatchType = dict["ItemMatchType"] as! String
                }
                if dict.keys.contains("SimilarityThreshold") {
                    self.similarityThreshold = dict["SimilarityThreshold"] as! Double
                }
                if dict.keys.contains("TargetType") {
                    self.targetType = dict["TargetType"] as! String
                }
                if dict.keys.contains("WatchMode") {
                    self.watchMode = dict["WatchMode"] as! String
                }
                if dict.keys.contains("WatchPolicyId") {
                    self.watchPolicyId = dict["WatchPolicyId"] as! String
                }
                if dict.keys.contains("WatchPolicyName") {
                    self.watchPolicyName = dict["WatchPolicyName"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [DescribeWatchPoliciesResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeWatchPoliciesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeWatchPoliciesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeWatchPoliciesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeWatchPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWatchPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeWatchPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWatchTasksRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var watchTaskIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.watchTaskIds != nil {
            map["WatchTaskIds"] = self.watchTaskIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("WatchTaskIds") {
            self.watchTaskIds = dict["WatchTaskIds"] as! String
        }
    }
}

public class DescribeWatchTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var corpId: String?

            public var description_: String?

            public var deviceList: String?

            public var messageReceiver: String?

            public var scheduleCycleDates: String?

            public var scheduleTimes: String?

            public var scheduleType: String?

            public var taskName: String?

            public var watchPolicyIds: String?

            public var watchTaskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceList != nil {
                    map["DeviceList"] = self.deviceList!
                }
                if self.messageReceiver != nil {
                    map["MessageReceiver"] = self.messageReceiver!
                }
                if self.scheduleCycleDates != nil {
                    map["ScheduleCycleDates"] = self.scheduleCycleDates!
                }
                if self.scheduleTimes != nil {
                    map["ScheduleTimes"] = self.scheduleTimes!
                }
                if self.scheduleType != nil {
                    map["ScheduleType"] = self.scheduleType!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.watchPolicyIds != nil {
                    map["WatchPolicyIds"] = self.watchPolicyIds!
                }
                if self.watchTaskId != nil {
                    map["WatchTaskId"] = self.watchTaskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DeviceList") {
                    self.deviceList = dict["DeviceList"] as! String
                }
                if dict.keys.contains("MessageReceiver") {
                    self.messageReceiver = dict["MessageReceiver"] as! String
                }
                if dict.keys.contains("ScheduleCycleDates") {
                    self.scheduleCycleDates = dict["ScheduleCycleDates"] as! String
                }
                if dict.keys.contains("ScheduleTimes") {
                    self.scheduleTimes = dict["ScheduleTimes"] as! String
                }
                if dict.keys.contains("ScheduleType") {
                    self.scheduleType = dict["ScheduleType"] as! String
                }
                if dict.keys.contains("TaskName") {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("WatchPolicyIds") {
                    self.watchPolicyIds = dict["WatchPolicyIds"] as! String
                }
                if dict.keys.contains("WatchTaskId") {
                    self.watchTaskId = dict["WatchTaskId"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [DescribeWatchTasksResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [DescribeWatchTasksResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeWatchTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeWatchTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeWatchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWatchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeWatchTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribesDoubleVerificationGroupsRequest : Tea.TeaModel {
    public var doubleVerificationGroupIds: String?

    public var id: String?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.doubleVerificationGroupIds != nil {
            map["DoubleVerificationGroupIds"] = self.doubleVerificationGroupIds!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DoubleVerificationGroupIds") {
            self.doubleVerificationGroupIds = dict["DoubleVerificationGroupIds"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class DescribesDoubleVerificationGroupsResponseBody : Tea.TeaModel {
    public class DoubleVerificationGroups : Tea.TeaModel {
        public class DoubleVerificationGroupList : Tea.TeaModel {
            public class PersonIdList : Tea.TeaModel {
                public var personId: String?

                public var personTableId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.personId != nil {
                        map["PersonId"] = self.personId!
                    }
                    if self.personTableId != nil {
                        map["PersonTableId"] = self.personTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PersonId") {
                        self.personId = dict["PersonId"] as! String
                    }
                    if dict.keys.contains("PersonTableId") {
                        self.personTableId = dict["PersonTableId"] as! String
                    }
                }
            }
            public var deviceId: String?

            public var enabled: String?

            public var groupId: String?

            public var interval: Int64?

            public var lastChange: String?

            public var memberNumber: Int64?

            public var personIdList: [DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups.DoubleVerificationGroupList.PersonIdList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.lastChange != nil {
                    map["LastChange"] = self.lastChange!
                }
                if self.memberNumber != nil {
                    map["MemberNumber"] = self.memberNumber!
                }
                if self.personIdList != nil {
                    var tmp : [Any] = []
                    for k in self.personIdList! {
                        tmp.append(k.toMap())
                    }
                    map["PersonIdList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("LastChange") {
                    self.lastChange = dict["LastChange"] as! String
                }
                if dict.keys.contains("MemberNumber") {
                    self.memberNumber = dict["MemberNumber"] as! Int64
                }
                if dict.keys.contains("PersonIdList") {
                    self.personIdList = dict["PersonIdList"] as! [DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups.DoubleVerificationGroupList.PersonIdList]
                }
            }
        }
        public var doubleVerificationGroupList: [DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups.DoubleVerificationGroupList]?

        public var pageNum: Int64?

        public var pageSize: Int64?

        public var totalNum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.doubleVerificationGroupList != nil {
                var tmp : [Any] = []
                for k in self.doubleVerificationGroupList! {
                    tmp.append(k.toMap())
                }
                map["DoubleVerificationGroupList"] = tmp
            }
            if self.pageNum != nil {
                map["PageNum"] = self.pageNum!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalNum != nil {
                map["TotalNum"] = self.totalNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DoubleVerificationGroupList") {
                self.doubleVerificationGroupList = dict["DoubleVerificationGroupList"] as! [DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups.DoubleVerificationGroupList]
            }
            if dict.keys.contains("PageNum") {
                self.pageNum = dict["PageNum"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalNum") {
                self.totalNum = dict["TotalNum"] as! Int64
            }
        }
    }
    public var code: String?

    public var doubleVerificationGroups: DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.doubleVerificationGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.doubleVerificationGroups != nil {
            map["DoubleVerificationGroups"] = self.doubleVerificationGroups?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DoubleVerificationGroups") {
            var model = DescribesDoubleVerificationGroupsResponseBody.DoubleVerificationGroups()
            model.fromMap(dict["DoubleVerificationGroups"] as! [String: Any])
            self.doubleVerificationGroups = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribesDoubleVerificationGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribesDoubleVerificationGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribesDoubleVerificationGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAiotStorageInfoResponseBody : Tea.TeaModel {
    public class AiotStorageInfo : Tea.TeaModel {
        public class EventAlarmMq : Tea.TeaModel {
            public var alarmTopic: String?

            public var eventTopic: String?

            public var instanceId: String?

            public var mqType: String?

            public var ramArnRole: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alarmTopic != nil {
                    map["AlarmTopic"] = self.alarmTopic!
                }
                if self.eventTopic != nil {
                    map["EventTopic"] = self.eventTopic!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mqType != nil {
                    map["MqType"] = self.mqType!
                }
                if self.ramArnRole != nil {
                    map["RamArnRole"] = self.ramArnRole!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlarmTopic") {
                    self.alarmTopic = dict["AlarmTopic"] as! String
                }
                if dict.keys.contains("EventTopic") {
                    self.eventTopic = dict["EventTopic"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MqType") {
                    self.mqType = dict["MqType"] as! String
                }
                if dict.keys.contains("RamArnRole") {
                    self.ramArnRole = dict["RamArnRole"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public class EventAlarmPictureStorage : Tea.TeaModel {
            public var bucket: String?

            public var endpoint: String?

            public var path: String?

            public var proxy: String?

            public var ramArnRole: String?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.proxy != nil {
                    map["Proxy"] = self.proxy!
                }
                if self.ramArnRole != nil {
                    map["RamArnRole"] = self.ramArnRole!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Endpoint") {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Proxy") {
                    self.proxy = dict["Proxy"] as! String
                }
                if dict.keys.contains("RamArnRole") {
                    self.ramArnRole = dict["RamArnRole"] as! String
                }
                if dict.keys.contains("StorageType") {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var eventAlarmMq: GetAiotStorageInfoResponseBody.AiotStorageInfo.EventAlarmMq?

        public var eventAlarmPictureStorage: GetAiotStorageInfoResponseBody.AiotStorageInfo.EventAlarmPictureStorage?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventAlarmMq?.validate()
            try self.eventAlarmPictureStorage?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventAlarmMq != nil {
                map["EventAlarmMq"] = self.eventAlarmMq?.toMap()
            }
            if self.eventAlarmPictureStorage != nil {
                map["EventAlarmPictureStorage"] = self.eventAlarmPictureStorage?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventAlarmMq") {
                var model = GetAiotStorageInfoResponseBody.AiotStorageInfo.EventAlarmMq()
                model.fromMap(dict["EventAlarmMq"] as! [String: Any])
                self.eventAlarmMq = model
            }
            if dict.keys.contains("EventAlarmPictureStorage") {
                var model = GetAiotStorageInfoResponseBody.AiotStorageInfo.EventAlarmPictureStorage()
                model.fromMap(dict["EventAlarmPictureStorage"] as! [String: Any])
                self.eventAlarmPictureStorage = model
            }
        }
    }
    public var aiotStorageInfo: GetAiotStorageInfoResponseBody.AiotStorageInfo?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aiotStorageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotStorageInfo != nil {
            map["AiotStorageInfo"] = self.aiotStorageInfo?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotStorageInfo") {
            var model = GetAiotStorageInfoResponseBody.AiotStorageInfo()
            model.fromMap(dict["AiotStorageInfo"] as! [String: Any])
            self.aiotStorageInfo = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAiotStorageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAiotStorageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAiotStorageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBodyOptionsRequest : Tea.TeaModel {
    public var corpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
    }
}

public class GetBodyOptionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class OptionList : Tea.TeaModel {
            public var key: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var key: String?

        public var name: String?

        public var optionList: [GetBodyOptionsResponseBody.Data.OptionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.optionList != nil {
                var tmp : [Any] = []
                for k in self.optionList! {
                    tmp.append(k.toMap())
                }
                map["OptionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OptionList") {
                self.optionList = dict["OptionList"] as! [GetBodyOptionsResponseBody.Data.OptionList]
            }
        }
    }
    public var code: String?

    public var data: [GetBodyOptionsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetBodyOptionsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBodyOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBodyOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBodyOptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCatalogListRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
    }
}

public class GetCatalogListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var catalogId: Int64?

        public var catalogName: String?

        public var isvSubId: String?

        public var parentCatalogId: Int64?

        public var profileCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogId != nil {
                map["CatalogId"] = self.catalogId!
            }
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.parentCatalogId != nil {
                map["ParentCatalogId"] = self.parentCatalogId!
            }
            if self.profileCount != nil {
                map["ProfileCount"] = self.profileCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogId") {
                self.catalogId = dict["CatalogId"] as! Int64
            }
            if dict.keys.contains("CatalogName") {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("ParentCatalogId") {
                self.parentCatalogId = dict["ParentCatalogId"] as! Int64
            }
            if dict.keys.contains("ProfileCount") {
                self.profileCount = dict["ProfileCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetCatalogListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetCatalogListResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCatalogListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCatalogListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCatalogListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCityCodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cityAddress: String?

        public var cityCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cityAddress != nil {
                map["CityAddress"] = self.cityAddress!
            }
            if self.cityCode != nil {
                map["CityCode"] = self.cityCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CityAddress") {
                self.cityAddress = dict["CityAddress"] as! String
            }
            if dict.keys.contains("CityCode") {
                self.cityCode = dict["CityCode"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetCityCodeResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetCityCodeResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCityCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCityCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCityCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataSourceStatsRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var dataSourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
    }
}

public class GetDataSourceStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var dataSourceType: String?

        public var items: [String: Any]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceType != nil {
                map["DataSourceType"] = self.dataSourceType!
            }
            if self.items != nil {
                map["Items"] = self.items!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceType") {
                self.dataSourceType = dict["DataSourceType"] as! String
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [String: Any]
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetDataSourceStatsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetDataSourceStatsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataSourceStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataSourceStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataSourceStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceCaptureStrategyRequest : Tea.TeaModel {
    public var deviceCode: String?

    public var deviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCode != nil {
            map["DeviceCode"] = self.deviceCode!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCode") {
            self.deviceCode = dict["DeviceCode"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
    }
}

public class GetDeviceCaptureStrategyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var deviceCode: String?

        public var deviceType: String?

        public var fridayCaptureStrategy: String?

        public var mondayCaptureStrategy: String?

        public var saturdayCaptureStrategy: String?

        public var sundayCaptureStrategy: String?

        public var thursdayCaptureStrategy: String?

        public var tuesdayCaptureStrategy: String?

        public var wednesdayCaptureStrategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceCode != nil {
                map["DeviceCode"] = self.deviceCode!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.fridayCaptureStrategy != nil {
                map["FridayCaptureStrategy"] = self.fridayCaptureStrategy!
            }
            if self.mondayCaptureStrategy != nil {
                map["MondayCaptureStrategy"] = self.mondayCaptureStrategy!
            }
            if self.saturdayCaptureStrategy != nil {
                map["SaturdayCaptureStrategy"] = self.saturdayCaptureStrategy!
            }
            if self.sundayCaptureStrategy != nil {
                map["SundayCaptureStrategy"] = self.sundayCaptureStrategy!
            }
            if self.thursdayCaptureStrategy != nil {
                map["ThursdayCaptureStrategy"] = self.thursdayCaptureStrategy!
            }
            if self.tuesdayCaptureStrategy != nil {
                map["TuesdayCaptureStrategy"] = self.tuesdayCaptureStrategy!
            }
            if self.wednesdayCaptureStrategy != nil {
                map["WednesdayCaptureStrategy"] = self.wednesdayCaptureStrategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceCode") {
                self.deviceCode = dict["DeviceCode"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("FridayCaptureStrategy") {
                self.fridayCaptureStrategy = dict["FridayCaptureStrategy"] as! String
            }
            if dict.keys.contains("MondayCaptureStrategy") {
                self.mondayCaptureStrategy = dict["MondayCaptureStrategy"] as! String
            }
            if dict.keys.contains("SaturdayCaptureStrategy") {
                self.saturdayCaptureStrategy = dict["SaturdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("SundayCaptureStrategy") {
                self.sundayCaptureStrategy = dict["SundayCaptureStrategy"] as! String
            }
            if dict.keys.contains("ThursdayCaptureStrategy") {
                self.thursdayCaptureStrategy = dict["ThursdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("TuesdayCaptureStrategy") {
                self.tuesdayCaptureStrategy = dict["TuesdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("WednesdayCaptureStrategy") {
                self.wednesdayCaptureStrategy = dict["WednesdayCaptureStrategy"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDeviceCaptureStrategyResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDeviceCaptureStrategyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDeviceCaptureStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceCaptureStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeviceCaptureStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceConfigRequest : Tea.TeaModel {
    public var deviceSn: String?

    public var deviceTimeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceSn != nil {
            map["DeviceSn"] = self.deviceSn!
        }
        if self.deviceTimeStamp != nil {
            map["DeviceTimeStamp"] = self.deviceTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceSn") {
            self.deviceSn = dict["DeviceSn"] as! String
        }
        if dict.keys.contains("DeviceTimeStamp") {
            self.deviceTimeStamp = dict["DeviceTimeStamp"] as! String
        }
    }
}

public class GetDeviceConfigResponseBody : Tea.TeaModel {
    public class ChannelList : Tea.TeaModel {
        public var channelGbId: String?

        public var fridayCaptureStrategy: String?

        public var mondayCaptureStrategy: String?

        public var saturdayCaptureStrategy: String?

        public var sundayCaptureStrategy: String?

        public var thursdayCaptureStrategy: String?

        public var tuesdayCaptureStrategy: String?

        public var wednesdayCaptureStrategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelGbId != nil {
                map["ChannelGbId"] = self.channelGbId!
            }
            if self.fridayCaptureStrategy != nil {
                map["FridayCaptureStrategy"] = self.fridayCaptureStrategy!
            }
            if self.mondayCaptureStrategy != nil {
                map["MondayCaptureStrategy"] = self.mondayCaptureStrategy!
            }
            if self.saturdayCaptureStrategy != nil {
                map["SaturdayCaptureStrategy"] = self.saturdayCaptureStrategy!
            }
            if self.sundayCaptureStrategy != nil {
                map["SundayCaptureStrategy"] = self.sundayCaptureStrategy!
            }
            if self.thursdayCaptureStrategy != nil {
                map["ThursdayCaptureStrategy"] = self.thursdayCaptureStrategy!
            }
            if self.tuesdayCaptureStrategy != nil {
                map["TuesdayCaptureStrategy"] = self.tuesdayCaptureStrategy!
            }
            if self.wednesdayCaptureStrategy != nil {
                map["WednesdayCaptureStrategy"] = self.wednesdayCaptureStrategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelGbId") {
                self.channelGbId = dict["ChannelGbId"] as! String
            }
            if dict.keys.contains("FridayCaptureStrategy") {
                self.fridayCaptureStrategy = dict["FridayCaptureStrategy"] as! String
            }
            if dict.keys.contains("MondayCaptureStrategy") {
                self.mondayCaptureStrategy = dict["MondayCaptureStrategy"] as! String
            }
            if dict.keys.contains("SaturdayCaptureStrategy") {
                self.saturdayCaptureStrategy = dict["SaturdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("SundayCaptureStrategy") {
                self.sundayCaptureStrategy = dict["SundayCaptureStrategy"] as! String
            }
            if dict.keys.contains("ThursdayCaptureStrategy") {
                self.thursdayCaptureStrategy = dict["ThursdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("TuesdayCaptureStrategy") {
                self.tuesdayCaptureStrategy = dict["TuesdayCaptureStrategy"] as! String
            }
            if dict.keys.contains("WednesdayCaptureStrategy") {
                self.wednesdayCaptureStrategy = dict["WednesdayCaptureStrategy"] as! String
            }
        }
    }
    public class OSDList : Tea.TeaModel {
        public var leftTopX: String?

        public var leftTopY: String?

        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.leftTopX != nil {
                map["LeftTopX"] = self.leftTopX!
            }
            if self.leftTopY != nil {
                map["LeftTopY"] = self.leftTopY!
            }
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LeftTopX") {
                self.leftTopX = dict["LeftTopX"] as! String
            }
            if dict.keys.contains("LeftTopY") {
                self.leftTopY = dict["LeftTopY"] as! String
            }
            if dict.keys.contains("Text") {
                self.text = dict["Text"] as! String
            }
        }
    }
    public var audioEnable: String?

    public var audioFormat: String?

    public var bitRate: String?

    public var channelList: [GetDeviceConfigResponseBody.ChannelList]?

    public var code: String?

    public var deviceAddress: String?

    public var deviceId: String?

    public var deviceName: String?

    public var encodeFormat: String?

    public var frameRate: String?

    public var govLength: Int64?

    public var latitude: String?

    public var longitude: String?

    public var message: String?

    public var OSDList: [GetDeviceConfigResponseBody.OSDList]?

    public var OSDTimeEnable: String?

    public var OSDTimeType: String?

    public var OSDTimeX: String?

    public var OSDTimeY: String?

    public var passWord: String?

    public var protocol_: String?

    public var requestId: String?

    public var resolution: String?

    public var retryInterval: String?

    public var serverId: String?

    public var serverIp: String?

    public var serverPort: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioEnable != nil {
            map["AudioEnable"] = self.audioEnable!
        }
        if self.audioFormat != nil {
            map["AudioFormat"] = self.audioFormat!
        }
        if self.bitRate != nil {
            map["BitRate"] = self.bitRate!
        }
        if self.channelList != nil {
            var tmp : [Any] = []
            for k in self.channelList! {
                tmp.append(k.toMap())
            }
            map["ChannelList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.encodeFormat != nil {
            map["EncodeFormat"] = self.encodeFormat!
        }
        if self.frameRate != nil {
            map["FrameRate"] = self.frameRate!
        }
        if self.govLength != nil {
            map["GovLength"] = self.govLength!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.OSDList != nil {
            var tmp : [Any] = []
            for k in self.OSDList! {
                tmp.append(k.toMap())
            }
            map["OSDList"] = tmp
        }
        if self.OSDTimeEnable != nil {
            map["OSDTimeEnable"] = self.OSDTimeEnable!
        }
        if self.OSDTimeType != nil {
            map["OSDTimeType"] = self.OSDTimeType!
        }
        if self.OSDTimeX != nil {
            map["OSDTimeX"] = self.OSDTimeX!
        }
        if self.OSDTimeY != nil {
            map["OSDTimeY"] = self.OSDTimeY!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resolution != nil {
            map["Resolution"] = self.resolution!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.serverIp != nil {
            map["ServerIp"] = self.serverIp!
        }
        if self.serverPort != nil {
            map["ServerPort"] = self.serverPort!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioEnable") {
            self.audioEnable = dict["AudioEnable"] as! String
        }
        if dict.keys.contains("AudioFormat") {
            self.audioFormat = dict["AudioFormat"] as! String
        }
        if dict.keys.contains("BitRate") {
            self.bitRate = dict["BitRate"] as! String
        }
        if dict.keys.contains("ChannelList") {
            self.channelList = dict["ChannelList"] as! [GetDeviceConfigResponseBody.ChannelList]
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("EncodeFormat") {
            self.encodeFormat = dict["EncodeFormat"] as! String
        }
        if dict.keys.contains("FrameRate") {
            self.frameRate = dict["FrameRate"] as! String
        }
        if dict.keys.contains("GovLength") {
            self.govLength = dict["GovLength"] as! Int64
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! String
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OSDList") {
            self.OSDList = dict["OSDList"] as! [GetDeviceConfigResponseBody.OSDList]
        }
        if dict.keys.contains("OSDTimeEnable") {
            self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
        }
        if dict.keys.contains("OSDTimeType") {
            self.OSDTimeType = dict["OSDTimeType"] as! String
        }
        if dict.keys.contains("OSDTimeX") {
            self.OSDTimeX = dict["OSDTimeX"] as! String
        }
        if dict.keys.contains("OSDTimeY") {
            self.OSDTimeY = dict["OSDTimeY"] as! String
        }
        if dict.keys.contains("PassWord") {
            self.passWord = dict["PassWord"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resolution") {
            self.resolution = dict["Resolution"] as! String
        }
        if dict.keys.contains("RetryInterval") {
            self.retryInterval = dict["RetryInterval"] as! String
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
        if dict.keys.contains("ServerIp") {
            self.serverIp = dict["ServerIp"] as! String
        }
        if dict.keys.contains("ServerPort") {
            self.serverPort = dict["ServerPort"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class GetDeviceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeviceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceLiveUrlRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public var gbId: String?

    public var outProtocol: String?

    public var streamType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.outProtocol != nil {
            map["OutProtocol"] = self.outProtocol!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OutProtocol") {
            self.outProtocol = dict["OutProtocol"] as! String
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! String
        }
    }
}

public class GetDeviceLiveUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var outProtocol: String?

    public var requestId: String?

    public var streamType: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outProtocol != nil {
            map["OutProtocol"] = self.outProtocol!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OutProtocol") {
            self.outProtocol = dict["OutProtocol"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! Int64
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetDeviceLiveUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceLiveUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeviceLiveUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDevicePictureRequest : Tea.TeaModel {
    public var deviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
    }
}

public class GetDevicePictureResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDevicePictureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDevicePictureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDevicePictureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceStatsRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceStatus: String?

    public var deviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceStatus != nil {
            map["DeviceStatus"] = self.deviceStatus!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceStatus") {
            self.deviceStatus = dict["DeviceStatus"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
    }
}

public class GetDeviceStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int64?

        public var deviceStatus: String?

        public var deviceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.deviceStatus != nil {
                map["DeviceStatus"] = self.deviceStatus!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("DeviceStatus") {
                self.deviceStatus = dict["DeviceStatus"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetDeviceStatsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetDeviceStatsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDeviceStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeviceStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceVideoUrlRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public var endTime: Int64?

    public var gbId: String?

    public var outProtocol: String?

    public var startTime: Int64?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.outProtocol != nil {
            map["OutProtocol"] = self.outProtocol!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OutProtocol") {
            self.outProtocol = dict["OutProtocol"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
    }
}

public class GetDeviceVideoUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var outProtocol: String?

    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outProtocol != nil {
            map["OutProtocol"] = self.outProtocol!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OutProtocol") {
            self.outProtocol = dict["OutProtocol"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetDeviceVideoUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceVideoUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeviceVideoUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFaceModelResultRequest : Tea.TeaModel {
    public var pictureContent: String?

    public var pictureId: String?

    public var pictureUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pictureContent != nil {
            map["PictureContent"] = self.pictureContent!
        }
        if self.pictureId != nil {
            map["PictureId"] = self.pictureId!
        }
        if self.pictureUrl != nil {
            map["PictureUrl"] = self.pictureUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PictureContent") {
            self.pictureContent = dict["PictureContent"] as! String
        }
        if dict.keys.contains("PictureId") {
            self.pictureId = dict["PictureId"] as! String
        }
        if dict.keys.contains("PictureUrl") {
            self.pictureUrl = dict["PictureUrl"] as! String
        }
    }
}

public class GetFaceModelResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var ageLowerLimit: Int32?

            public var ageLowerLimitReliability: String?

            public var ageUpLimit: Int32?

            public var ageUpLimitReliability: String?

            public var capColor: Int32?

            public var capColorReliability: String?

            public var capStyle: Int32?

            public var capStyleReliability: String?

            public var ethicCode: Int32?

            public var ethicCodeReliability: String?

            public var faceStyle: String?

            public var faceStyleReliability: String?

            public var featureData: [Double]?

            public var genderCode: Int32?

            public var genderCodeReliability: String?

            public var glassColor: Int32?

            public var glassColorReliability: String?

            public var glassStyle: Int32?

            public var glassStyleReliability: String?

            public var hairColor: Int32?

            public var hairColorReliability: String?

            public var hairStyle: Int32?

            public var hairStyleReliability: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var mustacheStyle: String?

            public var mustacheStyleReliability: String?

            public var respiratorColor: Int32?

            public var respiratorColorReliability: String?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var skinColor: Int32?

            public var skinColorReliability: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ageLowerLimit != nil {
                    map["AgeLowerLimit"] = self.ageLowerLimit!
                }
                if self.ageLowerLimitReliability != nil {
                    map["AgeLowerLimitReliability"] = self.ageLowerLimitReliability!
                }
                if self.ageUpLimit != nil {
                    map["AgeUpLimit"] = self.ageUpLimit!
                }
                if self.ageUpLimitReliability != nil {
                    map["AgeUpLimitReliability"] = self.ageUpLimitReliability!
                }
                if self.capColor != nil {
                    map["CapColor"] = self.capColor!
                }
                if self.capColorReliability != nil {
                    map["CapColorReliability"] = self.capColorReliability!
                }
                if self.capStyle != nil {
                    map["CapStyle"] = self.capStyle!
                }
                if self.capStyleReliability != nil {
                    map["CapStyleReliability"] = self.capStyleReliability!
                }
                if self.ethicCode != nil {
                    map["EthicCode"] = self.ethicCode!
                }
                if self.ethicCodeReliability != nil {
                    map["EthicCodeReliability"] = self.ethicCodeReliability!
                }
                if self.faceStyle != nil {
                    map["FaceStyle"] = self.faceStyle!
                }
                if self.faceStyleReliability != nil {
                    map["FaceStyleReliability"] = self.faceStyleReliability!
                }
                if self.featureData != nil {
                    map["FeatureData"] = self.featureData!
                }
                if self.genderCode != nil {
                    map["GenderCode"] = self.genderCode!
                }
                if self.genderCodeReliability != nil {
                    map["GenderCodeReliability"] = self.genderCodeReliability!
                }
                if self.glassColor != nil {
                    map["GlassColor"] = self.glassColor!
                }
                if self.glassColorReliability != nil {
                    map["GlassColorReliability"] = self.glassColorReliability!
                }
                if self.glassStyle != nil {
                    map["GlassStyle"] = self.glassStyle!
                }
                if self.glassStyleReliability != nil {
                    map["GlassStyleReliability"] = self.glassStyleReliability!
                }
                if self.hairColor != nil {
                    map["HairColor"] = self.hairColor!
                }
                if self.hairColorReliability != nil {
                    map["HairColorReliability"] = self.hairColorReliability!
                }
                if self.hairStyle != nil {
                    map["HairStyle"] = self.hairStyle!
                }
                if self.hairStyleReliability != nil {
                    map["HairStyleReliability"] = self.hairStyleReliability!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.mustacheStyle != nil {
                    map["MustacheStyle"] = self.mustacheStyle!
                }
                if self.mustacheStyleReliability != nil {
                    map["MustacheStyleReliability"] = self.mustacheStyleReliability!
                }
                if self.respiratorColor != nil {
                    map["RespiratorColor"] = self.respiratorColor!
                }
                if self.respiratorColorReliability != nil {
                    map["RespiratorColorReliability"] = self.respiratorColorReliability!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.skinColor != nil {
                    map["SkinColor"] = self.skinColor!
                }
                if self.skinColorReliability != nil {
                    map["SkinColorReliability"] = self.skinColorReliability!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgeLowerLimit") {
                    self.ageLowerLimit = dict["AgeLowerLimit"] as! Int32
                }
                if dict.keys.contains("AgeLowerLimitReliability") {
                    self.ageLowerLimitReliability = dict["AgeLowerLimitReliability"] as! String
                }
                if dict.keys.contains("AgeUpLimit") {
                    self.ageUpLimit = dict["AgeUpLimit"] as! Int32
                }
                if dict.keys.contains("AgeUpLimitReliability") {
                    self.ageUpLimitReliability = dict["AgeUpLimitReliability"] as! String
                }
                if dict.keys.contains("CapColor") {
                    self.capColor = dict["CapColor"] as! Int32
                }
                if dict.keys.contains("CapColorReliability") {
                    self.capColorReliability = dict["CapColorReliability"] as! String
                }
                if dict.keys.contains("CapStyle") {
                    self.capStyle = dict["CapStyle"] as! Int32
                }
                if dict.keys.contains("CapStyleReliability") {
                    self.capStyleReliability = dict["CapStyleReliability"] as! String
                }
                if dict.keys.contains("EthicCode") {
                    self.ethicCode = dict["EthicCode"] as! Int32
                }
                if dict.keys.contains("EthicCodeReliability") {
                    self.ethicCodeReliability = dict["EthicCodeReliability"] as! String
                }
                if dict.keys.contains("FaceStyle") {
                    self.faceStyle = dict["FaceStyle"] as! String
                }
                if dict.keys.contains("FaceStyleReliability") {
                    self.faceStyleReliability = dict["FaceStyleReliability"] as! String
                }
                if dict.keys.contains("FeatureData") {
                    self.featureData = dict["FeatureData"] as! [Double]
                }
                if dict.keys.contains("GenderCode") {
                    self.genderCode = dict["GenderCode"] as! Int32
                }
                if dict.keys.contains("GenderCodeReliability") {
                    self.genderCodeReliability = dict["GenderCodeReliability"] as! String
                }
                if dict.keys.contains("GlassColor") {
                    self.glassColor = dict["GlassColor"] as! Int32
                }
                if dict.keys.contains("GlassColorReliability") {
                    self.glassColorReliability = dict["GlassColorReliability"] as! String
                }
                if dict.keys.contains("GlassStyle") {
                    self.glassStyle = dict["GlassStyle"] as! Int32
                }
                if dict.keys.contains("GlassStyleReliability") {
                    self.glassStyleReliability = dict["GlassStyleReliability"] as! String
                }
                if dict.keys.contains("HairColor") {
                    self.hairColor = dict["HairColor"] as! Int32
                }
                if dict.keys.contains("HairColorReliability") {
                    self.hairColorReliability = dict["HairColorReliability"] as! String
                }
                if dict.keys.contains("HairStyle") {
                    self.hairStyle = dict["HairStyle"] as! Int32
                }
                if dict.keys.contains("HairStyleReliability") {
                    self.hairStyleReliability = dict["HairStyleReliability"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("MustacheStyle") {
                    self.mustacheStyle = dict["MustacheStyle"] as! String
                }
                if dict.keys.contains("MustacheStyleReliability") {
                    self.mustacheStyleReliability = dict["MustacheStyleReliability"] as! String
                }
                if dict.keys.contains("RespiratorColor") {
                    self.respiratorColor = dict["RespiratorColor"] as! Int32
                }
                if dict.keys.contains("RespiratorColorReliability") {
                    self.respiratorColorReliability = dict["RespiratorColorReliability"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("SkinColor") {
                    self.skinColor = dict["SkinColor"] as! Int32
                }
                if dict.keys.contains("SkinColorReliability") {
                    self.skinColorReliability = dict["SkinColorReliability"] as! String
                }
            }
        }
        public var records: [GetFaceModelResultResponseBody.Data.Records]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [GetFaceModelResultResponseBody.Data.Records]
            }
        }
    }
    public var code: String?

    public var data: GetFaceModelResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetFaceModelResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFaceModelResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFaceModelResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFaceModelResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFaceOptionsRequest : Tea.TeaModel {
    public var corpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
    }
}

public class GetFaceOptionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class OptionList : Tea.TeaModel {
            public var key: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var key: String?

        public var name: String?

        public var optionList: [GetFaceOptionsResponseBody.Data.OptionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.optionList != nil {
                var tmp : [Any] = []
                for k in self.optionList! {
                    tmp.append(k.toMap())
                }
                map["OptionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OptionList") {
                self.optionList = dict["OptionList"] as! [GetFaceOptionsResponseBody.Data.OptionList]
            }
        }
    }
    public var code: String?

    public var data: [GetFaceOptionsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [GetFaceOptionsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFaceOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFaceOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFaceOptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInventoryRequest : Tea.TeaModel {
    public var commodityCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
    }
}

public class GetInventoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ResultObject : Tea.TeaModel {
            public var buyerId: String?

            public var commodityCode: String?

            public var currentInventory: String?

            public var instanceId: String?

            public var inventoryId: String?

            public var validEndTime: String?

            public var validStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.buyerId != nil {
                    map["BuyerId"] = self.buyerId!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.currentInventory != nil {
                    map["CurrentInventory"] = self.currentInventory!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.inventoryId != nil {
                    map["InventoryId"] = self.inventoryId!
                }
                if self.validEndTime != nil {
                    map["ValidEndTime"] = self.validEndTime!
                }
                if self.validStartTime != nil {
                    map["ValidStartTime"] = self.validStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BuyerId") {
                    self.buyerId = dict["BuyerId"] as! String
                }
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("CurrentInventory") {
                    self.currentInventory = dict["CurrentInventory"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InventoryId") {
                    self.inventoryId = dict["InventoryId"] as! String
                }
                if dict.keys.contains("ValidEndTime") {
                    self.validEndTime = dict["ValidEndTime"] as! String
                }
                if dict.keys.contains("ValidStartTime") {
                    self.validStartTime = dict["ValidStartTime"] as! String
                }
            }
        }
        public var resultObject: [GetInventoryResponseBody.Data.ResultObject]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultObject != nil {
                var tmp : [Any] = []
                for k in self.resultObject! {
                    tmp.append(k.toMap())
                }
                map["ResultObject"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultObject") {
                self.resultObject = dict["ResultObject"] as! [GetInventoryResponseBody.Data.ResultObject]
            }
        }
    }
    public var data: GetInventoryResponseBody.Data?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = GetInventoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetInventoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInventoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInventoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMonitorListRequest : Tea.TeaModel {
    public var corpId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetMonitorListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var algorithmVendor: String?

            public var attributes: String?

            public var createDate: String?

            public var description_: String?

            public var deviceList: String?

            public var expression: String?

            public var imageMatch: String?

            public var modifiedDate: String?

            public var monitorType: String?

            public var notifierExtendValues: String?

            public var notifierType: String?

            public var ruleExpression: String?

            public var ruleName: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.algorithmVendor != nil {
                    map["AlgorithmVendor"] = self.algorithmVendor!
                }
                if self.attributes != nil {
                    map["Attributes"] = self.attributes!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceList != nil {
                    map["DeviceList"] = self.deviceList!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.imageMatch != nil {
                    map["ImageMatch"] = self.imageMatch!
                }
                if self.modifiedDate != nil {
                    map["ModifiedDate"] = self.modifiedDate!
                }
                if self.monitorType != nil {
                    map["MonitorType"] = self.monitorType!
                }
                if self.notifierExtendValues != nil {
                    map["NotifierExtendValues"] = self.notifierExtendValues!
                }
                if self.notifierType != nil {
                    map["NotifierType"] = self.notifierType!
                }
                if self.ruleExpression != nil {
                    map["RuleExpression"] = self.ruleExpression!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlgorithmVendor") {
                    self.algorithmVendor = dict["AlgorithmVendor"] as! String
                }
                if dict.keys.contains("Attributes") {
                    self.attributes = dict["Attributes"] as! String
                }
                if dict.keys.contains("CreateDate") {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DeviceList") {
                    self.deviceList = dict["DeviceList"] as! String
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("ImageMatch") {
                    self.imageMatch = dict["ImageMatch"] as! String
                }
                if dict.keys.contains("ModifiedDate") {
                    self.modifiedDate = dict["ModifiedDate"] as! String
                }
                if dict.keys.contains("MonitorType") {
                    self.monitorType = dict["MonitorType"] as! String
                }
                if dict.keys.contains("NotifierExtendValues") {
                    self.notifierExtendValues = dict["NotifierExtendValues"] as! String
                }
                if dict.keys.contains("NotifierType") {
                    self.notifierType = dict["NotifierType"] as! String
                }
                if dict.keys.contains("RuleExpression") {
                    self.ruleExpression = dict["RuleExpression"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [GetMonitorListResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [GetMonitorListResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: GetMonitorListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetMonitorListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMonitorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMonitorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMonitorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMonitorResultRequest : Tea.TeaModel {
    public var algorithmVendor: String?

    public var corpId: String?

    public var endTime: Int64?

    public var minRecordId: String?

    public var startTime: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmVendor != nil {
            map["AlgorithmVendor"] = self.algorithmVendor!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.minRecordId != nil {
            map["MinRecordId"] = self.minRecordId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmVendor") {
            self.algorithmVendor = dict["AlgorithmVendor"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("MinRecordId") {
            self.minRecordId = dict["MinRecordId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetMonitorResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public class ExtendInfo : Tea.TeaModel {
                public var plateNo: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.plateNo != nil {
                        map["PlateNo"] = self.plateNo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PlateNo") {
                        self.plateNo = dict["PlateNo"] as! String
                    }
                }
            }
            public var extendInfo: GetMonitorResultResponseBody.Data.Records.ExtendInfo?

            public var gbId: String?

            public var leftUpX: String?

            public var leftUpY: String?

            public var monitorPicUrl: String?

            public var picUrl: String?

            public var rightBottomX: String?

            public var rightBottomY: String?

            public var score: String?

            public var shotTime: String?

            public var targetPicUrl: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extendInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo?.toMap()
                }
                if self.gbId != nil {
                    map["GbId"] = self.gbId!
                }
                if self.leftUpX != nil {
                    map["LeftUpX"] = self.leftUpX!
                }
                if self.leftUpY != nil {
                    map["LeftUpY"] = self.leftUpY!
                }
                if self.monitorPicUrl != nil {
                    map["MonitorPicUrl"] = self.monitorPicUrl!
                }
                if self.picUrl != nil {
                    map["PicUrl"] = self.picUrl!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.targetPicUrl != nil {
                    map["TargetPicUrl"] = self.targetPicUrl!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExtendInfo") {
                    var model = GetMonitorResultResponseBody.Data.Records.ExtendInfo()
                    model.fromMap(dict["ExtendInfo"] as! [String: Any])
                    self.extendInfo = model
                }
                if dict.keys.contains("GbId") {
                    self.gbId = dict["GbId"] as! String
                }
                if dict.keys.contains("LeftUpX") {
                    self.leftUpX = dict["LeftUpX"] as! String
                }
                if dict.keys.contains("LeftUpY") {
                    self.leftUpY = dict["LeftUpY"] as! String
                }
                if dict.keys.contains("MonitorPicUrl") {
                    self.monitorPicUrl = dict["MonitorPicUrl"] as! String
                }
                if dict.keys.contains("PicUrl") {
                    self.picUrl = dict["PicUrl"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! String
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! String
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("TargetPicUrl") {
                    self.targetPicUrl = dict["TargetPicUrl"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var maxId: String?

        public var records: [GetMonitorResultResponseBody.Data.Records]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxId != nil {
                map["MaxId"] = self.maxId!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaxId") {
                self.maxId = dict["MaxId"] as! String
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [GetMonitorResultResponseBody.Data.Records]
            }
        }
    }
    public var code: String?

    public var data: GetMonitorResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetMonitorResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMonitorResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMonitorResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMonitorResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPersonDetailRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var corpId: String?

    public var personID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.personID != nil {
            map["PersonID"] = self.personID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PersonID") {
            self.personID = dict["PersonID"] as! String
        }
    }
}

public class GetPersonDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TagList : Tea.TeaModel {
            public var tagCode: String?

            public var tagName: String?

            public var tagValue: String?

            public var tagValueId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagCode != nil {
                    map["TagCode"] = self.tagCode!
                }
                if self.tagName != nil {
                    map["TagName"] = self.tagName!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                if self.tagValueId != nil {
                    map["TagValueId"] = self.tagValueId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagCode") {
                    self.tagCode = dict["TagCode"] as! String
                }
                if dict.keys.contains("TagName") {
                    self.tagName = dict["TagName"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
                if dict.keys.contains("TagValueId") {
                    self.tagValueId = dict["TagValueId"] as! String
                }
            }
        }
        public var personId: String?

        public var picUrl: String?

        public var tagList: [GetPersonDetailResponseBody.Data.TagList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.picUrl != nil {
                map["PicUrl"] = self.picUrl!
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["TagList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PicUrl") {
                self.picUrl = dict["PicUrl"] as! String
            }
            if dict.keys.contains("TagList") {
                self.tagList = dict["TagList"] as! [GetPersonDetailResponseBody.Data.TagList]
            }
        }
    }
    public var code: String?

    public var data: GetPersonDetailResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetPersonDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPersonDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPersonDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPersonDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPersonListRequest : Tea.TeaModel {
    public var corpId: String?

    public var corpIdList: [String: Any]?

    public var faceMatchingRateThreshold: String?

    public var faceUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personIdList: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.faceMatchingRateThreshold != nil {
            map["FaceMatchingRateThreshold"] = self.faceMatchingRateThreshold!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personIdList != nil {
            map["PersonIdList"] = self.personIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! [String: Any]
        }
        if dict.keys.contains("FaceMatchingRateThreshold") {
            self.faceMatchingRateThreshold = dict["FaceMatchingRateThreshold"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonIdList") {
            self.personIdList = dict["PersonIdList"] as! [String: Any]
        }
    }
}

public class GetPersonListShrinkRequest : Tea.TeaModel {
    public var corpId: String?

    public var corpIdListShrink: String?

    public var faceMatchingRateThreshold: String?

    public var faceUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.corpIdListShrink != nil {
            map["CorpIdList"] = self.corpIdListShrink!
        }
        if self.faceMatchingRateThreshold != nil {
            map["FaceMatchingRateThreshold"] = self.faceMatchingRateThreshold!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personIdListShrink != nil {
            map["PersonIdList"] = self.personIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CorpIdList") {
            self.corpIdListShrink = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("FaceMatchingRateThreshold") {
            self.faceMatchingRateThreshold = dict["FaceMatchingRateThreshold"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonIdList") {
            self.personIdListShrink = dict["PersonIdList"] as! String
        }
    }
}

public class GetPersonListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public class PropertyTagList : Tea.TeaModel {
                public var code: String?

                public var tagCodeName: String?

                public var tagName: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.tagCodeName != nil {
                        map["TagCodeName"] = self.tagCodeName!
                    }
                    if self.tagName != nil {
                        map["TagName"] = self.tagName!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("TagCodeName") {
                        self.tagCodeName = dict["TagCodeName"] as! String
                    }
                    if dict.keys.contains("TagName") {
                        self.tagName = dict["TagName"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var faceUrl: String?

            public var firstShotTime: Int64?

            public var lastShotTime: Int64?

            public var personId: String?

            public var propertyTagList: [GetPersonListResponseBody.Data.Records.PropertyTagList]?

            public var searchMatchingRate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.faceUrl != nil {
                    map["FaceUrl"] = self.faceUrl!
                }
                if self.firstShotTime != nil {
                    map["FirstShotTime"] = self.firstShotTime!
                }
                if self.lastShotTime != nil {
                    map["LastShotTime"] = self.lastShotTime!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.propertyTagList != nil {
                    var tmp : [Any] = []
                    for k in self.propertyTagList! {
                        tmp.append(k.toMap())
                    }
                    map["PropertyTagList"] = tmp
                }
                if self.searchMatchingRate != nil {
                    map["SearchMatchingRate"] = self.searchMatchingRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FaceUrl") {
                    self.faceUrl = dict["FaceUrl"] as! String
                }
                if dict.keys.contains("FirstShotTime") {
                    self.firstShotTime = dict["FirstShotTime"] as! Int64
                }
                if dict.keys.contains("LastShotTime") {
                    self.lastShotTime = dict["LastShotTime"] as! Int64
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PropertyTagList") {
                    self.propertyTagList = dict["PropertyTagList"] as! [GetPersonListResponseBody.Data.Records.PropertyTagList]
                }
                if dict.keys.contains("SearchMatchingRate") {
                    self.searchMatchingRate = dict["SearchMatchingRate"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [GetPersonListResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [GetPersonListResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetPersonListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetPersonListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPersonListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPersonListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPersonListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPictureUrlRequest : Tea.TeaModel {
    public var expireTime: String?

    public var originUrl: String?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.originUrl != nil {
            map["OriginUrl"] = self.originUrl!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("OriginUrl") {
            self.originUrl = dict["OriginUrl"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class GetPictureUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class GetPictureUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPictureUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPictureUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProfileDetailRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var profileId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.profileId != nil {
            map["ProfileId"] = self.profileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ProfileId") {
            self.profileId = dict["ProfileId"] as! Int64
        }
    }
}

public class GetProfileDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizId: String?

        public var catalogId: Int32?

        public var faceUrl: String?

        public var gender: String?

        public var idNumber: String?

        public var isvSubId: String?

        public var liveAddress: String?

        public var name: String?

        public var personId: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var profileId: Int32?

        public var sceneType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.catalogId != nil {
                map["CatalogId"] = self.catalogId!
            }
            if self.faceUrl != nil {
                map["FaceUrl"] = self.faceUrl!
            }
            if self.gender != nil {
                map["Gender"] = self.gender!
            }
            if self.idNumber != nil {
                map["IdNumber"] = self.idNumber!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.liveAddress != nil {
                map["LiveAddress"] = self.liveAddress!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.profileId != nil {
                map["ProfileId"] = self.profileId!
            }
            if self.sceneType != nil {
                map["SceneType"] = self.sceneType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizId") {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("CatalogId") {
                self.catalogId = dict["CatalogId"] as! Int32
            }
            if dict.keys.contains("FaceUrl") {
                self.faceUrl = dict["FaceUrl"] as! String
            }
            if dict.keys.contains("Gender") {
                self.gender = dict["Gender"] as! String
            }
            if dict.keys.contains("IdNumber") {
                self.idNumber = dict["IdNumber"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("LiveAddress") {
                self.liveAddress = dict["LiveAddress"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("ProfileId") {
                self.profileId = dict["ProfileId"] as! Int32
            }
            if dict.keys.contains("SceneType") {
                self.sceneType = dict["SceneType"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetProfileDetailResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetProfileDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProfileDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProfileDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProfileDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProfileListRequest : Tea.TeaModel {
    public var bizId: String?

    public var catalogId: Int64?

    public var corpId: String?

    public var faceImageId: String?

    public var faceUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var liveAddress: String?

    public var matchingRateThreshold: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personIdList: [String: Any]?

    public var phoneNo: String?

    public var plateNo: String?

    public var profileIdList: [String: Any]?

    public var sceneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageId != nil {
            map["FaceImageId"] = self.faceImageId!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.liveAddress != nil {
            map["LiveAddress"] = self.liveAddress!
        }
        if self.matchingRateThreshold != nil {
            map["MatchingRateThreshold"] = self.matchingRateThreshold!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personIdList != nil {
            map["PersonIdList"] = self.personIdList!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.profileIdList != nil {
            map["ProfileIdList"] = self.profileIdList!
        }
        if self.sceneType != nil {
            map["SceneType"] = self.sceneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! Int64
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageId") {
            self.faceImageId = dict["FaceImageId"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("LiveAddress") {
            self.liveAddress = dict["LiveAddress"] as! String
        }
        if dict.keys.contains("MatchingRateThreshold") {
            self.matchingRateThreshold = dict["MatchingRateThreshold"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonIdList") {
            self.personIdList = dict["PersonIdList"] as! [String: Any]
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("ProfileIdList") {
            self.profileIdList = dict["ProfileIdList"] as! [String: Any]
        }
        if dict.keys.contains("SceneType") {
            self.sceneType = dict["SceneType"] as! String
        }
    }
}

public class GetProfileListShrinkRequest : Tea.TeaModel {
    public var bizId: String?

    public var catalogId: Int64?

    public var corpId: String?

    public var faceImageId: String?

    public var faceUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var liveAddress: String?

    public var matchingRateThreshold: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personIdListShrink: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var profileIdListShrink: String?

    public var sceneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageId != nil {
            map["FaceImageId"] = self.faceImageId!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.liveAddress != nil {
            map["LiveAddress"] = self.liveAddress!
        }
        if self.matchingRateThreshold != nil {
            map["MatchingRateThreshold"] = self.matchingRateThreshold!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personIdListShrink != nil {
            map["PersonIdList"] = self.personIdListShrink!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.profileIdListShrink != nil {
            map["ProfileIdList"] = self.profileIdListShrink!
        }
        if self.sceneType != nil {
            map["SceneType"] = self.sceneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! Int64
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageId") {
            self.faceImageId = dict["FaceImageId"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("LiveAddress") {
            self.liveAddress = dict["LiveAddress"] as! String
        }
        if dict.keys.contains("MatchingRateThreshold") {
            self.matchingRateThreshold = dict["MatchingRateThreshold"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonIdList") {
            self.personIdListShrink = dict["PersonIdList"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("ProfileIdList") {
            self.profileIdListShrink = dict["ProfileIdList"] as! String
        }
        if dict.keys.contains("SceneType") {
            self.sceneType = dict["SceneType"] as! String
        }
    }
}

public class GetProfileListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var bizId: String?

            public var catalogId: Int32?

            public var faceUrl: String?

            public var gender: String?

            public var idNumber: String?

            public var isvSubId: String?

            public var name: String?

            public var personId: String?

            public var profileId: Int32?

            public var sceneType: String?

            public var searchMatchingRate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.catalogId != nil {
                    map["CatalogId"] = self.catalogId!
                }
                if self.faceUrl != nil {
                    map["FaceUrl"] = self.faceUrl!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.idNumber != nil {
                    map["IdNumber"] = self.idNumber!
                }
                if self.isvSubId != nil {
                    map["IsvSubId"] = self.isvSubId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.profileId != nil {
                    map["ProfileId"] = self.profileId!
                }
                if self.sceneType != nil {
                    map["SceneType"] = self.sceneType!
                }
                if self.searchMatchingRate != nil {
                    map["SearchMatchingRate"] = self.searchMatchingRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("CatalogId") {
                    self.catalogId = dict["CatalogId"] as! Int32
                }
                if dict.keys.contains("FaceUrl") {
                    self.faceUrl = dict["FaceUrl"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("IdNumber") {
                    self.idNumber = dict["IdNumber"] as! String
                }
                if dict.keys.contains("IsvSubId") {
                    self.isvSubId = dict["IsvSubId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("ProfileId") {
                    self.profileId = dict["ProfileId"] as! Int32
                }
                if dict.keys.contains("SceneType") {
                    self.sceneType = dict["SceneType"] as! String
                }
                if dict.keys.contains("SearchMatchingRate") {
                    self.searchMatchingRate = dict["SearchMatchingRate"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [GetProfileListResponseBody.Data.Records]?

        public var success: Bool?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [GetProfileListResponseBody.Data.Records]
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetProfileListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetProfileListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProfileListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProfileListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProfileListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetScanSubDevicesRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
    }
}

public class GetScanSubDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceList : Tea.TeaModel {
            public var associatedNvr: String?

            public var deviceMac: String?

            public var deviceModel: String?

            public var deviceSn: String?

            public var firmwareVersion: String?

            public var manufacturer: String?

            public var subDeviceIp: String?

            public var subDevicePort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedNvr != nil {
                    map["AssociatedNvr"] = self.associatedNvr!
                }
                if self.deviceMac != nil {
                    map["DeviceMac"] = self.deviceMac!
                }
                if self.deviceModel != nil {
                    map["DeviceModel"] = self.deviceModel!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.firmwareVersion != nil {
                    map["FirmwareVersion"] = self.firmwareVersion!
                }
                if self.manufacturer != nil {
                    map["Manufacturer"] = self.manufacturer!
                }
                if self.subDeviceIp != nil {
                    map["SubDeviceIp"] = self.subDeviceIp!
                }
                if self.subDevicePort != nil {
                    map["SubDevicePort"] = self.subDevicePort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedNvr") {
                    self.associatedNvr = dict["AssociatedNvr"] as! String
                }
                if dict.keys.contains("DeviceMac") {
                    self.deviceMac = dict["DeviceMac"] as! String
                }
                if dict.keys.contains("DeviceModel") {
                    self.deviceModel = dict["DeviceModel"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("FirmwareVersion") {
                    self.firmwareVersion = dict["FirmwareVersion"] as! String
                }
                if dict.keys.contains("Manufacturer") {
                    self.manufacturer = dict["Manufacturer"] as! String
                }
                if dict.keys.contains("SubDeviceIp") {
                    self.subDeviceIp = dict["SubDeviceIp"] as! String
                }
                if dict.keys.contains("SubDevicePort") {
                    self.subDevicePort = dict["SubDevicePort"] as! String
                }
            }
        }
        public var subDeviceList: [GetScanSubDevicesResponseBody.Data.SubDeviceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subDeviceList != nil {
                var tmp : [Any] = []
                for k in self.subDeviceList! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SubDeviceList") {
                self.subDeviceList = dict["SubDeviceList"] as! [GetScanSubDevicesResponseBody.Data.SubDeviceList]
            }
        }
    }
    public var code: String?

    public var data: GetScanSubDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetScanSubDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetScanSubDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScanSubDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetScanSubDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserDetailRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var needFaceDetail: Bool?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.needFaceDetail != nil {
            map["NeedFaceDetail"] = self.needFaceDetail!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("NeedFaceDetail") {
            self.needFaceDetail = dict["NeedFaceDetail"] as! Bool
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class GetUserDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var address: String?

        public var age: String?

        public var attachment: String?

        public var bizId: String?

        public var faceImageUrl: String?

        public var gender: String?

        public var idNumber: String?

        public var isvSubId: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var userGroupId: Int32?

        public var userId: Int32?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.age != nil {
                map["Age"] = self.age!
            }
            if self.attachment != nil {
                map["Attachment"] = self.attachment!
            }
            if self.bizId != nil {
                map["BizId"] = self.bizId!
            }
            if self.faceImageUrl != nil {
                map["FaceImageUrl"] = self.faceImageUrl!
            }
            if self.gender != nil {
                map["Gender"] = self.gender!
            }
            if self.idNumber != nil {
                map["IdNumber"] = self.idNumber!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("Age") {
                self.age = dict["Age"] as! String
            }
            if dict.keys.contains("Attachment") {
                self.attachment = dict["Attachment"] as! String
            }
            if dict.keys.contains("BizId") {
                self.bizId = dict["BizId"] as! String
            }
            if dict.keys.contains("FaceImageUrl") {
                self.faceImageUrl = dict["FaceImageUrl"] as! String
            }
            if dict.keys.contains("Gender") {
                self.gender = dict["Gender"] as! String
            }
            if dict.keys.contains("IdNumber") {
                self.idNumber = dict["IdNumber"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! Int32
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int32
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetUserDetailResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetUserDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUserDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoComposeResultRequest : Tea.TeaModel {
    public var corpId: String?

    public var taskRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.taskRequestId != nil {
            map["TaskRequestId"] = self.taskRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("TaskRequestId") {
            self.taskRequestId = dict["TaskRequestId"] as! String
        }
    }
}

public class GetVideoComposeResultResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var status: String?

    public var videoUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.videoUrl != nil {
            map["VideoUrl"] = self.videoUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VideoUrl") {
            self.videoUrl = dict["VideoUrl"] as! String
        }
    }
}

public class GetVideoComposeResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoComposeResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoComposeResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoSummaryTaskResultRequest : Tea.TeaModel {
    public var corpId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetVideoSummaryTaskResultResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVideoSummaryTaskResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoSummaryTaskResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoSummaryTaskResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InvokeMotorModelRequest : Tea.TeaModel {
    public var corpId: String?

    public var picId: String?

    public var picPath: String?

    public var picUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.picId != nil {
            map["PicId"] = self.picId!
        }
        if self.picPath != nil {
            map["PicPath"] = self.picPath!
        }
        if self.picUrl != nil {
            map["PicUrl"] = self.picUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PicId") {
            self.picId = dict["PicId"] as! String
        }
        if dict.keys.contains("PicPath") {
            self.picPath = dict["PicPath"] as! String
        }
        if dict.keys.contains("PicUrl") {
            self.picUrl = dict["PicUrl"] as! String
        }
    }
}

public class InvokeMotorModelResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var structList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.structList != nil {
                map["StructList"] = self.structList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StructList") {
                self.structList = dict["StructList"] as! String
            }
        }
    }
    public var code: String?

    public var data: InvokeMotorModelResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = InvokeMotorModelResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InvokeMotorModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InvokeMotorModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InvokeMotorModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAccessNumberRequest : Tea.TeaModel {
    public var corpIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
    }
}

public class ListAccessNumberResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: String?

        public var item: String?

        public var percent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAccessNumberResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListAccessNumberResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAccessNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAccessNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAccessNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlgorithmNamesByDeviceIdsRequest : Tea.TeaModel {
    public var gbIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gbIds != nil {
            map["GbIds"] = self.gbIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GbIds") {
            self.gbIds = dict["GbIds"] as! String
        }
    }
}

public class ListAlgorithmNamesByDeviceIdsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var algorithmNames: [String]?

        public var gbId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.algorithmNames != nil {
                map["AlgorithmNames"] = self.algorithmNames!
            }
            if self.gbId != nil {
                map["GbId"] = self.gbId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlgorithmNames") {
                self.algorithmNames = dict["AlgorithmNames"] as! [String]
            }
            if dict.keys.contains("GbId") {
                self.gbId = dict["GbId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAlgorithmNamesByDeviceIdsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListAlgorithmNamesByDeviceIdsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAlgorithmNamesByDeviceIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlgorithmNamesByDeviceIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlgorithmNamesByDeviceIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBodyAlgorithmResultsRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var capStyle: String?

    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.capStyle != nil {
            map["CapStyle"] = self.capStyle!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("CapStyle") {
            self.capStyle = dict["CapStyle"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListBodyAlgorithmResultsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var capStyle: String?

            public var coatColor: String?

            public var coatLength: String?

            public var coatStyle: String?

            public var corpId: String?

            public var dataSourceId: String?

            public var genderCode: String?

            public var hairStyle: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var maxAge: String?

            public var minAge: String?

            public var personId: String?

            public var picUrlPath: String?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var shotTime: String?

            public var sourceId: String?

            public var targetPicUrlPath: String?

            public var trousersColor: String?

            public var trousersLength: String?

            public var trousersStyle: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capStyle != nil {
                    map["CapStyle"] = self.capStyle!
                }
                if self.coatColor != nil {
                    map["CoatColor"] = self.coatColor!
                }
                if self.coatLength != nil {
                    map["CoatLength"] = self.coatLength!
                }
                if self.coatStyle != nil {
                    map["CoatStyle"] = self.coatStyle!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.genderCode != nil {
                    map["GenderCode"] = self.genderCode!
                }
                if self.hairStyle != nil {
                    map["HairStyle"] = self.hairStyle!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.maxAge != nil {
                    map["MaxAge"] = self.maxAge!
                }
                if self.minAge != nil {
                    map["MinAge"] = self.minAge!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.picUrlPath != nil {
                    map["PicUrlPath"] = self.picUrlPath!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.targetPicUrlPath != nil {
                    map["TargetPicUrlPath"] = self.targetPicUrlPath!
                }
                if self.trousersColor != nil {
                    map["TrousersColor"] = self.trousersColor!
                }
                if self.trousersLength != nil {
                    map["TrousersLength"] = self.trousersLength!
                }
                if self.trousersStyle != nil {
                    map["TrousersStyle"] = self.trousersStyle!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapStyle") {
                    self.capStyle = dict["CapStyle"] as! String
                }
                if dict.keys.contains("CoatColor") {
                    self.coatColor = dict["CoatColor"] as! String
                }
                if dict.keys.contains("CoatLength") {
                    self.coatLength = dict["CoatLength"] as! String
                }
                if dict.keys.contains("CoatStyle") {
                    self.coatStyle = dict["CoatStyle"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("DataSourceId") {
                    self.dataSourceId = dict["DataSourceId"] as! String
                }
                if dict.keys.contains("GenderCode") {
                    self.genderCode = dict["GenderCode"] as! String
                }
                if dict.keys.contains("HairStyle") {
                    self.hairStyle = dict["HairStyle"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("MaxAge") {
                    self.maxAge = dict["MaxAge"] as! String
                }
                if dict.keys.contains("MinAge") {
                    self.minAge = dict["MinAge"] as! String
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PicUrlPath") {
                    self.picUrlPath = dict["PicUrlPath"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("TargetPicUrlPath") {
                    self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
                }
                if dict.keys.contains("TrousersColor") {
                    self.trousersColor = dict["TrousersColor"] as! String
                }
                if dict.keys.contains("TrousersLength") {
                    self.trousersLength = dict["TrousersLength"] as! String
                }
                if dict.keys.contains("TrousersStyle") {
                    self.trousersStyle = dict["TrousersStyle"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListBodyAlgorithmResultsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListBodyAlgorithmResultsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListBodyAlgorithmResultsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListBodyAlgorithmResultsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBodyAlgorithmResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBodyAlgorithmResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBodyAlgorithmResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCorpGroupMetricsRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceGroup: String?

    public var deviceId: String?

    public var endTime: String?

    public var groupId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public var tagCode: String?

    public var userGroup: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceGroup != nil {
            map["DeviceGroup"] = self.deviceGroup!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tagCode != nil {
            map["TagCode"] = self.tagCode!
        }
        if self.userGroup != nil {
            map["UserGroup"] = self.userGroup!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceGroup") {
            self.deviceGroup = dict["DeviceGroup"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TagCode") {
            self.tagCode = dict["TagCode"] as! String
        }
        if dict.keys.contains("UserGroup") {
            self.userGroup = dict["UserGroup"] as! String
        }
    }
}

public class ListCorpGroupMetricsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpGroupId: String?

        public var corpId: String?

        public var dateId: String?

        public var deviceGroupId: String?

        public var deviceId: String?

        public var personID: String?

        public var tagCode: String?

        public var tagMetrics: String?

        public var tagValue: String?

        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpGroupId != nil {
                map["CorpGroupId"] = self.corpGroupId!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dateId != nil {
                map["DateId"] = self.dateId!
            }
            if self.deviceGroupId != nil {
                map["DeviceGroupId"] = self.deviceGroupId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.personID != nil {
                map["PersonID"] = self.personID!
            }
            if self.tagCode != nil {
                map["TagCode"] = self.tagCode!
            }
            if self.tagMetrics != nil {
                map["TagMetrics"] = self.tagMetrics!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpGroupId") {
                self.corpGroupId = dict["CorpGroupId"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DateId") {
                self.dateId = dict["DateId"] as! String
            }
            if dict.keys.contains("DeviceGroupId") {
                self.deviceGroupId = dict["DeviceGroupId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("PersonID") {
                self.personID = dict["PersonID"] as! String
            }
            if dict.keys.contains("TagCode") {
                self.tagCode = dict["TagCode"] as! String
            }
            if dict.keys.contains("TagMetrics") {
                self.tagMetrics = dict["TagMetrics"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListCorpGroupMetricsResponseBody.Data]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListCorpGroupMetricsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCorpGroupMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCorpGroupMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCorpGroupMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCorpGroupsRequest : Tea.TeaModel {
    public var corpId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class ListCorpGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [String]?

        public var totalCount: Int64?

        public var totalPage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                map["Records"] = self.records!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [String]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListCorpGroupsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCorpGroupsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCorpGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCorpGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCorpGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCorpMetricsRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceGroupList: String?

    public var deviceIdList: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public var tagCode: String?

    public var userGroupList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceGroupList != nil {
            map["DeviceGroupList"] = self.deviceGroupList!
        }
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tagCode != nil {
            map["TagCode"] = self.tagCode!
        }
        if self.userGroupList != nil {
            map["UserGroupList"] = self.userGroupList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceGroupList") {
            self.deviceGroupList = dict["DeviceGroupList"] as! String
        }
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TagCode") {
            self.tagCode = dict["TagCode"] as! String
        }
        if dict.keys.contains("UserGroupList") {
            self.userGroupList = dict["UserGroupList"] as! String
        }
    }
}

public class ListCorpMetricsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpId: String?

        public var dateId: String?

        public var deviceGroupId: String?

        public var deviceId: String?

        public var personId: String?

        public var tagCode: String?

        public var tagMetrics: String?

        public var tagValue: String?

        public var userGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dateId != nil {
                map["DateId"] = self.dateId!
            }
            if self.deviceGroupId != nil {
                map["DeviceGroupId"] = self.deviceGroupId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.tagCode != nil {
                map["TagCode"] = self.tagCode!
            }
            if self.tagMetrics != nil {
                map["TagMetrics"] = self.tagMetrics!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DateId") {
                self.dateId = dict["DateId"] as! String
            }
            if dict.keys.contains("DeviceGroupId") {
                self.deviceGroupId = dict["DeviceGroupId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("TagCode") {
                self.tagCode = dict["TagCode"] as! String
            }
            if dict.keys.contains("TagMetrics") {
                self.tagMetrics = dict["TagMetrics"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListCorpMetricsResponseBody.Data]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListCorpMetricsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCorpMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCorpMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCorpMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCorpsRequest : Tea.TeaModel {
    public var corpName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpName != nil {
            map["CorpName"] = self.corpName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpName") {
            self.corpName = dict["CorpName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListCorpsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var acuUsed: Int32?

            public var appName: String?

            public var corpId: String?

            public var corpName: String?

            public var createDate: String?

            public var description_: String?

            public var deviceCount: Int32?

            public var iconPath: String?

            public var isvSubId: String?

            public var parentCorpId: String?

            public var YOfflineAcuUsed: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acuUsed != nil {
                    map["AcuUsed"] = self.acuUsed!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.corpName != nil {
                    map["CorpName"] = self.corpName!
                }
                if self.createDate != nil {
                    map["CreateDate"] = self.createDate!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceCount != nil {
                    map["DeviceCount"] = self.deviceCount!
                }
                if self.iconPath != nil {
                    map["IconPath"] = self.iconPath!
                }
                if self.isvSubId != nil {
                    map["IsvSubId"] = self.isvSubId!
                }
                if self.parentCorpId != nil {
                    map["ParentCorpId"] = self.parentCorpId!
                }
                if self.YOfflineAcuUsed != nil {
                    map["YOfflineAcuUsed"] = self.YOfflineAcuUsed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcuUsed") {
                    self.acuUsed = dict["AcuUsed"] as! Int32
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("CorpName") {
                    self.corpName = dict["CorpName"] as! String
                }
                if dict.keys.contains("CreateDate") {
                    self.createDate = dict["CreateDate"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DeviceCount") {
                    self.deviceCount = dict["DeviceCount"] as! Int32
                }
                if dict.keys.contains("IconPath") {
                    self.iconPath = dict["IconPath"] as! String
                }
                if dict.keys.contains("IsvSubId") {
                    self.isvSubId = dict["IsvSubId"] as! String
                }
                if dict.keys.contains("ParentCorpId") {
                    self.parentCorpId = dict["ParentCorpId"] as! String
                }
                if dict.keys.contains("YOfflineAcuUsed") {
                    self.YOfflineAcuUsed = dict["YOfflineAcuUsed"] as! Double
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListCorpsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListCorpsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCorpsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCorpsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCorpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCorpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCorpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDeviceGroupsRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var dataSourceType: String?

    public var deviceCodeList: String?

    public var group: String?

    public var isPage: Int32?

    public var name: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.dataSourceType != nil {
            map["DataSourceType"] = self.dataSourceType!
        }
        if self.deviceCodeList != nil {
            map["DeviceCodeList"] = self.deviceCodeList!
        }
        if self.group != nil {
            map["Group"] = self.group!
        }
        if self.isPage != nil {
            map["IsPage"] = self.isPage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DataSourceType") {
            self.dataSourceType = dict["DataSourceType"] as! String
        }
        if dict.keys.contains("DeviceCodeList") {
            self.deviceCodeList = dict["DeviceCodeList"] as! String
        }
        if dict.keys.contains("Group") {
            self.group = dict["Group"] as! String
        }
        if dict.keys.contains("IsPage") {
            self.isPage = dict["IsPage"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDeviceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var bitRate: String?

            public var codingFormat: String?

            public var dataSourceType: String?

            public var deviceCode: String?

            public var deviceComputeStatus: String?

            public var deviceGroup: String?

            public var deviceName: String?

            public var deviceSn: String?

            public var deviceStatus: String?

            public var deviceStreamStatus: String?

            public var installAddress: String?

            public var regionId: String?

            public var regionName: String?

            public var resolvingPower: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.codingFormat != nil {
                    map["CodingFormat"] = self.codingFormat!
                }
                if self.dataSourceType != nil {
                    map["DataSourceType"] = self.dataSourceType!
                }
                if self.deviceCode != nil {
                    map["DeviceCode"] = self.deviceCode!
                }
                if self.deviceComputeStatus != nil {
                    map["DeviceComputeStatus"] = self.deviceComputeStatus!
                }
                if self.deviceGroup != nil {
                    map["DeviceGroup"] = self.deviceGroup!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceSn != nil {
                    map["DeviceSn"] = self.deviceSn!
                }
                if self.deviceStatus != nil {
                    map["DeviceStatus"] = self.deviceStatus!
                }
                if self.deviceStreamStatus != nil {
                    map["DeviceStreamStatus"] = self.deviceStreamStatus!
                }
                if self.installAddress != nil {
                    map["InstallAddress"] = self.installAddress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.resolvingPower != nil {
                    map["ResolvingPower"] = self.resolvingPower!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BitRate") {
                    self.bitRate = dict["BitRate"] as! String
                }
                if dict.keys.contains("CodingFormat") {
                    self.codingFormat = dict["CodingFormat"] as! String
                }
                if dict.keys.contains("DataSourceType") {
                    self.dataSourceType = dict["DataSourceType"] as! String
                }
                if dict.keys.contains("DeviceCode") {
                    self.deviceCode = dict["DeviceCode"] as! String
                }
                if dict.keys.contains("DeviceComputeStatus") {
                    self.deviceComputeStatus = dict["DeviceComputeStatus"] as! String
                }
                if dict.keys.contains("DeviceGroup") {
                    self.deviceGroup = dict["DeviceGroup"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceSn") {
                    self.deviceSn = dict["DeviceSn"] as! String
                }
                if dict.keys.contains("DeviceStatus") {
                    self.deviceStatus = dict["DeviceStatus"] as! String
                }
                if dict.keys.contains("DeviceStreamStatus") {
                    self.deviceStreamStatus = dict["DeviceStreamStatus"] as! String
                }
                if dict.keys.contains("InstallAddress") {
                    self.installAddress = dict["InstallAddress"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RegionName") {
                    self.regionName = dict["RegionName"] as! String
                }
                if dict.keys.contains("ResolvingPower") {
                    self.resolvingPower = dict["ResolvingPower"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var list: [ListDeviceGroupsResponseBody.Data.List]?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListDeviceGroupsResponseBody.Data.List]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListDeviceGroupsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListDeviceGroupsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDeviceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeviceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDeviceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDevicesRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceName: String?

    public var gbId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var accessProtocolType: String?

            public var bitRate: String?

            public var coverImageUrl: String?

            public var createTime: String?

            public var deviceAddress: String?

            public var deviceDirection: String?

            public var deviceName: String?

            public var deviceSite: String?

            public var deviceType: String?

            public var gbId: String?

            public var latitude: String?

            public var longitude: String?

            public var resolution: String?

            public var sipGBId: String?

            public var sipPassword: String?

            public var sipServerIp: String?

            public var sipServerPort: String?

            public var status: Int32?

            public var vendor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessProtocolType != nil {
                    map["AccessProtocolType"] = self.accessProtocolType!
                }
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.coverImageUrl != nil {
                    map["CoverImageUrl"] = self.coverImageUrl!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deviceAddress != nil {
                    map["DeviceAddress"] = self.deviceAddress!
                }
                if self.deviceDirection != nil {
                    map["DeviceDirection"] = self.deviceDirection!
                }
                if self.deviceName != nil {
                    map["DeviceName"] = self.deviceName!
                }
                if self.deviceSite != nil {
                    map["DeviceSite"] = self.deviceSite!
                }
                if self.deviceType != nil {
                    map["DeviceType"] = self.deviceType!
                }
                if self.gbId != nil {
                    map["GbId"] = self.gbId!
                }
                if self.latitude != nil {
                    map["Latitude"] = self.latitude!
                }
                if self.longitude != nil {
                    map["Longitude"] = self.longitude!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.sipGBId != nil {
                    map["SipGBId"] = self.sipGBId!
                }
                if self.sipPassword != nil {
                    map["SipPassword"] = self.sipPassword!
                }
                if self.sipServerIp != nil {
                    map["SipServerIp"] = self.sipServerIp!
                }
                if self.sipServerPort != nil {
                    map["SipServerPort"] = self.sipServerPort!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessProtocolType") {
                    self.accessProtocolType = dict["AccessProtocolType"] as! String
                }
                if dict.keys.contains("BitRate") {
                    self.bitRate = dict["BitRate"] as! String
                }
                if dict.keys.contains("CoverImageUrl") {
                    self.coverImageUrl = dict["CoverImageUrl"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DeviceAddress") {
                    self.deviceAddress = dict["DeviceAddress"] as! String
                }
                if dict.keys.contains("DeviceDirection") {
                    self.deviceDirection = dict["DeviceDirection"] as! String
                }
                if dict.keys.contains("DeviceName") {
                    self.deviceName = dict["DeviceName"] as! String
                }
                if dict.keys.contains("DeviceSite") {
                    self.deviceSite = dict["DeviceSite"] as! String
                }
                if dict.keys.contains("DeviceType") {
                    self.deviceType = dict["DeviceType"] as! String
                }
                if dict.keys.contains("GbId") {
                    self.gbId = dict["GbId"] as! String
                }
                if dict.keys.contains("Latitude") {
                    self.latitude = dict["Latitude"] as! String
                }
                if dict.keys.contains("Longitude") {
                    self.longitude = dict["Longitude"] as! String
                }
                if dict.keys.contains("Resolution") {
                    self.resolution = dict["Resolution"] as! String
                }
                if dict.keys.contains("SipGBId") {
                    self.sipGBId = dict["SipGBId"] as! String
                }
                if dict.keys.contains("SipPassword") {
                    self.sipPassword = dict["SipPassword"] as! String
                }
                if dict.keys.contains("SipServerIp") {
                    self.sipServerIp = dict["SipServerIp"] as! String
                }
                if dict.keys.contains("SipServerPort") {
                    self.sipServerPort = dict["SipServerPort"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Vendor") {
                    self.vendor = dict["Vendor"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListDevicesResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListDevicesResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventAlgorithmDetailsRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var eventType: String?

    public var eventValue: String?

    public var extendValue: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var recordId: String?

    public var sourceId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.eventValue != nil {
            map["EventValue"] = self.eventValue!
        }
        if self.extendValue != nil {
            map["ExtendValue"] = self.extendValue!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.sourceId != nil {
            map["SourceId"] = self.sourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("EventValue") {
            self.eventValue = dict["EventValue"] as! String
        }
        if dict.keys.contains("ExtendValue") {
            self.extendValue = dict["ExtendValue"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("SourceId") {
            self.sourceId = dict["SourceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListEventAlgorithmDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpId: String?

        public var dataSourceId: String?

        public var eventType: String?

        public var eventValue: String?

        public var extendValue: String?

        public var extraExtendValue: String?

        public var faceCount: String?

        public var leftTopX: String?

        public var leftTopY: String?

        public var picUrlPath: String?

        public var pointX: String?

        public var pointY: String?

        public var recordId: String?

        public var rightBottomX: String?

        public var rightBottomY: String?

        public var shotTime: String?

        public var sourceId: String?

        public var tagCode: String?

        public var tagCodeReliability: String?

        public var targetPicUrlPath: String?

        public var uuidCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.eventValue != nil {
                map["EventValue"] = self.eventValue!
            }
            if self.extendValue != nil {
                map["ExtendValue"] = self.extendValue!
            }
            if self.extraExtendValue != nil {
                map["ExtraExtendValue"] = self.extraExtendValue!
            }
            if self.faceCount != nil {
                map["FaceCount"] = self.faceCount!
            }
            if self.leftTopX != nil {
                map["LeftTopX"] = self.leftTopX!
            }
            if self.leftTopY != nil {
                map["LeftTopY"] = self.leftTopY!
            }
            if self.picUrlPath != nil {
                map["PicUrlPath"] = self.picUrlPath!
            }
            if self.pointX != nil {
                map["PointX"] = self.pointX!
            }
            if self.pointY != nil {
                map["PointY"] = self.pointY!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.rightBottomX != nil {
                map["RightBottomX"] = self.rightBottomX!
            }
            if self.rightBottomY != nil {
                map["RightBottomY"] = self.rightBottomY!
            }
            if self.shotTime != nil {
                map["ShotTime"] = self.shotTime!
            }
            if self.sourceId != nil {
                map["SourceId"] = self.sourceId!
            }
            if self.tagCode != nil {
                map["TagCode"] = self.tagCode!
            }
            if self.tagCodeReliability != nil {
                map["TagCodeReliability"] = self.tagCodeReliability!
            }
            if self.targetPicUrlPath != nil {
                map["TargetPicUrlPath"] = self.targetPicUrlPath!
            }
            if self.uuidCode != nil {
                map["UuidCode"] = self.uuidCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! String
            }
            if dict.keys.contains("EventType") {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("EventValue") {
                self.eventValue = dict["EventValue"] as! String
            }
            if dict.keys.contains("ExtendValue") {
                self.extendValue = dict["ExtendValue"] as! String
            }
            if dict.keys.contains("ExtraExtendValue") {
                self.extraExtendValue = dict["ExtraExtendValue"] as! String
            }
            if dict.keys.contains("FaceCount") {
                self.faceCount = dict["FaceCount"] as! String
            }
            if dict.keys.contains("LeftTopX") {
                self.leftTopX = dict["LeftTopX"] as! String
            }
            if dict.keys.contains("LeftTopY") {
                self.leftTopY = dict["LeftTopY"] as! String
            }
            if dict.keys.contains("PicUrlPath") {
                self.picUrlPath = dict["PicUrlPath"] as! String
            }
            if dict.keys.contains("PointX") {
                self.pointX = dict["PointX"] as! String
            }
            if dict.keys.contains("PointY") {
                self.pointY = dict["PointY"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RightBottomX") {
                self.rightBottomX = dict["RightBottomX"] as! String
            }
            if dict.keys.contains("RightBottomY") {
                self.rightBottomY = dict["RightBottomY"] as! String
            }
            if dict.keys.contains("ShotTime") {
                self.shotTime = dict["ShotTime"] as! String
            }
            if dict.keys.contains("SourceId") {
                self.sourceId = dict["SourceId"] as! String
            }
            if dict.keys.contains("TagCode") {
                self.tagCode = dict["TagCode"] as! String
            }
            if dict.keys.contains("TagCodeReliability") {
                self.tagCodeReliability = dict["TagCodeReliability"] as! String
            }
            if dict.keys.contains("TargetPicUrlPath") {
                self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
            }
            if dict.keys.contains("UuidCode") {
                self.uuidCode = dict["UuidCode"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListEventAlgorithmDetailsResponseBody.Data]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListEventAlgorithmDetailsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEventAlgorithmDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventAlgorithmDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventAlgorithmDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEventAlgorithmResultsRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var eventType: String?

    public var extendValue: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.extendValue != nil {
            map["ExtendValue"] = self.extendValue!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("ExtendValue") {
            self.extendValue = dict["ExtendValue"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListEventAlgorithmResultsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var capStyle: String?

            public var corpId: String?

            public var dataSourceId: String?

            public var eventType: String?

            public var extendValue: String?

            public var extendValueThree: String?

            public var extendValueTwo: String?

            public var faceCount: String?

            public var picUrlPath: String?

            public var recordId: String?

            public var shotTime: String?

            public var tagCode: String?

            public var tagCodeReliability: String?

            public var targetPicUrlPath: String?

            public var uuidCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capStyle != nil {
                    map["CapStyle"] = self.capStyle!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.extendValue != nil {
                    map["ExtendValue"] = self.extendValue!
                }
                if self.extendValueThree != nil {
                    map["ExtendValueThree"] = self.extendValueThree!
                }
                if self.extendValueTwo != nil {
                    map["ExtendValueTwo"] = self.extendValueTwo!
                }
                if self.faceCount != nil {
                    map["FaceCount"] = self.faceCount!
                }
                if self.picUrlPath != nil {
                    map["PicUrlPath"] = self.picUrlPath!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.tagCode != nil {
                    map["TagCode"] = self.tagCode!
                }
                if self.tagCodeReliability != nil {
                    map["TagCodeReliability"] = self.tagCodeReliability!
                }
                if self.targetPicUrlPath != nil {
                    map["TargetPicUrlPath"] = self.targetPicUrlPath!
                }
                if self.uuidCode != nil {
                    map["UuidCode"] = self.uuidCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapStyle") {
                    self.capStyle = dict["CapStyle"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("DataSourceId") {
                    self.dataSourceId = dict["DataSourceId"] as! String
                }
                if dict.keys.contains("EventType") {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("ExtendValue") {
                    self.extendValue = dict["ExtendValue"] as! String
                }
                if dict.keys.contains("ExtendValueThree") {
                    self.extendValueThree = dict["ExtendValueThree"] as! String
                }
                if dict.keys.contains("ExtendValueTwo") {
                    self.extendValueTwo = dict["ExtendValueTwo"] as! String
                }
                if dict.keys.contains("FaceCount") {
                    self.faceCount = dict["FaceCount"] as! String
                }
                if dict.keys.contains("PicUrlPath") {
                    self.picUrlPath = dict["PicUrlPath"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("TagCode") {
                    self.tagCode = dict["TagCode"] as! String
                }
                if dict.keys.contains("TagCodeReliability") {
                    self.tagCodeReliability = dict["TagCodeReliability"] as! String
                }
                if dict.keys.contains("TargetPicUrlPath") {
                    self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
                }
                if dict.keys.contains("UuidCode") {
                    self.uuidCode = dict["UuidCode"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListEventAlgorithmResultsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListEventAlgorithmResultsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListEventAlgorithmResultsResponseBody.Data?

    public var extendValue: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.extendValue != nil {
            map["ExtendValue"] = self.extendValue!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListEventAlgorithmResultsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ExtendValue") {
            self.extendValue = dict["ExtendValue"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEventAlgorithmResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventAlgorithmResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEventAlgorithmResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFaceAlgorithmResultsRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListFaceAlgorithmResultsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var capStyle: String?

            public var corpId: String?

            public var dataSourceId: String?

            public var faceId: String?

            public var genderCode: String?

            public var hairStyle: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var maxAge: String?

            public var minAge: String?

            public var picUrlPath: String?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var shotTime: String?

            public var sourceId: String?

            public var targetPicUrlPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capStyle != nil {
                    map["CapStyle"] = self.capStyle!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.faceId != nil {
                    map["FaceId"] = self.faceId!
                }
                if self.genderCode != nil {
                    map["GenderCode"] = self.genderCode!
                }
                if self.hairStyle != nil {
                    map["HairStyle"] = self.hairStyle!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.maxAge != nil {
                    map["MaxAge"] = self.maxAge!
                }
                if self.minAge != nil {
                    map["MinAge"] = self.minAge!
                }
                if self.picUrlPath != nil {
                    map["PicUrlPath"] = self.picUrlPath!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.targetPicUrlPath != nil {
                    map["TargetPicUrlPath"] = self.targetPicUrlPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CapStyle") {
                    self.capStyle = dict["CapStyle"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("DataSourceId") {
                    self.dataSourceId = dict["DataSourceId"] as! String
                }
                if dict.keys.contains("FaceId") {
                    self.faceId = dict["FaceId"] as! String
                }
                if dict.keys.contains("GenderCode") {
                    self.genderCode = dict["GenderCode"] as! String
                }
                if dict.keys.contains("HairStyle") {
                    self.hairStyle = dict["HairStyle"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("MaxAge") {
                    self.maxAge = dict["MaxAge"] as! String
                }
                if dict.keys.contains("MinAge") {
                    self.minAge = dict["MinAge"] as! String
                }
                if dict.keys.contains("PicUrlPath") {
                    self.picUrlPath = dict["PicUrlPath"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("TargetPicUrlPath") {
                    self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListFaceAlgorithmResultsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListFaceAlgorithmResultsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListFaceAlgorithmResultsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListFaceAlgorithmResultsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFaceAlgorithmResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFaceAlgorithmResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFaceAlgorithmResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var instanceName: String?

    public var pageSize: Int32?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class Algorithms : Tea.TeaModel {
                public var algorithmId: String?

                public var algorithmName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithmId != nil {
                        map["AlgorithmId"] = self.algorithmId!
                    }
                    if self.algorithmName != nil {
                        map["AlgorithmName"] = self.algorithmName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlgorithmId") {
                        self.algorithmId = dict["AlgorithmId"] as! String
                    }
                    if dict.keys.contains("AlgorithmName") {
                        self.algorithmName = dict["AlgorithmName"] as! String
                    }
                }
            }
            public var acuUsed: Int32?

            public var algorithms: [ListInstancesResponseBody.Data.Items.Algorithms]?

            public var createTime: Int64?

            public var deviceNumber: Int32?

            public var instanceId: String?

            public var instanceName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acuUsed != nil {
                    map["AcuUsed"] = self.acuUsed!
                }
                if self.algorithms != nil {
                    var tmp : [Any] = []
                    for k in self.algorithms! {
                        tmp.append(k.toMap())
                    }
                    map["Algorithms"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deviceNumber != nil {
                    map["DeviceNumber"] = self.deviceNumber!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcuUsed") {
                    self.acuUsed = dict["AcuUsed"] as! Int32
                }
                if dict.keys.contains("Algorithms") {
                    self.algorithms = dict["Algorithms"] as! [ListInstancesResponseBody.Data.Items.Algorithms]
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DeviceNumber") {
                    self.deviceNumber = dict["DeviceNumber"] as! Int32
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var items: [ListInstancesResponseBody.Data.Items]?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("Items") {
                self.items = dict["Items"] as! [ListInstancesResponseBody.Data.Items]
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListInstancesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMetricsRequest : Tea.TeaModel {
    public var aggregateType: String?

    public var corpId: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var startTime: String?

    public var tagCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregateType != nil {
            map["AggregateType"] = self.aggregateType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tagCode != nil {
            map["TagCode"] = self.tagCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregateType") {
            self.aggregateType = dict["AggregateType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TagCode") {
            self.tagCode = dict["TagCode"] as! String
        }
    }
}

public class ListMetricsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var dateTime: String?

            public var tagCode: String?

            public var tagMetric: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dateTime != nil {
                    map["DateTime"] = self.dateTime!
                }
                if self.tagCode != nil {
                    map["TagCode"] = self.tagCode!
                }
                if self.tagMetric != nil {
                    map["TagMetric"] = self.tagMetric!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DateTime") {
                    self.dateTime = dict["DateTime"] as! String
                }
                if dict.keys.contains("TagCode") {
                    self.tagCode = dict["TagCode"] as! String
                }
                if dict.keys.contains("TagMetric") {
                    self.tagMetric = dict["TagMetric"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListMetricsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListMetricsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListMetricsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListMetricsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMotorAlgorithmResultsRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var plateNumber: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.plateNumber != nil {
            map["PlateNumber"] = self.plateNumber!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("PlateNumber") {
            self.plateNumber = dict["PlateNumber"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListMotorAlgorithmResultsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var calling: String?

            public var corpId: String?

            public var dataSourceId: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var motorBrand: String?

            public var motorClass: String?

            public var motorColor: String?

            public var motorId: String?

            public var motorModel: String?

            public var motorStyle: String?

            public var picUrlPath: String?

            public var plateClass: String?

            public var plateColor: String?

            public var plateNumber: String?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var safetyBelt: String?

            public var shotTime: String?

            public var sourceId: String?

            public var targetPicUrlPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.calling != nil {
                    map["Calling"] = self.calling!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.motorBrand != nil {
                    map["MotorBrand"] = self.motorBrand!
                }
                if self.motorClass != nil {
                    map["MotorClass"] = self.motorClass!
                }
                if self.motorColor != nil {
                    map["MotorColor"] = self.motorColor!
                }
                if self.motorId != nil {
                    map["MotorId"] = self.motorId!
                }
                if self.motorModel != nil {
                    map["MotorModel"] = self.motorModel!
                }
                if self.motorStyle != nil {
                    map["MotorStyle"] = self.motorStyle!
                }
                if self.picUrlPath != nil {
                    map["PicUrlPath"] = self.picUrlPath!
                }
                if self.plateClass != nil {
                    map["PlateClass"] = self.plateClass!
                }
                if self.plateColor != nil {
                    map["PlateColor"] = self.plateColor!
                }
                if self.plateNumber != nil {
                    map["PlateNumber"] = self.plateNumber!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.safetyBelt != nil {
                    map["SafetyBelt"] = self.safetyBelt!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.targetPicUrlPath != nil {
                    map["TargetPicUrlPath"] = self.targetPicUrlPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Calling") {
                    self.calling = dict["Calling"] as! String
                }
                if dict.keys.contains("CorpId") {
                    self.corpId = dict["CorpId"] as! String
                }
                if dict.keys.contains("DataSourceId") {
                    self.dataSourceId = dict["DataSourceId"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("MotorBrand") {
                    self.motorBrand = dict["MotorBrand"] as! String
                }
                if dict.keys.contains("MotorClass") {
                    self.motorClass = dict["MotorClass"] as! String
                }
                if dict.keys.contains("MotorColor") {
                    self.motorColor = dict["MotorColor"] as! String
                }
                if dict.keys.contains("MotorId") {
                    self.motorId = dict["MotorId"] as! String
                }
                if dict.keys.contains("MotorModel") {
                    self.motorModel = dict["MotorModel"] as! String
                }
                if dict.keys.contains("MotorStyle") {
                    self.motorStyle = dict["MotorStyle"] as! String
                }
                if dict.keys.contains("PicUrlPath") {
                    self.picUrlPath = dict["PicUrlPath"] as! String
                }
                if dict.keys.contains("PlateClass") {
                    self.plateClass = dict["PlateClass"] as! String
                }
                if dict.keys.contains("PlateColor") {
                    self.plateColor = dict["PlateColor"] as! String
                }
                if dict.keys.contains("PlateNumber") {
                    self.plateNumber = dict["PlateNumber"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("SafetyBelt") {
                    self.safetyBelt = dict["SafetyBelt"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("TargetPicUrlPath") {
                    self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [ListMotorAlgorithmResultsResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListMotorAlgorithmResultsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListMotorAlgorithmResultsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListMotorAlgorithmResultsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMotorAlgorithmResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMotorAlgorithmResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMotorAlgorithmResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNVRChannelDeviceRequest : Tea.TeaModel {
    public var deviceCode: String?

    public var isPage: String?

    public var pageNum: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCode != nil {
            map["DeviceCode"] = self.deviceCode!
        }
        if self.isPage != nil {
            map["IsPage"] = self.isPage!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCode") {
            self.deviceCode = dict["DeviceCode"] as! String
        }
        if dict.keys.contains("IsPage") {
            self.isPage = dict["IsPage"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class ListNVRChannelDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var comptureStatus: String?

        public var corpId: String?

        public var datasourceType: String?

        public var deviceCode: String?

        public var deviceName: String?

        public var deviceSn: String?

        public var deviceStatus: String?

        public var deviceType: String?

        public var projectName: String?

        public var regionName: String?

        public var sampleName: String?

        public var streamStatus: String?

        public var vap: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comptureStatus != nil {
                map["ComptureStatus"] = self.comptureStatus!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.datasourceType != nil {
                map["DatasourceType"] = self.datasourceType!
            }
            if self.deviceCode != nil {
                map["DeviceCode"] = self.deviceCode!
            }
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.deviceSn != nil {
                map["DeviceSn"] = self.deviceSn!
            }
            if self.deviceStatus != nil {
                map["DeviceStatus"] = self.deviceStatus!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.sampleName != nil {
                map["SampleName"] = self.sampleName!
            }
            if self.streamStatus != nil {
                map["StreamStatus"] = self.streamStatus!
            }
            if self.vap != nil {
                map["Vap"] = self.vap!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComptureStatus") {
                self.comptureStatus = dict["ComptureStatus"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DatasourceType") {
                self.datasourceType = dict["DatasourceType"] as! String
            }
            if dict.keys.contains("DeviceCode") {
                self.deviceCode = dict["DeviceCode"] as! String
            }
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DeviceSn") {
                self.deviceSn = dict["DeviceSn"] as! String
            }
            if dict.keys.contains("DeviceStatus") {
                self.deviceStatus = dict["DeviceStatus"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("RegionName") {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("SampleName") {
                self.sampleName = dict["SampleName"] as! String
            }
            if dict.keys.contains("StreamStatus") {
                self.streamStatus = dict["StreamStatus"] as! String
            }
            if dict.keys.contains("Vap") {
                self.vap = dict["Vap"] as! String
            }
        }
    }
    public var data: [ListNVRChannelDeviceResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListNVRChannelDeviceResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! String
        }
    }
}

public class ListNVRChannelDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNVRChannelDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNVRChannelDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNVRDeviceRequest : Tea.TeaModel {
    public var corpIdList: String?

    public var deviceCode: String?

    public var isPage: Int64?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpIdList != nil {
            map["CorpIdList"] = self.corpIdList!
        }
        if self.deviceCode != nil {
            map["DeviceCode"] = self.deviceCode!
        }
        if self.isPage != nil {
            map["IsPage"] = self.isPage!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpIdList") {
            self.corpIdList = dict["CorpIdList"] as! String
        }
        if dict.keys.contains("DeviceCode") {
            self.deviceCode = dict["DeviceCode"] as! String
        }
        if dict.keys.contains("IsPage") {
            self.isPage = dict["IsPage"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class ListNVRDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessQuota: String?

        public var channel: String?

        public var comptureStatus: String?

        public var corpId: String?

        public var datasourceType: String?

        public var deviceCode: String?

        public var deviceName: String?

        public var deviceSn: String?

        public var deviceStatus: String?

        public var deviceType: String?

        public var projectName: String?

        public var regionName: String?

        public var registrationTime: String?

        public var streamStatus: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessQuota != nil {
                map["AccessQuota"] = self.accessQuota!
            }
            if self.channel != nil {
                map["Channel"] = self.channel!
            }
            if self.comptureStatus != nil {
                map["ComptureStatus"] = self.comptureStatus!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.datasourceType != nil {
                map["DatasourceType"] = self.datasourceType!
            }
            if self.deviceCode != nil {
                map["DeviceCode"] = self.deviceCode!
            }
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.deviceSn != nil {
                map["DeviceSn"] = self.deviceSn!
            }
            if self.deviceStatus != nil {
                map["DeviceStatus"] = self.deviceStatus!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.registrationTime != nil {
                map["RegistrationTime"] = self.registrationTime!
            }
            if self.streamStatus != nil {
                map["StreamStatus"] = self.streamStatus!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessQuota") {
                self.accessQuota = dict["AccessQuota"] as! String
            }
            if dict.keys.contains("Channel") {
                self.channel = dict["Channel"] as! String
            }
            if dict.keys.contains("ComptureStatus") {
                self.comptureStatus = dict["ComptureStatus"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DatasourceType") {
                self.datasourceType = dict["DatasourceType"] as! String
            }
            if dict.keys.contains("DeviceCode") {
                self.deviceCode = dict["DeviceCode"] as! String
            }
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("DeviceSn") {
                self.deviceSn = dict["DeviceSn"] as! String
            }
            if dict.keys.contains("DeviceStatus") {
                self.deviceStatus = dict["DeviceStatus"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("RegionName") {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("RegistrationTime") {
                self.registrationTime = dict["RegistrationTime"] as! String
            }
            if dict.keys.contains("StreamStatus") {
                self.streamStatus = dict["StreamStatus"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var data: [ListNVRDeviceResponseBody.Data]?

    public var requestId: String?

    public var success: Bool?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListNVRDeviceResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! String
        }
    }
}

public class ListNVRDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNVRDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNVRDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonTraceRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var groupId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var personId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListPersonTraceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpId: String?

        public var date: String?

        public var deviceId: String?

        public var endSourceImage: String?

        public var endTargetImage: String?

        public var groupId: String?

        public var lastTime: String?

        public var personId: String?

        public var startSourceImage: String?

        public var startTargetImage: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.date != nil {
                map["Date"] = self.date!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.endSourceImage != nil {
                map["EndSourceImage"] = self.endSourceImage!
            }
            if self.endTargetImage != nil {
                map["EndTargetImage"] = self.endTargetImage!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.startSourceImage != nil {
                map["StartSourceImage"] = self.startSourceImage!
            }
            if self.startTargetImage != nil {
                map["StartTargetImage"] = self.startTargetImage!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("Date") {
                self.date = dict["Date"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("EndSourceImage") {
                self.endSourceImage = dict["EndSourceImage"] as! String
            }
            if dict.keys.contains("EndTargetImage") {
                self.endTargetImage = dict["EndTargetImage"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("LastTime") {
                self.lastTime = dict["LastTime"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("StartSourceImage") {
                self.startSourceImage = dict["StartSourceImage"] as! String
            }
            if dict.keys.contains("StartTargetImage") {
                self.startTargetImage = dict["StartTargetImage"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPersonTraceResponseBody.Data]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListPersonTraceResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListPersonTraceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonTraceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPersonTraceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonTraceDetailsRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public var endTime: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personId: String?

    public var startTime: String?

    public var subId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.subId != nil {
            map["SubId"] = self.subId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("SubId") {
            self.subId = dict["SubId"] as! String
        }
    }
}

public class ListPersonTraceDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpId: String?

        public var dataSourceId: String?

        public var leftTopX: String?

        public var leftTopY: String?

        public var personId: String?

        public var picUrlPath: String?

        public var rightBottomX: String?

        public var rightBottomY: String?

        public var shotTime: String?

        public var subId: String?

        public var targetPicUrlPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.leftTopX != nil {
                map["LeftTopX"] = self.leftTopX!
            }
            if self.leftTopY != nil {
                map["LeftTopY"] = self.leftTopY!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.picUrlPath != nil {
                map["PicUrlPath"] = self.picUrlPath!
            }
            if self.rightBottomX != nil {
                map["RightBottomX"] = self.rightBottomX!
            }
            if self.rightBottomY != nil {
                map["RightBottomY"] = self.rightBottomY!
            }
            if self.shotTime != nil {
                map["ShotTime"] = self.shotTime!
            }
            if self.subId != nil {
                map["SubId"] = self.subId!
            }
            if self.targetPicUrlPath != nil {
                map["TargetPicUrlPath"] = self.targetPicUrlPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! String
            }
            if dict.keys.contains("LeftTopX") {
                self.leftTopX = dict["LeftTopX"] as! String
            }
            if dict.keys.contains("LeftTopY") {
                self.leftTopY = dict["LeftTopY"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PicUrlPath") {
                self.picUrlPath = dict["PicUrlPath"] as! String
            }
            if dict.keys.contains("RightBottomX") {
                self.rightBottomX = dict["RightBottomX"] as! String
            }
            if dict.keys.contains("RightBottomY") {
                self.rightBottomY = dict["RightBottomY"] as! String
            }
            if dict.keys.contains("ShotTime") {
                self.shotTime = dict["ShotTime"] as! String
            }
            if dict.keys.contains("SubId") {
                self.subId = dict["SubId"] as! String
            }
            if dict.keys.contains("TargetPicUrlPath") {
                self.targetPicUrlPath = dict["TargetPicUrlPath"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPersonTraceDetailsResponseBody.Data]?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListPersonTraceDetailsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPersonTraceDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonTraceDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPersonTraceDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonVisitCountRequest : Tea.TeaModel {
    public var aggregateType: String?

    public var corpId: String?

    public var countType: String?

    public var endTime: String?

    public var maxVal: Int32?

    public var minVal: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var tagCode: String?

    public var timeAggregateType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregateType != nil {
            map["AggregateType"] = self.aggregateType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.countType != nil {
            map["CountType"] = self.countType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.maxVal != nil {
            map["MaxVal"] = self.maxVal!
        }
        if self.minVal != nil {
            map["MinVal"] = self.minVal!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tagCode != nil {
            map["TagCode"] = self.tagCode!
        }
        if self.timeAggregateType != nil {
            map["TimeAggregateType"] = self.timeAggregateType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregateType") {
            self.aggregateType = dict["AggregateType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CountType") {
            self.countType = dict["CountType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MaxVal") {
            self.maxVal = dict["MaxVal"] as! Int32
        }
        if dict.keys.contains("MinVal") {
            self.minVal = dict["MinVal"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TagCode") {
            self.tagCode = dict["TagCode"] as! String
        }
        if dict.keys.contains("TimeAggregateType") {
            self.timeAggregateType = dict["TimeAggregateType"] as! String
        }
    }
}

public class ListPersonVisitCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var corpId: String?

        public var dayId: String?

        public var deviceId: String?

        public var groupId: String?

        public var hourId: String?

        public var personId: String?

        public var tagCode: String?

        public var tagMetrics: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dayId != nil {
                map["DayId"] = self.dayId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.hourId != nil {
                map["HourId"] = self.hourId!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.tagCode != nil {
                map["TagCode"] = self.tagCode!
            }
            if self.tagMetrics != nil {
                map["TagMetrics"] = self.tagMetrics!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DayId") {
                self.dayId = dict["DayId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("HourId") {
                self.hourId = dict["HourId"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("TagCode") {
                self.tagCode = dict["TagCode"] as! String
            }
            if dict.keys.contains("TagMetrics") {
                self.tagMetrics = dict["TagMetrics"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPersonVisitCountResponseBody.Data]?

    public var message: String?

    public var pageNo: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListPersonVisitCountResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListPersonVisitCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonVisitCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPersonVisitCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonsRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var corpId: String?

    public var endTime: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListPersonsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public class TagList : Tea.TeaModel {
                public var tagCode: String?

                public var tagName: String?

                public var tagValue: String?

                public var tagValueId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagCode != nil {
                        map["TagCode"] = self.tagCode!
                    }
                    if self.tagName != nil {
                        map["TagName"] = self.tagName!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    if self.tagValueId != nil {
                        map["TagValueId"] = self.tagValueId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagCode") {
                        self.tagCode = dict["TagCode"] as! String
                    }
                    if dict.keys.contains("TagName") {
                        self.tagName = dict["TagName"] as! String
                    }
                    if dict.keys.contains("TagValue") {
                        self.tagValue = dict["TagValue"] as! String
                    }
                    if dict.keys.contains("TagValueId") {
                        self.tagValueId = dict["TagValueId"] as! String
                    }
                }
            }
            public var firstAppearTime: String?

            public var personId: String?

            public var picUrl: String?

            public var tagList: [ListPersonsResponseBody.Data.Records.TagList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.firstAppearTime != nil {
                    map["FirstAppearTime"] = self.firstAppearTime!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.picUrl != nil {
                    map["PicUrl"] = self.picUrl!
                }
                if self.tagList != nil {
                    var tmp : [Any] = []
                    for k in self.tagList! {
                        tmp.append(k.toMap())
                    }
                    map["TagList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FirstAppearTime") {
                    self.firstAppearTime = dict["FirstAppearTime"] as! String
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PicUrl") {
                    self.picUrl = dict["PicUrl"] as! String
                }
                if dict.keys.contains("TagList") {
                    self.tagList = dict["TagList"] as! [ListPersonsResponseBody.Data.Records.TagList]
                }
            }
        }
        public var pageNo: String?

        public var pageSize: String?

        public var records: [ListPersonsResponseBody.Data.Records]?

        public var totalCount: String?

        public var totalPage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListPersonsResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! String
            }
        }
    }
    public var code: String?

    public var data: ListPersonsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListPersonsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPersonsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPersonsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserGroupsRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
    }
}

public class ListUserGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: String?

        public var creator: String?

        public var isvSubId: String?

        public var parentUserGroupId: Int64?

        public var updateTime: String?

        public var userCount: Int64?

        public var userGroupId: Int64?

        public var userGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.parentUserGroupId != nil {
                map["ParentUserGroupId"] = self.parentUserGroupId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userCount != nil {
                map["UserCount"] = self.userCount!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            if self.userGroupName != nil {
                map["UserGroupName"] = self.userGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("ParentUserGroupId") {
                self.parentUserGroupId = dict["ParentUserGroupId"] as! Int64
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
            if dict.keys.contains("UserCount") {
                self.userCount = dict["UserCount"] as! Int64
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! Int64
            }
            if dict.keys.contains("UserGroupName") {
                self.userGroupName = dict["UserGroupName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListUserGroupsResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [ListUserGroupsResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUserGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var address: String?

    public var age: Int32?

    public var attachment: String?

    public var bizId: String?

    public var corpId: String?

    public var faceImageUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var matchingRateThreshold: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personList: [String: Any]?

    public var phoneNo: String?

    public var plateNo: String?

    public var userGroupId: Int64?

    public var userList: [String: Any]?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.age != nil {
            map["Age"] = self.age!
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageUrl != nil {
            map["FaceImageUrl"] = self.faceImageUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.matchingRateThreshold != nil {
            map["MatchingRateThreshold"] = self.matchingRateThreshold!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personList != nil {
            map["PersonList"] = self.personList!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        if self.userList != nil {
            map["UserList"] = self.userList!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Age") {
            self.age = dict["Age"] as! Int32
        }
        if dict.keys.contains("Attachment") {
            self.attachment = dict["Attachment"] as! String
        }
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageUrl") {
            self.faceImageUrl = dict["FaceImageUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("MatchingRateThreshold") {
            self.matchingRateThreshold = dict["MatchingRateThreshold"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonList") {
            self.personList = dict["PersonList"] as! [String: Any]
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! Int64
        }
        if dict.keys.contains("UserList") {
            self.userList = dict["UserList"] as! [String: Any]
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListUsersShrinkRequest : Tea.TeaModel {
    public var address: String?

    public var age: Int32?

    public var attachment: String?

    public var bizId: String?

    public var corpId: String?

    public var faceImageUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var matchingRateThreshold: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var personListShrink: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var userGroupId: Int64?

    public var userListShrink: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.age != nil {
            map["Age"] = self.age!
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageUrl != nil {
            map["FaceImageUrl"] = self.faceImageUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.matchingRateThreshold != nil {
            map["MatchingRateThreshold"] = self.matchingRateThreshold!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.personListShrink != nil {
            map["PersonList"] = self.personListShrink!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        if self.userListShrink != nil {
            map["UserList"] = self.userListShrink!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Age") {
            self.age = dict["Age"] as! Int32
        }
        if dict.keys.contains("Attachment") {
            self.attachment = dict["Attachment"] as! String
        }
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageUrl") {
            self.faceImageUrl = dict["FaceImageUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("MatchingRateThreshold") {
            self.matchingRateThreshold = dict["MatchingRateThreshold"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PersonList") {
            self.personListShrink = dict["PersonList"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! Int64
        }
        if dict.keys.contains("UserList") {
            self.userListShrink = dict["UserList"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var age: String?

            public var attachment: String?

            public var bizId: String?

            public var faceImageUrl: String?

            public var gender: String?

            public var idNumber: String?

            public var isvSubId: String?

            public var matchingRate: String?

            public var personId: String?

            public var userGroupId: Int32?

            public var userId: Int32?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.age != nil {
                    map["Age"] = self.age!
                }
                if self.attachment != nil {
                    map["Attachment"] = self.attachment!
                }
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.faceImageUrl != nil {
                    map["FaceImageUrl"] = self.faceImageUrl!
                }
                if self.gender != nil {
                    map["Gender"] = self.gender!
                }
                if self.idNumber != nil {
                    map["IdNumber"] = self.idNumber!
                }
                if self.isvSubId != nil {
                    map["IsvSubId"] = self.isvSubId!
                }
                if self.matchingRate != nil {
                    map["MatchingRate"] = self.matchingRate!
                }
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.userGroupId != nil {
                    map["UserGroupId"] = self.userGroupId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Age") {
                    self.age = dict["Age"] as! String
                }
                if dict.keys.contains("Attachment") {
                    self.attachment = dict["Attachment"] as! String
                }
                if dict.keys.contains("BizId") {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("FaceImageUrl") {
                    self.faceImageUrl = dict["FaceImageUrl"] as! String
                }
                if dict.keys.contains("Gender") {
                    self.gender = dict["Gender"] as! String
                }
                if dict.keys.contains("IdNumber") {
                    self.idNumber = dict["IdNumber"] as! String
                }
                if dict.keys.contains("IsvSubId") {
                    self.isvSubId = dict["IsvSubId"] as! String
                }
                if dict.keys.contains("MatchingRate") {
                    self.matchingRate = dict["MatchingRate"] as! String
                }
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("UserGroupId") {
                    self.userGroupId = dict["UserGroupId"] as! Int32
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int32
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [ListUsersResponseBody.Data.Records]?

        public var success: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [ListUsersResponseBody.Data.Records]
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListUsersResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListUsersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDeviceRequest : Tea.TeaModel {
    public var audioEnable: String?

    public var deviceAddress: String?

    public var deviceDirection: String?

    public var deviceId: String?

    public var deviceIp: String?

    public var deviceModel: String?

    public var deviceName: String?

    public var deviceRate: String?

    public var deviceResolution: String?

    public var deviceSite: String?

    public var deviceSubType: String?

    public var encodeFormat: String?

    public var frameRate: String?

    public var govLength: String?

    public var latitude: String?

    public var longitude: String?

    public var OSDTimeEnable: String?

    public var OSDTimeType: String?

    public var OSDTimeX: String?

    public var OSDTimeY: String?

    public var password: String?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioEnable != nil {
            map["AudioEnable"] = self.audioEnable!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceDirection != nil {
            map["DeviceDirection"] = self.deviceDirection!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceIp != nil {
            map["DeviceIp"] = self.deviceIp!
        }
        if self.deviceModel != nil {
            map["DeviceModel"] = self.deviceModel!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceRate != nil {
            map["DeviceRate"] = self.deviceRate!
        }
        if self.deviceResolution != nil {
            map["DeviceResolution"] = self.deviceResolution!
        }
        if self.deviceSite != nil {
            map["DeviceSite"] = self.deviceSite!
        }
        if self.deviceSubType != nil {
            map["DeviceSubType"] = self.deviceSubType!
        }
        if self.encodeFormat != nil {
            map["EncodeFormat"] = self.encodeFormat!
        }
        if self.frameRate != nil {
            map["FrameRate"] = self.frameRate!
        }
        if self.govLength != nil {
            map["GovLength"] = self.govLength!
        }
        if self.latitude != nil {
            map["Latitude"] = self.latitude!
        }
        if self.longitude != nil {
            map["Longitude"] = self.longitude!
        }
        if self.OSDTimeEnable != nil {
            map["OSDTimeEnable"] = self.OSDTimeEnable!
        }
        if self.OSDTimeType != nil {
            map["OSDTimeType"] = self.OSDTimeType!
        }
        if self.OSDTimeX != nil {
            map["OSDTimeX"] = self.OSDTimeX!
        }
        if self.OSDTimeY != nil {
            map["OSDTimeY"] = self.OSDTimeY!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioEnable") {
            self.audioEnable = dict["AudioEnable"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceDirection") {
            self.deviceDirection = dict["DeviceDirection"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceIp") {
            self.deviceIp = dict["DeviceIp"] as! String
        }
        if dict.keys.contains("DeviceModel") {
            self.deviceModel = dict["DeviceModel"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceRate") {
            self.deviceRate = dict["DeviceRate"] as! String
        }
        if dict.keys.contains("DeviceResolution") {
            self.deviceResolution = dict["DeviceResolution"] as! String
        }
        if dict.keys.contains("DeviceSite") {
            self.deviceSite = dict["DeviceSite"] as! String
        }
        if dict.keys.contains("DeviceSubType") {
            self.deviceSubType = dict["DeviceSubType"] as! String
        }
        if dict.keys.contains("EncodeFormat") {
            self.encodeFormat = dict["EncodeFormat"] as! String
        }
        if dict.keys.contains("FrameRate") {
            self.frameRate = dict["FrameRate"] as! String
        }
        if dict.keys.contains("GovLength") {
            self.govLength = dict["GovLength"] as! String
        }
        if dict.keys.contains("Latitude") {
            self.latitude = dict["Latitude"] as! String
        }
        if dict.keys.contains("Longitude") {
            self.longitude = dict["Longitude"] as! String
        }
        if dict.keys.contains("OSDTimeEnable") {
            self.OSDTimeEnable = dict["OSDTimeEnable"] as! String
        }
        if dict.keys.contains("OSDTimeType") {
            self.OSDTimeType = dict["OSDTimeType"] as! String
        }
        if dict.keys.contains("OSDTimeX") {
            self.OSDTimeX = dict["OSDTimeX"] as! String
        }
        if dict.keys.contains("OSDTimeY") {
            self.OSDTimeY = dict["OSDTimeY"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class ModifyDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PeekNvrRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
    }
}

public class PeekNvrResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceList : Tea.TeaModel {
            public var associatedPlatform: String?

            public var subDeviceId: String?

            public var subDeviceName: String?

            public var subDeviceNum: String?

            public var subDeviceStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPlatform != nil {
                    map["AssociatedPlatform"] = self.associatedPlatform!
                }
                if self.subDeviceId != nil {
                    map["SubDeviceId"] = self.subDeviceId!
                }
                if self.subDeviceName != nil {
                    map["SubDeviceName"] = self.subDeviceName!
                }
                if self.subDeviceNum != nil {
                    map["SubDeviceNum"] = self.subDeviceNum!
                }
                if self.subDeviceStatus != nil {
                    map["SubDeviceStatus"] = self.subDeviceStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedPlatform") {
                    self.associatedPlatform = dict["AssociatedPlatform"] as! String
                }
                if dict.keys.contains("SubDeviceId") {
                    self.subDeviceId = dict["SubDeviceId"] as! String
                }
                if dict.keys.contains("SubDeviceName") {
                    self.subDeviceName = dict["SubDeviceName"] as! String
                }
                if dict.keys.contains("SubDeviceNum") {
                    self.subDeviceNum = dict["SubDeviceNum"] as! String
                }
                if dict.keys.contains("SubDeviceStatus") {
                    self.subDeviceStatus = dict["SubDeviceStatus"] as! String
                }
            }
        }
        public var idleCount: Int64?

        public var subDeviceList: [PeekNvrResponseBody.Data.SubDeviceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idleCount != nil {
                map["IdleCount"] = self.idleCount!
            }
            if self.subDeviceList != nil {
                var tmp : [Any] = []
                for k in self.subDeviceList! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdleCount") {
                self.idleCount = dict["IdleCount"] as! Int64
            }
            if dict.keys.contains("SubDeviceList") {
                self.subDeviceList = dict["SubDeviceList"] as! [PeekNvrResponseBody.Data.SubDeviceList]
            }
        }
    }
    public var code: String?

    public var data: PeekNvrResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = PeekNvrResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PeekNvrResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PeekNvrResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PeekNvrResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RaiseDevicesStorageRequest : Tea.TeaModel {
    public var json: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.json != nil {
            map["Json"] = self.json!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Json") {
            self.json = dict["Json"] as! String
        }
    }
}

public class RaiseDevicesStorageResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RaiseDevicesStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RaiseDevicesStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RaiseDevicesStorageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecognizeFaceQualityRequest : Tea.TeaModel {
    public var corpId: String?

    public var picContent: String?

    public var picFormat: String?

    public var picUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.picContent != nil {
            map["PicContent"] = self.picContent!
        }
        if self.picFormat != nil {
            map["PicFormat"] = self.picFormat!
        }
        if self.picUrl != nil {
            map["PicUrl"] = self.picUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PicContent") {
            self.picContent = dict["PicContent"] as! String
        }
        if dict.keys.contains("PicFormat") {
            self.picFormat = dict["PicFormat"] as! String
        }
        if dict.keys.contains("PicUrl") {
            self.picUrl = dict["PicUrl"] as! String
        }
    }
}

public class RecognizeFaceQualityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Attributes : Tea.TeaModel {
            public var faceQuality: String?

            public var faceScore: String?

            public var faceStyle: String?

            public var leftTopX: Int32?

            public var leftTopY: Int32?

            public var rightBottomX: Int32?

            public var rightBottomY: Int32?

            public var targetImageStoragePath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.faceQuality != nil {
                    map["FaceQuality"] = self.faceQuality!
                }
                if self.faceScore != nil {
                    map["FaceScore"] = self.faceScore!
                }
                if self.faceStyle != nil {
                    map["FaceStyle"] = self.faceStyle!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.targetImageStoragePath != nil {
                    map["TargetImageStoragePath"] = self.targetImageStoragePath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FaceQuality") {
                    self.faceQuality = dict["FaceQuality"] as! String
                }
                if dict.keys.contains("FaceScore") {
                    self.faceScore = dict["FaceScore"] as! String
                }
                if dict.keys.contains("FaceStyle") {
                    self.faceStyle = dict["FaceStyle"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Int32
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Int32
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Int32
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Int32
                }
                if dict.keys.contains("TargetImageStoragePath") {
                    self.targetImageStoragePath = dict["TargetImageStoragePath"] as! String
                }
            }
        }
        public var attributes: RecognizeFaceQualityResponseBody.Data.Attributes?

        public var description_: String?

        public var qualityScore: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.attributes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributes != nil {
                map["Attributes"] = self.attributes?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.qualityScore != nil {
                map["QualityScore"] = self.qualityScore!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attributes") {
                var model = RecognizeFaceQualityResponseBody.Data.Attributes()
                model.fromMap(dict["Attributes"] as! [String: Any])
                self.attributes = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("QualityScore") {
                self.qualityScore = dict["QualityScore"] as! String
            }
        }
    }
    public var code: String?

    public var data: RecognizeFaceQualityResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RecognizeFaceQualityResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecognizeFaceQualityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecognizeFaceQualityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecognizeFaceQualityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecognizeImageRequest : Tea.TeaModel {
    public var corpId: String?

    public var picContent: String?

    public var picFormat: String?

    public var picUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.picContent != nil {
            map["PicContent"] = self.picContent!
        }
        if self.picFormat != nil {
            map["PicFormat"] = self.picFormat!
        }
        if self.picUrl != nil {
            map["PicUrl"] = self.picUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("PicContent") {
            self.picContent = dict["PicContent"] as! String
        }
        if dict.keys.contains("PicFormat") {
            self.picFormat = dict["PicFormat"] as! String
        }
        if dict.keys.contains("PicUrl") {
            self.picUrl = dict["PicUrl"] as! String
        }
    }
}

public class RecognizeImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BodyList : Tea.TeaModel {
            public var feature: String?

            public var fileName: String?

            public var imageBaseSixFour: String?

            public var leftTopX: String?

            public var leftTopY: String?

            public var localFeature: String?

            public var respiratorColor: String?

            public var rightBottomX: String?

            public var rightBottomY: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.feature != nil {
                    map["Feature"] = self.feature!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.imageBaseSixFour != nil {
                    map["ImageBaseSixFour"] = self.imageBaseSixFour!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.localFeature != nil {
                    map["LocalFeature"] = self.localFeature!
                }
                if self.respiratorColor != nil {
                    map["RespiratorColor"] = self.respiratorColor!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Feature") {
                    self.feature = dict["Feature"] as! String
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("ImageBaseSixFour") {
                    self.imageBaseSixFour = dict["ImageBaseSixFour"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! String
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! String
                }
                if dict.keys.contains("LocalFeature") {
                    self.localFeature = dict["LocalFeature"] as! String
                }
                if dict.keys.contains("RespiratorColor") {
                    self.respiratorColor = dict["RespiratorColor"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! String
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! String
                }
            }
        }
        public class FaceList : Tea.TeaModel {
            public var feature: String?

            public var fileName: String?

            public var imageBaseSixFour: String?

            public var keyPointQuality: Double?

            public var leftTopX: String?

            public var leftTopY: String?

            public var localFeature: String?

            public var quality: Double?

            public var respiratorColor: String?

            public var rightBottomX: String?

            public var rightBottomY: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.feature != nil {
                    map["Feature"] = self.feature!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.imageBaseSixFour != nil {
                    map["ImageBaseSixFour"] = self.imageBaseSixFour!
                }
                if self.keyPointQuality != nil {
                    map["KeyPointQuality"] = self.keyPointQuality!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.localFeature != nil {
                    map["LocalFeature"] = self.localFeature!
                }
                if self.quality != nil {
                    map["Quality"] = self.quality!
                }
                if self.respiratorColor != nil {
                    map["RespiratorColor"] = self.respiratorColor!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Feature") {
                    self.feature = dict["Feature"] as! String
                }
                if dict.keys.contains("FileName") {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("ImageBaseSixFour") {
                    self.imageBaseSixFour = dict["ImageBaseSixFour"] as! String
                }
                if dict.keys.contains("KeyPointQuality") {
                    self.keyPointQuality = dict["KeyPointQuality"] as! Double
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! String
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! String
                }
                if dict.keys.contains("LocalFeature") {
                    self.localFeature = dict["LocalFeature"] as! String
                }
                if dict.keys.contains("Quality") {
                    self.quality = dict["Quality"] as! Double
                }
                if dict.keys.contains("RespiratorColor") {
                    self.respiratorColor = dict["RespiratorColor"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! String
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! String
                }
            }
        }
        public var bodyList: [RecognizeImageResponseBody.Data.BodyList]?

        public var faceList: [RecognizeImageResponseBody.Data.FaceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyList != nil {
                var tmp : [Any] = []
                for k in self.bodyList! {
                    tmp.append(k.toMap())
                }
                map["BodyList"] = tmp
            }
            if self.faceList != nil {
                var tmp : [Any] = []
                for k in self.faceList! {
                    tmp.append(k.toMap())
                }
                map["FaceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyList") {
                self.bodyList = dict["BodyList"] as! [RecognizeImageResponseBody.Data.BodyList]
            }
            if dict.keys.contains("FaceList") {
                self.faceList = dict["FaceList"] as! [RecognizeImageResponseBody.Data.FaceList]
            }
        }
    }
    public var code: String?

    public var data: RecognizeImageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RecognizeImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecognizeImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecognizeImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecognizeImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterDeviceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var deviceSn: String?

    public var deviceTimeStamp: String?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceSn != nil {
            map["DeviceSn"] = self.deviceSn!
        }
        if self.deviceTimeStamp != nil {
            map["DeviceTimeStamp"] = self.deviceTimeStamp!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceSn") {
            self.deviceSn = dict["DeviceSn"] as! String
        }
        if dict.keys.contains("DeviceTimeStamp") {
            self.deviceTimeStamp = dict["DeviceTimeStamp"] as! String
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RegisterDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var retryInterval: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetryInterval") {
            self.retryInterval = dict["RetryInterval"] as! String
        }
    }
}

public class RegisterDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveCameraForInstanceRequest : Tea.TeaModel {
    public var cameraIds: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cameraIds != nil {
            map["CameraIds"] = self.cameraIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CameraIds") {
            self.cameraIds = dict["CameraIds"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RemoveCameraForInstanceShrinkRequest : Tea.TeaModel {
    public var cameraIdsShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cameraIdsShrink != nil {
            map["CameraIds"] = self.cameraIdsShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CameraIds") {
            self.cameraIdsShrink = dict["CameraIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RemoveCameraForInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveCameraForInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveCameraForInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveCameraForInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSearchItemsRequest : Tea.TeaModel {
    public var searchItemIds: String?

    public var searchTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchItemIds != nil {
            map["SearchItemIds"] = self.searchItemIds!
        }
        if self.searchTableId != nil {
            map["SearchTableId"] = self.searchTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchItemIds") {
            self.searchItemIds = dict["SearchItemIds"] as! String
        }
        if dict.keys.contains("SearchTableId") {
            self.searchTableId = dict["SearchTableId"] as! String
        }
    }
}

public class RemoveSearchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var deletedItemIds: String?

        public var failedItemIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletedItemIds != nil {
                map["DeletedItemIds"] = self.deletedItemIds!
            }
            if self.failedItemIds != nil {
                map["FailedItemIds"] = self.failedItemIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeletedItemIds") {
                self.deletedItemIds = dict["DeletedItemIds"] as! String
            }
            if dict.keys.contains("FailedItemIds") {
                self.failedItemIds = dict["FailedItemIds"] as! String
            }
        }
    }
    public var code: String?

    public var data: RemoveSearchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RemoveSearchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class RemoveSearchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSearchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSearchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveWatchItemsRequest : Tea.TeaModel {
    public var watchItemIds: String?

    public var watchPolicyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.watchItemIds != nil {
            map["WatchItemIds"] = self.watchItemIds!
        }
        if self.watchPolicyId != nil {
            map["WatchPolicyId"] = self.watchPolicyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WatchItemIds") {
            self.watchItemIds = dict["WatchItemIds"] as! String
        }
        if dict.keys.contains("WatchPolicyId") {
            self.watchPolicyId = dict["WatchPolicyId"] as! String
        }
    }
}

public class RemoveWatchItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var deletedItemIds: String?

        public var failedItemIds: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletedItemIds != nil {
                map["DeletedItemIds"] = self.deletedItemIds!
            }
            if self.failedItemIds != nil {
                map["FailedItemIds"] = self.failedItemIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeletedItemIds") {
                self.deletedItemIds = dict["DeletedItemIds"] as! String
            }
            if dict.keys.contains("FailedItemIds") {
                self.failedItemIds = dict["FailedItemIds"] as! String
            }
        }
    }
    public var code: String?

    public var data: RemoveWatchItemsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RemoveWatchItemsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveWatchItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveWatchItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveWatchItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveVideoSummaryTaskVideoRequest : Tea.TeaModel {
    public var corpId: String?

    public var saveVideo: Bool?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.saveVideo != nil {
            map["SaveVideo"] = self.saveVideo!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("SaveVideo") {
            self.saveVideo = dict["SaveVideo"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class SaveVideoSummaryTaskVideoResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SaveVideoSummaryTaskVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveVideoSummaryTaskVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveVideoSummaryTaskVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ScanSubDeviceRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
    }
}

public class ScanSubDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ScanSubDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ScanSubDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ScanSubDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchBodyRequest : Tea.TeaModel {
    public var corpId: String?

    public var endTimeStamp: Int64?

    public var gbId: String?

    public var optionList: [String: Any]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.optionList != nil {
            map["OptionList"] = self.optionList!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTimeStamp") {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OptionList") {
            self.optionList = dict["OptionList"] as! [String: Any]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeStamp") {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class SearchBodyShrinkRequest : Tea.TeaModel {
    public var corpId: String?

    public var endTimeStamp: Int64?

    public var gbId: String?

    public var optionListShrink: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.optionListShrink != nil {
            map["OptionList"] = self.optionListShrink!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTimeStamp") {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OptionList") {
            self.optionListShrink = dict["OptionList"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeStamp") {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class SearchBodyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var gbId: String?

            public var imageUrl: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var score: Double?

            public var targetImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gbId != nil {
                    map["GbId"] = self.gbId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.targetImageUrl != nil {
                    map["TargetImageUrl"] = self.targetImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GbId") {
                    self.gbId = dict["GbId"] as! String
                }
                if dict.keys.contains("ImageUrl") {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("TargetImageUrl") {
                    self.targetImageUrl = dict["TargetImageUrl"] as! String
                }
            }
        }
        public var pageNo: Int32?

        public var pageSize: Int32?

        public var records: [SearchBodyResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [SearchBodyResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: SearchBodyResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchBodyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchBodyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchBodyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchBodyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchFaceRequest : Tea.TeaModel {
    public var corpId: String?

    public var endTimeStamp: Int64?

    public var gbId: String?

    public var optionList: [String: Any]?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.optionList != nil {
            map["OptionList"] = self.optionList!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTimeStamp") {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OptionList") {
            self.optionList = dict["OptionList"] as! [String: Any]
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeStamp") {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class SearchFaceShrinkRequest : Tea.TeaModel {
    public var corpId: String?

    public var endTimeStamp: Int64?

    public var gbId: String?

    public var optionListShrink: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.optionListShrink != nil {
            map["OptionList"] = self.optionListShrink!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("EndTimeStamp") {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("OptionList") {
            self.optionListShrink = dict["OptionList"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTimeStamp") {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class SearchFaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var gbId: String?

            public var imageUrl: String?

            public var leftTopX: Double?

            public var leftTopY: Double?

            public var matchSuggestion: String?

            public var rightBottomX: Double?

            public var rightBottomY: Double?

            public var score: Double?

            public var sourceId: String?

            public var targetImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gbId != nil {
                    map["GbId"] = self.gbId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.matchSuggestion != nil {
                    map["MatchSuggestion"] = self.matchSuggestion!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.targetImageUrl != nil {
                    map["TargetImageUrl"] = self.targetImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GbId") {
                    self.gbId = dict["GbId"] as! String
                }
                if dict.keys.contains("ImageUrl") {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Double
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Double
                }
                if dict.keys.contains("MatchSuggestion") {
                    self.matchSuggestion = dict["MatchSuggestion"] as! String
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Double
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Double
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("TargetImageUrl") {
                    self.targetImageUrl = dict["TargetImageUrl"] as! String
                }
            }
        }
        public var pageNo: Int32?

        public var pageSize: Int32?

        public var records: [SearchFaceResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [SearchFaceResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: SearchFaceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchFaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchItemRequest : Tea.TeaModel {
    public var itemImageData: String?

    public var itemImageUrl: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var searchTableIds: String?

    public var similarityThreshold: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemImageData != nil {
            map["ItemImageData"] = self.itemImageData!
        }
        if self.itemImageUrl != nil {
            map["ItemImageUrl"] = self.itemImageUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchTableIds != nil {
            map["SearchTableIds"] = self.searchTableIds!
        }
        if self.similarityThreshold != nil {
            map["SimilarityThreshold"] = self.similarityThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemImageData") {
            self.itemImageData = dict["ItemImageData"] as! String
        }
        if dict.keys.contains("ItemImageUrl") {
            self.itemImageUrl = dict["ItemImageUrl"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SearchTableIds") {
            self.searchTableIds = dict["SearchTableIds"] as! String
        }
        if dict.keys.contains("SimilarityThreshold") {
            self.similarityThreshold = dict["SimilarityThreshold"] as! Double
        }
    }
}

public class SearchItemResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var itemId: String?

            public var itemImageSimilarity: Double?

            public var itemImageUrl: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemImageSimilarity != nil {
                    map["ItemImageSimilarity"] = self.itemImageSimilarity!
                }
                if self.itemImageUrl != nil {
                    map["ItemImageUrl"] = self.itemImageUrl!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("ItemImageSimilarity") {
                    self.itemImageSimilarity = dict["ItemImageSimilarity"] as! Double
                }
                if dict.keys.contains("ItemImageUrl") {
                    self.itemImageUrl = dict["ItemImageUrl"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [SearchItemResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [SearchItemResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: SearchItemResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchItemResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SearchItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchObjectRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var conditions: [String: Any]?

    public var corpId: String?

    public var deviceList: [String: Any]?

    public var endTime: Int64?

    public var imagePath: [String: Any]?

    public var objectType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var picUrl: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.conditions != nil {
            map["Conditions"] = self.conditions!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceList != nil {
            map["DeviceList"] = self.deviceList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.imagePath != nil {
            map["ImagePath"] = self.imagePath!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.picUrl != nil {
            map["PicUrl"] = self.picUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("Conditions") {
            self.conditions = dict["Conditions"] as! [String: Any]
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceList = dict["DeviceList"] as! [String: Any]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ImagePath") {
            self.imagePath = dict["ImagePath"] as! [String: Any]
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PicUrl") {
            self.picUrl = dict["PicUrl"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchObjectShrinkRequest : Tea.TeaModel {
    public var algorithmType: String?

    public var conditionsShrink: String?

    public var corpId: String?

    public var deviceListShrink: String?

    public var endTime: Int64?

    public var imagePathShrink: String?

    public var objectType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var picUrl: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmType != nil {
            map["AlgorithmType"] = self.algorithmType!
        }
        if self.conditionsShrink != nil {
            map["Conditions"] = self.conditionsShrink!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceListShrink != nil {
            map["DeviceList"] = self.deviceListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.imagePathShrink != nil {
            map["ImagePath"] = self.imagePathShrink!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.picUrl != nil {
            map["PicUrl"] = self.picUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmType") {
            self.algorithmType = dict["AlgorithmType"] as! String
        }
        if dict.keys.contains("Conditions") {
            self.conditionsShrink = dict["Conditions"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceListShrink = dict["DeviceList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ImagePath") {
            self.imagePathShrink = dict["ImagePath"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PicUrl") {
            self.picUrl = dict["PicUrl"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class SearchObjectResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var compareResult: String?

            public var deviceID: String?

            public var leftTopX: Int32?

            public var leftTopY: Int32?

            public var rightBtmX: Int32?

            public var rightBtmY: Int32?

            public var score: Double?

            public var shotTime: Int64?

            public var sourceID: String?

            public var sourceImagePath: String?

            public var sourceImageUrl: String?

            public var targetImagePath: String?

            public var targetImageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compareResult != nil {
                    map["CompareResult"] = self.compareResult!
                }
                if self.deviceID != nil {
                    map["DeviceID"] = self.deviceID!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.rightBtmX != nil {
                    map["RightBtmX"] = self.rightBtmX!
                }
                if self.rightBtmY != nil {
                    map["RightBtmY"] = self.rightBtmY!
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.sourceID != nil {
                    map["SourceID"] = self.sourceID!
                }
                if self.sourceImagePath != nil {
                    map["SourceImagePath"] = self.sourceImagePath!
                }
                if self.sourceImageUrl != nil {
                    map["SourceImageUrl"] = self.sourceImageUrl!
                }
                if self.targetImagePath != nil {
                    map["TargetImagePath"] = self.targetImagePath!
                }
                if self.targetImageUrl != nil {
                    map["TargetImageUrl"] = self.targetImageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompareResult") {
                    self.compareResult = dict["CompareResult"] as! String
                }
                if dict.keys.contains("DeviceID") {
                    self.deviceID = dict["DeviceID"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Int32
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Int32
                }
                if dict.keys.contains("RightBtmX") {
                    self.rightBtmX = dict["RightBtmX"] as! Int32
                }
                if dict.keys.contains("RightBtmY") {
                    self.rightBtmY = dict["RightBtmY"] as! Int32
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Double
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! Int64
                }
                if dict.keys.contains("SourceID") {
                    self.sourceID = dict["SourceID"] as! String
                }
                if dict.keys.contains("SourceImagePath") {
                    self.sourceImagePath = dict["SourceImagePath"] as! String
                }
                if dict.keys.contains("SourceImageUrl") {
                    self.sourceImageUrl = dict["SourceImageUrl"] as! String
                }
                if dict.keys.contains("TargetImagePath") {
                    self.targetImagePath = dict["TargetImagePath"] as! String
                }
                if dict.keys.contains("TargetImageUrl") {
                    self.targetImageUrl = dict["TargetImageUrl"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var records: [SearchObjectResponseBody.Data.Records]?

        public var totalCount: Int32?

        public var totalPage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.totalPage != nil {
                map["TotalPage"] = self.totalPage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [SearchObjectResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("TotalPage") {
                self.totalPage = dict["TotalPage"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: SearchObjectResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchObjectResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SearchObjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchObjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchObjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTargetRequest : Tea.TeaModel {
    public var beginTime: String?

    public var corpId: String?

    public var deviceList: String?

    public var endTime: String?

    public var modelId: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var similarityThreshold: Double?

    public var targetAttributes: String?

    public var targetImageData: String?

    public var targetImageUrl: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceList != nil {
            map["DeviceList"] = self.deviceList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.similarityThreshold != nil {
            map["SimilarityThreshold"] = self.similarityThreshold!
        }
        if self.targetAttributes != nil {
            map["TargetAttributes"] = self.targetAttributes!
        }
        if self.targetImageData != nil {
            map["TargetImageData"] = self.targetImageData!
        }
        if self.targetImageUrl != nil {
            map["TargetImageUrl"] = self.targetImageUrl!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceList = dict["DeviceList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SimilarityThreshold") {
            self.similarityThreshold = dict["SimilarityThreshold"] as! Double
        }
        if dict.keys.contains("TargetAttributes") {
            self.targetAttributes = dict["TargetAttributes"] as! String
        }
        if dict.keys.contains("TargetImageData") {
            self.targetImageData = dict["TargetImageData"] as! String
        }
        if dict.keys.contains("TargetImageUrl") {
            self.targetImageUrl = dict["TargetImageUrl"] as! String
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class SearchTargetResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var dataDetail: String?

            public var deviceId: String?

            public var leftTopX: Int64?

            public var leftTopY: Int64?

            public var rightBottomX: Int64?

            public var rightBottomY: Int64?

            public var sourceImageFullUrl: String?

            public var sourceImageUrl: String?

            public var targetAttributes: String?

            public var targetImageFullUrl: String?

            public var targetImageSimilarity: Double?

            public var targetImageUrl: String?

            public var targetType: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDetail != nil {
                    map["DataDetail"] = self.dataDetail!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.leftTopX != nil {
                    map["LeftTopX"] = self.leftTopX!
                }
                if self.leftTopY != nil {
                    map["LeftTopY"] = self.leftTopY!
                }
                if self.rightBottomX != nil {
                    map["RightBottomX"] = self.rightBottomX!
                }
                if self.rightBottomY != nil {
                    map["RightBottomY"] = self.rightBottomY!
                }
                if self.sourceImageFullUrl != nil {
                    map["SourceImageFullUrl"] = self.sourceImageFullUrl!
                }
                if self.sourceImageUrl != nil {
                    map["SourceImageUrl"] = self.sourceImageUrl!
                }
                if self.targetAttributes != nil {
                    map["TargetAttributes"] = self.targetAttributes!
                }
                if self.targetImageFullUrl != nil {
                    map["TargetImageFullUrl"] = self.targetImageFullUrl!
                }
                if self.targetImageSimilarity != nil {
                    map["TargetImageSimilarity"] = self.targetImageSimilarity!
                }
                if self.targetImageUrl != nil {
                    map["TargetImageUrl"] = self.targetImageUrl!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDetail") {
                    self.dataDetail = dict["DataDetail"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("LeftTopX") {
                    self.leftTopX = dict["LeftTopX"] as! Int64
                }
                if dict.keys.contains("LeftTopY") {
                    self.leftTopY = dict["LeftTopY"] as! Int64
                }
                if dict.keys.contains("RightBottomX") {
                    self.rightBottomX = dict["RightBottomX"] as! Int64
                }
                if dict.keys.contains("RightBottomY") {
                    self.rightBottomY = dict["RightBottomY"] as! Int64
                }
                if dict.keys.contains("SourceImageFullUrl") {
                    self.sourceImageFullUrl = dict["SourceImageFullUrl"] as! String
                }
                if dict.keys.contains("SourceImageUrl") {
                    self.sourceImageUrl = dict["SourceImageUrl"] as! String
                }
                if dict.keys.contains("TargetAttributes") {
                    self.targetAttributes = dict["TargetAttributes"] as! String
                }
                if dict.keys.contains("TargetImageFullUrl") {
                    self.targetImageFullUrl = dict["TargetImageFullUrl"] as! String
                }
                if dict.keys.contains("TargetImageSimilarity") {
                    self.targetImageSimilarity = dict["TargetImageSimilarity"] as! Double
                }
                if dict.keys.contains("TargetImageUrl") {
                    self.targetImageUrl = dict["TargetImageUrl"] as! String
                }
                if dict.keys.contains("TargetType") {
                    self.targetType = dict["TargetType"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var records: [SearchTargetResponseBody.Data.Records]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [SearchTargetResponseBody.Data.Records]
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: SearchTargetResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SearchTargetResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SearchTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAiotStorageInfoRequest : Tea.TeaModel {
    public class EventAlarmMq : Tea.TeaModel {
        public var alarmTopic: String?

        public var eventTopic: String?

        public var instanceId: String?

        public var mqType: String?

        public var ramArnRole: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmTopic != nil {
                map["AlarmTopic"] = self.alarmTopic!
            }
            if self.eventTopic != nil {
                map["EventTopic"] = self.eventTopic!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mqType != nil {
                map["MqType"] = self.mqType!
            }
            if self.ramArnRole != nil {
                map["RamArnRole"] = self.ramArnRole!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmTopic") {
                self.alarmTopic = dict["AlarmTopic"] as! String
            }
            if dict.keys.contains("EventTopic") {
                self.eventTopic = dict["EventTopic"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MqType") {
                self.mqType = dict["MqType"] as! String
            }
            if dict.keys.contains("RamArnRole") {
                self.ramArnRole = dict["RamArnRole"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public class EventAlarmPictureStorage : Tea.TeaModel {
        public var bucket: String?

        public var endpoint: String?

        public var path: String?

        public var proxy: String?

        public var ramArnRole: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.proxy != nil {
                map["Proxy"] = self.proxy!
            }
            if self.ramArnRole != nil {
                map["RamArnRole"] = self.ramArnRole!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Proxy") {
                self.proxy = dict["Proxy"] as! String
            }
            if dict.keys.contains("RamArnRole") {
                self.ramArnRole = dict["RamArnRole"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var eventAlarmMq: SetAiotStorageInfoRequest.EventAlarmMq?

    public var eventAlarmPictureStorage: SetAiotStorageInfoRequest.EventAlarmPictureStorage?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventAlarmMq?.validate()
        try self.eventAlarmPictureStorage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventAlarmMq != nil {
            map["EventAlarmMq"] = self.eventAlarmMq?.toMap()
        }
        if self.eventAlarmPictureStorage != nil {
            map["EventAlarmPictureStorage"] = self.eventAlarmPictureStorage?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventAlarmMq") {
            var model = SetAiotStorageInfoRequest.EventAlarmMq()
            model.fromMap(dict["EventAlarmMq"] as! [String: Any])
            self.eventAlarmMq = model
        }
        if dict.keys.contains("EventAlarmPictureStorage") {
            var model = SetAiotStorageInfoRequest.EventAlarmPictureStorage()
            model.fromMap(dict["EventAlarmPictureStorage"] as! [String: Any])
            self.eventAlarmPictureStorage = model
        }
    }
}

public class SetAiotStorageInfoShrinkRequest : Tea.TeaModel {
    public var eventAlarmMqShrink: String?

    public var eventAlarmPictureStorageShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventAlarmMqShrink != nil {
            map["EventAlarmMq"] = self.eventAlarmMqShrink!
        }
        if self.eventAlarmPictureStorageShrink != nil {
            map["EventAlarmPictureStorage"] = self.eventAlarmPictureStorageShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventAlarmMq") {
            self.eventAlarmMqShrink = dict["EventAlarmMq"] as! String
        }
        if dict.keys.contains("EventAlarmPictureStorage") {
            self.eventAlarmPictureStorageShrink = dict["EventAlarmPictureStorage"] as! String
        }
    }
}

public class SetAiotStorageInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAiotStorageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAiotStorageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetAiotStorageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetStreamModeRequest : Tea.TeaModel {
    public var deviceIdList: String?

    public var streamMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        if self.streamMode != nil {
            map["StreamMode"] = self.streamMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
        if dict.keys.contains("StreamMode") {
            self.streamMode = dict["StreamMode"] as! String
        }
    }
}

public class SetStreamModeResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetStreamModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetStreamModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetStreamModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartModelServiceRequest : Tea.TeaModel {
    public var modelServiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelServiceId != nil {
            map["ModelServiceId"] = self.modelServiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelServiceId") {
            self.modelServiceId = dict["ModelServiceId"] as! String
        }
    }
}

public class StartModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var modelServiceInstanceId: String?

        public var modelServiceInstanceName: Int32?

        public var modelServiceStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceInstanceName != nil {
                map["ModelServiceInstanceName"] = self.modelServiceInstanceName!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceName") {
                self.modelServiceInstanceName = dict["ModelServiceInstanceName"] as! Int32
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: StartModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartStreamsRequest : Tea.TeaModel {
    public var description_: String?

    public var deviceIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
    }
}

public class StartStreamsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartStreamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartStreamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartStreamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopModelServiceRequest : Tea.TeaModel {
    public var modelServiceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelServiceId != nil {
            map["ModelServiceId"] = self.modelServiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelServiceId") {
            self.modelServiceId = dict["ModelServiceId"] as! String
        }
    }
}

public class StopModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var modelServiceInstanceId: String?

        public var modelServiceInstanceName: Int32?

        public var modelServiceStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceInstanceName != nil {
                map["ModelServiceInstanceName"] = self.modelServiceInstanceName!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceName") {
                self.modelServiceInstanceName = dict["ModelServiceInstanceName"] as! Int32
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: StopModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StopModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopMonitorRequest : Tea.TeaModel {
    public var algorithmVendor: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmVendor != nil {
            map["AlgorithmVendor"] = self.algorithmVendor!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmVendor") {
            self.algorithmVendor = dict["AlgorithmVendor"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class StopMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopStreamsRequest : Tea.TeaModel {
    public var description_: String?

    public var deviceIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceIdList != nil {
            map["DeviceIdList"] = self.deviceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceIdList") {
            self.deviceIdList = dict["DeviceIdList"] as! String
        }
    }
}

public class StopStreamsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopStreamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopStreamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopStreamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncDeviceTimeRequest : Tea.TeaModel {
    public var deviceSn: String?

    public var deviceTimeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceSn != nil {
            map["DeviceSn"] = self.deviceSn!
        }
        if self.deviceTimeStamp != nil {
            map["DeviceTimeStamp"] = self.deviceTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceSn") {
            self.deviceSn = dict["DeviceSn"] as! String
        }
        if dict.keys.contains("DeviceTimeStamp") {
            self.deviceTimeStamp = dict["DeviceTimeStamp"] as! String
        }
    }
}

public class SyncDeviceTimeResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var NTPServer: String?

    public var requestId: String?

    public var retryInterval: String?

    public var syncInterval: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.NTPServer != nil {
            map["NTPServer"] = self.NTPServer!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.syncInterval != nil {
            map["SyncInterval"] = self.syncInterval!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NTPServer") {
            self.NTPServer = dict["NTPServer"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetryInterval") {
            self.retryInterval = dict["RetryInterval"] as! String
        }
        if dict.keys.contains("SyncInterval") {
            self.syncInterval = dict["SyncInterval"] as! String
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class SyncDeviceTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncDeviceTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncDeviceTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TryCreateAIInstanceRequest : Tea.TeaModel {
    public class DataSourceTimes : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class ScheduleTimes : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var algorithmId: String?

    public var cameraNumber: Int64?

    public var computeType: String?

    public var dataSource: String?

    public var dataSourceTimes: [TryCreateAIInstanceRequest.DataSourceTimes]?

    public var dataType: String?

    public var fps: Int64?

    public var instanceType: String?

    public var scheduleCycleDates: [Int64]?

    public var scheduleTimes: [TryCreateAIInstanceRequest.ScheduleTimes]?

    public var scheduleType: String?

    public var spf: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.cameraNumber != nil {
            map["CameraNumber"] = self.cameraNumber!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.dataSourceTimes != nil {
            var tmp : [Any] = []
            for k in self.dataSourceTimes! {
                tmp.append(k.toMap())
            }
            map["DataSourceTimes"] = tmp
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.fps != nil {
            map["Fps"] = self.fps!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.scheduleCycleDates != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDates!
        }
        if self.scheduleTimes != nil {
            var tmp : [Any] = []
            for k in self.scheduleTimes! {
                tmp.append(k.toMap())
            }
            map["ScheduleTimes"] = tmp
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.spf != nil {
            map["Spf"] = self.spf!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("CameraNumber") {
            self.cameraNumber = dict["CameraNumber"] as! Int64
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("DataSourceTimes") {
            self.dataSourceTimes = dict["DataSourceTimes"] as! [TryCreateAIInstanceRequest.DataSourceTimes]
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Fps") {
            self.fps = dict["Fps"] as! Int64
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDates = dict["ScheduleCycleDates"] as! [Int64]
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! [TryCreateAIInstanceRequest.ScheduleTimes]
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("Spf") {
            self.spf = dict["Spf"] as! Int64
        }
    }
}

public class TryCreateAIInstanceShrinkRequest : Tea.TeaModel {
    public var algorithmId: String?

    public var cameraNumber: Int64?

    public var computeType: String?

    public var dataSource: String?

    public var dataSourceTimesShrink: String?

    public var dataType: String?

    public var fps: Int64?

    public var instanceType: String?

    public var scheduleCycleDatesShrink: String?

    public var scheduleTimesShrink: String?

    public var scheduleType: String?

    public var spf: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmId != nil {
            map["AlgorithmId"] = self.algorithmId!
        }
        if self.cameraNumber != nil {
            map["CameraNumber"] = self.cameraNumber!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.dataSourceTimesShrink != nil {
            map["DataSourceTimes"] = self.dataSourceTimesShrink!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.fps != nil {
            map["Fps"] = self.fps!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.scheduleCycleDatesShrink != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDatesShrink!
        }
        if self.scheduleTimesShrink != nil {
            map["ScheduleTimes"] = self.scheduleTimesShrink!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.spf != nil {
            map["Spf"] = self.spf!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmId") {
            self.algorithmId = dict["AlgorithmId"] as! String
        }
        if dict.keys.contains("CameraNumber") {
            self.cameraNumber = dict["CameraNumber"] as! Int64
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("DataSource") {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("DataSourceTimes") {
            self.dataSourceTimesShrink = dict["DataSourceTimes"] as! String
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Fps") {
            self.fps = dict["Fps"] as! Int64
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDatesShrink = dict["ScheduleCycleDates"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimesShrink = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("Spf") {
            self.spf = dict["Spf"] as! Int64
        }
    }
}

public class TryCreateAIInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var acuUsed: Int64?

        public var storage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuUsed != nil {
                map["AcuUsed"] = self.acuUsed!
            }
            if self.storage != nil {
                map["Storage"] = self.storage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcuUsed") {
                self.acuUsed = dict["AcuUsed"] as! Int64
            }
            if dict.keys.contains("Storage") {
                self.storage = dict["Storage"] as! String
            }
        }
    }
    public var code: String?

    public var data: TryCreateAIInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = TryCreateAIInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TryCreateAIInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TryCreateAIInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TryCreateAIInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindCorpGroupRequest : Tea.TeaModel {
    public var corpGroupId: String?

    public var corpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpGroupId != nil {
            map["CorpGroupId"] = self.corpGroupId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpGroupId") {
            self.corpGroupId = dict["CorpGroupId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
    }
}

public class UnbindCorpGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UnbindCorpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindCorpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindCorpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindDevicesRequest : Tea.TeaModel {
    public var corpId: String?

    public var deviceId: String?

    public var subDeviceIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.subDeviceIdList != nil {
            map["SubDeviceIdList"] = self.subDeviceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("SubDeviceIdList") {
            self.subDeviceIdList = dict["SubDeviceIdList"] as! String
        }
    }
}

public class UnbindDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubDeviceList : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public var subDeviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.subDeviceId != nil {
                    map["SubDeviceId"] = self.subDeviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("SubDeviceId") {
                    self.subDeviceId = dict["SubDeviceId"] as! String
                }
            }
        }
        public var subDeviceList: [UnbindDevicesResponseBody.Data.SubDeviceList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subDeviceList != nil {
                var tmp : [Any] = []
                for k in self.subDeviceList! {
                    tmp.append(k.toMap())
                }
                map["SubDeviceList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SubDeviceList") {
                self.subDeviceList = dict["SubDeviceList"] as! [UnbindDevicesResponseBody.Data.SubDeviceList]
            }
        }
    }
    public var code: String?

    public var data: UnbindDevicesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UnbindDevicesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindPersonRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var profileId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.profileId != nil {
            map["ProfileId"] = self.profileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ProfileId") {
            self.profileId = dict["ProfileId"] as! Int64
        }
    }
}

public class UnbindPersonResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindPersonResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindPersonResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindPersonResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindUserRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class UnbindUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAiotDeviceRequest : Tea.TeaModel {
    public class AiotDevice : Tea.TeaModel {
        public var IPAddr: String?

        public var latitude: Double?

        public var longitude: Double?

        public var name: String?

        public var place: String?

        public var port: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IPAddr != nil {
                map["IPAddr"] = self.IPAddr!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.place != nil {
                map["Place"] = self.place!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IPAddr") {
                self.IPAddr = dict["IPAddr"] as! String
            }
            if dict.keys.contains("Latitude") {
                self.latitude = dict["Latitude"] as! Double
            }
            if dict.keys.contains("Longitude") {
                self.longitude = dict["Longitude"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Place") {
                self.place = dict["Place"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int64
            }
        }
    }
    public var aiotDevice: UpdateAiotDeviceRequest.AiotDevice?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aiotDevice?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDevice != nil {
            map["AiotDevice"] = self.aiotDevice?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDevice") {
            var model = UpdateAiotDeviceRequest.AiotDevice()
            model.fromMap(dict["AiotDevice"] as! [String: Any])
            self.aiotDevice = model
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class UpdateAiotDeviceShrinkRequest : Tea.TeaModel {
    public var aiotDeviceShrink: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDeviceShrink != nil {
            map["AiotDevice"] = self.aiotDeviceShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDevice") {
            self.aiotDeviceShrink = dict["AiotDevice"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class UpdateAiotDeviceResponseBody : Tea.TeaModel {
    public class AiotDevice : Tea.TeaModel {
        public var capDirection: String?

        public var corpId: String?

        public var deviceId: String?

        public var deviceType: String?

        public var firmwareVersion: String?

        public var IPAddr: String?

        public var IPV6Addr: String?

        public var IPv4Gateway: String?

        public var IPv4Netmask: String?

        public var isOnline: String?

        public var latitude: Double?

        public var longitude: Double?

        public var MAC: String?

        public var manufacturer: String?

        public var model: String?

        public var monitorAreaDesc: String?

        public var monitorDirection: String?

        public var name: String?

        public var orgCode: String?

        public var ownerApsID: String?

        public var password: String?

        public var place: String?

        public var placeCode: String?

        public var port: Int64?

        public var serialNumber: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capDirection != nil {
                map["CapDirection"] = self.capDirection!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.firmwareVersion != nil {
                map["FirmwareVersion"] = self.firmwareVersion!
            }
            if self.IPAddr != nil {
                map["IPAddr"] = self.IPAddr!
            }
            if self.IPV6Addr != nil {
                map["IPV6Addr"] = self.IPV6Addr!
            }
            if self.IPv4Gateway != nil {
                map["IPv4Gateway"] = self.IPv4Gateway!
            }
            if self.IPv4Netmask != nil {
                map["IPv4Netmask"] = self.IPv4Netmask!
            }
            if self.isOnline != nil {
                map["IsOnline"] = self.isOnline!
            }
            if self.latitude != nil {
                map["Latitude"] = self.latitude!
            }
            if self.longitude != nil {
                map["Longitude"] = self.longitude!
            }
            if self.MAC != nil {
                map["MAC"] = self.MAC!
            }
            if self.manufacturer != nil {
                map["Manufacturer"] = self.manufacturer!
            }
            if self.model != nil {
                map["Model"] = self.model!
            }
            if self.monitorAreaDesc != nil {
                map["MonitorAreaDesc"] = self.monitorAreaDesc!
            }
            if self.monitorDirection != nil {
                map["MonitorDirection"] = self.monitorDirection!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orgCode != nil {
                map["OrgCode"] = self.orgCode!
            }
            if self.ownerApsID != nil {
                map["OwnerApsID"] = self.ownerApsID!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.place != nil {
                map["Place"] = self.place!
            }
            if self.placeCode != nil {
                map["PlaceCode"] = self.placeCode!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CapDirection") {
                self.capDirection = dict["CapDirection"] as! String
            }
            if dict.keys.contains("CorpId") {
                self.corpId = dict["CorpId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("FirmwareVersion") {
                self.firmwareVersion = dict["FirmwareVersion"] as! String
            }
            if dict.keys.contains("IPAddr") {
                self.IPAddr = dict["IPAddr"] as! String
            }
            if dict.keys.contains("IPV6Addr") {
                self.IPV6Addr = dict["IPV6Addr"] as! String
            }
            if dict.keys.contains("IPv4Gateway") {
                self.IPv4Gateway = dict["IPv4Gateway"] as! String
            }
            if dict.keys.contains("IPv4Netmask") {
                self.IPv4Netmask = dict["IPv4Netmask"] as! String
            }
            if dict.keys.contains("IsOnline") {
                self.isOnline = dict["IsOnline"] as! String
            }
            if dict.keys.contains("Latitude") {
                self.latitude = dict["Latitude"] as! Double
            }
            if dict.keys.contains("Longitude") {
                self.longitude = dict["Longitude"] as! Double
            }
            if dict.keys.contains("MAC") {
                self.MAC = dict["MAC"] as! String
            }
            if dict.keys.contains("Manufacturer") {
                self.manufacturer = dict["Manufacturer"] as! String
            }
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! String
            }
            if dict.keys.contains("MonitorAreaDesc") {
                self.monitorAreaDesc = dict["MonitorAreaDesc"] as! String
            }
            if dict.keys.contains("MonitorDirection") {
                self.monitorDirection = dict["MonitorDirection"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrgCode") {
                self.orgCode = dict["OrgCode"] as! String
            }
            if dict.keys.contains("OwnerApsID") {
                self.ownerApsID = dict["OwnerApsID"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Place") {
                self.place = dict["Place"] as! String
            }
            if dict.keys.contains("PlaceCode") {
                self.placeCode = dict["PlaceCode"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int64
            }
            if dict.keys.contains("SerialNumber") {
                self.serialNumber = dict["SerialNumber"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var aiotDevice: UpdateAiotDeviceResponseBody.AiotDevice?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aiotDevice?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aiotDevice != nil {
            map["AiotDevice"] = self.aiotDevice?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AiotDevice") {
            var model = UpdateAiotDeviceResponseBody.AiotDevice()
            model.fromMap(dict["AiotDevice"] as! [String: Any])
            self.aiotDevice = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAiotDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAiotDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAiotDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAiotPersonTableRequest : Tea.TeaModel {
    public class PersonTable : Tea.TeaModel {
        public var name: String?

        public var personTableId: String?

        public var type: Int64?

        public var verificationModelList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.verificationModelList != nil {
                map["VerificationModelList"] = self.verificationModelList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
            if dict.keys.contains("VerificationModelList") {
                self.verificationModelList = dict["VerificationModelList"] as! [Int64]
            }
        }
    }
    public var id: String?

    public var personTable: UpdateAiotPersonTableRequest.PersonTable?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTable?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTable != nil {
            map["PersonTable"] = self.personTable?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTable") {
            var model = UpdateAiotPersonTableRequest.PersonTable()
            model.fromMap(dict["PersonTable"] as! [String: Any])
            self.personTable = model
        }
    }
}

public class UpdateAiotPersonTableResponseBody : Tea.TeaModel {
    public class PersonTable : Tea.TeaModel {
        public var deviceId: String?

        public var faceNum: Int64?

        public var lastChange: String?

        public var name: String?

        public var personNum: Int64?

        public var personTableId: String?

        public var totalPersonNum: Int64?

        public var type: Int64?

        public var verificationModelList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.faceNum != nil {
                map["FaceNum"] = self.faceNum!
            }
            if self.lastChange != nil {
                map["LastChange"] = self.lastChange!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.personNum != nil {
                map["PersonNum"] = self.personNum!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            if self.totalPersonNum != nil {
                map["TotalPersonNum"] = self.totalPersonNum!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.verificationModelList != nil {
                map["VerificationModelList"] = self.verificationModelList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("FaceNum") {
                self.faceNum = dict["FaceNum"] as! Int64
            }
            if dict.keys.contains("LastChange") {
                self.lastChange = dict["LastChange"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PersonNum") {
                self.personNum = dict["PersonNum"] as! Int64
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
            if dict.keys.contains("TotalPersonNum") {
                self.totalPersonNum = dict["TotalPersonNum"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int64
            }
            if dict.keys.contains("VerificationModelList") {
                self.verificationModelList = dict["VerificationModelList"] as! [Int64]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var personTable: UpdateAiotPersonTableResponseBody.PersonTable?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTable?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.personTable != nil {
            map["PersonTable"] = self.personTable?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PersonTable") {
            var model = UpdateAiotPersonTableResponseBody.PersonTable()
            model.fromMap(dict["PersonTable"] as! [String: Any])
            self.personTable = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAiotPersonTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAiotPersonTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAiotPersonTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAiotPersonTableItemRequest : Tea.TeaModel {
    public class PersonTableItem : Tea.TeaModel {
        public class IdentificationList : Tea.TeaModel {
            public var number: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public class ImageList : Tea.TeaModel {
            public class FeatureInfo : Tea.TeaModel {
                public var algorithmType: String?

                public var algorithmVersion: String?

                public var featureData: String?

                public var imageId: String?

                public var objectId: String?

                public var tabIeId: String?

                public var vendor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithmType != nil {
                        map["AlgorithmType"] = self.algorithmType!
                    }
                    if self.algorithmVersion != nil {
                        map["AlgorithmVersion"] = self.algorithmVersion!
                    }
                    if self.featureData != nil {
                        map["FeatureData"] = self.featureData!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.objectId != nil {
                        map["ObjectId"] = self.objectId!
                    }
                    if self.tabIeId != nil {
                        map["TabIeId"] = self.tabIeId!
                    }
                    if self.vendor != nil {
                        map["Vendor"] = self.vendor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlgorithmType") {
                        self.algorithmType = dict["AlgorithmType"] as! String
                    }
                    if dict.keys.contains("AlgorithmVersion") {
                        self.algorithmVersion = dict["AlgorithmVersion"] as! String
                    }
                    if dict.keys.contains("FeatureData") {
                        self.featureData = dict["FeatureData"] as! String
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ObjectId") {
                        self.objectId = dict["ObjectId"] as! String
                    }
                    if dict.keys.contains("TabIeId") {
                        self.tabIeId = dict["TabIeId"] as! String
                    }
                    if dict.keys.contains("Vendor") {
                        self.vendor = dict["Vendor"] as! String
                    }
                }
            }
            public var data: String?

            public var deviceId: String?

            public var eventSort: String?

            public var featureInfo: UpdateAiotPersonTableItemRequest.PersonTableItem.ImageList.FeatureInfo?

            public var fileFormat: String?

            public var height: Int64?

            public var imageId: String?

            public var shotTime: String?

            public var size: Int64?

            public var storagePath: String?

            public var type: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.featureInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.eventSort != nil {
                    map["EventSort"] = self.eventSort!
                }
                if self.featureInfo != nil {
                    map["FeatureInfo"] = self.featureInfo?.toMap()
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.storagePath != nil {
                    map["StoragePath"] = self.storagePath!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("EventSort") {
                    self.eventSort = dict["EventSort"] as! String
                }
                if dict.keys.contains("FeatureInfo") {
                    var model = UpdateAiotPersonTableItemRequest.PersonTableItem.ImageList.FeatureInfo()
                    model.fromMap(dict["FeatureInfo"] as! [String: Any])
                    self.featureInfo = model
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("StoragePath") {
                    self.storagePath = dict["StoragePath"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var identificationList: [UpdateAiotPersonTableItemRequest.PersonTableItem.IdentificationList]?

        public var identificationNum: Int64?

        public var imageList: [UpdateAiotPersonTableItemRequest.PersonTableItem.ImageList]?

        public var imageNum: Int64?

        public var personCode: String?

        public var personId: String?

        public var personName: String?

        public var remarks: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identificationList != nil {
                var tmp : [Any] = []
                for k in self.identificationList! {
                    tmp.append(k.toMap())
                }
                map["IdentificationList"] = tmp
            }
            if self.identificationNum != nil {
                map["IdentificationNum"] = self.identificationNum!
            }
            if self.imageList != nil {
                var tmp : [Any] = []
                for k in self.imageList! {
                    tmp.append(k.toMap())
                }
                map["ImageList"] = tmp
            }
            if self.imageNum != nil {
                map["ImageNum"] = self.imageNum!
            }
            if self.personCode != nil {
                map["PersonCode"] = self.personCode!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.personName != nil {
                map["PersonName"] = self.personName!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdentificationList") {
                self.identificationList = dict["IdentificationList"] as! [UpdateAiotPersonTableItemRequest.PersonTableItem.IdentificationList]
            }
            if dict.keys.contains("IdentificationNum") {
                self.identificationNum = dict["IdentificationNum"] as! Int64
            }
            if dict.keys.contains("ImageList") {
                self.imageList = dict["ImageList"] as! [UpdateAiotPersonTableItemRequest.PersonTableItem.ImageList]
            }
            if dict.keys.contains("ImageNum") {
                self.imageNum = dict["ImageNum"] as! Int64
            }
            if dict.keys.contains("PersonCode") {
                self.personCode = dict["PersonCode"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PersonName") {
                self.personName = dict["PersonName"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
        }
    }
    public var id: String?

    public var personTableId: String?

    public var personTableItem: UpdateAiotPersonTableItemRequest.PersonTableItem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTableItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.personTableId != nil {
            map["PersonTableId"] = self.personTableId!
        }
        if self.personTableItem != nil {
            map["PersonTableItem"] = self.personTableItem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PersonTableId") {
            self.personTableId = dict["PersonTableId"] as! String
        }
        if dict.keys.contains("PersonTableItem") {
            var model = UpdateAiotPersonTableItemRequest.PersonTableItem()
            model.fromMap(dict["PersonTableItem"] as! [String: Any])
            self.personTableItem = model
        }
    }
}

public class UpdateAiotPersonTableItemResponseBody : Tea.TeaModel {
    public class PersonTableItem : Tea.TeaModel {
        public class IdentificationList : Tea.TeaModel {
            public var number: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public class ImageList : Tea.TeaModel {
            public class FeatureInfo : Tea.TeaModel {
                public var algorithmType: String?

                public var algorithmVersion: String?

                public var featureData: String?

                public var imageId: String?

                public var objectId: String?

                public var tabIed: String?

                public var vendor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.algorithmType != nil {
                        map["AlgorithmType"] = self.algorithmType!
                    }
                    if self.algorithmVersion != nil {
                        map["AlgorithmVersion"] = self.algorithmVersion!
                    }
                    if self.featureData != nil {
                        map["FeatureData"] = self.featureData!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.objectId != nil {
                        map["ObjectId"] = self.objectId!
                    }
                    if self.tabIed != nil {
                        map["TabIed"] = self.tabIed!
                    }
                    if self.vendor != nil {
                        map["Vendor"] = self.vendor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlgorithmType") {
                        self.algorithmType = dict["AlgorithmType"] as! String
                    }
                    if dict.keys.contains("AlgorithmVersion") {
                        self.algorithmVersion = dict["AlgorithmVersion"] as! String
                    }
                    if dict.keys.contains("FeatureData") {
                        self.featureData = dict["FeatureData"] as! String
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ObjectId") {
                        self.objectId = dict["ObjectId"] as! String
                    }
                    if dict.keys.contains("TabIed") {
                        self.tabIed = dict["TabIed"] as! String
                    }
                    if dict.keys.contains("Vendor") {
                        self.vendor = dict["Vendor"] as! String
                    }
                }
            }
            public var data: String?

            public var deviceId: String?

            public var eventSort: String?

            public var featureInfo: UpdateAiotPersonTableItemResponseBody.PersonTableItem.ImageList.FeatureInfo?

            public var fileFormat: String?

            public var height: Int64?

            public var imageId: String?

            public var shotTime: String?

            public var size: Int64?

            public var storagePath: String?

            public var type: String?

            public var width: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.featureInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.eventSort != nil {
                    map["EventSort"] = self.eventSort!
                }
                if self.featureInfo != nil {
                    map["FeatureInfo"] = self.featureInfo?.toMap()
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.shotTime != nil {
                    map["ShotTime"] = self.shotTime!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.storagePath != nil {
                    map["StoragePath"] = self.storagePath!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("EventSort") {
                    self.eventSort = dict["EventSort"] as! String
                }
                if dict.keys.contains("FeatureInfo") {
                    var model = UpdateAiotPersonTableItemResponseBody.PersonTableItem.ImageList.FeatureInfo()
                    model.fromMap(dict["FeatureInfo"] as! [String: Any])
                    self.featureInfo = model
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ShotTime") {
                    self.shotTime = dict["ShotTime"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("StoragePath") {
                    self.storagePath = dict["StoragePath"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int64
                }
            }
        }
        public var identificationList: [UpdateAiotPersonTableItemResponseBody.PersonTableItem.IdentificationList]?

        public var identificationNum: Int64?

        public var imageList: [UpdateAiotPersonTableItemResponseBody.PersonTableItem.ImageList]?

        public var imageNum: Int64?

        public var lastChange: String?

        public var personCode: String?

        public var personId: String?

        public var personName: String?

        public var personTableId: String?

        public var remarks: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identificationList != nil {
                var tmp : [Any] = []
                for k in self.identificationList! {
                    tmp.append(k.toMap())
                }
                map["IdentificationList"] = tmp
            }
            if self.identificationNum != nil {
                map["IdentificationNum"] = self.identificationNum!
            }
            if self.imageList != nil {
                var tmp : [Any] = []
                for k in self.imageList! {
                    tmp.append(k.toMap())
                }
                map["ImageList"] = tmp
            }
            if self.imageNum != nil {
                map["ImageNum"] = self.imageNum!
            }
            if self.lastChange != nil {
                map["LastChange"] = self.lastChange!
            }
            if self.personCode != nil {
                map["PersonCode"] = self.personCode!
            }
            if self.personId != nil {
                map["PersonId"] = self.personId!
            }
            if self.personName != nil {
                map["PersonName"] = self.personName!
            }
            if self.personTableId != nil {
                map["PersonTableId"] = self.personTableId!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdentificationList") {
                self.identificationList = dict["IdentificationList"] as! [UpdateAiotPersonTableItemResponseBody.PersonTableItem.IdentificationList]
            }
            if dict.keys.contains("IdentificationNum") {
                self.identificationNum = dict["IdentificationNum"] as! Int64
            }
            if dict.keys.contains("ImageList") {
                self.imageList = dict["ImageList"] as! [UpdateAiotPersonTableItemResponseBody.PersonTableItem.ImageList]
            }
            if dict.keys.contains("ImageNum") {
                self.imageNum = dict["ImageNum"] as! Int64
            }
            if dict.keys.contains("LastChange") {
                self.lastChange = dict["LastChange"] as! String
            }
            if dict.keys.contains("PersonCode") {
                self.personCode = dict["PersonCode"] as! String
            }
            if dict.keys.contains("PersonId") {
                self.personId = dict["PersonId"] as! String
            }
            if dict.keys.contains("PersonName") {
                self.personName = dict["PersonName"] as! String
            }
            if dict.keys.contains("PersonTableId") {
                self.personTableId = dict["PersonTableId"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var personTableItem: UpdateAiotPersonTableItemResponseBody.PersonTableItem?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.personTableItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.personTableItem != nil {
            map["PersonTableItem"] = self.personTableItem?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PersonTableItem") {
            var model = UpdateAiotPersonTableItemResponseBody.PersonTableItem()
            model.fromMap(dict["PersonTableItem"] as! [String: Any])
            self.personTableItem = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAiotPersonTableItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAiotPersonTableItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAiotPersonTableItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAiotVehicleTableItemRequest : Tea.TeaModel {
    public class VehicleTableItem : Tea.TeaModel {
        public var beginTime: String?

        public var endTime: String?

        public var ownerName: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var remarks: String?

        public var vehicleTableItemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginTime != nil {
                map["BeginTime"] = self.beginTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            if self.vehicleTableItemId != nil {
                map["VehicleTableItemId"] = self.vehicleTableItemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginTime") {
                self.beginTime = dict["BeginTime"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
            if dict.keys.contains("VehicleTableItemId") {
                self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
            }
        }
    }
    public var id: String?

    public var vehicleTableId: String?

    public var vehicleTableItem: UpdateAiotVehicleTableItemRequest.VehicleTableItem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vehicleTableItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItem != nil {
            map["VehicleTableItem"] = self.vehicleTableItem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItem") {
            var model = UpdateAiotVehicleTableItemRequest.VehicleTableItem()
            model.fromMap(dict["VehicleTableItem"] as! [String: Any])
            self.vehicleTableItem = model
        }
    }
}

public class UpdateAiotVehicleTableItemShrinkRequest : Tea.TeaModel {
    public var id: String?

    public var vehicleTableId: String?

    public var vehicleTableItemShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.vehicleTableId != nil {
            map["VehicleTableId"] = self.vehicleTableId!
        }
        if self.vehicleTableItemShrink != nil {
            map["VehicleTableItem"] = self.vehicleTableItemShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("VehicleTableId") {
            self.vehicleTableId = dict["VehicleTableId"] as! String
        }
        if dict.keys.contains("VehicleTableItem") {
            self.vehicleTableItemShrink = dict["VehicleTableItem"] as! String
        }
    }
}

public class UpdateAiotVehicleTableItemResponseBody : Tea.TeaModel {
    public class VehicleTableItem : Tea.TeaModel {
        public var beginTime: String?

        public var endTime: String?

        public var ownerName: String?

        public var phoneNo: String?

        public var plateNo: String?

        public var remarks: String?

        public var vehicleTableId: String?

        public var vehicleTableItemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginTime != nil {
                map["BeginTime"] = self.beginTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.phoneNo != nil {
                map["PhoneNo"] = self.phoneNo!
            }
            if self.plateNo != nil {
                map["PlateNo"] = self.plateNo!
            }
            if self.remarks != nil {
                map["Remarks"] = self.remarks!
            }
            if self.vehicleTableId != nil {
                map["VehicleTableId"] = self.vehicleTableId!
            }
            if self.vehicleTableItemId != nil {
                map["VehicleTableItemId"] = self.vehicleTableItemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginTime") {
                self.beginTime = dict["BeginTime"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("PhoneNo") {
                self.phoneNo = dict["PhoneNo"] as! String
            }
            if dict.keys.contains("PlateNo") {
                self.plateNo = dict["PlateNo"] as! String
            }
            if dict.keys.contains("Remarks") {
                self.remarks = dict["Remarks"] as! String
            }
            if dict.keys.contains("VehicleTableId") {
                self.vehicleTableId = dict["VehicleTableId"] as! String
            }
            if dict.keys.contains("VehicleTableItemId") {
                self.vehicleTableItemId = dict["VehicleTableItemId"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var vehicleTableItem: UpdateAiotVehicleTableItemResponseBody.VehicleTableItem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vehicleTableItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vehicleTableItem != nil {
            map["VehicleTableItem"] = self.vehicleTableItem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VehicleTableItem") {
            var model = UpdateAiotVehicleTableItemResponseBody.VehicleTableItem()
            model.fromMap(dict["VehicleTableItem"] as! [String: Any])
            self.vehicleTableItem = model
        }
    }
}

public class UpdateAiotVehicleTableItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAiotVehicleTableItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAiotVehicleTableItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCorpRequest : Tea.TeaModel {
    public var appName: String?

    public var corpId: String?

    public var corpName: String?

    public var description_: String?

    public var iconPath: String?

    public var isvSubId: String?

    public var parentCorpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.corpName != nil {
            map["CorpName"] = self.corpName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.iconPath != nil {
            map["IconPath"] = self.iconPath!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.parentCorpId != nil {
            map["ParentCorpId"] = self.parentCorpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("CorpName") {
            self.corpName = dict["CorpName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IconPath") {
            self.iconPath = dict["IconPath"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("ParentCorpId") {
            self.parentCorpId = dict["ParentCorpId"] as! String
        }
    }
}

public class UpdateCorpResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCorpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCorpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCorpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var dataSourceId: String?

    public var dataSourceName: String?

    public var description_: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.dataSourceName != nil {
            map["DataSourceName"] = self.dataSourceName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("DataSourceName") {
            self.dataSourceName = dict["DataSourceName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDeviceRequest : Tea.TeaModel {
    public var bitRate: String?

    public var corpId: String?

    public var deviceAddress: String?

    public var deviceDirection: String?

    public var deviceName: String?

    public var deviceResolution: String?

    public var deviceSite: String?

    public var deviceType: String?

    public var gbId: String?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bitRate != nil {
            map["BitRate"] = self.bitRate!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.deviceDirection != nil {
            map["DeviceDirection"] = self.deviceDirection!
        }
        if self.deviceName != nil {
            map["DeviceName"] = self.deviceName!
        }
        if self.deviceResolution != nil {
            map["DeviceResolution"] = self.deviceResolution!
        }
        if self.deviceSite != nil {
            map["DeviceSite"] = self.deviceSite!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.gbId != nil {
            map["GbId"] = self.gbId!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BitRate") {
            self.bitRate = dict["BitRate"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("DeviceDirection") {
            self.deviceDirection = dict["DeviceDirection"] as! String
        }
        if dict.keys.contains("DeviceName") {
            self.deviceName = dict["DeviceName"] as! String
        }
        if dict.keys.contains("DeviceResolution") {
            self.deviceResolution = dict["DeviceResolution"] as! String
        }
        if dict.keys.contains("DeviceSite") {
            self.deviceSite = dict["DeviceSite"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("GbId") {
            self.gbId = dict["GbId"] as! String
        }
        if dict.keys.contains("Vendor") {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class UpdateDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDeviceCaptureStrategyRequest : Tea.TeaModel {
    public var deviceCode: String?

    public var deviceType: String?

    public var mondayCaptureStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceCode != nil {
            map["DeviceCode"] = self.deviceCode!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.mondayCaptureStrategy != nil {
            map["MondayCaptureStrategy"] = self.mondayCaptureStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceCode") {
            self.deviceCode = dict["DeviceCode"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("MondayCaptureStrategy") {
            self.mondayCaptureStrategy = dict["MondayCaptureStrategy"] as! String
        }
    }
}

public class UpdateDeviceCaptureStrategyResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDeviceCaptureStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDeviceCaptureStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDeviceCaptureStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDevicesStorageRequest : Tea.TeaModel {
    public class UpdateStorageRequests : Tea.TeaModel {
        public class StorageDays : Tea.TeaModel {
            public var storageDays: Int64?

            public var storageType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.storageDays != nil {
                    map["StorageDays"] = self.storageDays!
                }
                if self.storageType != nil {
                    map["StorageType"] = self.storageType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StorageDays") {
                    self.storageDays = dict["StorageDays"] as! Int64
                }
                if dict.keys.contains("StorageType") {
                    self.storageType = dict["StorageType"] as! String
                }
            }
        }
        public var deviceIds: String?

        public var storageDays: [UpdateDevicesStorageRequest.UpdateStorageRequests.StorageDays]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceIds != nil {
                map["DeviceIds"] = self.deviceIds!
            }
            if self.storageDays != nil {
                var tmp : [Any] = []
                for k in self.storageDays! {
                    tmp.append(k.toMap())
                }
                map["StorageDays"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceIds") {
                self.deviceIds = dict["DeviceIds"] as! String
            }
            if dict.keys.contains("StorageDays") {
                self.storageDays = dict["StorageDays"] as! [UpdateDevicesStorageRequest.UpdateStorageRequests.StorageDays]
            }
        }
    }
    public var updateStorageRequests: [UpdateDevicesStorageRequest.UpdateStorageRequests]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateStorageRequests != nil {
            var tmp : [Any] = []
            for k in self.updateStorageRequests! {
                tmp.append(k.toMap())
            }
            map["UpdateStorageRequests"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateStorageRequests") {
            self.updateStorageRequests = dict["UpdateStorageRequests"] as! [UpdateDevicesStorageRequest.UpdateStorageRequests]
        }
    }
}

public class UpdateDevicesStorageShrinkRequest : Tea.TeaModel {
    public var updateStorageRequestsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateStorageRequestsShrink != nil {
            map["UpdateStorageRequests"] = self.updateStorageRequestsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UpdateStorageRequests") {
            self.updateStorageRequestsShrink = dict["UpdateStorageRequests"] as! String
        }
    }
}

public class UpdateDevicesStorageResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDevicesStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDevicesStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDevicesStorageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDoubleVerificationGroupRequest : Tea.TeaModel {
    public class DoubleVerificationGroup : Tea.TeaModel {
        public class PersonIdList : Tea.TeaModel {
            public var personId: String?

            public var personTableId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.personTableId != nil {
                    map["PersonTableId"] = self.personTableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PersonTableId") {
                    self.personTableId = dict["PersonTableId"] as! String
                }
            }
        }
        public var groupId: String?

        public var interval: Int64?

        public var memberNumber: Int64?

        public var personIdList: [UpdateDoubleVerificationGroupRequest.DoubleVerificationGroup.PersonIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.memberNumber != nil {
                map["MemberNumber"] = self.memberNumber!
            }
            if self.personIdList != nil {
                var tmp : [Any] = []
                for k in self.personIdList! {
                    tmp.append(k.toMap())
                }
                map["PersonIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int64
            }
            if dict.keys.contains("MemberNumber") {
                self.memberNumber = dict["MemberNumber"] as! Int64
            }
            if dict.keys.contains("PersonIdList") {
                self.personIdList = dict["PersonIdList"] as! [UpdateDoubleVerificationGroupRequest.DoubleVerificationGroup.PersonIdList]
            }
        }
    }
    public var doubleVerificationGroup: UpdateDoubleVerificationGroupRequest.DoubleVerificationGroup?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.doubleVerificationGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.doubleVerificationGroup != nil {
            map["DoubleVerificationGroup"] = self.doubleVerificationGroup?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DoubleVerificationGroup") {
            var model = UpdateDoubleVerificationGroupRequest.DoubleVerificationGroup()
            model.fromMap(dict["DoubleVerificationGroup"] as! [String: Any])
            self.doubleVerificationGroup = model
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class UpdateDoubleVerificationGroupResponseBody : Tea.TeaModel {
    public class DoubleVerificationGroup : Tea.TeaModel {
        public class PersonIdList : Tea.TeaModel {
            public var personId: String?

            public var personTableId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.personId != nil {
                    map["PersonId"] = self.personId!
                }
                if self.personTableId != nil {
                    map["PersonTableId"] = self.personTableId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PersonId") {
                    self.personId = dict["PersonId"] as! String
                }
                if dict.keys.contains("PersonTableId") {
                    self.personTableId = dict["PersonTableId"] as! String
                }
            }
        }
        public var deviceId: String?

        public var enabled: String?

        public var groupId: String?

        public var interval: Int64?

        public var lastChange: String?

        public var memberNumber: Int64?

        public var personIdList: [UpdateDoubleVerificationGroupResponseBody.DoubleVerificationGroup.PersonIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.interval != nil {
                map["Interval"] = self.interval!
            }
            if self.lastChange != nil {
                map["LastChange"] = self.lastChange!
            }
            if self.memberNumber != nil {
                map["MemberNumber"] = self.memberNumber!
            }
            if self.personIdList != nil {
                var tmp : [Any] = []
                for k in self.personIdList! {
                    tmp.append(k.toMap())
                }
                map["PersonIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("Interval") {
                self.interval = dict["Interval"] as! Int64
            }
            if dict.keys.contains("LastChange") {
                self.lastChange = dict["LastChange"] as! String
            }
            if dict.keys.contains("MemberNumber") {
                self.memberNumber = dict["MemberNumber"] as! Int64
            }
            if dict.keys.contains("PersonIdList") {
                self.personIdList = dict["PersonIdList"] as! [UpdateDoubleVerificationGroupResponseBody.DoubleVerificationGroup.PersonIdList]
            }
        }
    }
    public var code: String?

    public var doubleVerificationGroup: UpdateDoubleVerificationGroupResponseBody.DoubleVerificationGroup?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.doubleVerificationGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.doubleVerificationGroup != nil {
            map["DoubleVerificationGroup"] = self.doubleVerificationGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DoubleVerificationGroup") {
            var model = UpdateDoubleVerificationGroupResponseBody.DoubleVerificationGroup()
            model.fromMap(dict["DoubleVerificationGroup"] as! [String: Any])
            self.doubleVerificationGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDoubleVerificationGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDoubleVerificationGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDoubleVerificationGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateModelServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var modelServiceId: String?

    public var modelServiceName: String?

    public var qpsRequired: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.modelServiceId != nil {
            map["ModelServiceId"] = self.modelServiceId!
        }
        if self.modelServiceName != nil {
            map["ModelServiceName"] = self.modelServiceName!
        }
        if self.qpsRequired != nil {
            map["QpsRequired"] = self.qpsRequired!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ModelServiceId") {
            self.modelServiceId = dict["ModelServiceId"] as! String
        }
        if dict.keys.contains("ModelServiceName") {
            self.modelServiceName = dict["ModelServiceName"] as! String
        }
        if dict.keys.contains("QpsRequired") {
            self.qpsRequired = dict["QpsRequired"] as! Int32
        }
    }
}

public class UpdateModelServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var algorithmCode: String?

        public var modelServiceInstanceId: String?

        public var modelServiceInstanceName: String?

        public var modelServiceStatus: String?

        public var qpsRequired: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.algorithmCode != nil {
                map["AlgorithmCode"] = self.algorithmCode!
            }
            if self.modelServiceInstanceId != nil {
                map["ModelServiceInstanceId"] = self.modelServiceInstanceId!
            }
            if self.modelServiceInstanceName != nil {
                map["ModelServiceInstanceName"] = self.modelServiceInstanceName!
            }
            if self.modelServiceStatus != nil {
                map["ModelServiceStatus"] = self.modelServiceStatus!
            }
            if self.qpsRequired != nil {
                map["QpsRequired"] = self.qpsRequired!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlgorithmCode") {
                self.algorithmCode = dict["AlgorithmCode"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceId") {
                self.modelServiceInstanceId = dict["ModelServiceInstanceId"] as! String
            }
            if dict.keys.contains("ModelServiceInstanceName") {
                self.modelServiceInstanceName = dict["ModelServiceInstanceName"] as! String
            }
            if dict.keys.contains("ModelServiceStatus") {
                self.modelServiceStatus = dict["ModelServiceStatus"] as! String
            }
            if dict.keys.contains("QpsRequired") {
                self.qpsRequired = dict["QpsRequired"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: UpdateModelServiceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateModelServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateModelServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateModelServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateModelServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMonitorRequest : Tea.TeaModel {
    public var algorithmVendor: String?

    public var attributeName: String?

    public var attributeOperateType: String?

    public var attributeValueList: String?

    public var corpId: String?

    public var description_: String?

    public var deviceList: String?

    public var deviceOperateType: String?

    public var notifierAppSecret: String?

    public var notifierExtendValues: String?

    public var notifierTimeOut: Int32?

    public var notifierType: String?

    public var notifierUrl: String?

    public var picList: String?

    public var picOperateType: String?

    public var ruleExpression: String?

    public var ruleName: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithmVendor != nil {
            map["AlgorithmVendor"] = self.algorithmVendor!
        }
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.attributeOperateType != nil {
            map["AttributeOperateType"] = self.attributeOperateType!
        }
        if self.attributeValueList != nil {
            map["AttributeValueList"] = self.attributeValueList!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceList != nil {
            map["DeviceList"] = self.deviceList!
        }
        if self.deviceOperateType != nil {
            map["DeviceOperateType"] = self.deviceOperateType!
        }
        if self.notifierAppSecret != nil {
            map["NotifierAppSecret"] = self.notifierAppSecret!
        }
        if self.notifierExtendValues != nil {
            map["NotifierExtendValues"] = self.notifierExtendValues!
        }
        if self.notifierTimeOut != nil {
            map["NotifierTimeOut"] = self.notifierTimeOut!
        }
        if self.notifierType != nil {
            map["NotifierType"] = self.notifierType!
        }
        if self.notifierUrl != nil {
            map["NotifierUrl"] = self.notifierUrl!
        }
        if self.picList != nil {
            map["PicList"] = self.picList!
        }
        if self.picOperateType != nil {
            map["PicOperateType"] = self.picOperateType!
        }
        if self.ruleExpression != nil {
            map["RuleExpression"] = self.ruleExpression!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlgorithmVendor") {
            self.algorithmVendor = dict["AlgorithmVendor"] as! String
        }
        if dict.keys.contains("AttributeName") {
            self.attributeName = dict["AttributeName"] as! String
        }
        if dict.keys.contains("AttributeOperateType") {
            self.attributeOperateType = dict["AttributeOperateType"] as! String
        }
        if dict.keys.contains("AttributeValueList") {
            self.attributeValueList = dict["AttributeValueList"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceList = dict["DeviceList"] as! String
        }
        if dict.keys.contains("DeviceOperateType") {
            self.deviceOperateType = dict["DeviceOperateType"] as! String
        }
        if dict.keys.contains("NotifierAppSecret") {
            self.notifierAppSecret = dict["NotifierAppSecret"] as! String
        }
        if dict.keys.contains("NotifierExtendValues") {
            self.notifierExtendValues = dict["NotifierExtendValues"] as! String
        }
        if dict.keys.contains("NotifierTimeOut") {
            self.notifierTimeOut = dict["NotifierTimeOut"] as! Int32
        }
        if dict.keys.contains("NotifierType") {
            self.notifierType = dict["NotifierType"] as! String
        }
        if dict.keys.contains("NotifierUrl") {
            self.notifierUrl = dict["NotifierUrl"] as! String
        }
        if dict.keys.contains("PicList") {
            self.picList = dict["PicList"] as! String
        }
        if dict.keys.contains("PicOperateType") {
            self.picOperateType = dict["PicOperateType"] as! String
        }
        if dict.keys.contains("RuleExpression") {
            self.ruleExpression = dict["RuleExpression"] as! String
        }
        if dict.keys.contains("RuleName") {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class UpdateMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProfileRequest : Tea.TeaModel {
    public var bizId: String?

    public var catalogId: Int64?

    public var corpId: String?

    public var faceUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var liveAddress: String?

    public var name: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var profileId: Int64?

    public var sceneType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceUrl != nil {
            map["FaceUrl"] = self.faceUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.liveAddress != nil {
            map["LiveAddress"] = self.liveAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.profileId != nil {
            map["ProfileId"] = self.profileId!
        }
        if self.sceneType != nil {
            map["SceneType"] = self.sceneType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! Int64
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceUrl") {
            self.faceUrl = dict["FaceUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("LiveAddress") {
            self.liveAddress = dict["LiveAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("ProfileId") {
            self.profileId = dict["ProfileId"] as! Int64
        }
        if dict.keys.contains("SceneType") {
            self.sceneType = dict["SceneType"] as! String
        }
    }
}

public class UpdateProfileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateProfileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProfileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProfileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProfileCatalogRequest : Tea.TeaModel {
    public var catalogId: Int64?

    public var catalogName: String?

    public var corpId: String?

    public var isvSubId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.catalogName != nil {
            map["CatalogName"] = self.catalogName!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! Int64
        }
        if dict.keys.contains("CatalogName") {
            self.catalogName = dict["CatalogName"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
    }
}

public class UpdateProfileCatalogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var catalogId: Int64?

        public var catalogName: String?

        public var isvSubId: String?

        public var parentCatalogId: String?

        public var profileCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogId != nil {
                map["CatalogId"] = self.catalogId!
            }
            if self.catalogName != nil {
                map["CatalogName"] = self.catalogName!
            }
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.parentCatalogId != nil {
                map["ParentCatalogId"] = self.parentCatalogId!
            }
            if self.profileCount != nil {
                map["ProfileCount"] = self.profileCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CatalogId") {
                self.catalogId = dict["CatalogId"] as! Int64
            }
            if dict.keys.contains("CatalogName") {
                self.catalogName = dict["CatalogName"] as! String
            }
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("ParentCatalogId") {
                self.parentCatalogId = dict["ParentCatalogId"] as! String
            }
            if dict.keys.contains("ProfileCount") {
                self.profileCount = dict["ProfileCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: UpdateProfileCatalogResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateProfileCatalogResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateProfileCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProfileCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProfileCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSearchTableRequest : Tea.TeaModel {
    public var searchTableId: String?

    public var searchTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchTableId != nil {
            map["SearchTableId"] = self.searchTableId!
        }
        if self.searchTableName != nil {
            map["SearchTableName"] = self.searchTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchTableId") {
            self.searchTableId = dict["SearchTableId"] as! String
        }
        if dict.keys.contains("SearchTableName") {
            self.searchTableName = dict["SearchTableName"] as! String
        }
    }
}

public class UpdateSearchTableResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateSearchTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSearchTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSearchTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserRequest : Tea.TeaModel {
    public var address: String?

    public var age: Int32?

    public var attachment: String?

    public var bizId: String?

    public var corpId: String?

    public var faceImageContent: String?

    public var faceImageUrl: String?

    public var gender: Int32?

    public var idNumber: String?

    public var isvSubId: String?

    public var phoneNo: String?

    public var plateNo: String?

    public var userGroupId: Int64?

    public var userId: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.age != nil {
            map["Age"] = self.age!
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.faceImageContent != nil {
            map["FaceImageContent"] = self.faceImageContent!
        }
        if self.faceImageUrl != nil {
            map["FaceImageUrl"] = self.faceImageUrl!
        }
        if self.gender != nil {
            map["Gender"] = self.gender!
        }
        if self.idNumber != nil {
            map["IdNumber"] = self.idNumber!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.phoneNo != nil {
            map["PhoneNo"] = self.phoneNo!
        }
        if self.plateNo != nil {
            map["PlateNo"] = self.plateNo!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Age") {
            self.age = dict["Age"] as! Int32
        }
        if dict.keys.contains("Attachment") {
            self.attachment = dict["Attachment"] as! String
        }
        if dict.keys.contains("BizId") {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("FaceImageContent") {
            self.faceImageContent = dict["FaceImageContent"] as! String
        }
        if dict.keys.contains("FaceImageUrl") {
            self.faceImageUrl = dict["FaceImageUrl"] as! String
        }
        if dict.keys.contains("Gender") {
            self.gender = dict["Gender"] as! Int32
        }
        if dict.keys.contains("IdNumber") {
            self.idNumber = dict["IdNumber"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("PhoneNo") {
            self.phoneNo = dict["PhoneNo"] as! String
        }
        if dict.keys.contains("PlateNo") {
            self.plateNo = dict["PlateNo"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class UpdateUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserGroupRequest : Tea.TeaModel {
    public var corpId: String?

    public var isvSubId: String?

    public var userGroupId: Int64?

    public var userGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.isvSubId != nil {
            map["IsvSubId"] = self.isvSubId!
        }
        if self.userGroupId != nil {
            map["UserGroupId"] = self.userGroupId!
        }
        if self.userGroupName != nil {
            map["UserGroupName"] = self.userGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("IsvSubId") {
            self.isvSubId = dict["IsvSubId"] as! String
        }
        if dict.keys.contains("UserGroupId") {
            self.userGroupId = dict["UserGroupId"] as! Int64
        }
        if dict.keys.contains("UserGroupName") {
            self.userGroupName = dict["UserGroupName"] as! String
        }
    }
}

public class UpdateUserGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isvSubId: String?

        public var parentUserGroupId: String?

        public var userCount: Int64?

        public var userGroupId: Int64?

        public var userGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isvSubId != nil {
                map["IsvSubId"] = self.isvSubId!
            }
            if self.parentUserGroupId != nil {
                map["ParentUserGroupId"] = self.parentUserGroupId!
            }
            if self.userCount != nil {
                map["UserCount"] = self.userCount!
            }
            if self.userGroupId != nil {
                map["UserGroupId"] = self.userGroupId!
            }
            if self.userGroupName != nil {
                map["UserGroupName"] = self.userGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IsvSubId") {
                self.isvSubId = dict["IsvSubId"] as! String
            }
            if dict.keys.contains("ParentUserGroupId") {
                self.parentUserGroupId = dict["ParentUserGroupId"] as! String
            }
            if dict.keys.contains("UserCount") {
                self.userCount = dict["UserCount"] as! Int64
            }
            if dict.keys.contains("UserGroupId") {
                self.userGroupId = dict["UserGroupId"] as! Int64
            }
            if dict.keys.contains("UserGroupName") {
                self.userGroupName = dict["UserGroupName"] as! String
            }
        }
    }
    public var code: String?

    public var data: UpdateUserGroupResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateUserGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateUserGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateUserGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWatchPolicyRequest : Tea.TeaModel {
    public var itemMatchType: String?

    public var similarityThreshold: Double?

    public var targetType: String?

    public var watchMode: String?

    public var watchPolicyId: String?

    public var watchPolicyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemMatchType != nil {
            map["ItemMatchType"] = self.itemMatchType!
        }
        if self.similarityThreshold != nil {
            map["SimilarityThreshold"] = self.similarityThreshold!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.watchMode != nil {
            map["WatchMode"] = self.watchMode!
        }
        if self.watchPolicyId != nil {
            map["WatchPolicyId"] = self.watchPolicyId!
        }
        if self.watchPolicyName != nil {
            map["WatchPolicyName"] = self.watchPolicyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemMatchType") {
            self.itemMatchType = dict["ItemMatchType"] as! String
        }
        if dict.keys.contains("SimilarityThreshold") {
            self.similarityThreshold = dict["SimilarityThreshold"] as! Double
        }
        if dict.keys.contains("TargetType") {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("WatchMode") {
            self.watchMode = dict["WatchMode"] as! String
        }
        if dict.keys.contains("WatchPolicyId") {
            self.watchPolicyId = dict["WatchPolicyId"] as! String
        }
        if dict.keys.contains("WatchPolicyName") {
            self.watchPolicyName = dict["WatchPolicyName"] as! String
        }
    }
}

public class UpdateWatchPolicyResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateWatchPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWatchPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWatchPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWatchTaskRequest : Tea.TeaModel {
    public var description_: String?

    public var deviceList: String?

    public var messageReceiver: String?

    public var scheduleCycleDates: String?

    public var scheduleTimes: String?

    public var scheduleType: String?

    public var taskName: String?

    public var watchPolicyIds: String?

    public var watchTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.deviceList != nil {
            map["DeviceList"] = self.deviceList!
        }
        if self.messageReceiver != nil {
            map["MessageReceiver"] = self.messageReceiver!
        }
        if self.scheduleCycleDates != nil {
            map["ScheduleCycleDates"] = self.scheduleCycleDates!
        }
        if self.scheduleTimes != nil {
            map["ScheduleTimes"] = self.scheduleTimes!
        }
        if self.scheduleType != nil {
            map["ScheduleType"] = self.scheduleType!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.watchPolicyIds != nil {
            map["WatchPolicyIds"] = self.watchPolicyIds!
        }
        if self.watchTaskId != nil {
            map["WatchTaskId"] = self.watchTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DeviceList") {
            self.deviceList = dict["DeviceList"] as! String
        }
        if dict.keys.contains("MessageReceiver") {
            self.messageReceiver = dict["MessageReceiver"] as! String
        }
        if dict.keys.contains("ScheduleCycleDates") {
            self.scheduleCycleDates = dict["ScheduleCycleDates"] as! String
        }
        if dict.keys.contains("ScheduleTimes") {
            self.scheduleTimes = dict["ScheduleTimes"] as! String
        }
        if dict.keys.contains("ScheduleType") {
            self.scheduleType = dict["ScheduleType"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("WatchPolicyIds") {
            self.watchPolicyIds = dict["WatchPolicyIds"] as! String
        }
        if dict.keys.contains("WatchTaskId") {
            self.watchTaskId = dict["WatchTaskId"] as! String
        }
    }
}

public class UpdateWatchTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateWatchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWatchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWatchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadFileRequest : Tea.TeaModel {
    public var corpId: String?

    public var dataSourceId: String?

    public var fileAliasName: String?

    public var fileContent: String?

    public var fileName: String?

    public var filePath: String?

    public var fileType: String?

    public var MD5: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.corpId != nil {
            map["CorpId"] = self.corpId!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.fileAliasName != nil {
            map["FileAliasName"] = self.fileAliasName!
        }
        if self.fileContent != nil {
            map["FileContent"] = self.fileContent!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.fileType != nil {
            map["FileType"] = self.fileType!
        }
        if self.MD5 != nil {
            map["MD5"] = self.MD5!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CorpId") {
            self.corpId = dict["CorpId"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! String
        }
        if dict.keys.contains("FileAliasName") {
            self.fileAliasName = dict["FileAliasName"] as! String
        }
        if dict.keys.contains("FileContent") {
            self.fileContent = dict["FileContent"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("FileType") {
            self.fileType = dict["FileType"] as! String
        }
        if dict.keys.contains("MD5") {
            self.MD5 = dict["MD5"] as! String
        }
    }
}

public class UploadFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Records : Tea.TeaModel {
            public var ossPath: String?

            public var sourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ossPath != nil {
                    map["OssPath"] = self.ossPath!
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OssPath") {
                    self.ossPath = dict["OssPath"] as! String
                }
                if dict.keys.contains("SourceId") {
                    self.sourceId = dict["SourceId"] as! String
                }
            }
        }
        public var records: [UploadFileResponseBody.Data.Records]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.records != nil {
                var tmp : [Any] = []
                for k in self.records! {
                    tmp.append(k.toMap())
                }
                map["Records"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Records") {
                self.records = dict["Records"] as! [UploadFileResponseBody.Data.Records]
            }
        }
    }
    public var code: String?

    public var data: UploadFileResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UploadFileResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UploadFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadImageRequest : Tea.TeaModel {
    public var imageUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
    }
}

public class UploadImageResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UploadImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyDeviceRequest : Tea.TeaModel {
    public var deviceAddress: String?

    public var filePath: String?

    public var nvrExisted: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceAddress != nil {
            map["DeviceAddress"] = self.deviceAddress!
        }
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.nvrExisted != nil {
            map["NvrExisted"] = self.nvrExisted!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceAddress") {
            self.deviceAddress = dict["DeviceAddress"] as! String
        }
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("NvrExisted") {
            self.nvrExisted = dict["NvrExisted"] as! Int64
        }
    }
}

public class VerifyDeviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var id: String?

        public var message: String?

        public var originalGbId: String?

        public var rowNumber: Int64?

        public var suggestGbId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.originalGbId != nil {
                map["OriginalGbId"] = self.originalGbId!
            }
            if self.rowNumber != nil {
                map["RowNumber"] = self.rowNumber!
            }
            if self.suggestGbId != nil {
                map["SuggestGbId"] = self.suggestGbId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("OriginalGbId") {
                self.originalGbId = dict["OriginalGbId"] as! String
            }
            if dict.keys.contains("RowNumber") {
                self.rowNumber = dict["RowNumber"] as! Int64
            }
            if dict.keys.contains("SuggestGbId") {
                self.suggestGbId = dict["SuggestGbId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [VerifyDeviceResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [VerifyDeviceResponseBody.Data]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
