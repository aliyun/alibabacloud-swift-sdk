import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddMdsMiniConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMiniConfigAddJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMiniConfigAddJsonStr != nil {
            map["MpaasMappcenterMiniConfigAddJsonStr"] = self.mpaasMappcenterMiniConfigAddJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMiniConfigAddJsonStr") && dict["MpaasMappcenterMiniConfigAddJsonStr"] != nil {
            self.mpaasMappcenterMiniConfigAddJsonStr = dict["MpaasMappcenterMiniConfigAddJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class AddMdsMiniConfigResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var content: String?

            public var errorCode: String?

            public var requestId: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: AddMdsMiniConfigResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = AddMdsMiniConfigResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: AddMdsMiniConfigResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = AddMdsMiniConfigResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class AddMdsMiniConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMdsMiniConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddMdsMiniConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelPushSchedulerRequest : Tea.TeaModel {
    public var appId: String?

    public var type: Int32?

    public var uniqueIds: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uniqueIds != nil {
            map["UniqueIds"] = self.uniqueIds!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UniqueIds") && dict["UniqueIds"] != nil {
            self.uniqueIds = dict["UniqueIds"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CancelPushSchedulerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CancelPushSchedulerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelPushSchedulerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelPushSchedulerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeMcubeMiniTaskStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var bizType: String?

    public var packageId: Int64?

    public var taskId: Int64?

    public var taskStatus: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! Int64
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ChangeMcubeMiniTaskStatusResponseBody : Tea.TeaModel {
    public class ChangeMiniTaskStatusResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var changeMiniTaskStatusResult: ChangeMcubeMiniTaskStatusResponseBody.ChangeMiniTaskStatusResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeMiniTaskStatusResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeMiniTaskStatusResult != nil {
            map["ChangeMiniTaskStatusResult"] = self.changeMiniTaskStatusResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeMiniTaskStatusResult") && dict["ChangeMiniTaskStatusResult"] != nil {
            var model = ChangeMcubeMiniTaskStatusResponseBody.ChangeMiniTaskStatusResult()
            model.fromMap(dict["ChangeMiniTaskStatusResult"] as! [String: Any])
            self.changeMiniTaskStatusResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ChangeMcubeMiniTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeMcubeMiniTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeMcubeMiniTaskStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeMcubeNebulaTaskStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var bizType: String?

    public var packageId: String?

    public var taskId: String?

    public var taskStatus: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ChangeMcubeNebulaTaskStatusResponseBody : Tea.TeaModel {
    public class ChangeMcubeNebulaTaskStatusResult : Tea.TeaModel {
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var changeMcubeNebulaTaskStatusResult: ChangeMcubeNebulaTaskStatusResponseBody.ChangeMcubeNebulaTaskStatusResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.changeMcubeNebulaTaskStatusResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeMcubeNebulaTaskStatusResult != nil {
            map["ChangeMcubeNebulaTaskStatusResult"] = self.changeMcubeNebulaTaskStatusResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeMcubeNebulaTaskStatusResult") && dict["ChangeMcubeNebulaTaskStatusResult"] != nil {
            var model = ChangeMcubeNebulaTaskStatusResponseBody.ChangeMcubeNebulaTaskStatusResult()
            model.fromMap(dict["ChangeMcubeNebulaTaskStatusResult"] as! [String: Any])
            self.changeMcubeNebulaTaskStatusResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ChangeMcubeNebulaTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeMcubeNebulaTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeMcubeNebulaTaskStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeMcubePublicTaskStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: String?

    public var taskStatus: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ChangeMcubePublicTaskStatusResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var data: String?

        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: ChangeMcubePublicTaskStatusResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = ChangeMcubePublicTaskStatusResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ChangeMcubePublicTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeMcubePublicTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeMcubePublicTaskStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyMcdpGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpGroupCopyJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpGroupCopyJsonStr != nil {
            map["MpaasMappcenterMcdpGroupCopyJsonStr"] = self.mpaasMappcenterMcdpGroupCopyJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpGroupCopyJsonStr") && dict["MpaasMappcenterMcdpGroupCopyJsonStr"] != nil {
            self.mpaasMappcenterMcdpGroupCopyJsonStr = dict["MpaasMappcenterMcdpGroupCopyJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CopyMcdpGroupResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CopyMcdpGroupResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CopyMcdpGroupResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CopyMcdpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyMcdpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CopyMcdpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMasCrowdRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpMasCrowdCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpMasCrowdCreateJsonStr != nil {
            map["MpaasMappcenterMcdpMasCrowdCreateJsonStr"] = self.mpaasMappcenterMcdpMasCrowdCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpMasCrowdCreateJsonStr") && dict["MpaasMappcenterMcdpMasCrowdCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpMasCrowdCreateJsonStr = dict["MpaasMappcenterMcdpMasCrowdCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMasCrowdResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMasCrowdResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMasCrowdResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMasCrowdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMasCrowdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMasCrowdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMasFunnelRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpMasFunnelCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpMasFunnelCreateJsonStr != nil {
            map["MpaasMappcenterMcdpMasFunnelCreateJsonStr"] = self.mpaasMappcenterMcdpMasFunnelCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpMasFunnelCreateJsonStr") && dict["MpaasMappcenterMcdpMasFunnelCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpMasFunnelCreateJsonStr = dict["MpaasMappcenterMcdpMasFunnelCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMasFunnelResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMasFunnelResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMasFunnelResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMasFunnelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMasFunnelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMasFunnelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcdpEventRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpEventCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpEventCreateJsonStr != nil {
            map["MpaasMappcenterMcdpEventCreateJsonStr"] = self.mpaasMappcenterMcdpEventCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpEventCreateJsonStr") && dict["MpaasMappcenterMcdpEventCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpEventCreateJsonStr = dict["MpaasMappcenterMcdpEventCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcdpEventResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcdpEventResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcdpEventResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcdpEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcdpEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcdpEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcdpEventAttributeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpEventAttributeCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpEventAttributeCreateJsonStr != nil {
            map["MpaasMappcenterMcdpEventAttributeCreateJsonStr"] = self.mpaasMappcenterMcdpEventAttributeCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpEventAttributeCreateJsonStr") && dict["MpaasMappcenterMcdpEventAttributeCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpEventAttributeCreateJsonStr = dict["MpaasMappcenterMcdpEventAttributeCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcdpEventAttributeResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcdpEventAttributeResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcdpEventAttributeResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcdpEventAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcdpEventAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcdpEventAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcdpGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpGroupCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpGroupCreateJsonStr != nil {
            map["MpaasMappcenterMcdpGroupCreateJsonStr"] = self.mpaasMappcenterMcdpGroupCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpGroupCreateJsonStr") && dict["MpaasMappcenterMcdpGroupCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpGroupCreateJsonStr = dict["MpaasMappcenterMcdpGroupCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcdpGroupResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcdpGroupResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcdpGroupResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcdpGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcdpGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcdpGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcdpMaterialRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpMaterialCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpMaterialCreateJsonStr != nil {
            map["MpaasMappcenterMcdpMaterialCreateJsonStr"] = self.mpaasMappcenterMcdpMaterialCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpMaterialCreateJsonStr") && dict["MpaasMappcenterMcdpMaterialCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpMaterialCreateJsonStr = dict["MpaasMappcenterMcdpMaterialCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcdpMaterialResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcdpMaterialResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcdpMaterialResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcdpMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcdpMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcdpMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcdpZoneRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpZoneCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpZoneCreateJsonStr != nil {
            map["MpaasMappcenterMcdpZoneCreateJsonStr"] = self.mpaasMappcenterMcdpZoneCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpZoneCreateJsonStr") && dict["MpaasMappcenterMcdpZoneCreateJsonStr"] != nil {
            self.mpaasMappcenterMcdpZoneCreateJsonStr = dict["MpaasMappcenterMcdpZoneCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcdpZoneResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcdpZoneResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcdpZoneResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcdpZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcdpZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcdpZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeMiniAppRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var h5Name: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.h5Name != nil {
            map["H5Name"] = self.h5Name!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
            self.h5Name = dict["H5Name"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeMiniAppResponseBody : Tea.TeaModel {
    public class CreateMiniResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createMiniResult: CreateMcubeMiniAppResponseBody.CreateMiniResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createMiniResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMiniResult != nil {
            map["CreateMiniResult"] = self.createMiniResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMiniResult") && dict["CreateMiniResult"] != nil {
            var model = CreateMcubeMiniAppResponseBody.CreateMiniResult()
            model.fromMap(dict["CreateMiniResult"] as! [String: Any])
            self.createMiniResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeMiniAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeMiniAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeMiniAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeMiniTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var greyConfigInfo: String?

    public var greyEndtimeData: String?

    public var greyNum: Int64?

    public var memo: String?

    public var packageId: Int64?

    public var publishMode: Int64?

    public var publishType: Int64?

    public var tenantId: String?

    public var whitelistIds: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.greyConfigInfo != nil {
            map["GreyConfigInfo"] = self.greyConfigInfo!
        }
        if self.greyEndtimeData != nil {
            map["GreyEndtimeData"] = self.greyEndtimeData!
        }
        if self.greyNum != nil {
            map["GreyNum"] = self.greyNum!
        }
        if self.memo != nil {
            map["Memo"] = self.memo!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.publishMode != nil {
            map["PublishMode"] = self.publishMode!
        }
        if self.publishType != nil {
            map["PublishType"] = self.publishType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whitelistIds != nil {
            map["WhitelistIds"] = self.whitelistIds!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
            self.greyConfigInfo = dict["GreyConfigInfo"] as! String
        }
        if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
            self.greyEndtimeData = dict["GreyEndtimeData"] as! String
        }
        if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
            self.greyNum = dict["GreyNum"] as! Int64
        }
        if dict.keys.contains("Memo") && dict["Memo"] != nil {
            self.memo = dict["Memo"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! Int64
        }
        if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
            self.publishMode = dict["PublishMode"] as! Int64
        }
        if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
            self.publishType = dict["PublishType"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
            self.whitelistIds = dict["WhitelistIds"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeMiniTaskResponseBody : Tea.TeaModel {
    public class CreateMiniTaskResult : Tea.TeaModel {
        public var miniTaskId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.miniTaskId != nil {
                map["MiniTaskId"] = self.miniTaskId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MiniTaskId") && dict["MiniTaskId"] != nil {
                self.miniTaskId = dict["MiniTaskId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createMiniTaskResult: CreateMcubeMiniTaskResponseBody.CreateMiniTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createMiniTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMiniTaskResult != nil {
            map["CreateMiniTaskResult"] = self.createMiniTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMiniTaskResult") && dict["CreateMiniTaskResult"] != nil {
            var model = CreateMcubeMiniTaskResponseBody.CreateMiniTaskResult()
            model.fromMap(dict["CreateMiniTaskResult"] as! [String: Any])
            self.createMiniTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeMiniTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeMiniTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeMiniTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeNebulaAppRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var h5Name: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.h5Name != nil {
            map["H5Name"] = self.h5Name!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
            self.h5Name = dict["H5Name"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeNebulaAppResponseBody : Tea.TeaModel {
    public class CreateNebulaAppResult : Tea.TeaModel {
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createNebulaAppResult: CreateMcubeNebulaAppResponseBody.CreateNebulaAppResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createNebulaAppResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createNebulaAppResult != nil {
            map["CreateNebulaAppResult"] = self.createNebulaAppResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateNebulaAppResult") && dict["CreateNebulaAppResult"] != nil {
            var model = CreateMcubeNebulaAppResponseBody.CreateNebulaAppResult()
            model.fromMap(dict["CreateNebulaAppResult"] as! [String: Any])
            self.createNebulaAppResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeNebulaAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeNebulaAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeNebulaAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeNebulaResourceRequest : Tea.TeaModel {
    public var appId: String?

    public var autoInstall: Int32?

    public var clientVersionMax: String?

    public var clientVersionMin: String?

    public var customDomainName: String?

    public var extendInfo: String?

    public var fileUrl: String?

    public var h5Id: String?

    public var h5Name: String?

    public var h5Version: String?

    public var installType: Int32?

    public var mainUrl: String?

    public var onexFlag: Bool?

    public var platform: String?

    public var repeatNebula: Int32?

    public var resourceType: Int32?

    public var subUrl: String?

    public var tenantId: String?

    public var vhost: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoInstall != nil {
            map["AutoInstall"] = self.autoInstall!
        }
        if self.clientVersionMax != nil {
            map["ClientVersionMax"] = self.clientVersionMax!
        }
        if self.clientVersionMin != nil {
            map["ClientVersionMin"] = self.clientVersionMin!
        }
        if self.customDomainName != nil {
            map["CustomDomainName"] = self.customDomainName!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.h5Name != nil {
            map["H5Name"] = self.h5Name!
        }
        if self.h5Version != nil {
            map["H5Version"] = self.h5Version!
        }
        if self.installType != nil {
            map["InstallType"] = self.installType!
        }
        if self.mainUrl != nil {
            map["MainUrl"] = self.mainUrl!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.repeatNebula != nil {
            map["RepeatNebula"] = self.repeatNebula!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.subUrl != nil {
            map["SubUrl"] = self.subUrl!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.vhost != nil {
            map["Vhost"] = self.vhost!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
            self.autoInstall = dict["AutoInstall"] as! Int32
        }
        if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
            self.clientVersionMax = dict["ClientVersionMax"] as! String
        }
        if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
            self.clientVersionMin = dict["ClientVersionMin"] as! String
        }
        if dict.keys.contains("CustomDomainName") && dict["CustomDomainName"] != nil {
            self.customDomainName = dict["CustomDomainName"] as! String
        }
        if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
            self.h5Name = dict["H5Name"] as! String
        }
        if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
            self.h5Version = dict["H5Version"] as! String
        }
        if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
            self.installType = dict["InstallType"] as! Int32
        }
        if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
            self.mainUrl = dict["MainUrl"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RepeatNebula") && dict["RepeatNebula"] != nil {
            self.repeatNebula = dict["RepeatNebula"] as! Int32
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! Int32
        }
        if dict.keys.contains("SubUrl") && dict["SubUrl"] != nil {
            self.subUrl = dict["SubUrl"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Vhost") && dict["Vhost"] != nil {
            self.vhost = dict["Vhost"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeNebulaResourceResponseBody : Tea.TeaModel {
    public class CreateMcubeNebulaResourceReslult : Tea.TeaModel {
        public var errorCode: String?

        public var nebulaResourceId: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.nebulaResourceId != nil {
                map["NebulaResourceId"] = self.nebulaResourceId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("NebulaResourceId") && dict["NebulaResourceId"] != nil {
                self.nebulaResourceId = dict["NebulaResourceId"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createMcubeNebulaResourceReslult: CreateMcubeNebulaResourceResponseBody.CreateMcubeNebulaResourceReslult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createMcubeNebulaResourceReslult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMcubeNebulaResourceReslult != nil {
            map["CreateMcubeNebulaResourceReslult"] = self.createMcubeNebulaResourceReslult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMcubeNebulaResourceReslult") && dict["CreateMcubeNebulaResourceReslult"] != nil {
            var model = CreateMcubeNebulaResourceResponseBody.CreateMcubeNebulaResourceReslult()
            model.fromMap(dict["CreateMcubeNebulaResourceReslult"] as! [String: Any])
            self.createMcubeNebulaResourceReslult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeNebulaResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeNebulaResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeNebulaResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeNebulaTaskRequest : Tea.TeaModel {
    public var appCode: String?

    public var appId: String?

    public var bizType: String?

    public var creator: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var gmtModifiedStr: String?

    public var greyConfigInfo: String?

    public var greyEndtime: String?

    public var greyEndtimeData: String?

    public var greyEndtimeStr: String?

    public var greyNum: Int32?

    public var greyUrl: String?

    public var id: Int64?

    public var memo: String?

    public var modifier: String?

    public var packageId: Int64?

    public var percent: Int32?

    public var platform: String?

    public var productId: String?

    public var productVersion: String?

    public var publishMode: Int32?

    public var publishType: Int32?

    public var releaseVersion: String?

    public var resIds: String?

    public var serialVersionUID: Int64?

    public var status: Int32?

    public var syncMode: String?

    public var syncResult: String?

    public var taskName: String?

    public var taskStatus: Int32?

    public var taskType: Int32?

    public var taskVersion: Int64?

    public var tenantId: String?

    public var upgradeNoticeNum: Int64?

    public var upgradeProgress: String?

    public var whitelistIds: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.gmtModifiedStr != nil {
            map["GmtModifiedStr"] = self.gmtModifiedStr!
        }
        if self.greyConfigInfo != nil {
            map["GreyConfigInfo"] = self.greyConfigInfo!
        }
        if self.greyEndtime != nil {
            map["GreyEndtime"] = self.greyEndtime!
        }
        if self.greyEndtimeData != nil {
            map["GreyEndtimeData"] = self.greyEndtimeData!
        }
        if self.greyEndtimeStr != nil {
            map["GreyEndtimeStr"] = self.greyEndtimeStr!
        }
        if self.greyNum != nil {
            map["GreyNum"] = self.greyNum!
        }
        if self.greyUrl != nil {
            map["GreyUrl"] = self.greyUrl!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.memo != nil {
            map["Memo"] = self.memo!
        }
        if self.modifier != nil {
            map["Modifier"] = self.modifier!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.percent != nil {
            map["Percent"] = self.percent!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.productId != nil {
            map["ProductId"] = self.productId!
        }
        if self.productVersion != nil {
            map["ProductVersion"] = self.productVersion!
        }
        if self.publishMode != nil {
            map["PublishMode"] = self.publishMode!
        }
        if self.publishType != nil {
            map["PublishType"] = self.publishType!
        }
        if self.releaseVersion != nil {
            map["ReleaseVersion"] = self.releaseVersion!
        }
        if self.resIds != nil {
            map["ResIds"] = self.resIds!
        }
        if self.serialVersionUID != nil {
            map["SerialVersionUID"] = self.serialVersionUID!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.syncMode != nil {
            map["SyncMode"] = self.syncMode!
        }
        if self.syncResult != nil {
            map["SyncResult"] = self.syncResult!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.taskVersion != nil {
            map["TaskVersion"] = self.taskVersion!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.upgradeNoticeNum != nil {
            map["UpgradeNoticeNum"] = self.upgradeNoticeNum!
        }
        if self.upgradeProgress != nil {
            map["UpgradeProgress"] = self.upgradeProgress!
        }
        if self.whitelistIds != nil {
            map["WhitelistIds"] = self.whitelistIds!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("Creator") && dict["Creator"] != nil {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
            self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
        }
        if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
            self.greyConfigInfo = dict["GreyConfigInfo"] as! String
        }
        if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
            self.greyEndtime = dict["GreyEndtime"] as! String
        }
        if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
            self.greyEndtimeData = dict["GreyEndtimeData"] as! String
        }
        if dict.keys.contains("GreyEndtimeStr") && dict["GreyEndtimeStr"] != nil {
            self.greyEndtimeStr = dict["GreyEndtimeStr"] as! String
        }
        if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
            self.greyNum = dict["GreyNum"] as! Int32
        }
        if dict.keys.contains("GreyUrl") && dict["GreyUrl"] != nil {
            self.greyUrl = dict["GreyUrl"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Memo") && dict["Memo"] != nil {
            self.memo = dict["Memo"] as! String
        }
        if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
            self.modifier = dict["Modifier"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! Int64
        }
        if dict.keys.contains("Percent") && dict["Percent"] != nil {
            self.percent = dict["Percent"] as! Int32
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
            self.productId = dict["ProductId"] as! String
        }
        if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
            self.productVersion = dict["ProductVersion"] as! String
        }
        if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
            self.publishMode = dict["PublishMode"] as! Int32
        }
        if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
            self.publishType = dict["PublishType"] as! Int32
        }
        if dict.keys.contains("ReleaseVersion") && dict["ReleaseVersion"] != nil {
            self.releaseVersion = dict["ReleaseVersion"] as! String
        }
        if dict.keys.contains("ResIds") && dict["ResIds"] != nil {
            self.resIds = dict["ResIds"] as! String
        }
        if dict.keys.contains("SerialVersionUID") && dict["SerialVersionUID"] != nil {
            self.serialVersionUID = dict["SerialVersionUID"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SyncMode") && dict["SyncMode"] != nil {
            self.syncMode = dict["SyncMode"] as! String
        }
        if dict.keys.contains("SyncResult") && dict["SyncResult"] != nil {
            self.syncResult = dict["SyncResult"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
            self.taskStatus = dict["TaskStatus"] as! Int32
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! Int32
        }
        if dict.keys.contains("TaskVersion") && dict["TaskVersion"] != nil {
            self.taskVersion = dict["TaskVersion"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UpgradeNoticeNum") && dict["UpgradeNoticeNum"] != nil {
            self.upgradeNoticeNum = dict["UpgradeNoticeNum"] as! Int64
        }
        if dict.keys.contains("UpgradeProgress") && dict["UpgradeProgress"] != nil {
            self.upgradeProgress = dict["UpgradeProgress"] as! String
        }
        if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
            self.whitelistIds = dict["WhitelistIds"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeNebulaTaskResponseBody : Tea.TeaModel {
    public class CreateMcubeNebulaTaskResult : Tea.TeaModel {
        public var errorCode: String?

        public var nebulaTaskId: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.nebulaTaskId != nil {
                map["NebulaTaskId"] = self.nebulaTaskId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("NebulaTaskId") && dict["NebulaTaskId"] != nil {
                self.nebulaTaskId = dict["NebulaTaskId"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createMcubeNebulaTaskResult: CreateMcubeNebulaTaskResponseBody.CreateMcubeNebulaTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createMcubeNebulaTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMcubeNebulaTaskResult != nil {
            map["CreateMcubeNebulaTaskResult"] = self.createMcubeNebulaTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMcubeNebulaTaskResult") && dict["CreateMcubeNebulaTaskResult"] != nil {
            var model = CreateMcubeNebulaTaskResponseBody.CreateMcubeNebulaTaskResult()
            model.fromMap(dict["CreateMcubeNebulaTaskResult"] as! [String: Any])
            self.createMcubeNebulaTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeNebulaTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeNebulaTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeNebulaTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeUpgradePackageRequest : Tea.TeaModel {
    public var appId: String?

    public var appVersion: String?

    public var appstoreUrl: String?

    public var bundleId: String?

    public var customDomainName: String?

    public var desc: String?

    public var downloadUrl: String?

    public var fileUrl: String?

    public var iconFileUrl: String?

    public var installAmount: Int32?

    public var iosSymbolfileUrl: String?

    public var isEnterprise: Int32?

    public var needCheck: Int32?

    public var onexFlag: Bool?

    public var platform: String?

    public var tenantId: String?

    public var validDays: Int32?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appVersion != nil {
            map["AppVersion"] = self.appVersion!
        }
        if self.appstoreUrl != nil {
            map["AppstoreUrl"] = self.appstoreUrl!
        }
        if self.bundleId != nil {
            map["BundleId"] = self.bundleId!
        }
        if self.customDomainName != nil {
            map["CustomDomainName"] = self.customDomainName!
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.downloadUrl != nil {
            map["DownloadUrl"] = self.downloadUrl!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.iconFileUrl != nil {
            map["IconFileUrl"] = self.iconFileUrl!
        }
        if self.installAmount != nil {
            map["InstallAmount"] = self.installAmount!
        }
        if self.iosSymbolfileUrl != nil {
            map["IosSymbolfileUrl"] = self.iosSymbolfileUrl!
        }
        if self.isEnterprise != nil {
            map["IsEnterprise"] = self.isEnterprise!
        }
        if self.needCheck != nil {
            map["NeedCheck"] = self.needCheck!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.validDays != nil {
            map["ValidDays"] = self.validDays!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
            self.appVersion = dict["AppVersion"] as! String
        }
        if dict.keys.contains("AppstoreUrl") && dict["AppstoreUrl"] != nil {
            self.appstoreUrl = dict["AppstoreUrl"] as! String
        }
        if dict.keys.contains("BundleId") && dict["BundleId"] != nil {
            self.bundleId = dict["BundleId"] as! String
        }
        if dict.keys.contains("CustomDomainName") && dict["CustomDomainName"] != nil {
            self.customDomainName = dict["CustomDomainName"] as! String
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
            self.downloadUrl = dict["DownloadUrl"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("IconFileUrl") && dict["IconFileUrl"] != nil {
            self.iconFileUrl = dict["IconFileUrl"] as! String
        }
        if dict.keys.contains("InstallAmount") && dict["InstallAmount"] != nil {
            self.installAmount = dict["InstallAmount"] as! Int32
        }
        if dict.keys.contains("IosSymbolfileUrl") && dict["IosSymbolfileUrl"] != nil {
            self.iosSymbolfileUrl = dict["IosSymbolfileUrl"] as! String
        }
        if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
            self.isEnterprise = dict["IsEnterprise"] as! Int32
        }
        if dict.keys.contains("NeedCheck") && dict["NeedCheck"] != nil {
            self.needCheck = dict["NeedCheck"] as! Int32
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("ValidDays") && dict["ValidDays"] != nil {
            self.validDays = dict["ValidDays"] as! Int32
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeUpgradePackageResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var data: String?

        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMcubeUpgradePackageResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMcubeUpgradePackageResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeUpgradePackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeUpgradePackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeUpgradePackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeUpgradeTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var greyConfigInfo: String?

    public var greyEndtimeData: String?

    public var greyNum: Int32?

    public var historyForce: Int32?

    public var memo: String?

    public var packageInfoId: Int64?

    public var publishMode: Int32?

    public var publishType: Int32?

    public var tenantId: String?

    public var upgradeContent: String?

    public var upgradeType: Int32?

    public var whitelistIds: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.greyConfigInfo != nil {
            map["GreyConfigInfo"] = self.greyConfigInfo!
        }
        if self.greyEndtimeData != nil {
            map["GreyEndtimeData"] = self.greyEndtimeData!
        }
        if self.greyNum != nil {
            map["GreyNum"] = self.greyNum!
        }
        if self.historyForce != nil {
            map["HistoryForce"] = self.historyForce!
        }
        if self.memo != nil {
            map["Memo"] = self.memo!
        }
        if self.packageInfoId != nil {
            map["PackageInfoId"] = self.packageInfoId!
        }
        if self.publishMode != nil {
            map["PublishMode"] = self.publishMode!
        }
        if self.publishType != nil {
            map["PublishType"] = self.publishType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.upgradeContent != nil {
            map["UpgradeContent"] = self.upgradeContent!
        }
        if self.upgradeType != nil {
            map["UpgradeType"] = self.upgradeType!
        }
        if self.whitelistIds != nil {
            map["WhitelistIds"] = self.whitelistIds!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
            self.greyConfigInfo = dict["GreyConfigInfo"] as! String
        }
        if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
            self.greyEndtimeData = dict["GreyEndtimeData"] as! String
        }
        if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
            self.greyNum = dict["GreyNum"] as! Int32
        }
        if dict.keys.contains("HistoryForce") && dict["HistoryForce"] != nil {
            self.historyForce = dict["HistoryForce"] as! Int32
        }
        if dict.keys.contains("Memo") && dict["Memo"] != nil {
            self.memo = dict["Memo"] as! String
        }
        if dict.keys.contains("PackageInfoId") && dict["PackageInfoId"] != nil {
            self.packageInfoId = dict["PackageInfoId"] as! Int64
        }
        if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
            self.publishMode = dict["PublishMode"] as! Int32
        }
        if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
            self.publishType = dict["PublishType"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UpgradeContent") && dict["UpgradeContent"] != nil {
            self.upgradeContent = dict["UpgradeContent"] as! String
        }
        if dict.keys.contains("UpgradeType") && dict["UpgradeType"] != nil {
            self.upgradeType = dict["UpgradeType"] as! Int32
        }
        if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
            self.whitelistIds = dict["WhitelistIds"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeUpgradeTaskResponseBody : Tea.TeaModel {
    public class CreateTaskResult : Tea.TeaModel {
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var upgradeTaskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.upgradeTaskId != nil {
                map["upgradeTaskId"] = self.upgradeTaskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("upgradeTaskId") && dict["upgradeTaskId"] != nil {
                self.upgradeTaskId = dict["upgradeTaskId"] as! String
            }
        }
    }
    public var createTaskResult: CreateMcubeUpgradeTaskResponseBody.CreateTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTaskResult != nil {
            map["CreateTaskResult"] = self.createTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTaskResult") && dict["CreateTaskResult"] != nil {
            var model = CreateMcubeUpgradeTaskResponseBody.CreateTaskResult()
            model.fromMap(dict["CreateTaskResult"] as! [String: Any])
            self.createTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeUpgradeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeUpgradeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeUpgradeTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeVhostRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var vhost: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.vhost != nil {
            map["Vhost"] = self.vhost!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Vhost") && dict["Vhost"] != nil {
            self.vhost = dict["Vhost"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeVhostResponseBody : Tea.TeaModel {
    public class CreateVhostResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var createVhostResult: CreateMcubeVhostResponseBody.CreateVhostResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createVhostResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createVhostResult != nil {
            map["CreateVhostResult"] = self.createVhostResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateVhostResult") && dict["CreateVhostResult"] != nil {
            var model = CreateMcubeVhostResponseBody.CreateVhostResult()
            model.fromMap(dict["CreateVhostResult"] as! [String: Any])
            self.createVhostResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeVhostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeVhostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeVhostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeWhitelistRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var whiteListName: String?

    public var whitelistType: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whiteListName != nil {
            map["WhiteListName"] = self.whiteListName!
        }
        if self.whitelistType != nil {
            map["WhitelistType"] = self.whitelistType!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhiteListName") && dict["WhiteListName"] != nil {
            self.whiteListName = dict["WhiteListName"] as! String
        }
        if dict.keys.contains("WhitelistType") && dict["WhitelistType"] != nil {
            self.whitelistType = dict["WhitelistType"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeWhitelistResponseBody : Tea.TeaModel {
    public class CreateWhitelistResult : Tea.TeaModel {
        public var resultMsg: String?

        public var success: Bool?

        public var whitelistId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.whitelistId != nil {
                map["WhitelistId"] = self.whitelistId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("WhitelistId") && dict["WhitelistId"] != nil {
                self.whitelistId = dict["WhitelistId"] as! String
            }
        }
    }
    public var createWhitelistResult: CreateMcubeWhitelistResponseBody.CreateWhitelistResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createWhitelistResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createWhitelistResult != nil {
            map["CreateWhitelistResult"] = self.createWhitelistResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateWhitelistResult") && dict["CreateWhitelistResult"] != nil {
            var model = CreateMcubeWhitelistResponseBody.CreateWhitelistResult()
            model.fromMap(dict["CreateWhitelistResult"] as! [String: Any])
            self.createWhitelistResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMcubeWhitelistForIdeRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var userId: String?

    public var whitelistValue: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.whitelistValue != nil {
            map["WhitelistValue"] = self.whitelistValue!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WhitelistValue") && dict["WhitelistValue"] != nil {
            self.whitelistValue = dict["WhitelistValue"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMcubeWhitelistForIdeResponseBody : Tea.TeaModel {
    public class CreateWhitelistForIdeResult : Tea.TeaModel {
        public var resultMsg: String?

        public var success: Bool?

        public var whitelistId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.whitelistId != nil {
                map["WhitelistId"] = self.whitelistId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("WhitelistId") && dict["WhitelistId"] != nil {
                self.whitelistId = dict["WhitelistId"] as! String
            }
        }
    }
    public var createWhitelistForIdeResult: CreateMcubeWhitelistForIdeResponseBody.CreateWhitelistForIdeResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createWhitelistForIdeResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createWhitelistForIdeResult != nil {
            map["CreateWhitelistForIdeResult"] = self.createWhitelistForIdeResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateWhitelistForIdeResult") && dict["CreateWhitelistForIdeResult"] != nil {
            var model = CreateMcubeWhitelistForIdeResponseBody.CreateWhitelistForIdeResult()
            model.fromMap(dict["CreateWhitelistForIdeResult"] as! [String: Any])
            self.createWhitelistForIdeResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMcubeWhitelistForIdeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMcubeWhitelistForIdeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMcubeWhitelistForIdeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMdsMiniprogramTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var greyConfigInfo: String?

    public var greyEndtimeData: String?

    public var greyNum: String?

    public var id: Int64?

    public var memo: String?

    public var packageId: Int64?

    public var publishMode: String?

    public var publishType: Int64?

    public var syncMode: String?

    public var tenantId: String?

    public var whitelistIds: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.greyConfigInfo != nil {
            map["GreyConfigInfo"] = self.greyConfigInfo!
        }
        if self.greyEndtimeData != nil {
            map["GreyEndtimeData"] = self.greyEndtimeData!
        }
        if self.greyNum != nil {
            map["GreyNum"] = self.greyNum!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.memo != nil {
            map["Memo"] = self.memo!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.publishMode != nil {
            map["PublishMode"] = self.publishMode!
        }
        if self.publishType != nil {
            map["PublishType"] = self.publishType!
        }
        if self.syncMode != nil {
            map["SyncMode"] = self.syncMode!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whitelistIds != nil {
            map["WhitelistIds"] = self.whitelistIds!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
            self.greyConfigInfo = dict["GreyConfigInfo"] as! String
        }
        if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
            self.greyEndtimeData = dict["GreyEndtimeData"] as! String
        }
        if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
            self.greyNum = dict["GreyNum"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Memo") && dict["Memo"] != nil {
            self.memo = dict["Memo"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! Int64
        }
        if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
            self.publishMode = dict["PublishMode"] as! String
        }
        if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
            self.publishType = dict["PublishType"] as! Int64
        }
        if dict.keys.contains("SyncMode") && dict["SyncMode"] != nil {
            self.syncMode = dict["SyncMode"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
            self.whitelistIds = dict["WhitelistIds"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMdsMiniprogramTaskResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var content: String?

            public var errorCode: String?

            public var requestId: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: CreateMdsMiniprogramTaskResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = CreateMdsMiniprogramTaskResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMdsMiniprogramTaskResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMdsMiniprogramTaskResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMdsMiniprogramTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMdsMiniprogramTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMdsMiniprogramTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMsaEnhanceRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMsaEnhanceCreateJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMsaEnhanceCreateJsonStr != nil {
            map["MpaasMappcenterMsaEnhanceCreateJsonStr"] = self.mpaasMappcenterMsaEnhanceCreateJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMsaEnhanceCreateJsonStr") && dict["MpaasMappcenterMsaEnhanceCreateJsonStr"] != nil {
            self.mpaasMappcenterMsaEnhanceCreateJsonStr = dict["MpaasMappcenterMsaEnhanceCreateJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateMsaEnhanceResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: CreateMsaEnhanceResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = CreateMsaEnhanceResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateMsaEnhanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMsaEnhanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMsaEnhanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOpenGlobalDataRequest : Tea.TeaModel {
    public var appId: String?

    public var appMaxVersion: String?

    public var appMinVersion: String?

    public var bizType: String?

    public var extAttrStr: String?

    public var maxUid: Int64?

    public var minUid: Int64?

    public var osType: String?

    public var payload: String?

    public var thirdMsgId: String?

    public var uids: String?

    public var validTimeEnd: Int64?

    public var validTimeStart: Int64?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appMaxVersion != nil {
            map["AppMaxVersion"] = self.appMaxVersion!
        }
        if self.appMinVersion != nil {
            map["AppMinVersion"] = self.appMinVersion!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.extAttrStr != nil {
            map["ExtAttrStr"] = self.extAttrStr!
        }
        if self.maxUid != nil {
            map["MaxUid"] = self.maxUid!
        }
        if self.minUid != nil {
            map["MinUid"] = self.minUid!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.payload != nil {
            map["Payload"] = self.payload!
        }
        if self.thirdMsgId != nil {
            map["ThirdMsgId"] = self.thirdMsgId!
        }
        if self.uids != nil {
            map["Uids"] = self.uids!
        }
        if self.validTimeEnd != nil {
            map["ValidTimeEnd"] = self.validTimeEnd!
        }
        if self.validTimeStart != nil {
            map["ValidTimeStart"] = self.validTimeStart!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppMaxVersion") && dict["AppMaxVersion"] != nil {
            self.appMaxVersion = dict["AppMaxVersion"] as! String
        }
        if dict.keys.contains("AppMinVersion") && dict["AppMinVersion"] != nil {
            self.appMinVersion = dict["AppMinVersion"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("ExtAttrStr") && dict["ExtAttrStr"] != nil {
            self.extAttrStr = dict["ExtAttrStr"] as! String
        }
        if dict.keys.contains("MaxUid") && dict["MaxUid"] != nil {
            self.maxUid = dict["MaxUid"] as! Int64
        }
        if dict.keys.contains("MinUid") && dict["MinUid"] != nil {
            self.minUid = dict["MinUid"] as! Int64
        }
        if dict.keys.contains("OsType") && dict["OsType"] != nil {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("Payload") && dict["Payload"] != nil {
            self.payload = dict["Payload"] as! String
        }
        if dict.keys.contains("ThirdMsgId") && dict["ThirdMsgId"] != nil {
            self.thirdMsgId = dict["ThirdMsgId"] as! String
        }
        if dict.keys.contains("Uids") && dict["Uids"] != nil {
            self.uids = dict["Uids"] as! String
        }
        if dict.keys.contains("ValidTimeEnd") && dict["ValidTimeEnd"] != nil {
            self.validTimeEnd = dict["ValidTimeEnd"] as! Int64
        }
        if dict.keys.contains("ValidTimeStart") && dict["ValidTimeStart"] != nil {
            self.validTimeStart = dict["ValidTimeStart"] as! Int64
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateOpenGlobalDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateOpenGlobalDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOpenGlobalDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOpenGlobalDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOpenSingleDataRequest : Tea.TeaModel {
    public var appId: String?

    public var appMaxVersion: String?

    public var appMinVersion: String?

    public var bizType: String?

    public var checkOnline: Bool?

    public var extAttrStr: String?

    public var linkToken: String?

    public var osType: String?

    public var payload: String?

    public var thirdMsgId: String?

    public var validTimeEnd: Int64?

    public var validTimeStart: Int64?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appMaxVersion != nil {
            map["AppMaxVersion"] = self.appMaxVersion!
        }
        if self.appMinVersion != nil {
            map["AppMinVersion"] = self.appMinVersion!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.checkOnline != nil {
            map["CheckOnline"] = self.checkOnline!
        }
        if self.extAttrStr != nil {
            map["ExtAttrStr"] = self.extAttrStr!
        }
        if self.linkToken != nil {
            map["LinkToken"] = self.linkToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.payload != nil {
            map["Payload"] = self.payload!
        }
        if self.thirdMsgId != nil {
            map["ThirdMsgId"] = self.thirdMsgId!
        }
        if self.validTimeEnd != nil {
            map["ValidTimeEnd"] = self.validTimeEnd!
        }
        if self.validTimeStart != nil {
            map["ValidTimeStart"] = self.validTimeStart!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppMaxVersion") && dict["AppMaxVersion"] != nil {
            self.appMaxVersion = dict["AppMaxVersion"] as! String
        }
        if dict.keys.contains("AppMinVersion") && dict["AppMinVersion"] != nil {
            self.appMinVersion = dict["AppMinVersion"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("CheckOnline") && dict["CheckOnline"] != nil {
            self.checkOnline = dict["CheckOnline"] as! Bool
        }
        if dict.keys.contains("ExtAttrStr") && dict["ExtAttrStr"] != nil {
            self.extAttrStr = dict["ExtAttrStr"] as! String
        }
        if dict.keys.contains("LinkToken") && dict["LinkToken"] != nil {
            self.linkToken = dict["LinkToken"] as! String
        }
        if dict.keys.contains("OsType") && dict["OsType"] != nil {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("Payload") && dict["Payload"] != nil {
            self.payload = dict["Payload"] as! String
        }
        if dict.keys.contains("ThirdMsgId") && dict["ThirdMsgId"] != nil {
            self.thirdMsgId = dict["ThirdMsgId"] as! String
        }
        if dict.keys.contains("ValidTimeEnd") && dict["ValidTimeEnd"] != nil {
            self.validTimeEnd = dict["ValidTimeEnd"] as! Int64
        }
        if dict.keys.contains("ValidTimeStart") && dict["ValidTimeStart"] != nil {
            self.validTimeStart = dict["ValidTimeStart"] as! Int64
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class CreateOpenSingleDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class CreateOpenSingleDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOpenSingleDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOpenSingleDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCubecardWhitelistContentRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var whitelistId: String?

    public var whitelistValue: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whitelistId != nil {
            map["WhitelistId"] = self.whitelistId!
        }
        if self.whitelistValue != nil {
            map["WhitelistValue"] = self.whitelistValue!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhitelistId") && dict["WhitelistId"] != nil {
            self.whitelistId = dict["WhitelistId"] as! String
        }
        if dict.keys.contains("WhitelistValue") && dict["WhitelistValue"] != nil {
            self.whitelistValue = dict["WhitelistValue"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteCubecardWhitelistContentResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var content: String?

            public var errorCode: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: DeleteCubecardWhitelistContentResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = DeleteCubecardWhitelistContentResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteCubecardWhitelistContentResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteCubecardWhitelistContentResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteCubecardWhitelistContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCubecardWhitelistContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCubecardWhitelistContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpAimRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpAimDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpAimDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpAimDeleteJsonStr"] = self.mpaasMappcenterMcdpAimDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpAimDeleteJsonStr") && dict["MpaasMappcenterMcdpAimDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpAimDeleteJsonStr = dict["MpaasMappcenterMcdpAimDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpAimResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpAimResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpAimResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpAimResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpAimResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpAimResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpCrowdRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpCrowdDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpCrowdDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpCrowdDeleteJsonStr"] = self.mpaasMappcenterMcdpCrowdDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpCrowdDeleteJsonStr") && dict["MpaasMappcenterMcdpCrowdDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpCrowdDeleteJsonStr = dict["MpaasMappcenterMcdpCrowdDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpCrowdResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpCrowdResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpCrowdResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpCrowdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpCrowdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpCrowdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpEventAttributeByIdRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpEventAttributeDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpEventAttributeDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"] = self.mpaasMappcenterMcdpEventAttributeDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpEventAttributeDeleteJsonStr") && dict["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpEventAttributeDeleteJsonStr = dict["MpaasMappcenterMcdpEventAttributeDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpEventAttributeByIdResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpEventAttributeByIdResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpEventAttributeByIdResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpEventAttributeByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpEventAttributeByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpEventAttributeByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpEventByIdRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpEventDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpEventDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpEventDeleteJsonStr"] = self.mpaasMappcenterMcdpEventDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpEventDeleteJsonStr") && dict["MpaasMappcenterMcdpEventDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpEventDeleteJsonStr = dict["MpaasMappcenterMcdpEventDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpEventByIdResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpEventByIdResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpEventByIdResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpEventByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpEventByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpEventByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpMaterialRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpMaterialDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpMaterialDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpMaterialDeleteJsonStr"] = self.mpaasMappcenterMcdpMaterialDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpMaterialDeleteJsonStr") && dict["MpaasMappcenterMcdpMaterialDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpMaterialDeleteJsonStr = dict["MpaasMappcenterMcdpMaterialDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpMaterialResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpMaterialResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpMaterialResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpMaterialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpMaterialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpMaterialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcdpZoneRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMcdpZoneDeleteJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMcdpZoneDeleteJsonStr != nil {
            map["MpaasMappcenterMcdpZoneDeleteJsonStr"] = self.mpaasMappcenterMcdpZoneDeleteJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMcdpZoneDeleteJsonStr") && dict["MpaasMappcenterMcdpZoneDeleteJsonStr"] != nil {
            self.mpaasMappcenterMcdpZoneDeleteJsonStr = dict["MpaasMappcenterMcdpZoneDeleteJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcdpZoneResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMcdpZoneResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMcdpZoneResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcdpZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcdpZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcdpZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcubeMiniAppRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcubeMiniAppResponseBody : Tea.TeaModel {
    public class DeleteMiniResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var deleteMiniResult: DeleteMcubeMiniAppResponseBody.DeleteMiniResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteMiniResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteMiniResult != nil {
            map["DeleteMiniResult"] = self.deleteMiniResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteMiniResult") && dict["DeleteMiniResult"] != nil {
            var model = DeleteMcubeMiniAppResponseBody.DeleteMiniResult()
            model.fromMap(dict["DeleteMiniResult"] as! [String: Any])
            self.deleteMiniResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcubeMiniAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcubeMiniAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcubeMiniAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcubeNebulaAppRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcubeNebulaAppResponseBody : Tea.TeaModel {
    public class DeleteMcubeNebulaAppResult : Tea.TeaModel {
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var deleteMcubeNebulaAppResult: DeleteMcubeNebulaAppResponseBody.DeleteMcubeNebulaAppResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteMcubeNebulaAppResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteMcubeNebulaAppResult != nil {
            map["DeleteMcubeNebulaAppResult"] = self.deleteMcubeNebulaAppResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteMcubeNebulaAppResult") && dict["DeleteMcubeNebulaAppResult"] != nil {
            var model = DeleteMcubeNebulaAppResponseBody.DeleteMcubeNebulaAppResult()
            model.fromMap(dict["DeleteMcubeNebulaAppResult"] as! [String: Any])
            self.deleteMcubeNebulaAppResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcubeNebulaAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcubeNebulaAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcubeNebulaAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcubeUpgradeResourceRequest : Tea.TeaModel {
    public var appId: String?

    public var id: String?

    public var platform: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcubeUpgradeResourceResponseBody : Tea.TeaModel {
    public class DeleteResult : Tea.TeaModel {
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var deleteResult: DeleteMcubeUpgradeResourceResponseBody.DeleteResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteResult != nil {
            map["DeleteResult"] = self.deleteResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteResult") && dict["DeleteResult"] != nil {
            var model = DeleteMcubeUpgradeResourceResponseBody.DeleteResult()
            model.fromMap(dict["DeleteResult"] as! [String: Any])
            self.deleteResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcubeUpgradeResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcubeUpgradeResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcubeUpgradeResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMcubeWhitelistRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMcubeWhitelistResponseBody : Tea.TeaModel {
    public class DeleteWhitelistResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var deleteWhitelistResult: DeleteMcubeWhitelistResponseBody.DeleteWhitelistResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deleteWhitelistResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWhitelistResult != nil {
            map["DeleteWhitelistResult"] = self.deleteWhitelistResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteWhitelistResult") && dict["DeleteWhitelistResult"] != nil {
            var model = DeleteMcubeWhitelistResponseBody.DeleteWhitelistResult()
            model.fromMap(dict["DeleteWhitelistResult"] as! [String: Any])
            self.deleteWhitelistResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMcubeWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMcubeWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMcubeWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMdsWhitelistContentRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var whitelistId: String?

    public var whitelistValue: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whitelistId != nil {
            map["WhitelistId"] = self.whitelistId!
        }
        if self.whitelistValue != nil {
            map["WhitelistValue"] = self.whitelistValue!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhitelistId") && dict["WhitelistId"] != nil {
            self.whitelistId = dict["WhitelistId"] as! String
        }
        if dict.keys.contains("WhitelistValue") && dict["WhitelistValue"] != nil {
            self.whitelistValue = dict["WhitelistValue"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class DeleteMdsWhitelistContentResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var content: String?

            public var errorCode: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: DeleteMdsWhitelistContentResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = DeleteMdsWhitelistContentResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: DeleteMdsWhitelistContentResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = DeleteMdsWhitelistContentResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class DeleteMdsWhitelistContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMdsWhitelistContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMdsWhitelistContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExistMcubeRsaKeyRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ExistMcubeRsaKeyResponseBody : Tea.TeaModel {
    public class CheckRsaKeyResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var checkRsaKeyResult: ExistMcubeRsaKeyResponseBody.CheckRsaKeyResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkRsaKeyResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkRsaKeyResult != nil {
            map["CheckRsaKeyResult"] = self.checkRsaKeyResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckRsaKeyResult") && dict["CheckRsaKeyResult"] != nil {
            var model = ExistMcubeRsaKeyResponseBody.CheckRsaKeyResult()
            model.fromMap(dict["CheckRsaKeyResult"] as! [String: Any])
            self.checkRsaKeyResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ExistMcubeRsaKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExistMcubeRsaKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExistMcubeRsaKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportMappCenterAppConfigRequest : Tea.TeaModel {
    public var apkFileUrl: String?

    public var appId: String?

    public var certRsaBase64: String?

    public var identifier: String?

    public var onexFlag: Bool?

    public var systemType: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apkFileUrl != nil {
            map["ApkFileUrl"] = self.apkFileUrl!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.certRsaBase64 != nil {
            map["CertRsaBase64"] = self.certRsaBase64!
        }
        if self.identifier != nil {
            map["Identifier"] = self.identifier!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApkFileUrl") && dict["ApkFileUrl"] != nil {
            self.apkFileUrl = dict["ApkFileUrl"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CertRsaBase64") && dict["CertRsaBase64"] != nil {
            self.certRsaBase64 = dict["CertRsaBase64"] as! String
        }
        if dict.keys.contains("Identifier") && dict["Identifier"] != nil {
            self.identifier = dict["Identifier"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("SystemType") && dict["SystemType"] != nil {
            self.systemType = dict["SystemType"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ExportMappCenterAppConfigResponseBody : Tea.TeaModel {
    public class ExportMappCenterAppConfigResult : Tea.TeaModel {
        public var configDownloadUrl: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configDownloadUrl != nil {
                map["ConfigDownloadUrl"] = self.configDownloadUrl!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigDownloadUrl") && dict["ConfigDownloadUrl"] != nil {
                self.configDownloadUrl = dict["ConfigDownloadUrl"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var exportMappCenterAppConfigResult: ExportMappCenterAppConfigResponseBody.ExportMappCenterAppConfigResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.exportMappCenterAppConfigResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportMappCenterAppConfigResult != nil {
            map["ExportMappCenterAppConfigResult"] = self.exportMappCenterAppConfigResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportMappCenterAppConfigResult") && dict["ExportMappCenterAppConfigResult"] != nil {
            var model = ExportMappCenterAppConfigResponseBody.ExportMappCenterAppConfigResult()
            model.fromMap(dict["ExportMappCenterAppConfigResult"] as! [String: Any])
            self.exportMappCenterAppConfigResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ExportMappCenterAppConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportMappCenterAppConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportMappCenterAppConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileTokenForUploadToMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var onexFlag: Bool?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetFileTokenForUploadToMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var accessid: String?

            public var dir: String?

            public var expire: String?

            public var host: String?

            public var policy: String?

            public var signature: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessid != nil {
                    map["Accessid"] = self.accessid!
                }
                if self.dir != nil {
                    map["Dir"] = self.dir!
                }
                if self.expire != nil {
                    map["Expire"] = self.expire!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.signature != nil {
                    map["Signature"] = self.signature!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Accessid") && dict["Accessid"] != nil {
                    self.accessid = dict["Accessid"] as! String
                }
                if dict.keys.contains("Dir") && dict["Dir"] != nil {
                    self.dir = dict["Dir"] as! String
                }
                if dict.keys.contains("Expire") && dict["Expire"] != nil {
                    self.expire = dict["Expire"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("Signature") && dict["Signature"] != nil {
                    self.signature = dict["Signature"] as! String
                }
            }
        }
        public var content: GetFileTokenForUploadToMsaResponseBody.ResultContent.Content?

        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") && dict["Content"] != nil {
                var model = GetFileTokenForUploadToMsaResponseBody.ResultContent.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetFileTokenForUploadToMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetFileTokenForUploadToMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetFileTokenForUploadToMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileTokenForUploadToMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileTokenForUploadToMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLogUrlInMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetLogUrlInMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetLogUrlInMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetLogUrlInMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetLogUrlInMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLogUrlInMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLogUrlInMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMcubeFileTokenRequest : Tea.TeaModel {
    public var appId: String?

    public var onexFlag: Bool?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMcubeFileTokenResponseBody : Tea.TeaModel {
    public class GetFileTokenResult : Tea.TeaModel {
        public class FileToken : Tea.TeaModel {
            public var accessid: String?

            public var dir: String?

            public var expire: String?

            public var host: String?

            public var policy: String?

            public var signature: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessid != nil {
                    map["Accessid"] = self.accessid!
                }
                if self.dir != nil {
                    map["Dir"] = self.dir!
                }
                if self.expire != nil {
                    map["Expire"] = self.expire!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.signature != nil {
                    map["Signature"] = self.signature!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Accessid") && dict["Accessid"] != nil {
                    self.accessid = dict["Accessid"] as! String
                }
                if dict.keys.contains("Dir") && dict["Dir"] != nil {
                    self.dir = dict["Dir"] as! String
                }
                if dict.keys.contains("Expire") && dict["Expire"] != nil {
                    self.expire = dict["Expire"] as! String
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("Signature") && dict["Signature"] != nil {
                    self.signature = dict["Signature"] as! String
                }
            }
        }
        public var fileToken: GetMcubeFileTokenResponseBody.GetFileTokenResult.FileToken?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fileToken?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileToken != nil {
                map["FileToken"] = self.fileToken?.toMap()
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileToken") && dict["FileToken"] != nil {
                var model = GetMcubeFileTokenResponseBody.GetFileTokenResult.FileToken()
                model.fromMap(dict["FileToken"] as! [String: Any])
                self.fileToken = model
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var getFileTokenResult: GetMcubeFileTokenResponseBody.GetFileTokenResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.getFileTokenResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.getFileTokenResult != nil {
            map["GetFileTokenResult"] = self.getFileTokenResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GetFileTokenResult") && dict["GetFileTokenResult"] != nil {
            var model = GetMcubeFileTokenResponseBody.GetFileTokenResult()
            model.fromMap(dict["GetFileTokenResult"] as! [String: Any])
            self.getFileTokenResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMcubeFileTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMcubeFileTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMcubeFileTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMcubeNebulaResourceRequest : Tea.TeaModel {
    public var appId: String?

    public var id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMcubeNebulaResourceResponseBody : Tea.TeaModel {
    public class GetNebulaResourceResult : Tea.TeaModel {
        public class NebulaResourceInfo : Tea.TeaModel {
            public var appCode: String?

            public var autoInstall: Int32?

            public var clientVersionMax: String?

            public var clientVersionMin: String?

            public var creator: String?

            public var downloadUrl: String?

            public var extendInfo: String?

            public var extraData: String?

            public var fallbackBaseUrl: String?

            public var fileSize: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var h5Id: String?

            public var h5Name: String?

            public var h5Version: String?

            public var id: Int64?

            public var installType: Int32?

            public var mainUrl: String?

            public var memo: String?

            public var metaId: Int64?

            public var modifier: String?

            public var packageType: Int32?

            public var platform: String?

            public var publishPeriod: Int32?

            public var resourceType: String?

            public var status: Int32?

            public var vhost: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.autoInstall != nil {
                    map["AutoInstall"] = self.autoInstall!
                }
                if self.clientVersionMax != nil {
                    map["ClientVersionMax"] = self.clientVersionMax!
                }
                if self.clientVersionMin != nil {
                    map["ClientVersionMin"] = self.clientVersionMin!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.extraData != nil {
                    map["ExtraData"] = self.extraData!
                }
                if self.fallbackBaseUrl != nil {
                    map["FallbackBaseUrl"] = self.fallbackBaseUrl!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                if self.h5Version != nil {
                    map["H5Version"] = self.h5Version!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.installType != nil {
                    map["InstallType"] = self.installType!
                }
                if self.mainUrl != nil {
                    map["MainUrl"] = self.mainUrl!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.metaId != nil {
                    map["MetaId"] = self.metaId!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vhost != nil {
                    map["Vhost"] = self.vhost!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
                    self.autoInstall = dict["AutoInstall"] as! Int32
                }
                if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
                    self.clientVersionMax = dict["ClientVersionMax"] as! String
                }
                if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
                    self.clientVersionMin = dict["ClientVersionMin"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                    self.extraData = dict["ExtraData"] as! String
                }
                if dict.keys.contains("FallbackBaseUrl") && dict["FallbackBaseUrl"] != nil {
                    self.fallbackBaseUrl = dict["FallbackBaseUrl"] as! String
                }
                if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
                if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
                    self.h5Version = dict["H5Version"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
                    self.installType = dict["InstallType"] as! Int32
                }
                if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
                    self.mainUrl = dict["MainUrl"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("MetaId") && dict["MetaId"] != nil {
                    self.metaId = dict["MetaId"] as! Int64
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! Int32
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int32
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Vhost") && dict["Vhost"] != nil {
                    self.vhost = dict["Vhost"] as! String
                }
            }
        }
        public var errorCode: String?

        public var nebulaResourceInfo: GetMcubeNebulaResourceResponseBody.GetNebulaResourceResult.NebulaResourceInfo?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.nebulaResourceInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.nebulaResourceInfo != nil {
                map["NebulaResourceInfo"] = self.nebulaResourceInfo?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("NebulaResourceInfo") && dict["NebulaResourceInfo"] != nil {
                var model = GetMcubeNebulaResourceResponseBody.GetNebulaResourceResult.NebulaResourceInfo()
                model.fromMap(dict["NebulaResourceInfo"] as! [String: Any])
                self.nebulaResourceInfo = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var getNebulaResourceResult: GetMcubeNebulaResourceResponseBody.GetNebulaResourceResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.getNebulaResourceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.getNebulaResourceResult != nil {
            map["GetNebulaResourceResult"] = self.getNebulaResourceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GetNebulaResourceResult") && dict["GetNebulaResourceResult"] != nil {
            var model = GetMcubeNebulaResourceResponseBody.GetNebulaResourceResult()
            model.fromMap(dict["GetNebulaResourceResult"] as! [String: Any])
            self.getNebulaResourceResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMcubeNebulaResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMcubeNebulaResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMcubeNebulaResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMcubeNebulaTaskDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMcubeNebulaTaskDetailResponseBody : Tea.TeaModel {
    public class GetMcubeNebulaTaskDetailResult : Tea.TeaModel {
        public class NebulaTaskDetail : Tea.TeaModel {
            public class RuleJsonList : Tea.TeaModel {
                public var operation: String?

                public var ruleElement: String?

                public var ruleType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operation != nil {
                        map["Operation"] = self.operation!
                    }
                    if self.ruleElement != nil {
                        map["RuleElement"] = self.ruleElement!
                    }
                    if self.ruleType != nil {
                        map["RuleType"] = self.ruleType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operation") && dict["Operation"] != nil {
                        self.operation = dict["Operation"] as! String
                    }
                    if dict.keys.contains("RuleElement") && dict["RuleElement"] != nil {
                        self.ruleElement = dict["RuleElement"] as! String
                    }
                    if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                        self.ruleType = dict["RuleType"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appCode: String?

            public var appId: String?

            public var atomic: Int32?

            public var baseInfoId: Int64?

            public var bizType: String?

            public var creator: String?

            public var cronexpress: Int32?

            public var downloadUrl: String?

            public var extraData: String?

            public var fileSize: String?

            public var fullRepair: Int32?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var gmtModifiedStr: String?

            public var greyConfigInfo: String?

            public var greyEndtime: String?

            public var greyEndtimeData: String?

            public var greyEndtimeStr: String?

            public var greyNum: Int32?

            public var greyUrl: String?

            public var id: Int64?

            public var issueDesc: String?

            public var memo: String?

            public var modifier: String?

            public var ossPath: String?

            public var packageId: Int64?

            public var percent: Int32?

            public var platform: String?

            public var productId: String?

            public var productVersion: String?

            public var publishMode: Int32?

            public var publishPeriod: Int32?

            public var publishType: Int32?

            public var quickRollback: Int32?

            public var releaseVersion: String?

            public var ruleJsonList: [GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult.NebulaTaskDetail.RuleJsonList]?

            public var sourceId: String?

            public var sourceName: String?

            public var sourceType: String?

            public var status: Int32?

            public var syncResult: String?

            public var syncType: Int32?

            public var taskName: String?

            public var taskStatus: Int32?

            public var taskType: Int32?

            public var taskVersion: Int64?

            public var upgradeNoticeNum: Int64?

            public var upgradeProgress: String?

            public var whitelistIds: String?

            public var workspaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.atomic != nil {
                    map["Atomic"] = self.atomic!
                }
                if self.baseInfoId != nil {
                    map["BaseInfoId"] = self.baseInfoId!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.cronexpress != nil {
                    map["Cronexpress"] = self.cronexpress!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.extraData != nil {
                    map["ExtraData"] = self.extraData!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.fullRepair != nil {
                    map["FullRepair"] = self.fullRepair!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.gmtModifiedStr != nil {
                    map["GmtModifiedStr"] = self.gmtModifiedStr!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtime != nil {
                    map["GreyEndtime"] = self.greyEndtime!
                }
                if self.greyEndtimeData != nil {
                    map["GreyEndtimeData"] = self.greyEndtimeData!
                }
                if self.greyEndtimeStr != nil {
                    map["GreyEndtimeStr"] = self.greyEndtimeStr!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.greyUrl != nil {
                    map["GreyUrl"] = self.greyUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.issueDesc != nil {
                    map["IssueDesc"] = self.issueDesc!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.ossPath != nil {
                    map["OssPath"] = self.ossPath!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.quickRollback != nil {
                    map["QuickRollback"] = self.quickRollback!
                }
                if self.releaseVersion != nil {
                    map["ReleaseVersion"] = self.releaseVersion!
                }
                if self.ruleJsonList != nil {
                    var tmp : [Any] = []
                    for k in self.ruleJsonList! {
                        tmp.append(k.toMap())
                    }
                    map["RuleJsonList"] = tmp
                }
                if self.sourceId != nil {
                    map["SourceId"] = self.sourceId!
                }
                if self.sourceName != nil {
                    map["SourceName"] = self.sourceName!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.syncResult != nil {
                    map["SyncResult"] = self.syncResult!
                }
                if self.syncType != nil {
                    map["SyncType"] = self.syncType!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.taskVersion != nil {
                    map["TaskVersion"] = self.taskVersion!
                }
                if self.upgradeNoticeNum != nil {
                    map["UpgradeNoticeNum"] = self.upgradeNoticeNum!
                }
                if self.upgradeProgress != nil {
                    map["UpgradeProgress"] = self.upgradeProgress!
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("Atomic") && dict["Atomic"] != nil {
                    self.atomic = dict["Atomic"] as! Int32
                }
                if dict.keys.contains("BaseInfoId") && dict["BaseInfoId"] != nil {
                    self.baseInfoId = dict["BaseInfoId"] as! Int64
                }
                if dict.keys.contains("BizType") && dict["BizType"] != nil {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Cronexpress") && dict["Cronexpress"] != nil {
                    self.cronexpress = dict["Cronexpress"] as! Int32
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                    self.extraData = dict["ExtraData"] as! String
                }
                if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("FullRepair") && dict["FullRepair"] != nil {
                    self.fullRepair = dict["FullRepair"] as! Int32
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
                    self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
                    self.greyEndtime = dict["GreyEndtime"] as! String
                }
                if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                    self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                }
                if dict.keys.contains("GreyEndtimeStr") && dict["GreyEndtimeStr"] != nil {
                    self.greyEndtimeStr = dict["GreyEndtimeStr"] as! String
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int32
                }
                if dict.keys.contains("GreyUrl") && dict["GreyUrl"] != nil {
                    self.greyUrl = dict["GreyUrl"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IssueDesc") && dict["IssueDesc"] != nil {
                    self.issueDesc = dict["IssueDesc"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("OssPath") && dict["OssPath"] != nil {
                    self.ossPath = dict["OssPath"] as! String
                }
                if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
                    self.packageId = dict["PackageId"] as! Int64
                }
                if dict.keys.contains("Percent") && dict["Percent"] != nil {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int32
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int32
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int32
                }
                if dict.keys.contains("QuickRollback") && dict["QuickRollback"] != nil {
                    self.quickRollback = dict["QuickRollback"] as! Int32
                }
                if dict.keys.contains("ReleaseVersion") && dict["ReleaseVersion"] != nil {
                    self.releaseVersion = dict["ReleaseVersion"] as! String
                }
                if dict.keys.contains("RuleJsonList") && dict["RuleJsonList"] != nil {
                    var tmp : [GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult.NebulaTaskDetail.RuleJsonList] = []
                    for v in dict["RuleJsonList"] as! [Any] {
                        var model = GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult.NebulaTaskDetail.RuleJsonList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ruleJsonList = tmp
                }
                if dict.keys.contains("SourceId") && dict["SourceId"] != nil {
                    self.sourceId = dict["SourceId"] as! String
                }
                if dict.keys.contains("SourceName") && dict["SourceName"] != nil {
                    self.sourceName = dict["SourceName"] as! String
                }
                if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SyncResult") && dict["SyncResult"] != nil {
                    self.syncResult = dict["SyncResult"] as! String
                }
                if dict.keys.contains("SyncType") && dict["SyncType"] != nil {
                    self.syncType = dict["SyncType"] as! Int32
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int32
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! Int32
                }
                if dict.keys.contains("TaskVersion") && dict["TaskVersion"] != nil {
                    self.taskVersion = dict["TaskVersion"] as! Int64
                }
                if dict.keys.contains("UpgradeNoticeNum") && dict["UpgradeNoticeNum"] != nil {
                    self.upgradeNoticeNum = dict["UpgradeNoticeNum"] as! Int64
                }
                if dict.keys.contains("UpgradeProgress") && dict["UpgradeProgress"] != nil {
                    self.upgradeProgress = dict["UpgradeProgress"] as! String
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
            }
        }
        public var errorCode: String?

        public var nebulaTaskDetail: GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult.NebulaTaskDetail?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.nebulaTaskDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.nebulaTaskDetail != nil {
                map["NebulaTaskDetail"] = self.nebulaTaskDetail?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("NebulaTaskDetail") && dict["NebulaTaskDetail"] != nil {
                var model = GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult.NebulaTaskDetail()
                model.fromMap(dict["NebulaTaskDetail"] as! [String: Any])
                self.nebulaTaskDetail = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var getMcubeNebulaTaskDetailResult: GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.getMcubeNebulaTaskDetailResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.getMcubeNebulaTaskDetailResult != nil {
            map["GetMcubeNebulaTaskDetailResult"] = self.getMcubeNebulaTaskDetailResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GetMcubeNebulaTaskDetailResult") && dict["GetMcubeNebulaTaskDetailResult"] != nil {
            var model = GetMcubeNebulaTaskDetailResponseBody.GetMcubeNebulaTaskDetailResult()
            model.fromMap(dict["GetMcubeNebulaTaskDetailResult"] as! [String: Any])
            self.getMcubeNebulaTaskDetailResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMcubeNebulaTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMcubeNebulaTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMcubeNebulaTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMcubeUpgradePackageInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var packageId: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMcubeUpgradePackageInfoResponseBody : Tea.TeaModel {
    public class GetPackageResult : Tea.TeaModel {
        public class PackageInfo : Tea.TeaModel {
            public class MobileTestFlightConfigDO : Tea.TeaModel {
                public var gmtCreate: String?

                public var gmtModified: String?

                public var id: Int64?

                public var installAmount: Int32?

                public var invalidTime: String?

                public var upgradeId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.installAmount != nil {
                        map["InstallAmount"] = self.installAmount!
                    }
                    if self.invalidTime != nil {
                        map["InvalidTime"] = self.invalidTime!
                    }
                    if self.upgradeId != nil {
                        map["UpgradeId"] = self.upgradeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InstallAmount") && dict["InstallAmount"] != nil {
                        self.installAmount = dict["InstallAmount"] as! Int32
                    }
                    if dict.keys.contains("InvalidTime") && dict["InvalidTime"] != nil {
                        self.invalidTime = dict["InvalidTime"] as! String
                    }
                    if dict.keys.contains("UpgradeId") && dict["UpgradeId"] != nil {
                        self.upgradeId = dict["UpgradeId"] as! Int64
                    }
                }
            }
            public class UpgradeBaseInfoDO : Tea.TeaModel {
                public var allowCreateTask: Bool?

                public var appCode: String?

                public var appstoreUrl: String?

                public var backLog: String?

                public var changeLog: String?

                public var clientFileSize: Int32?

                public var clientName: String?

                public var cpId: String?

                public var creator: String?

                public var downloadUrl: String?

                public var globalVariables: String?

                public var gmtCreate: String?

                public var gmtCreateStr: String?

                public var gmtModified: String?

                public var gmtModifiedStr: String?

                public var id: Int64?

                public var innerVersion: String?

                public var iosSymbol: String?

                public var isEnterprise: Int32?

                public var isRc: Int32?

                public var isRelease: Int32?

                public var maxVersion: String?

                public var md5: String?

                public var modifier: String?

                public var needCheck: Int32?

                public var ossPath: String?

                public var packageType: String?

                public var platform: String?

                public var productId: String?

                public var productName: String?

                public var productVersion: String?

                public var publishPeriod: Int32?

                public var qrcodeUrl: String?

                public var releaseType: String?

                public var releaseWindow: String?

                public var scmDownloadUrl: String?

                public var serverVersion: Int32?

                public var verificationCode: String?

                public var verifyResult: Int32?

                public var versionCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allowCreateTask != nil {
                        map["AllowCreateTask"] = self.allowCreateTask!
                    }
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.appstoreUrl != nil {
                        map["AppstoreUrl"] = self.appstoreUrl!
                    }
                    if self.backLog != nil {
                        map["BackLog"] = self.backLog!
                    }
                    if self.changeLog != nil {
                        map["ChangeLog"] = self.changeLog!
                    }
                    if self.clientFileSize != nil {
                        map["ClientFileSize"] = self.clientFileSize!
                    }
                    if self.clientName != nil {
                        map["ClientName"] = self.clientName!
                    }
                    if self.cpId != nil {
                        map["CpId"] = self.cpId!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.downloadUrl != nil {
                        map["DownloadUrl"] = self.downloadUrl!
                    }
                    if self.globalVariables != nil {
                        map["GlobalVariables"] = self.globalVariables!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtCreateStr != nil {
                        map["GmtCreateStr"] = self.gmtCreateStr!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.gmtModifiedStr != nil {
                        map["GmtModifiedStr"] = self.gmtModifiedStr!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.innerVersion != nil {
                        map["InnerVersion"] = self.innerVersion!
                    }
                    if self.iosSymbol != nil {
                        map["IosSymbol"] = self.iosSymbol!
                    }
                    if self.isEnterprise != nil {
                        map["IsEnterprise"] = self.isEnterprise!
                    }
                    if self.isRc != nil {
                        map["IsRc"] = self.isRc!
                    }
                    if self.isRelease != nil {
                        map["IsRelease"] = self.isRelease!
                    }
                    if self.maxVersion != nil {
                        map["MaxVersion"] = self.maxVersion!
                    }
                    if self.md5 != nil {
                        map["Md5"] = self.md5!
                    }
                    if self.modifier != nil {
                        map["Modifier"] = self.modifier!
                    }
                    if self.needCheck != nil {
                        map["NeedCheck"] = self.needCheck!
                    }
                    if self.ossPath != nil {
                        map["OssPath"] = self.ossPath!
                    }
                    if self.packageType != nil {
                        map["PackageType"] = self.packageType!
                    }
                    if self.platform != nil {
                        map["Platform"] = self.platform!
                    }
                    if self.productId != nil {
                        map["ProductId"] = self.productId!
                    }
                    if self.productName != nil {
                        map["ProductName"] = self.productName!
                    }
                    if self.productVersion != nil {
                        map["ProductVersion"] = self.productVersion!
                    }
                    if self.publishPeriod != nil {
                        map["PublishPeriod"] = self.publishPeriod!
                    }
                    if self.qrcodeUrl != nil {
                        map["QrcodeUrl"] = self.qrcodeUrl!
                    }
                    if self.releaseType != nil {
                        map["ReleaseType"] = self.releaseType!
                    }
                    if self.releaseWindow != nil {
                        map["ReleaseWindow"] = self.releaseWindow!
                    }
                    if self.scmDownloadUrl != nil {
                        map["ScmDownloadUrl"] = self.scmDownloadUrl!
                    }
                    if self.serverVersion != nil {
                        map["ServerVersion"] = self.serverVersion!
                    }
                    if self.verificationCode != nil {
                        map["VerificationCode"] = self.verificationCode!
                    }
                    if self.verifyResult != nil {
                        map["VerifyResult"] = self.verifyResult!
                    }
                    if self.versionCode != nil {
                        map["VersionCode"] = self.versionCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllowCreateTask") && dict["AllowCreateTask"] != nil {
                        self.allowCreateTask = dict["AllowCreateTask"] as! Bool
                    }
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("AppstoreUrl") && dict["AppstoreUrl"] != nil {
                        self.appstoreUrl = dict["AppstoreUrl"] as! String
                    }
                    if dict.keys.contains("BackLog") && dict["BackLog"] != nil {
                        self.backLog = dict["BackLog"] as! String
                    }
                    if dict.keys.contains("ChangeLog") && dict["ChangeLog"] != nil {
                        self.changeLog = dict["ChangeLog"] as! String
                    }
                    if dict.keys.contains("ClientFileSize") && dict["ClientFileSize"] != nil {
                        self.clientFileSize = dict["ClientFileSize"] as! Int32
                    }
                    if dict.keys.contains("ClientName") && dict["ClientName"] != nil {
                        self.clientName = dict["ClientName"] as! String
                    }
                    if dict.keys.contains("CpId") && dict["CpId"] != nil {
                        self.cpId = dict["CpId"] as! String
                    }
                    if dict.keys.contains("Creator") && dict["Creator"] != nil {
                        self.creator = dict["Creator"] as! String
                    }
                    if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                        self.downloadUrl = dict["DownloadUrl"] as! String
                    }
                    if dict.keys.contains("GlobalVariables") && dict["GlobalVariables"] != nil {
                        self.globalVariables = dict["GlobalVariables"] as! String
                    }
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtCreateStr") && dict["GmtCreateStr"] != nil {
                        self.gmtCreateStr = dict["GmtCreateStr"] as! String
                    }
                    if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
                        self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InnerVersion") && dict["InnerVersion"] != nil {
                        self.innerVersion = dict["InnerVersion"] as! String
                    }
                    if dict.keys.contains("IosSymbol") && dict["IosSymbol"] != nil {
                        self.iosSymbol = dict["IosSymbol"] as! String
                    }
                    if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
                        self.isEnterprise = dict["IsEnterprise"] as! Int32
                    }
                    if dict.keys.contains("IsRc") && dict["IsRc"] != nil {
                        self.isRc = dict["IsRc"] as! Int32
                    }
                    if dict.keys.contains("IsRelease") && dict["IsRelease"] != nil {
                        self.isRelease = dict["IsRelease"] as! Int32
                    }
                    if dict.keys.contains("MaxVersion") && dict["MaxVersion"] != nil {
                        self.maxVersion = dict["MaxVersion"] as! String
                    }
                    if dict.keys.contains("Md5") && dict["Md5"] != nil {
                        self.md5 = dict["Md5"] as! String
                    }
                    if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                        self.modifier = dict["Modifier"] as! String
                    }
                    if dict.keys.contains("NeedCheck") && dict["NeedCheck"] != nil {
                        self.needCheck = dict["NeedCheck"] as! Int32
                    }
                    if dict.keys.contains("OssPath") && dict["OssPath"] != nil {
                        self.ossPath = dict["OssPath"] as! String
                    }
                    if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                        self.packageType = dict["PackageType"] as! String
                    }
                    if dict.keys.contains("Platform") && dict["Platform"] != nil {
                        self.platform = dict["Platform"] as! String
                    }
                    if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                        self.productId = dict["ProductId"] as! String
                    }
                    if dict.keys.contains("ProductName") && dict["ProductName"] != nil {
                        self.productName = dict["ProductName"] as! String
                    }
                    if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                        self.productVersion = dict["ProductVersion"] as! String
                    }
                    if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                        self.publishPeriod = dict["PublishPeriod"] as! Int32
                    }
                    if dict.keys.contains("QrcodeUrl") && dict["QrcodeUrl"] != nil {
                        self.qrcodeUrl = dict["QrcodeUrl"] as! String
                    }
                    if dict.keys.contains("ReleaseType") && dict["ReleaseType"] != nil {
                        self.releaseType = dict["ReleaseType"] as! String
                    }
                    if dict.keys.contains("ReleaseWindow") && dict["ReleaseWindow"] != nil {
                        self.releaseWindow = dict["ReleaseWindow"] as! String
                    }
                    if dict.keys.contains("ScmDownloadUrl") && dict["ScmDownloadUrl"] != nil {
                        self.scmDownloadUrl = dict["ScmDownloadUrl"] as! String
                    }
                    if dict.keys.contains("ServerVersion") && dict["ServerVersion"] != nil {
                        self.serverVersion = dict["ServerVersion"] as! Int32
                    }
                    if dict.keys.contains("VerificationCode") && dict["VerificationCode"] != nil {
                        self.verificationCode = dict["VerificationCode"] as! String
                    }
                    if dict.keys.contains("VerifyResult") && dict["VerifyResult"] != nil {
                        self.verifyResult = dict["VerifyResult"] as! Int32
                    }
                    if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                        self.versionCode = dict["VersionCode"] as! String
                    }
                }
            }
            public var mobileTestFlightConfigDO: GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo.MobileTestFlightConfigDO?

            public var upgradeBaseInfoDO: GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo.UpgradeBaseInfoDO?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.mobileTestFlightConfigDO?.validate()
                try self.upgradeBaseInfoDO?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mobileTestFlightConfigDO != nil {
                    map["MobileTestFlightConfigDO"] = self.mobileTestFlightConfigDO?.toMap()
                }
                if self.upgradeBaseInfoDO != nil {
                    map["UpgradeBaseInfoDO"] = self.upgradeBaseInfoDO?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MobileTestFlightConfigDO") && dict["MobileTestFlightConfigDO"] != nil {
                    var model = GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo.MobileTestFlightConfigDO()
                    model.fromMap(dict["MobileTestFlightConfigDO"] as! [String: Any])
                    self.mobileTestFlightConfigDO = model
                }
                if dict.keys.contains("UpgradeBaseInfoDO") && dict["UpgradeBaseInfoDO"] != nil {
                    var model = GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo.UpgradeBaseInfoDO()
                    model.fromMap(dict["UpgradeBaseInfoDO"] as! [String: Any])
                    self.upgradeBaseInfoDO = model
                }
            }
        }
        public var errorCode: String?

        public var packageInfo: GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.packageInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.packageInfo != nil {
                map["PackageInfo"] = self.packageInfo?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("PackageInfo") && dict["PackageInfo"] != nil {
                var model = GetMcubeUpgradePackageInfoResponseBody.GetPackageResult.PackageInfo()
                model.fromMap(dict["PackageInfo"] as! [String: Any])
                self.packageInfo = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var getPackageResult: GetMcubeUpgradePackageInfoResponseBody.GetPackageResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.getPackageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.getPackageResult != nil {
            map["GetPackageResult"] = self.getPackageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GetPackageResult") && dict["GetPackageResult"] != nil {
            var model = GetMcubeUpgradePackageInfoResponseBody.GetPackageResult()
            model.fromMap(dict["GetPackageResult"] as! [String: Any])
            self.getPackageResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMcubeUpgradePackageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMcubeUpgradePackageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMcubeUpgradePackageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMcubeUpgradeTaskInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMcubeUpgradeTaskInfoResponseBody : Tea.TeaModel {
    public class GetTaskResult : Tea.TeaModel {
        public class TaskInfo : Tea.TeaModel {
            public class RuleJsonList : Tea.TeaModel {
                public var operation: String?

                public var ruleElement: String?

                public var ruleType: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operation != nil {
                        map["Operation"] = self.operation!
                    }
                    if self.ruleElement != nil {
                        map["RuleElement"] = self.ruleElement!
                    }
                    if self.ruleType != nil {
                        map["RuleType"] = self.ruleType!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Operation") && dict["Operation"] != nil {
                        self.operation = dict["Operation"] as! String
                    }
                    if dict.keys.contains("RuleElement") && dict["RuleElement"] != nil {
                        self.ruleElement = dict["RuleElement"] as! String
                    }
                    if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                        self.ruleType = dict["RuleType"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Whitelist : Tea.TeaModel {
                public var appCode: String?

                public var id: Int64?

                public var idType: String?

                public var platform: String?

                public var status: Int32?

                public var userType: String?

                public var whiteListCount: Int64?

                public var whiteListName: String?

                public var whitelistType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.idType != nil {
                        map["IdType"] = self.idType!
                    }
                    if self.platform != nil {
                        map["Platform"] = self.platform!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userType != nil {
                        map["UserType"] = self.userType!
                    }
                    if self.whiteListCount != nil {
                        map["WhiteListCount"] = self.whiteListCount!
                    }
                    if self.whiteListName != nil {
                        map["WhiteListName"] = self.whiteListName!
                    }
                    if self.whitelistType != nil {
                        map["WhitelistType"] = self.whitelistType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("IdType") && dict["IdType"] != nil {
                        self.idType = dict["IdType"] as! String
                    }
                    if dict.keys.contains("Platform") && dict["Platform"] != nil {
                        self.platform = dict["Platform"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("UserType") && dict["UserType"] != nil {
                        self.userType = dict["UserType"] as! String
                    }
                    if dict.keys.contains("WhiteListCount") && dict["WhiteListCount"] != nil {
                        self.whiteListCount = dict["WhiteListCount"] as! Int64
                    }
                    if dict.keys.contains("WhiteListName") && dict["WhiteListName"] != nil {
                        self.whiteListName = dict["WhiteListName"] as! String
                    }
                    if dict.keys.contains("WhitelistType") && dict["WhitelistType"] != nil {
                        self.whitelistType = dict["WhitelistType"] as! String
                    }
                }
            }
            public var appCode: String?

            public var appId: String?

            public var appstoreUrl: String?

            public var creater: String?

            public var creator: String?

            public var downloadUrl: String?

            public var greyConfigInfo: String?

            public var greyEndtimeData: String?

            public var greyNum: Int32?

            public var historyForce: Int32?

            public var id: Int64?

            public var isEnterprise: Int32?

            public var isOfficial: Int32?

            public var isRc: Int32?

            public var isRelease: Int32?

            public var memo: String?

            public var modifier: String?

            public var netType: String?

            public var osVersion: String?

            public var packageInfoId: Int64?

            public var packageType: String?

            public var platform: String?

            public var productId: String?

            public var publishMode: Int32?

            public var publishType: Int32?

            public var pushContent: String?

            public var qrcodeUrl: String?

            public var ruleJsonList: [GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.RuleJsonList]?

            public var silentType: Int32?

            public var taskStatus: Int32?

            public var upgradeContent: String?

            public var upgradeType: Int32?

            public var upgradeValidTime: Int32?

            public var whitelist: [GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.Whitelist]?

            public var whitelistIds: String?

            public var workspaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appstoreUrl != nil {
                    map["AppstoreUrl"] = self.appstoreUrl!
                }
                if self.creater != nil {
                    map["Creater"] = self.creater!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtimeData != nil {
                    map["GreyEndtimeData"] = self.greyEndtimeData!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.historyForce != nil {
                    map["HistoryForce"] = self.historyForce!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isEnterprise != nil {
                    map["IsEnterprise"] = self.isEnterprise!
                }
                if self.isOfficial != nil {
                    map["IsOfficial"] = self.isOfficial!
                }
                if self.isRc != nil {
                    map["IsRc"] = self.isRc!
                }
                if self.isRelease != nil {
                    map["IsRelease"] = self.isRelease!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.netType != nil {
                    map["NetType"] = self.netType!
                }
                if self.osVersion != nil {
                    map["OsVersion"] = self.osVersion!
                }
                if self.packageInfoId != nil {
                    map["PackageInfoId"] = self.packageInfoId!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.pushContent != nil {
                    map["PushContent"] = self.pushContent!
                }
                if self.qrcodeUrl != nil {
                    map["QrcodeUrl"] = self.qrcodeUrl!
                }
                if self.ruleJsonList != nil {
                    var tmp : [Any] = []
                    for k in self.ruleJsonList! {
                        tmp.append(k.toMap())
                    }
                    map["RuleJsonList"] = tmp
                }
                if self.silentType != nil {
                    map["SilentType"] = self.silentType!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.upgradeContent != nil {
                    map["UpgradeContent"] = self.upgradeContent!
                }
                if self.upgradeType != nil {
                    map["UpgradeType"] = self.upgradeType!
                }
                if self.upgradeValidTime != nil {
                    map["UpgradeValidTime"] = self.upgradeValidTime!
                }
                if self.whitelist != nil {
                    var tmp : [Any] = []
                    for k in self.whitelist! {
                        tmp.append(k.toMap())
                    }
                    map["Whitelist"] = tmp
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppstoreUrl") && dict["AppstoreUrl"] != nil {
                    self.appstoreUrl = dict["AppstoreUrl"] as! String
                }
                if dict.keys.contains("Creater") && dict["Creater"] != nil {
                    self.creater = dict["Creater"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                    self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int32
                }
                if dict.keys.contains("HistoryForce") && dict["HistoryForce"] != nil {
                    self.historyForce = dict["HistoryForce"] as! Int32
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
                    self.isEnterprise = dict["IsEnterprise"] as! Int32
                }
                if dict.keys.contains("IsOfficial") && dict["IsOfficial"] != nil {
                    self.isOfficial = dict["IsOfficial"] as! Int32
                }
                if dict.keys.contains("IsRc") && dict["IsRc"] != nil {
                    self.isRc = dict["IsRc"] as! Int32
                }
                if dict.keys.contains("IsRelease") && dict["IsRelease"] != nil {
                    self.isRelease = dict["IsRelease"] as! Int32
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("NetType") && dict["NetType"] != nil {
                    self.netType = dict["NetType"] as! String
                }
                if dict.keys.contains("OsVersion") && dict["OsVersion"] != nil {
                    self.osVersion = dict["OsVersion"] as! String
                }
                if dict.keys.contains("PackageInfoId") && dict["PackageInfoId"] != nil {
                    self.packageInfoId = dict["PackageInfoId"] as! Int64
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! String
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int32
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int32
                }
                if dict.keys.contains("PushContent") && dict["PushContent"] != nil {
                    self.pushContent = dict["PushContent"] as! String
                }
                if dict.keys.contains("QrcodeUrl") && dict["QrcodeUrl"] != nil {
                    self.qrcodeUrl = dict["QrcodeUrl"] as! String
                }
                if dict.keys.contains("RuleJsonList") && dict["RuleJsonList"] != nil {
                    var tmp : [GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.RuleJsonList] = []
                    for v in dict["RuleJsonList"] as! [Any] {
                        var model = GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.RuleJsonList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ruleJsonList = tmp
                }
                if dict.keys.contains("SilentType") && dict["SilentType"] != nil {
                    self.silentType = dict["SilentType"] as! Int32
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int32
                }
                if dict.keys.contains("UpgradeContent") && dict["UpgradeContent"] != nil {
                    self.upgradeContent = dict["UpgradeContent"] as! String
                }
                if dict.keys.contains("UpgradeType") && dict["UpgradeType"] != nil {
                    self.upgradeType = dict["UpgradeType"] as! Int32
                }
                if dict.keys.contains("UpgradeValidTime") && dict["UpgradeValidTime"] != nil {
                    self.upgradeValidTime = dict["UpgradeValidTime"] as! Int32
                }
                if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
                    var tmp : [GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.Whitelist] = []
                    for v in dict["Whitelist"] as! [Any] {
                        var model = GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo.Whitelist()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whitelist = tmp
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
            }
        }
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var taskInfo: GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.taskInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.taskInfo != nil {
                map["TaskInfo"] = self.taskInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TaskInfo") && dict["TaskInfo"] != nil {
                var model = GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult.TaskInfo()
                model.fromMap(dict["TaskInfo"] as! [String: Any])
                self.taskInfo = model
            }
        }
    }
    public var getTaskResult: GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.getTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.getTaskResult != nil {
            map["GetTaskResult"] = self.getTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GetTaskResult") && dict["GetTaskResult"] != nil {
            var model = GetMcubeUpgradeTaskInfoResponseBody.GetTaskResult()
            model.fromMap(dict["GetTaskResult"] as! [String: Any])
            self.getTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMcubeUpgradeTaskInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMcubeUpgradeTaskInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMcubeUpgradeTaskInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMdsMiniConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetMdsMiniConfigResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Content : Tea.TeaModel {
                public class ApiConfigList : Tea.TeaModel {
                    public var appCode: String?

                    public var configStatus: Int64?

                    public var configType: String?

                    public var configValue: String?

                    public var description_: String?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var h5Id: String?

                    public var h5Name: String?

                    public var id: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appCode != nil {
                            map["AppCode"] = self.appCode!
                        }
                        if self.configStatus != nil {
                            map["ConfigStatus"] = self.configStatus!
                        }
                        if self.configType != nil {
                            map["ConfigType"] = self.configType!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.h5Id != nil {
                            map["H5Id"] = self.h5Id!
                        }
                        if self.h5Name != nil {
                            map["H5Name"] = self.h5Name!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                            self.appCode = dict["AppCode"] as! String
                        }
                        if dict.keys.contains("ConfigStatus") && dict["ConfigStatus"] != nil {
                            self.configStatus = dict["ConfigStatus"] as! Int64
                        }
                        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                            self.configType = dict["ConfigType"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                            self.h5Id = dict["H5Id"] as! String
                        }
                        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                            self.h5Name = dict["H5Name"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                    }
                }
                public class PrivilegeSwitch : Tea.TeaModel {
                    public var appCode: String?

                    public var configStatus: Int64?

                    public var configType: String?

                    public var configValue: String?

                    public var description_: String?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var h5Id: String?

                    public var h5Name: String?

                    public var id: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appCode != nil {
                            map["AppCode"] = self.appCode!
                        }
                        if self.configStatus != nil {
                            map["ConfigStatus"] = self.configStatus!
                        }
                        if self.configType != nil {
                            map["ConfigType"] = self.configType!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.h5Id != nil {
                            map["H5Id"] = self.h5Id!
                        }
                        if self.h5Name != nil {
                            map["H5Name"] = self.h5Name!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                            self.appCode = dict["AppCode"] as! String
                        }
                        if dict.keys.contains("ConfigStatus") && dict["ConfigStatus"] != nil {
                            self.configStatus = dict["ConfigStatus"] as! Int64
                        }
                        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                            self.configType = dict["ConfigType"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                            self.h5Id = dict["H5Id"] as! String
                        }
                        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                            self.h5Name = dict["H5Name"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                    }
                }
                public class ServerDomainConfigList : Tea.TeaModel {
                    public var appCode: String?

                    public var configStatus: Int64?

                    public var configType: String?

                    public var configValue: String?

                    public var description_: String?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var h5Id: String?

                    public var h5Name: String?

                    public var id: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appCode != nil {
                            map["AppCode"] = self.appCode!
                        }
                        if self.configStatus != nil {
                            map["ConfigStatus"] = self.configStatus!
                        }
                        if self.configType != nil {
                            map["ConfigType"] = self.configType!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.h5Id != nil {
                            map["H5Id"] = self.h5Id!
                        }
                        if self.h5Name != nil {
                            map["H5Name"] = self.h5Name!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                            self.appCode = dict["AppCode"] as! String
                        }
                        if dict.keys.contains("ConfigStatus") && dict["ConfigStatus"] != nil {
                            self.configStatus = dict["ConfigStatus"] as! Int64
                        }
                        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                            self.configType = dict["ConfigType"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                            self.h5Id = dict["H5Id"] as! String
                        }
                        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                            self.h5Name = dict["H5Name"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                    }
                }
                public class WebviewDomainConfigList : Tea.TeaModel {
                    public var appCode: String?

                    public var configStatus: Int64?

                    public var configType: String?

                    public var configValue: String?

                    public var description_: String?

                    public var gmtCreate: String?

                    public var gmtModified: String?

                    public var h5Id: String?

                    public var h5Name: String?

                    public var id: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appCode != nil {
                            map["AppCode"] = self.appCode!
                        }
                        if self.configStatus != nil {
                            map["ConfigStatus"] = self.configStatus!
                        }
                        if self.configType != nil {
                            map["ConfigType"] = self.configType!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.gmtCreate != nil {
                            map["GmtCreate"] = self.gmtCreate!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.h5Id != nil {
                            map["H5Id"] = self.h5Id!
                        }
                        if self.h5Name != nil {
                            map["H5Name"] = self.h5Name!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                            self.appCode = dict["AppCode"] as! String
                        }
                        if dict.keys.contains("ConfigStatus") && dict["ConfigStatus"] != nil {
                            self.configStatus = dict["ConfigStatus"] as! Int64
                        }
                        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                            self.configType = dict["ConfigType"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                            self.gmtCreate = dict["GmtCreate"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                            self.h5Id = dict["H5Id"] as! String
                        }
                        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                            self.h5Name = dict["H5Name"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                    }
                }
                public var apiConfigList: [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ApiConfigList]?

                public var appCode: String?

                public var enableServerDomainCount: String?

                public var h5Id: String?

                public var h5Name: String?

                public var privilegeSwitch: GetMdsMiniConfigResponseBody.ResultContent.Data.Content.PrivilegeSwitch?

                public var serverDomainConfigList: [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ServerDomainConfigList]?

                public var webviewDomainConfigList: [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.WebviewDomainConfigList]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.privilegeSwitch?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiConfigList != nil {
                        var tmp : [Any] = []
                        for k in self.apiConfigList! {
                            tmp.append(k.toMap())
                        }
                        map["ApiConfigList"] = tmp
                    }
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.enableServerDomainCount != nil {
                        map["EnableServerDomainCount"] = self.enableServerDomainCount!
                    }
                    if self.h5Id != nil {
                        map["H5Id"] = self.h5Id!
                    }
                    if self.h5Name != nil {
                        map["H5Name"] = self.h5Name!
                    }
                    if self.privilegeSwitch != nil {
                        map["PrivilegeSwitch"] = self.privilegeSwitch?.toMap()
                    }
                    if self.serverDomainConfigList != nil {
                        var tmp : [Any] = []
                        for k in self.serverDomainConfigList! {
                            tmp.append(k.toMap())
                        }
                        map["ServerDomainConfigList"] = tmp
                    }
                    if self.webviewDomainConfigList != nil {
                        var tmp : [Any] = []
                        for k in self.webviewDomainConfigList! {
                            tmp.append(k.toMap())
                        }
                        map["WebviewDomainConfigList"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiConfigList") && dict["ApiConfigList"] != nil {
                        var tmp : [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ApiConfigList] = []
                        for v in dict["ApiConfigList"] as! [Any] {
                            var model = GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ApiConfigList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.apiConfigList = tmp
                    }
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("EnableServerDomainCount") && dict["EnableServerDomainCount"] != nil {
                        self.enableServerDomainCount = dict["EnableServerDomainCount"] as! String
                    }
                    if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                        self.h5Id = dict["H5Id"] as! String
                    }
                    if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                        self.h5Name = dict["H5Name"] as! String
                    }
                    if dict.keys.contains("PrivilegeSwitch") && dict["PrivilegeSwitch"] != nil {
                        var model = GetMdsMiniConfigResponseBody.ResultContent.Data.Content.PrivilegeSwitch()
                        model.fromMap(dict["PrivilegeSwitch"] as! [String: Any])
                        self.privilegeSwitch = model
                    }
                    if dict.keys.contains("ServerDomainConfigList") && dict["ServerDomainConfigList"] != nil {
                        var tmp : [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ServerDomainConfigList] = []
                        for v in dict["ServerDomainConfigList"] as! [Any] {
                            var model = GetMdsMiniConfigResponseBody.ResultContent.Data.Content.ServerDomainConfigList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serverDomainConfigList = tmp
                    }
                    if dict.keys.contains("WebviewDomainConfigList") && dict["WebviewDomainConfigList"] != nil {
                        var tmp : [GetMdsMiniConfigResponseBody.ResultContent.Data.Content.WebviewDomainConfigList] = []
                        for v in dict["WebviewDomainConfigList"] as! [Any] {
                            var model = GetMdsMiniConfigResponseBody.ResultContent.Data.Content.WebviewDomainConfigList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.webviewDomainConfigList = tmp
                    }
                }
            }
            public var content: GetMdsMiniConfigResponseBody.ResultContent.Data.Content?

            public var requestId: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.content?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content?.toMap()
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    var model = GetMdsMiniConfigResponseBody.ResultContent.Data.Content()
                    model.fromMap(dict["Content"] as! [String: Any])
                    self.content = model
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: GetMdsMiniConfigResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = GetMdsMiniConfigResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetMdsMiniConfigResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetMdsMiniConfigResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetMdsMiniConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMdsMiniConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMdsMiniConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserAppDonwloadUrlInMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetUserAppDonwloadUrlInMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var filename: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filename != nil {
                    map["Filename"] = self.filename!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Filename") && dict["Filename"] != nil {
                    self.filename = dict["Filename"] as! String
                }
                if dict.keys.contains("Url") && dict["Url"] != nil {
                    self.url = dict["Url"] as! String
                }
            }
        }
        public var code: String?

        public var data: GetUserAppDonwloadUrlInMsaResponseBody.ResultContent.Data?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = GetUserAppDonwloadUrlInMsaResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetUserAppDonwloadUrlInMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetUserAppDonwloadUrlInMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetUserAppDonwloadUrlInMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserAppDonwloadUrlInMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserAppDonwloadUrlInMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserAppEnhanceProcessInMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetUserAppEnhanceProcessInMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class EnhanceMapping : Tea.TeaModel {
                public var info: String?

                public var reason: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        map["Info"] = self.info!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Info") && dict["Info"] != nil {
                        self.info = dict["Info"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var afterMd5: String?

            public var afterSize: Int64?

            public var appCode: String?

            public var appPackage: String?

            public var assetsFileList: [String]?

            public var beforeMd5: String?

            public var beforeSize: Int64?

            public var classForest: [String]?

            public var enhanceMapping: [GetUserAppEnhanceProcessInMsaResponseBody.ResultContent.Data.EnhanceMapping]?

            public var enhanceRules: [String]?

            public var enhancedAssetsFiles: [String]?

            public var enhancedClasses: [String]?

            public var enhancedSoFiles: [String]?

            public var id: Int64?

            public var label: String?

            public var progress: Int64?

            public var soFileList: [String]?

            public var status: Int64?

            public var taskType: String?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.afterMd5 != nil {
                    map["AfterMd5"] = self.afterMd5!
                }
                if self.afterSize != nil {
                    map["AfterSize"] = self.afterSize!
                }
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.appPackage != nil {
                    map["AppPackage"] = self.appPackage!
                }
                if self.assetsFileList != nil {
                    map["AssetsFileList"] = self.assetsFileList!
                }
                if self.beforeMd5 != nil {
                    map["BeforeMd5"] = self.beforeMd5!
                }
                if self.beforeSize != nil {
                    map["BeforeSize"] = self.beforeSize!
                }
                if self.classForest != nil {
                    map["ClassForest"] = self.classForest!
                }
                if self.enhanceMapping != nil {
                    var tmp : [Any] = []
                    for k in self.enhanceMapping! {
                        tmp.append(k.toMap())
                    }
                    map["EnhanceMapping"] = tmp
                }
                if self.enhanceRules != nil {
                    map["EnhanceRules"] = self.enhanceRules!
                }
                if self.enhancedAssetsFiles != nil {
                    map["EnhancedAssetsFiles"] = self.enhancedAssetsFiles!
                }
                if self.enhancedClasses != nil {
                    map["EnhancedClasses"] = self.enhancedClasses!
                }
                if self.enhancedSoFiles != nil {
                    map["EnhancedSoFiles"] = self.enhancedSoFiles!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.soFileList != nil {
                    map["SoFileList"] = self.soFileList!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AfterMd5") && dict["AfterMd5"] != nil {
                    self.afterMd5 = dict["AfterMd5"] as! String
                }
                if dict.keys.contains("AfterSize") && dict["AfterSize"] != nil {
                    self.afterSize = dict["AfterSize"] as! Int64
                }
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AppPackage") && dict["AppPackage"] != nil {
                    self.appPackage = dict["AppPackage"] as! String
                }
                if dict.keys.contains("AssetsFileList") && dict["AssetsFileList"] != nil {
                    self.assetsFileList = dict["AssetsFileList"] as! [String]
                }
                if dict.keys.contains("BeforeMd5") && dict["BeforeMd5"] != nil {
                    self.beforeMd5 = dict["BeforeMd5"] as! String
                }
                if dict.keys.contains("BeforeSize") && dict["BeforeSize"] != nil {
                    self.beforeSize = dict["BeforeSize"] as! Int64
                }
                if dict.keys.contains("ClassForest") && dict["ClassForest"] != nil {
                    self.classForest = dict["ClassForest"] as! [String]
                }
                if dict.keys.contains("EnhanceMapping") && dict["EnhanceMapping"] != nil {
                    var tmp : [GetUserAppEnhanceProcessInMsaResponseBody.ResultContent.Data.EnhanceMapping] = []
                    for v in dict["EnhanceMapping"] as! [Any] {
                        var model = GetUserAppEnhanceProcessInMsaResponseBody.ResultContent.Data.EnhanceMapping()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.enhanceMapping = tmp
                }
                if dict.keys.contains("EnhanceRules") && dict["EnhanceRules"] != nil {
                    self.enhanceRules = dict["EnhanceRules"] as! [String]
                }
                if dict.keys.contains("EnhancedAssetsFiles") && dict["EnhancedAssetsFiles"] != nil {
                    self.enhancedAssetsFiles = dict["EnhancedAssetsFiles"] as! [String]
                }
                if dict.keys.contains("EnhancedClasses") && dict["EnhancedClasses"] != nil {
                    self.enhancedClasses = dict["EnhancedClasses"] as! [String]
                }
                if dict.keys.contains("EnhancedSoFiles") && dict["EnhancedSoFiles"] != nil {
                    self.enhancedSoFiles = dict["EnhancedSoFiles"] as! [String]
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Progress") && dict["Progress"] != nil {
                    self.progress = dict["Progress"] as! Int64
                }
                if dict.keys.contains("SoFileList") && dict["SoFileList"] != nil {
                    self.soFileList = dict["SoFileList"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") && dict["VersionName"] != nil {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var code: String?

        public var data: GetUserAppEnhanceProcessInMsaResponseBody.ResultContent.Data?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = GetUserAppEnhanceProcessInMsaResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetUserAppEnhanceProcessInMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetUserAppEnhanceProcessInMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetUserAppEnhanceProcessInMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserAppEnhanceProcessInMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserAppEnhanceProcessInMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserAppUploadProcessInMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class GetUserAppUploadProcessInMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class ApkInfo : Tea.TeaModel {
                public class EnhanceMapping : Tea.TeaModel {
                    public var info: String?

                    public var reason: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.info != nil {
                            map["Info"] = self.info!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Info") && dict["Info"] != nil {
                            self.info = dict["Info"] as! String
                        }
                        if dict.keys.contains("Reason") && dict["Reason"] != nil {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var afterMd5: String?

                public var afterSize: Int64?

                public var appCode: String?

                public var appPackage: String?

                public var assetsFileList: [String]?

                public var beforeMd5: String?

                public var beforeSize: Int64?

                public var classForest: String?

                public var enhanceMapping: [GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data.ApkInfo.EnhanceMapping]?

                public var enhanceRules: [String]?

                public var enhancedAssetsFiles: [String]?

                public var enhancedClasses: [String]?

                public var enhancedSoFiles: [String]?

                public var id: Int64?

                public var label: String?

                public var progress: Int64?

                public var soFileList: [String]?

                public var status: Int64?

                public var taskType: String?

                public var versionCode: String?

                public var versionName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.afterMd5 != nil {
                        map["AfterMd5"] = self.afterMd5!
                    }
                    if self.afterSize != nil {
                        map["AfterSize"] = self.afterSize!
                    }
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.appPackage != nil {
                        map["AppPackage"] = self.appPackage!
                    }
                    if self.assetsFileList != nil {
                        map["AssetsFileList"] = self.assetsFileList!
                    }
                    if self.beforeMd5 != nil {
                        map["BeforeMd5"] = self.beforeMd5!
                    }
                    if self.beforeSize != nil {
                        map["BeforeSize"] = self.beforeSize!
                    }
                    if self.classForest != nil {
                        map["ClassForest"] = self.classForest!
                    }
                    if self.enhanceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.enhanceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["EnhanceMapping"] = tmp
                    }
                    if self.enhanceRules != nil {
                        map["EnhanceRules"] = self.enhanceRules!
                    }
                    if self.enhancedAssetsFiles != nil {
                        map["EnhancedAssetsFiles"] = self.enhancedAssetsFiles!
                    }
                    if self.enhancedClasses != nil {
                        map["EnhancedClasses"] = self.enhancedClasses!
                    }
                    if self.enhancedSoFiles != nil {
                        map["EnhancedSoFiles"] = self.enhancedSoFiles!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.soFileList != nil {
                        map["SoFileList"] = self.soFileList!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.versionCode != nil {
                        map["VersionCode"] = self.versionCode!
                    }
                    if self.versionName != nil {
                        map["VersionName"] = self.versionName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AfterMd5") && dict["AfterMd5"] != nil {
                        self.afterMd5 = dict["AfterMd5"] as! String
                    }
                    if dict.keys.contains("AfterSize") && dict["AfterSize"] != nil {
                        self.afterSize = dict["AfterSize"] as! Int64
                    }
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("AppPackage") && dict["AppPackage"] != nil {
                        self.appPackage = dict["AppPackage"] as! String
                    }
                    if dict.keys.contains("AssetsFileList") && dict["AssetsFileList"] != nil {
                        self.assetsFileList = dict["AssetsFileList"] as! [String]
                    }
                    if dict.keys.contains("BeforeMd5") && dict["BeforeMd5"] != nil {
                        self.beforeMd5 = dict["BeforeMd5"] as! String
                    }
                    if dict.keys.contains("BeforeSize") && dict["BeforeSize"] != nil {
                        self.beforeSize = dict["BeforeSize"] as! Int64
                    }
                    if dict.keys.contains("ClassForest") && dict["ClassForest"] != nil {
                        self.classForest = dict["ClassForest"] as! String
                    }
                    if dict.keys.contains("EnhanceMapping") && dict["EnhanceMapping"] != nil {
                        var tmp : [GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data.ApkInfo.EnhanceMapping] = []
                        for v in dict["EnhanceMapping"] as! [Any] {
                            var model = GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data.ApkInfo.EnhanceMapping()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.enhanceMapping = tmp
                    }
                    if dict.keys.contains("EnhanceRules") && dict["EnhanceRules"] != nil {
                        self.enhanceRules = dict["EnhanceRules"] as! [String]
                    }
                    if dict.keys.contains("EnhancedAssetsFiles") && dict["EnhancedAssetsFiles"] != nil {
                        self.enhancedAssetsFiles = dict["EnhancedAssetsFiles"] as! [String]
                    }
                    if dict.keys.contains("EnhancedClasses") && dict["EnhancedClasses"] != nil {
                        self.enhancedClasses = dict["EnhancedClasses"] as! [String]
                    }
                    if dict.keys.contains("EnhancedSoFiles") && dict["EnhancedSoFiles"] != nil {
                        self.enhancedSoFiles = dict["EnhancedSoFiles"] as! [String]
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Progress") && dict["Progress"] != nil {
                        self.progress = dict["Progress"] as! Int64
                    }
                    if dict.keys.contains("SoFileList") && dict["SoFileList"] != nil {
                        self.soFileList = dict["SoFileList"] as! [String]
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int64
                    }
                    if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                        self.taskType = dict["TaskType"] as! String
                    }
                    if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                        self.versionCode = dict["VersionCode"] as! String
                    }
                    if dict.keys.contains("VersionName") && dict["VersionName"] != nil {
                        self.versionName = dict["VersionName"] as! String
                    }
                }
            }
            public var apkInfo: GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data.ApkInfo?

            public var enhanceTaskId: Int64?

            public var id: Int64?

            public var progress: Int64?

            public var status: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apkInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apkInfo != nil {
                    map["ApkInfo"] = self.apkInfo?.toMap()
                }
                if self.enhanceTaskId != nil {
                    map["EnhanceTaskId"] = self.enhanceTaskId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApkInfo") && dict["ApkInfo"] != nil {
                    var model = GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data.ApkInfo()
                    model.fromMap(dict["ApkInfo"] as! [String: Any])
                    self.apkInfo = model
                }
                if dict.keys.contains("EnhanceTaskId") && dict["EnhanceTaskId"] != nil {
                    self.enhanceTaskId = dict["EnhanceTaskId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Progress") && dict["Progress"] != nil {
                    self.progress = dict["Progress"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
            }
        }
        public var code: String?

        public var data: GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = GetUserAppUploadProcessInMsaResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: GetUserAppUploadProcessInMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = GetUserAppUploadProcessInMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class GetUserAppUploadProcessInMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserAppUploadProcessInMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserAppUploadProcessInMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMappCenterAppsResponseBody : Tea.TeaModel {
    public class ListMappCenterAppResult : Tea.TeaModel {
        public class MappCenterAppList : Tea.TeaModel {
            public class AndroidConfig : Tea.TeaModel {
                public var certRSA: String?

                public var packageName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.certRSA != nil {
                        map["CertRSA"] = self.certRSA!
                    }
                    if self.packageName != nil {
                        map["PackageName"] = self.packageName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CertRSA") && dict["CertRSA"] != nil {
                        self.certRSA = dict["CertRSA"] as! String
                    }
                    if dict.keys.contains("PackageName") && dict["PackageName"] != nil {
                        self.packageName = dict["PackageName"] as! String
                    }
                }
            }
            public class IosConfig : Tea.TeaModel {
                public var bundleId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bundleId != nil {
                        map["BundleId"] = self.bundleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BundleId") && dict["BundleId"] != nil {
                        self.bundleId = dict["BundleId"] as! String
                    }
                }
            }
            public var androidConfig: ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList.AndroidConfig?

            public var appDesc: String?

            public var appIcon: String?

            public var appId: String?

            public var appName: String?

            public var appSecret: String?

            public var creator: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var iosConfig: ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList.IosConfig?

            public var modifier: String?

            public var monitorJson: String?

            public var status: Int64?

            public var tenantId: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.androidConfig?.validate()
                try self.iosConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.androidConfig != nil {
                    map["AndroidConfig"] = self.androidConfig?.toMap()
                }
                if self.appDesc != nil {
                    map["AppDesc"] = self.appDesc!
                }
                if self.appIcon != nil {
                    map["AppIcon"] = self.appIcon!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.appSecret != nil {
                    map["AppSecret"] = self.appSecret!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.iosConfig != nil {
                    map["IosConfig"] = self.iosConfig?.toMap()
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.monitorJson != nil {
                    map["MonitorJson"] = self.monitorJson!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AndroidConfig") && dict["AndroidConfig"] != nil {
                    var model = ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList.AndroidConfig()
                    model.fromMap(dict["AndroidConfig"] as! [String: Any])
                    self.androidConfig = model
                }
                if dict.keys.contains("AppDesc") && dict["AppDesc"] != nil {
                    self.appDesc = dict["AppDesc"] as! String
                }
                if dict.keys.contains("AppIcon") && dict["AppIcon"] != nil {
                    self.appIcon = dict["AppIcon"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AppSecret") && dict["AppSecret"] != nil {
                    self.appSecret = dict["AppSecret"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IosConfig") && dict["IosConfig"] != nil {
                    var model = ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList.IosConfig()
                    model.fromMap(dict["IosConfig"] as! [String: Any])
                    self.iosConfig = model
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("MonitorJson") && dict["MonitorJson"] != nil {
                    self.monitorJson = dict["MonitorJson"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public var mappCenterAppList: [ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList]?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mappCenterAppList != nil {
                var tmp : [Any] = []
                for k in self.mappCenterAppList! {
                    tmp.append(k.toMap())
                }
                map["MappCenterAppList"] = tmp
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MappCenterAppList") && dict["MappCenterAppList"] != nil {
                var tmp : [ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList] = []
                for v in dict["MappCenterAppList"] as! [Any] {
                    var model = ListMappCenterAppsResponseBody.ListMappCenterAppResult.MappCenterAppList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mappCenterAppList = tmp
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var listMappCenterAppResult: ListMappCenterAppsResponseBody.ListMappCenterAppResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMappCenterAppResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMappCenterAppResult != nil {
            map["ListMappCenterAppResult"] = self.listMappCenterAppResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMappCenterAppResult") && dict["ListMappCenterAppResult"] != nil {
            var model = ListMappCenterAppsResponseBody.ListMappCenterAppResult()
            model.fromMap(dict["ListMappCenterAppResult"] as! [String: Any])
            self.listMappCenterAppResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMappCenterAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMappCenterAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMappCenterAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMappCenterWorkspacesResponseBody : Tea.TeaModel {
    public class ListMappCenterWorkspaceResult : Tea.TeaModel {
        public class MappCenterWorkspaceList : Tea.TeaModel {
            public var compatibleId: String?

            public var createTime: String?

            public var displayName: String?

            public var id: String?

            public var region: String?

            public var status: String?

            public var tenantId: String?

            public var type: String?

            public var uid: Int64?

            public var updateTime: String?

            public var workspaceId: String?

            public var zones: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.compatibleId != nil {
                    map["CompatibleId"] = self.compatibleId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                if self.zones != nil {
                    map["Zones"] = self.zones!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CompatibleId") && dict["CompatibleId"] != nil {
                    self.compatibleId = dict["CompatibleId"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Uid") && dict["Uid"] != nil {
                    self.uid = dict["Uid"] as! Int64
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
                if dict.keys.contains("Zones") && dict["Zones"] != nil {
                    self.zones = dict["Zones"] as! String
                }
            }
        }
        public var mappCenterWorkspaceList: [ListMappCenterWorkspacesResponseBody.ListMappCenterWorkspaceResult.MappCenterWorkspaceList]?

        public var resultMsg: String?

        public var success: Bool?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mappCenterWorkspaceList != nil {
                var tmp : [Any] = []
                for k in self.mappCenterWorkspaceList! {
                    tmp.append(k.toMap())
                }
                map["MappCenterWorkspaceList"] = tmp
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MappCenterWorkspaceList") && dict["MappCenterWorkspaceList"] != nil {
                var tmp : [ListMappCenterWorkspacesResponseBody.ListMappCenterWorkspaceResult.MappCenterWorkspaceList] = []
                for v in dict["MappCenterWorkspaceList"] as! [Any] {
                    var model = ListMappCenterWorkspacesResponseBody.ListMappCenterWorkspaceResult.MappCenterWorkspaceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mappCenterWorkspaceList = tmp
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var listMappCenterWorkspaceResult: ListMappCenterWorkspacesResponseBody.ListMappCenterWorkspaceResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMappCenterWorkspaceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMappCenterWorkspaceResult != nil {
            map["ListMappCenterWorkspaceResult"] = self.listMappCenterWorkspaceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMappCenterWorkspaceResult") && dict["ListMappCenterWorkspaceResult"] != nil {
            var model = ListMappCenterWorkspacesResponseBody.ListMappCenterWorkspaceResult()
            model.fromMap(dict["ListMappCenterWorkspaceResult"] as! [String: Any])
            self.listMappCenterWorkspaceResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMappCenterWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMappCenterWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMappCenterWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcdpAimRequest : Tea.TeaModel {
    public var appId: String?

    public var emptyTag: String?

    public var keyword: String?

    public var name: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var sort: String?

    public var sortField: String?

    public var tenantId: String?

    public var type: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.emptyTag != nil {
            map["EmptyTag"] = self.emptyTag!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sort != nil {
            map["Sort"] = self.sort!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EmptyTag") && dict["EmptyTag"] != nil {
            self.emptyTag = dict["EmptyTag"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNo") && dict["PageNo"] != nil {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Sort") && dict["Sort"] != nil {
            self.sort = dict["Sort"] as! String
        }
        if dict.keys.contains("SortField") && dict["SortField"] != nil {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcdpAimResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: ListMcdpAimResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = ListMcdpAimResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcdpAimResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcdpAimResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcdpAimResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeMiniAppsRequest : Tea.TeaModel {
    public var appId: String?

    public var keyword: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeMiniAppsResponseBody : Tea.TeaModel {
    public class ListMiniResult : Tea.TeaModel {
        public class MiniProgramList : Tea.TeaModel {
            public var appCode: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var h5Id: String?

            public var h5Name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var hasMore: Bool?

        public var miniProgramList: [ListMcubeMiniAppsResponseBody.ListMiniResult.MiniProgramList]?

        public var pageSize: Int32?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.miniProgramList != nil {
                var tmp : [Any] = []
                for k in self.miniProgramList! {
                    tmp.append(k.toMap())
                }
                map["MiniProgramList"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("MiniProgramList") && dict["MiniProgramList"] != nil {
                var tmp : [ListMcubeMiniAppsResponseBody.ListMiniResult.MiniProgramList] = []
                for v in dict["MiniProgramList"] as! [Any] {
                    var model = ListMcubeMiniAppsResponseBody.ListMiniResult.MiniProgramList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.miniProgramList = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var listMiniResult: ListMcubeMiniAppsResponseBody.ListMiniResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMiniResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMiniResult != nil {
            map["ListMiniResult"] = self.listMiniResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMiniResult") && dict["ListMiniResult"] != nil {
            var model = ListMcubeMiniAppsResponseBody.ListMiniResult()
            model.fromMap(dict["ListMiniResult"] as! [String: Any])
            self.listMiniResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeMiniAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeMiniAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeMiniAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeMiniPackagesRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var packageTypes: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.packageTypes != nil {
            map["PackageTypes"] = self.packageTypes!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("PackageTypes") && dict["PackageTypes"] != nil {
            self.packageTypes = dict["PackageTypes"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeMiniPackagesResponseBody : Tea.TeaModel {
    public class ListMiniPackageResult : Tea.TeaModel {
        public class MiniPackageList : Tea.TeaModel {
            public var appCode: String?

            public var autoInstall: Int64?

            public var clientVersionMax: String?

            public var clientVersionMin: String?

            public var downloadUrl: String?

            public var extendInfo: String?

            public var extraData: String?

            public var fallbackBaseUrl: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var h5Id: String?

            public var h5Name: String?

            public var h5Version: String?

            public var id: Int64?

            public var installType: Int64?

            public var mainUrl: String?

            public var memo: String?

            public var packageType: Int64?

            public var platform: String?

            public var publishPeriod: Int64?

            public var resourceType: Int64?

            public var status: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.autoInstall != nil {
                    map["AutoInstall"] = self.autoInstall!
                }
                if self.clientVersionMax != nil {
                    map["ClientVersionMax"] = self.clientVersionMax!
                }
                if self.clientVersionMin != nil {
                    map["ClientVersionMin"] = self.clientVersionMin!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.extraData != nil {
                    map["ExtraData"] = self.extraData!
                }
                if self.fallbackBaseUrl != nil {
                    map["FallbackBaseUrl"] = self.fallbackBaseUrl!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                if self.h5Version != nil {
                    map["H5Version"] = self.h5Version!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.installType != nil {
                    map["InstallType"] = self.installType!
                }
                if self.mainUrl != nil {
                    map["MainUrl"] = self.mainUrl!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
                    self.autoInstall = dict["AutoInstall"] as! Int64
                }
                if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
                    self.clientVersionMax = dict["ClientVersionMax"] as! String
                }
                if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
                    self.clientVersionMin = dict["ClientVersionMin"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                    self.extraData = dict["ExtraData"] as! String
                }
                if dict.keys.contains("FallbackBaseUrl") && dict["FallbackBaseUrl"] != nil {
                    self.fallbackBaseUrl = dict["FallbackBaseUrl"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
                if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
                    self.h5Version = dict["H5Version"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
                    self.installType = dict["InstallType"] as! Int64
                }
                if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
                    self.mainUrl = dict["MainUrl"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! Int64
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int64
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
            }
        }
        public var currentPage: Int32?

        public var hasMore: Bool?

        public var miniPackageList: [ListMcubeMiniPackagesResponseBody.ListMiniPackageResult.MiniPackageList]?

        public var pageSize: Int32?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.miniPackageList != nil {
                var tmp : [Any] = []
                for k in self.miniPackageList! {
                    tmp.append(k.toMap())
                }
                map["MiniPackageList"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("MiniPackageList") && dict["MiniPackageList"] != nil {
                var tmp : [ListMcubeMiniPackagesResponseBody.ListMiniPackageResult.MiniPackageList] = []
                for v in dict["MiniPackageList"] as! [Any] {
                    var model = ListMcubeMiniPackagesResponseBody.ListMiniPackageResult.MiniPackageList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.miniPackageList = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var listMiniPackageResult: ListMcubeMiniPackagesResponseBody.ListMiniPackageResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMiniPackageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMiniPackageResult != nil {
            map["ListMiniPackageResult"] = self.listMiniPackageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMiniPackageResult") && dict["ListMiniPackageResult"] != nil {
            var model = ListMcubeMiniPackagesResponseBody.ListMiniPackageResult()
            model.fromMap(dict["ListMiniPackageResult"] as! [String: Any])
            self.listMiniPackageResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeMiniPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeMiniPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeMiniPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeMiniTasksRequest : Tea.TeaModel {
    public var appId: String?

    public var id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeMiniTasksResponseBody : Tea.TeaModel {
    public class ListMiniTaskResult : Tea.TeaModel {
        public class MiniTaskList : Tea.TeaModel {
            public var appCode: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var greyConfigInfo: String?

            public var greyEndtime: String?

            public var greyEndtimeData: String?

            public var greyNum: Int64?

            public var id: Int64?

            public var memo: String?

            public var packageId: Int64?

            public var platform: String?

            public var productVersion: String?

            public var publishMode: Int64?

            public var publishType: Int64?

            public var status: String?

            public var taskStatus: Int64?

            public var whitelistIds: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtime != nil {
                    map["GreyEndtime"] = self.greyEndtime!
                }
                if self.greyEndtimeData != nil {
                    map["GreyEndtimeData"] = self.greyEndtimeData!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
                    self.greyEndtime = dict["GreyEndtime"] as! String
                }
                if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                    self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
                    self.packageId = dict["PackageId"] as! Int64
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int64
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int64
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
            }
        }
        public var miniTaskList: [ListMcubeMiniTasksResponseBody.ListMiniTaskResult.MiniTaskList]?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.miniTaskList != nil {
                var tmp : [Any] = []
                for k in self.miniTaskList! {
                    tmp.append(k.toMap())
                }
                map["MiniTaskList"] = tmp
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MiniTaskList") && dict["MiniTaskList"] != nil {
                var tmp : [ListMcubeMiniTasksResponseBody.ListMiniTaskResult.MiniTaskList] = []
                for v in dict["MiniTaskList"] as! [Any] {
                    var model = ListMcubeMiniTasksResponseBody.ListMiniTaskResult.MiniTaskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.miniTaskList = tmp
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var listMiniTaskResult: ListMcubeMiniTasksResponseBody.ListMiniTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMiniTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMiniTaskResult != nil {
            map["ListMiniTaskResult"] = self.listMiniTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMiniTaskResult") && dict["ListMiniTaskResult"] != nil {
            var model = ListMcubeMiniTasksResponseBody.ListMiniTaskResult()
            model.fromMap(dict["ListMiniTaskResult"] as! [String: Any])
            self.listMiniTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeMiniTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeMiniTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeMiniTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeNebulaAppsRequest : Tea.TeaModel {
    public var appId: String?

    public var keyword: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeNebulaAppsResponseBody : Tea.TeaModel {
    public class ListMcubeNebulaAppsResult : Tea.TeaModel {
        public class NebulaAppInfos : Tea.TeaModel {
            public var h5Id: String?

            public var h5Name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var errorCode: String?

        public var hasMore: Bool?

        public var nebulaAppInfos: [ListMcubeNebulaAppsResponseBody.ListMcubeNebulaAppsResult.NebulaAppInfos]?

        public var pageSize: Int32?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.nebulaAppInfos != nil {
                var tmp : [Any] = []
                for k in self.nebulaAppInfos! {
                    tmp.append(k.toMap())
                }
                map["NebulaAppInfos"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("NebulaAppInfos") && dict["NebulaAppInfos"] != nil {
                var tmp : [ListMcubeNebulaAppsResponseBody.ListMcubeNebulaAppsResult.NebulaAppInfos] = []
                for v in dict["NebulaAppInfos"] as! [Any] {
                    var model = ListMcubeNebulaAppsResponseBody.ListMcubeNebulaAppsResult.NebulaAppInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nebulaAppInfos = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var listMcubeNebulaAppsResult: ListMcubeNebulaAppsResponseBody.ListMcubeNebulaAppsResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMcubeNebulaAppsResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMcubeNebulaAppsResult != nil {
            map["ListMcubeNebulaAppsResult"] = self.listMcubeNebulaAppsResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMcubeNebulaAppsResult") && dict["ListMcubeNebulaAppsResult"] != nil {
            var model = ListMcubeNebulaAppsResponseBody.ListMcubeNebulaAppsResult()
            model.fromMap(dict["ListMcubeNebulaAppsResult"] as! [String: Any])
            self.listMcubeNebulaAppsResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeNebulaAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeNebulaAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeNebulaAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeNebulaResourcesRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeNebulaResourcesResponseBody : Tea.TeaModel {
    public class ListMcubeNebulaResourceResult : Tea.TeaModel {
        public class NebulaResourceInfo : Tea.TeaModel {
            public var appCode: String?

            public var autoInstall: Int32?

            public var clientVersionMax: String?

            public var clientVersionMin: String?

            public var creator: String?

            public var debugUrl: String?

            public var downloadUrl: String?

            public var extendInfo: String?

            public var extraData: String?

            public var fallbackBaseUrl: String?

            public var fileSize: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var h5Id: String?

            public var h5Name: String?

            public var h5Version: String?

            public var id: Int64?

            public var installType: Int32?

            public var lazyLoad: Int32?

            public var mainUrl: String?

            public var md5: String?

            public var memo: String?

            public var metaId: Int64?

            public var modifier: String?

            public var packageType: Int32?

            public var platform: String?

            public var publishPeriod: Int32?

            public var releaseVersion: String?

            public var resourceType: String?

            public var status: Int32?

            public var vhost: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.autoInstall != nil {
                    map["AutoInstall"] = self.autoInstall!
                }
                if self.clientVersionMax != nil {
                    map["ClientVersionMax"] = self.clientVersionMax!
                }
                if self.clientVersionMin != nil {
                    map["ClientVersionMin"] = self.clientVersionMin!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.debugUrl != nil {
                    map["DebugUrl"] = self.debugUrl!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.extraData != nil {
                    map["ExtraData"] = self.extraData!
                }
                if self.fallbackBaseUrl != nil {
                    map["FallbackBaseUrl"] = self.fallbackBaseUrl!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                if self.h5Version != nil {
                    map["H5Version"] = self.h5Version!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.installType != nil {
                    map["InstallType"] = self.installType!
                }
                if self.lazyLoad != nil {
                    map["LazyLoad"] = self.lazyLoad!
                }
                if self.mainUrl != nil {
                    map["MainUrl"] = self.mainUrl!
                }
                if self.md5 != nil {
                    map["Md5"] = self.md5!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.metaId != nil {
                    map["MetaId"] = self.metaId!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.releaseVersion != nil {
                    map["ReleaseVersion"] = self.releaseVersion!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vhost != nil {
                    map["Vhost"] = self.vhost!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
                    self.autoInstall = dict["AutoInstall"] as! Int32
                }
                if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
                    self.clientVersionMax = dict["ClientVersionMax"] as! String
                }
                if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
                    self.clientVersionMin = dict["ClientVersionMin"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DebugUrl") && dict["DebugUrl"] != nil {
                    self.debugUrl = dict["DebugUrl"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                    self.extraData = dict["ExtraData"] as! String
                }
                if dict.keys.contains("FallbackBaseUrl") && dict["FallbackBaseUrl"] != nil {
                    self.fallbackBaseUrl = dict["FallbackBaseUrl"] as! String
                }
                if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
                if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
                    self.h5Version = dict["H5Version"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
                    self.installType = dict["InstallType"] as! Int32
                }
                if dict.keys.contains("LazyLoad") && dict["LazyLoad"] != nil {
                    self.lazyLoad = dict["LazyLoad"] as! Int32
                }
                if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
                    self.mainUrl = dict["MainUrl"] as! String
                }
                if dict.keys.contains("Md5") && dict["Md5"] != nil {
                    self.md5 = dict["Md5"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("MetaId") && dict["MetaId"] != nil {
                    self.metaId = dict["MetaId"] as! Int64
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! Int32
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int32
                }
                if dict.keys.contains("ReleaseVersion") && dict["ReleaseVersion"] != nil {
                    self.releaseVersion = dict["ReleaseVersion"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Vhost") && dict["Vhost"] != nil {
                    self.vhost = dict["Vhost"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var errorCode: String?

        public var hasMore: Bool?

        public var nebulaResourceInfo: [ListMcubeNebulaResourcesResponseBody.ListMcubeNebulaResourceResult.NebulaResourceInfo]?

        public var pageSize: Int32?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.nebulaResourceInfo != nil {
                var tmp : [Any] = []
                for k in self.nebulaResourceInfo! {
                    tmp.append(k.toMap())
                }
                map["NebulaResourceInfo"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("NebulaResourceInfo") && dict["NebulaResourceInfo"] != nil {
                var tmp : [ListMcubeNebulaResourcesResponseBody.ListMcubeNebulaResourceResult.NebulaResourceInfo] = []
                for v in dict["NebulaResourceInfo"] as! [Any] {
                    var model = ListMcubeNebulaResourcesResponseBody.ListMcubeNebulaResourceResult.NebulaResourceInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nebulaResourceInfo = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var listMcubeNebulaResourceResult: ListMcubeNebulaResourcesResponseBody.ListMcubeNebulaResourceResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMcubeNebulaResourceResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMcubeNebulaResourceResult != nil {
            map["ListMcubeNebulaResourceResult"] = self.listMcubeNebulaResourceResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMcubeNebulaResourceResult") && dict["ListMcubeNebulaResourceResult"] != nil {
            var model = ListMcubeNebulaResourcesResponseBody.ListMcubeNebulaResourceResult()
            model.fromMap(dict["ListMcubeNebulaResourceResult"] as! [String: Any])
            self.listMcubeNebulaResourceResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeNebulaResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeNebulaResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeNebulaResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeNebulaTasksRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeNebulaTasksResponseBody : Tea.TeaModel {
    public class ListMcubeNebulaTaskResult : Tea.TeaModel {
        public class NebulaTaskInfo : Tea.TeaModel {
            public var appCode: String?

            public var bizType: String?

            public var creator: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var gmtModifiedStr: String?

            public var greyConfigInfo: String?

            public var greyEndtime: String?

            public var greyEndtimeData: String?

            public var greyEndtimeStr: String?

            public var greyNum: Int32?

            public var greyUrl: String?

            public var id: Int64?

            public var memo: String?

            public var modifier: String?

            public var packageId: Int64?

            public var percent: Int32?

            public var platform: String?

            public var productId: String?

            public var productVersion: String?

            public var publishMode: Int32?

            public var publishType: Int32?

            public var releaseVersion: String?

            public var status: Int32?

            public var syncResult: String?

            public var taskName: String?

            public var taskStatus: Int32?

            public var taskType: Int32?

            public var taskVersion: Int64?

            public var upgradeNoticeNum: Int64?

            public var upgradeProgress: String?

            public var whitelistIds: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.gmtModifiedStr != nil {
                    map["GmtModifiedStr"] = self.gmtModifiedStr!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtime != nil {
                    map["GreyEndtime"] = self.greyEndtime!
                }
                if self.greyEndtimeData != nil {
                    map["GreyEndtimeData"] = self.greyEndtimeData!
                }
                if self.greyEndtimeStr != nil {
                    map["GreyEndtimeStr"] = self.greyEndtimeStr!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.greyUrl != nil {
                    map["GreyUrl"] = self.greyUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.releaseVersion != nil {
                    map["ReleaseVersion"] = self.releaseVersion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.syncResult != nil {
                    map["SyncResult"] = self.syncResult!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.taskVersion != nil {
                    map["TaskVersion"] = self.taskVersion!
                }
                if self.upgradeNoticeNum != nil {
                    map["UpgradeNoticeNum"] = self.upgradeNoticeNum!
                }
                if self.upgradeProgress != nil {
                    map["UpgradeProgress"] = self.upgradeProgress!
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("BizType") && dict["BizType"] != nil {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
                    self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
                    self.greyEndtime = dict["GreyEndtime"] as! String
                }
                if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                    self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                }
                if dict.keys.contains("GreyEndtimeStr") && dict["GreyEndtimeStr"] != nil {
                    self.greyEndtimeStr = dict["GreyEndtimeStr"] as! String
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int32
                }
                if dict.keys.contains("GreyUrl") && dict["GreyUrl"] != nil {
                    self.greyUrl = dict["GreyUrl"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
                    self.packageId = dict["PackageId"] as! Int64
                }
                if dict.keys.contains("Percent") && dict["Percent"] != nil {
                    self.percent = dict["Percent"] as! Int32
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int32
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int32
                }
                if dict.keys.contains("ReleaseVersion") && dict["ReleaseVersion"] != nil {
                    self.releaseVersion = dict["ReleaseVersion"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SyncResult") && dict["SyncResult"] != nil {
                    self.syncResult = dict["SyncResult"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int32
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! Int32
                }
                if dict.keys.contains("TaskVersion") && dict["TaskVersion"] != nil {
                    self.taskVersion = dict["TaskVersion"] as! Int64
                }
                if dict.keys.contains("UpgradeNoticeNum") && dict["UpgradeNoticeNum"] != nil {
                    self.upgradeNoticeNum = dict["UpgradeNoticeNum"] as! Int64
                }
                if dict.keys.contains("UpgradeProgress") && dict["UpgradeProgress"] != nil {
                    self.upgradeProgress = dict["UpgradeProgress"] as! String
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
            }
        }
        public var errorCode: String?

        public var nebulaTaskInfo: [ListMcubeNebulaTasksResponseBody.ListMcubeNebulaTaskResult.NebulaTaskInfo]?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.nebulaTaskInfo != nil {
                var tmp : [Any] = []
                for k in self.nebulaTaskInfo! {
                    tmp.append(k.toMap())
                }
                map["NebulaTaskInfo"] = tmp
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("NebulaTaskInfo") && dict["NebulaTaskInfo"] != nil {
                var tmp : [ListMcubeNebulaTasksResponseBody.ListMcubeNebulaTaskResult.NebulaTaskInfo] = []
                for v in dict["NebulaTaskInfo"] as! [Any] {
                    var model = ListMcubeNebulaTasksResponseBody.ListMcubeNebulaTaskResult.NebulaTaskInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nebulaTaskInfo = tmp
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var listMcubeNebulaTaskResult: ListMcubeNebulaTasksResponseBody.ListMcubeNebulaTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listMcubeNebulaTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listMcubeNebulaTaskResult != nil {
            map["ListMcubeNebulaTaskResult"] = self.listMcubeNebulaTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListMcubeNebulaTaskResult") && dict["ListMcubeNebulaTaskResult"] != nil {
            var model = ListMcubeNebulaTasksResponseBody.ListMcubeNebulaTaskResult()
            model.fromMap(dict["ListMcubeNebulaTaskResult"] as! [String: Any])
            self.listMcubeNebulaTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeNebulaTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeNebulaTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeNebulaTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeUpgradePackagesRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeUpgradePackagesResponseBody : Tea.TeaModel {
    public class ListPackagesResult : Tea.TeaModel {
        public class Packages : Tea.TeaModel {
            public var allowCreateTask: Bool?

            public var appCode: String?

            public var appstoreUrl: String?

            public var backLog: String?

            public var changeLog: String?

            public var clientFileSize: Int32?

            public var clientName: String?

            public var cpId: String?

            public var creator: String?

            public var downloadUrl: String?

            public var globalVariables: String?

            public var gmtCreate: String?

            public var gmtCreateStr: String?

            public var gmtModified: String?

            public var gmtModifiedStr: String?

            public var id: Int64?

            public var innerVersion: String?

            public var iosSymbol: String?

            public var isEnterprise: Int32?

            public var isRc: Int32?

            public var isRelease: Int32?

            public var maxVersion: String?

            public var md5: String?

            public var modifier: String?

            public var needCheck: Int32?

            public var ossPath: String?

            public var packageType: String?

            public var platform: String?

            public var productId: String?

            public var productName: String?

            public var productVersion: String?

            public var publishPeriod: Int32?

            public var qrcodeUrl: String?

            public var releaseType: String?

            public var releaseWindow: String?

            public var scmDownloadUrl: String?

            public var serverVersion: Int32?

            public var verificationCode: String?

            public var verifyResult: Int32?

            public var versionCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCreateTask != nil {
                    map["AllowCreateTask"] = self.allowCreateTask!
                }
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.appstoreUrl != nil {
                    map["AppstoreUrl"] = self.appstoreUrl!
                }
                if self.backLog != nil {
                    map["BackLog"] = self.backLog!
                }
                if self.changeLog != nil {
                    map["ChangeLog"] = self.changeLog!
                }
                if self.clientFileSize != nil {
                    map["ClientFileSize"] = self.clientFileSize!
                }
                if self.clientName != nil {
                    map["ClientName"] = self.clientName!
                }
                if self.cpId != nil {
                    map["CpId"] = self.cpId!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.globalVariables != nil {
                    map["GlobalVariables"] = self.globalVariables!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtCreateStr != nil {
                    map["GmtCreateStr"] = self.gmtCreateStr!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.gmtModifiedStr != nil {
                    map["GmtModifiedStr"] = self.gmtModifiedStr!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.innerVersion != nil {
                    map["InnerVersion"] = self.innerVersion!
                }
                if self.iosSymbol != nil {
                    map["IosSymbol"] = self.iosSymbol!
                }
                if self.isEnterprise != nil {
                    map["IsEnterprise"] = self.isEnterprise!
                }
                if self.isRc != nil {
                    map["IsRc"] = self.isRc!
                }
                if self.isRelease != nil {
                    map["IsRelease"] = self.isRelease!
                }
                if self.maxVersion != nil {
                    map["MaxVersion"] = self.maxVersion!
                }
                if self.md5 != nil {
                    map["Md5"] = self.md5!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.needCheck != nil {
                    map["NeedCheck"] = self.needCheck!
                }
                if self.ossPath != nil {
                    map["OssPath"] = self.ossPath!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.productName != nil {
                    map["ProductName"] = self.productName!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.qrcodeUrl != nil {
                    map["QrcodeUrl"] = self.qrcodeUrl!
                }
                if self.releaseType != nil {
                    map["ReleaseType"] = self.releaseType!
                }
                if self.releaseWindow != nil {
                    map["ReleaseWindow"] = self.releaseWindow!
                }
                if self.scmDownloadUrl != nil {
                    map["ScmDownloadUrl"] = self.scmDownloadUrl!
                }
                if self.serverVersion != nil {
                    map["ServerVersion"] = self.serverVersion!
                }
                if self.verificationCode != nil {
                    map["VerificationCode"] = self.verificationCode!
                }
                if self.verifyResult != nil {
                    map["VerifyResult"] = self.verifyResult!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowCreateTask") && dict["AllowCreateTask"] != nil {
                    self.allowCreateTask = dict["AllowCreateTask"] as! Bool
                }
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AppstoreUrl") && dict["AppstoreUrl"] != nil {
                    self.appstoreUrl = dict["AppstoreUrl"] as! String
                }
                if dict.keys.contains("BackLog") && dict["BackLog"] != nil {
                    self.backLog = dict["BackLog"] as! String
                }
                if dict.keys.contains("ChangeLog") && dict["ChangeLog"] != nil {
                    self.changeLog = dict["ChangeLog"] as! String
                }
                if dict.keys.contains("ClientFileSize") && dict["ClientFileSize"] != nil {
                    self.clientFileSize = dict["ClientFileSize"] as! Int32
                }
                if dict.keys.contains("ClientName") && dict["ClientName"] != nil {
                    self.clientName = dict["ClientName"] as! String
                }
                if dict.keys.contains("CpId") && dict["CpId"] != nil {
                    self.cpId = dict["CpId"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("GlobalVariables") && dict["GlobalVariables"] != nil {
                    self.globalVariables = dict["GlobalVariables"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtCreateStr") && dict["GmtCreateStr"] != nil {
                    self.gmtCreateStr = dict["GmtCreateStr"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
                    self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InnerVersion") && dict["InnerVersion"] != nil {
                    self.innerVersion = dict["InnerVersion"] as! String
                }
                if dict.keys.contains("IosSymbol") && dict["IosSymbol"] != nil {
                    self.iosSymbol = dict["IosSymbol"] as! String
                }
                if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
                    self.isEnterprise = dict["IsEnterprise"] as! Int32
                }
                if dict.keys.contains("IsRc") && dict["IsRc"] != nil {
                    self.isRc = dict["IsRc"] as! Int32
                }
                if dict.keys.contains("IsRelease") && dict["IsRelease"] != nil {
                    self.isRelease = dict["IsRelease"] as! Int32
                }
                if dict.keys.contains("MaxVersion") && dict["MaxVersion"] != nil {
                    self.maxVersion = dict["MaxVersion"] as! String
                }
                if dict.keys.contains("Md5") && dict["Md5"] != nil {
                    self.md5 = dict["Md5"] as! String
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("NeedCheck") && dict["NeedCheck"] != nil {
                    self.needCheck = dict["NeedCheck"] as! Int32
                }
                if dict.keys.contains("OssPath") && dict["OssPath"] != nil {
                    self.ossPath = dict["OssPath"] as! String
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! String
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("ProductName") && dict["ProductName"] != nil {
                    self.productName = dict["ProductName"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int32
                }
                if dict.keys.contains("QrcodeUrl") && dict["QrcodeUrl"] != nil {
                    self.qrcodeUrl = dict["QrcodeUrl"] as! String
                }
                if dict.keys.contains("ReleaseType") && dict["ReleaseType"] != nil {
                    self.releaseType = dict["ReleaseType"] as! String
                }
                if dict.keys.contains("ReleaseWindow") && dict["ReleaseWindow"] != nil {
                    self.releaseWindow = dict["ReleaseWindow"] as! String
                }
                if dict.keys.contains("ScmDownloadUrl") && dict["ScmDownloadUrl"] != nil {
                    self.scmDownloadUrl = dict["ScmDownloadUrl"] as! String
                }
                if dict.keys.contains("ServerVersion") && dict["ServerVersion"] != nil {
                    self.serverVersion = dict["ServerVersion"] as! Int32
                }
                if dict.keys.contains("VerificationCode") && dict["VerificationCode"] != nil {
                    self.verificationCode = dict["VerificationCode"] as! String
                }
                if dict.keys.contains("VerifyResult") && dict["VerifyResult"] != nil {
                    self.verifyResult = dict["VerifyResult"] as! Int32
                }
                if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                    self.versionCode = dict["VersionCode"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var errorCode: String?

        public var hasMore: Bool?

        public var packages: [ListMcubeUpgradePackagesResponseBody.ListPackagesResult.Packages]?

        public var pageSize: Int32?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.packages != nil {
                var tmp : [Any] = []
                for k in self.packages! {
                    tmp.append(k.toMap())
                }
                map["Packages"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("Packages") && dict["Packages"] != nil {
                var tmp : [ListMcubeUpgradePackagesResponseBody.ListPackagesResult.Packages] = []
                for v in dict["Packages"] as! [Any] {
                    var model = ListMcubeUpgradePackagesResponseBody.ListPackagesResult.Packages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.packages = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var listPackagesResult: ListMcubeUpgradePackagesResponseBody.ListPackagesResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listPackagesResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listPackagesResult != nil {
            map["ListPackagesResult"] = self.listPackagesResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListPackagesResult") && dict["ListPackagesResult"] != nil {
            var model = ListMcubeUpgradePackagesResponseBody.ListPackagesResult()
            model.fromMap(dict["ListPackagesResult"] as! [String: Any])
            self.listPackagesResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeUpgradePackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeUpgradePackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeUpgradePackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeUpgradeTasksRequest : Tea.TeaModel {
    public var appId: String?

    public var packageId: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.packageId != nil {
            map["PackageId"] = self.packageId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
            self.packageId = dict["PackageId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeUpgradeTasksResponseBody : Tea.TeaModel {
    public class ListTaskResult : Tea.TeaModel {
        public class TaskInfo : Tea.TeaModel {
            public var appCode: String?

            public var creator: String?

            public var devicePercent: Int32?

            public var executionOrder: Int32?

            public var gmtCreate: String?

            public var gmtCreateStr: String?

            public var gmtModified: String?

            public var gmtModifiedStr: String?

            public var greyConfigInfo: String?

            public var greyEndtime: String?

            public var greyNotice: Int32?

            public var greyNum: Int32?

            public var greyPausePoint: Int32?

            public var greyPauseType: Int32?

            public var greyUv: Int32?

            public var historyForce: Int32?

            public var huobanNoticeId: String?

            public var huobanUrl: String?

            public var id: Int64?

            public var innerVersion: String?

            public var isEnterprise: Int32?

            public var isOfficial: Int32?

            public var isPush: Int32?

            public var isRelease: Int32?

            public var maxVersion: String?

            public var memo: String?

            public var modifier: String?

            public var packageInfoId: Int64?

            public var platform: String?

            public var productId: String?

            public var productVersion: String?

            public var publishMode: Int32?

            public var publishType: Int32?

            public var pushContent: String?

            public var realGreyEndtime: String?

            public var realGreyEndtimeStr: String?

            public var realGreyEndtype: Int32?

            public var realGreyNum: Int32?

            public var realGreyUv: Int32?

            public var silentType: Int32?

            public var syncResult: String?

            public var taskStatus: Int32?

            public var upgradeContent: String?

            public var upgradeType: Int32?

            public var upgradeValidTime: Int32?

            public var whitelistIds: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.devicePercent != nil {
                    map["DevicePercent"] = self.devicePercent!
                }
                if self.executionOrder != nil {
                    map["ExecutionOrder"] = self.executionOrder!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtCreateStr != nil {
                    map["GmtCreateStr"] = self.gmtCreateStr!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.gmtModifiedStr != nil {
                    map["GmtModifiedStr"] = self.gmtModifiedStr!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtime != nil {
                    map["GreyEndtime"] = self.greyEndtime!
                }
                if self.greyNotice != nil {
                    map["GreyNotice"] = self.greyNotice!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.greyPausePoint != nil {
                    map["GreyPausePoint"] = self.greyPausePoint!
                }
                if self.greyPauseType != nil {
                    map["GreyPauseType"] = self.greyPauseType!
                }
                if self.greyUv != nil {
                    map["GreyUv"] = self.greyUv!
                }
                if self.historyForce != nil {
                    map["HistoryForce"] = self.historyForce!
                }
                if self.huobanNoticeId != nil {
                    map["HuobanNoticeId"] = self.huobanNoticeId!
                }
                if self.huobanUrl != nil {
                    map["HuobanUrl"] = self.huobanUrl!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.innerVersion != nil {
                    map["InnerVersion"] = self.innerVersion!
                }
                if self.isEnterprise != nil {
                    map["IsEnterprise"] = self.isEnterprise!
                }
                if self.isOfficial != nil {
                    map["IsOfficial"] = self.isOfficial!
                }
                if self.isPush != nil {
                    map["IsPush"] = self.isPush!
                }
                if self.isRelease != nil {
                    map["IsRelease"] = self.isRelease!
                }
                if self.maxVersion != nil {
                    map["MaxVersion"] = self.maxVersion!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.packageInfoId != nil {
                    map["PackageInfoId"] = self.packageInfoId!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productId != nil {
                    map["ProductId"] = self.productId!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.pushContent != nil {
                    map["PushContent"] = self.pushContent!
                }
                if self.realGreyEndtime != nil {
                    map["RealGreyEndtime"] = self.realGreyEndtime!
                }
                if self.realGreyEndtimeStr != nil {
                    map["RealGreyEndtimeStr"] = self.realGreyEndtimeStr!
                }
                if self.realGreyEndtype != nil {
                    map["RealGreyEndtype"] = self.realGreyEndtype!
                }
                if self.realGreyNum != nil {
                    map["RealGreyNum"] = self.realGreyNum!
                }
                if self.realGreyUv != nil {
                    map["RealGreyUv"] = self.realGreyUv!
                }
                if self.silentType != nil {
                    map["SilentType"] = self.silentType!
                }
                if self.syncResult != nil {
                    map["SyncResult"] = self.syncResult!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.upgradeContent != nil {
                    map["UpgradeContent"] = self.upgradeContent!
                }
                if self.upgradeType != nil {
                    map["UpgradeType"] = self.upgradeType!
                }
                if self.upgradeValidTime != nil {
                    map["UpgradeValidTime"] = self.upgradeValidTime!
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DevicePercent") && dict["DevicePercent"] != nil {
                    self.devicePercent = dict["DevicePercent"] as! Int32
                }
                if dict.keys.contains("ExecutionOrder") && dict["ExecutionOrder"] != nil {
                    self.executionOrder = dict["ExecutionOrder"] as! Int32
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtCreateStr") && dict["GmtCreateStr"] != nil {
                    self.gmtCreateStr = dict["GmtCreateStr"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GmtModifiedStr") && dict["GmtModifiedStr"] != nil {
                    self.gmtModifiedStr = dict["GmtModifiedStr"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
                    self.greyEndtime = dict["GreyEndtime"] as! String
                }
                if dict.keys.contains("GreyNotice") && dict["GreyNotice"] != nil {
                    self.greyNotice = dict["GreyNotice"] as! Int32
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int32
                }
                if dict.keys.contains("GreyPausePoint") && dict["GreyPausePoint"] != nil {
                    self.greyPausePoint = dict["GreyPausePoint"] as! Int32
                }
                if dict.keys.contains("GreyPauseType") && dict["GreyPauseType"] != nil {
                    self.greyPauseType = dict["GreyPauseType"] as! Int32
                }
                if dict.keys.contains("GreyUv") && dict["GreyUv"] != nil {
                    self.greyUv = dict["GreyUv"] as! Int32
                }
                if dict.keys.contains("HistoryForce") && dict["HistoryForce"] != nil {
                    self.historyForce = dict["HistoryForce"] as! Int32
                }
                if dict.keys.contains("HuobanNoticeId") && dict["HuobanNoticeId"] != nil {
                    self.huobanNoticeId = dict["HuobanNoticeId"] as! String
                }
                if dict.keys.contains("HuobanUrl") && dict["HuobanUrl"] != nil {
                    self.huobanUrl = dict["HuobanUrl"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InnerVersion") && dict["InnerVersion"] != nil {
                    self.innerVersion = dict["InnerVersion"] as! String
                }
                if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
                    self.isEnterprise = dict["IsEnterprise"] as! Int32
                }
                if dict.keys.contains("IsOfficial") && dict["IsOfficial"] != nil {
                    self.isOfficial = dict["IsOfficial"] as! Int32
                }
                if dict.keys.contains("IsPush") && dict["IsPush"] != nil {
                    self.isPush = dict["IsPush"] as! Int32
                }
                if dict.keys.contains("IsRelease") && dict["IsRelease"] != nil {
                    self.isRelease = dict["IsRelease"] as! Int32
                }
                if dict.keys.contains("MaxVersion") && dict["MaxVersion"] != nil {
                    self.maxVersion = dict["MaxVersion"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("PackageInfoId") && dict["PackageInfoId"] != nil {
                    self.packageInfoId = dict["PackageInfoId"] as! Int64
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                    self.productId = dict["ProductId"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int32
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int32
                }
                if dict.keys.contains("PushContent") && dict["PushContent"] != nil {
                    self.pushContent = dict["PushContent"] as! String
                }
                if dict.keys.contains("RealGreyEndtime") && dict["RealGreyEndtime"] != nil {
                    self.realGreyEndtime = dict["RealGreyEndtime"] as! String
                }
                if dict.keys.contains("RealGreyEndtimeStr") && dict["RealGreyEndtimeStr"] != nil {
                    self.realGreyEndtimeStr = dict["RealGreyEndtimeStr"] as! String
                }
                if dict.keys.contains("RealGreyEndtype") && dict["RealGreyEndtype"] != nil {
                    self.realGreyEndtype = dict["RealGreyEndtype"] as! Int32
                }
                if dict.keys.contains("RealGreyNum") && dict["RealGreyNum"] != nil {
                    self.realGreyNum = dict["RealGreyNum"] as! Int32
                }
                if dict.keys.contains("RealGreyUv") && dict["RealGreyUv"] != nil {
                    self.realGreyUv = dict["RealGreyUv"] as! Int32
                }
                if dict.keys.contains("SilentType") && dict["SilentType"] != nil {
                    self.silentType = dict["SilentType"] as! Int32
                }
                if dict.keys.contains("SyncResult") && dict["SyncResult"] != nil {
                    self.syncResult = dict["SyncResult"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int32
                }
                if dict.keys.contains("UpgradeContent") && dict["UpgradeContent"] != nil {
                    self.upgradeContent = dict["UpgradeContent"] as! String
                }
                if dict.keys.contains("UpgradeType") && dict["UpgradeType"] != nil {
                    self.upgradeType = dict["UpgradeType"] as! Int32
                }
                if dict.keys.contains("UpgradeValidTime") && dict["UpgradeValidTime"] != nil {
                    self.upgradeValidTime = dict["UpgradeValidTime"] as! Int32
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
            }
        }
        public var errorCode: String?

        public var requestId: String?

        public var resultMsg: String?

        public var success: Bool?

        public var taskInfo: [ListMcubeUpgradeTasksResponseBody.ListTaskResult.TaskInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.taskInfo != nil {
                var tmp : [Any] = []
                for k in self.taskInfo! {
                    tmp.append(k.toMap())
                }
                map["TaskInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TaskInfo") && dict["TaskInfo"] != nil {
                var tmp : [ListMcubeUpgradeTasksResponseBody.ListTaskResult.TaskInfo] = []
                for v in dict["TaskInfo"] as! [Any] {
                    var model = ListMcubeUpgradeTasksResponseBody.ListTaskResult.TaskInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskInfo = tmp
            }
        }
    }
    public var listTaskResult: ListMcubeUpgradeTasksResponseBody.ListTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listTaskResult != nil {
            map["ListTaskResult"] = self.listTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListTaskResult") && dict["ListTaskResult"] != nil {
            var model = ListMcubeUpgradeTasksResponseBody.ListTaskResult()
            model.fromMap(dict["ListTaskResult"] as! [String: Any])
            self.listTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeUpgradeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeUpgradeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeUpgradeTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMcubeWhitelistsRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var tenantId: String?

    public var whitelistName: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.whitelistName != nil {
            map["WhitelistName"] = self.whitelistName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PageNum") && dict["PageNum"] != nil {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WhitelistName") && dict["WhitelistName"] != nil {
            self.whitelistName = dict["WhitelistName"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMcubeWhitelistsResponseBody : Tea.TeaModel {
    public class ListWhitelistResult : Tea.TeaModel {
        public class Whitelists : Tea.TeaModel {
            public var appCode: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var whiteListCount: Int64?

            public var whiteListName: String?

            public var whitelistType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.whiteListCount != nil {
                    map["WhiteListCount"] = self.whiteListCount!
                }
                if self.whiteListName != nil {
                    map["WhiteListName"] = self.whiteListName!
                }
                if self.whitelistType != nil {
                    map["WhitelistType"] = self.whitelistType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("WhiteListCount") && dict["WhiteListCount"] != nil {
                    self.whiteListCount = dict["WhiteListCount"] as! Int64
                }
                if dict.keys.contains("WhiteListName") && dict["WhiteListName"] != nil {
                    self.whiteListName = dict["WhiteListName"] as! String
                }
                if dict.keys.contains("WhitelistType") && dict["WhitelistType"] != nil {
                    self.whitelistType = dict["WhitelistType"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var hasMore: Bool?

        public var pageSize: Int32?

        public var resultMsg: String?

        public var success: Bool?

        public var totalCount: Int64?

        public var whitelists: [ListMcubeWhitelistsResponseBody.ListWhitelistResult.Whitelists]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.whitelists != nil {
                var tmp : [Any] = []
                for k in self.whitelists! {
                    tmp.append(k.toMap())
                }
                map["Whitelists"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
            if dict.keys.contains("Whitelists") && dict["Whitelists"] != nil {
                var tmp : [ListMcubeWhitelistsResponseBody.ListWhitelistResult.Whitelists] = []
                for v in dict["Whitelists"] as! [Any] {
                    var model = ListMcubeWhitelistsResponseBody.ListWhitelistResult.Whitelists()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.whitelists = tmp
            }
        }
    }
    public var listWhitelistResult: ListMcubeWhitelistsResponseBody.ListWhitelistResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listWhitelistResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listWhitelistResult != nil {
            map["ListWhitelistResult"] = self.listWhitelistResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListWhitelistResult") && dict["ListWhitelistResult"] != nil {
            var model = ListMcubeWhitelistsResponseBody.ListWhitelistResult()
            model.fromMap(dict["ListWhitelistResult"] as! [String: Any])
            self.listWhitelistResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMcubeWhitelistsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMcubeWhitelistsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMcubeWhitelistsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMgsApiRequest : Tea.TeaModel {
    public var apiStatus: String?

    public var apiType: String?

    public var appId: String?

    public var format: String?

    public var host: String?

    public var needEncrypt: String?

    public var needEtag: String?

    public var needSign: String?

    public var operationType: String?

    public var optFuzzy: String?

    public var pageIndex: Int64?

    public var pageSize: Int64?

    public var sysId: Int64?

    public var sysName: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiStatus != nil {
            map["ApiStatus"] = self.apiStatus!
        }
        if self.apiType != nil {
            map["ApiType"] = self.apiType!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.needEncrypt != nil {
            map["NeedEncrypt"] = self.needEncrypt!
        }
        if self.needEtag != nil {
            map["NeedEtag"] = self.needEtag!
        }
        if self.needSign != nil {
            map["NeedSign"] = self.needSign!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.optFuzzy != nil {
            map["OptFuzzy"] = self.optFuzzy!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sysId != nil {
            map["SysId"] = self.sysId!
        }
        if self.sysName != nil {
            map["SysName"] = self.sysName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiStatus") && dict["ApiStatus"] != nil {
            self.apiStatus = dict["ApiStatus"] as! String
        }
        if dict.keys.contains("ApiType") && dict["ApiType"] != nil {
            self.apiType = dict["ApiType"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("NeedEncrypt") && dict["NeedEncrypt"] != nil {
            self.needEncrypt = dict["NeedEncrypt"] as! String
        }
        if dict.keys.contains("NeedEtag") && dict["NeedEtag"] != nil {
            self.needEtag = dict["NeedEtag"] as! String
        }
        if dict.keys.contains("NeedSign") && dict["NeedSign"] != nil {
            self.needSign = dict["NeedSign"] as! String
        }
        if dict.keys.contains("OperationType") && dict["OperationType"] != nil {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("OptFuzzy") && dict["OptFuzzy"] != nil {
            self.optFuzzy = dict["OptFuzzy"] as! String
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SysId") && dict["SysId"] != nil {
            self.sysId = dict["SysId"] as! Int64
        }
        if dict.keys.contains("SysName") && dict["SysName"] != nil {
            self.sysName = dict["SysName"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class ListMgsApiResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Value : Tea.TeaModel {
            public class ApiInvoker : Tea.TeaModel {
                public class HttpInvoker : Tea.TeaModel {
                    public var charset: String?

                    public var contentType: String?

                    public var host: String?

                    public var method: String?

                    public var path: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charset != nil {
                            map["Charset"] = self.charset!
                        }
                        if self.contentType != nil {
                            map["ContentType"] = self.contentType!
                        }
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Charset") && dict["Charset"] != nil {
                            self.charset = dict["Charset"] as! String
                        }
                        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                            self.contentType = dict["ContentType"] as! String
                        }
                        if dict.keys.contains("Host") && dict["Host"] != nil {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Method") && dict["Method"] != nil {
                            self.method = dict["Method"] as! String
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                    }
                }
                public var httpInvoker: ListMgsApiResponseBody.ResultContent.Value.ApiInvoker.HttpInvoker?

                public var rpcInvoker: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpInvoker?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpInvoker != nil {
                        map["HttpInvoker"] = self.httpInvoker?.toMap()
                    }
                    if self.rpcInvoker != nil {
                        map["RpcInvoker"] = self.rpcInvoker!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HttpInvoker") && dict["HttpInvoker"] != nil {
                        var model = ListMgsApiResponseBody.ResultContent.Value.ApiInvoker.HttpInvoker()
                        model.fromMap(dict["HttpInvoker"] as! [String: Any])
                        self.httpInvoker = model
                    }
                    if dict.keys.contains("RpcInvoker") && dict["RpcInvoker"] != nil {
                        self.rpcInvoker = dict["RpcInvoker"] as! String
                    }
                }
            }
            public class CacheRule : Tea.TeaModel {
                public var cacheKey: String?

                public var needCache: Bool?

                public var ttl: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cacheKey != nil {
                        map["CacheKey"] = self.cacheKey!
                    }
                    if self.needCache != nil {
                        map["NeedCache"] = self.needCache!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CacheKey") && dict["CacheKey"] != nil {
                        self.cacheKey = dict["CacheKey"] as! String
                    }
                    if dict.keys.contains("NeedCache") && dict["NeedCache"] != nil {
                        self.needCache = dict["NeedCache"] as! Bool
                    }
                    if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                        self.ttl = dict["Ttl"] as! Int64
                    }
                }
            }
            public class CircuitBreakerRule : Tea.TeaModel {
                public var appId: String?

                public var defaultResponse: String?

                public var errorThreshold: Int64?

                public var id: Int64?

                public var model: String?

                public var openTimeoutSeconds: Int64?

                public var slowRatioThreshold: Double?

                public var switchStatus: String?

                public var windowsInSeconds: Int64?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.errorThreshold != nil {
                        map["ErrorThreshold"] = self.errorThreshold!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.model != nil {
                        map["Model"] = self.model!
                    }
                    if self.openTimeoutSeconds != nil {
                        map["OpenTimeoutSeconds"] = self.openTimeoutSeconds!
                    }
                    if self.slowRatioThreshold != nil {
                        map["SlowRatioThreshold"] = self.slowRatioThreshold!
                    }
                    if self.switchStatus != nil {
                        map["SwitchStatus"] = self.switchStatus!
                    }
                    if self.windowsInSeconds != nil {
                        map["WindowsInSeconds"] = self.windowsInSeconds!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("ErrorThreshold") && dict["ErrorThreshold"] != nil {
                        self.errorThreshold = dict["ErrorThreshold"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Model") && dict["Model"] != nil {
                        self.model = dict["Model"] as! String
                    }
                    if dict.keys.contains("OpenTimeoutSeconds") && dict["OpenTimeoutSeconds"] != nil {
                        self.openTimeoutSeconds = dict["OpenTimeoutSeconds"] as! Int64
                    }
                    if dict.keys.contains("SlowRatioThreshold") && dict["SlowRatioThreshold"] != nil {
                        self.slowRatioThreshold = dict["SlowRatioThreshold"] as! Double
                    }
                    if dict.keys.contains("SwitchStatus") && dict["SwitchStatus"] != nil {
                        self.switchStatus = dict["SwitchStatus"] as! String
                    }
                    if dict.keys.contains("WindowsInSeconds") && dict["WindowsInSeconds"] != nil {
                        self.windowsInSeconds = dict["WindowsInSeconds"] as! Int64
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public class HeaderRule : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class HeaderRules : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class LimitRule : Tea.TeaModel {
                public var defaultResponse: String?

                public var i18nResponse: String?

                public var interval: Int64?

                public var limit: Int64?

                public var mode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.i18nResponse != nil {
                        map["I18nResponse"] = self.i18nResponse!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.limit != nil {
                        map["Limit"] = self.limit!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("I18nResponse") && dict["I18nResponse"] != nil {
                        self.i18nResponse = dict["I18nResponse"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("Limit") && dict["Limit"] != nil {
                        self.limit = dict["Limit"] as! Int64
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! String
                    }
                }
            }
            public class MigrateRule : Tea.TeaModel {
                public var flowPercent: Int64?

                public var needMigrate: Bool?

                public var needSwitchCompletely: Bool?

                public var sysId: Int64?

                public var sysName: String?

                public var upstreamType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flowPercent != nil {
                        map["FlowPercent"] = self.flowPercent!
                    }
                    if self.needMigrate != nil {
                        map["NeedMigrate"] = self.needMigrate!
                    }
                    if self.needSwitchCompletely != nil {
                        map["NeedSwitchCompletely"] = self.needSwitchCompletely!
                    }
                    if self.sysId != nil {
                        map["SysId"] = self.sysId!
                    }
                    if self.sysName != nil {
                        map["SysName"] = self.sysName!
                    }
                    if self.upstreamType != nil {
                        map["UpstreamType"] = self.upstreamType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FlowPercent") && dict["FlowPercent"] != nil {
                        self.flowPercent = dict["FlowPercent"] as! Int64
                    }
                    if dict.keys.contains("NeedMigrate") && dict["NeedMigrate"] != nil {
                        self.needMigrate = dict["NeedMigrate"] as! Bool
                    }
                    if dict.keys.contains("NeedSwitchCompletely") && dict["NeedSwitchCompletely"] != nil {
                        self.needSwitchCompletely = dict["NeedSwitchCompletely"] as! Bool
                    }
                    if dict.keys.contains("SysId") && dict["SysId"] != nil {
                        self.sysId = dict["SysId"] as! Int64
                    }
                    if dict.keys.contains("SysName") && dict["SysName"] != nil {
                        self.sysName = dict["SysName"] as! String
                    }
                    if dict.keys.contains("UpstreamType") && dict["UpstreamType"] != nil {
                        self.upstreamType = dict["UpstreamType"] as! String
                    }
                }
            }
            public class MockRule : Tea.TeaModel {
                public var mockData: String?

                public var needMock: Bool?

                public var percentage: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mockData != nil {
                        map["MockData"] = self.mockData!
                    }
                    if self.needMock != nil {
                        map["NeedMock"] = self.needMock!
                    }
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MockData") && dict["MockData"] != nil {
                        self.mockData = dict["MockData"] as! String
                    }
                    if dict.keys.contains("NeedMock") && dict["NeedMock"] != nil {
                        self.needMock = dict["NeedMock"] as! Bool
                    }
                    if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                        self.percentage = dict["Percentage"] as! Int64
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RequestParams : Tea.TeaModel {
                public var apiId: String?

                public var appId: String?

                public var defaultValue: String?

                public var description_: String?

                public var id: Int64?

                public var location: String?

                public var name: String?

                public var refType: String?

                public var type: String?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiId != nil {
                        map["ApiId"] = self.apiId!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.refType != nil {
                        map["RefType"] = self.refType!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                        self.apiId = dict["ApiId"] as! String
                    }
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RefType") && dict["RefType"] != nil {
                        self.refType = dict["RefType"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public var apiInvoker: ListMgsApiResponseBody.ResultContent.Value.ApiInvoker?

            public var apiName: String?

            public var apiStatus: String?

            public var apiType: String?

            public var appId: String?

            public var authRuleName: String?

            public var cacheRule: ListMgsApiResponseBody.ResultContent.Value.CacheRule?

            public var charset: String?

            public var circuitBreakerRule: ListMgsApiResponseBody.ResultContent.Value.CircuitBreakerRule?

            public var contentType: String?

            public var description_: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var headerRule: [ListMgsApiResponseBody.ResultContent.Value.HeaderRule]?

            public var headerRules: [ListMgsApiResponseBody.ResultContent.Value.HeaderRules]?

            public var host: String?

            public var id: Int64?

            public var interfaceType: String?

            public var limitRule: ListMgsApiResponseBody.ResultContent.Value.LimitRule?

            public var method: String?

            public var methodName: String?

            public var migrateRule: ListMgsApiResponseBody.ResultContent.Value.MigrateRule?

            public var mockRule: ListMgsApiResponseBody.ResultContent.Value.MockRule?

            public var needETag: String?

            public var needEncrypt: String?

            public var needJsonp: String?

            public var needSign: String?

            public var operationType: String?

            public var paramGetMethod: String?

            public var path: String?

            public var requestBodyModel: String?

            public var requestParams: [ListMgsApiResponseBody.ResultContent.Value.RequestParams]?

            public var responseBodyModel: String?

            public var sysId: Int64?

            public var sysName: String?

            public var timeout: String?

            public var workspaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apiInvoker?.validate()
                try self.cacheRule?.validate()
                try self.circuitBreakerRule?.validate()
                try self.limitRule?.validate()
                try self.migrateRule?.validate()
                try self.mockRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiInvoker != nil {
                    map["ApiInvoker"] = self.apiInvoker?.toMap()
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.apiType != nil {
                    map["ApiType"] = self.apiType!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.authRuleName != nil {
                    map["AuthRuleName"] = self.authRuleName!
                }
                if self.cacheRule != nil {
                    map["CacheRule"] = self.cacheRule?.toMap()
                }
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.circuitBreakerRule != nil {
                    map["CircuitBreakerRule"] = self.circuitBreakerRule?.toMap()
                }
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.headerRule != nil {
                    var tmp : [Any] = []
                    for k in self.headerRule! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRule"] = tmp
                }
                if self.headerRules != nil {
                    var tmp : [Any] = []
                    for k in self.headerRules! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRules"] = tmp
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.interfaceType != nil {
                    map["InterfaceType"] = self.interfaceType!
                }
                if self.limitRule != nil {
                    map["LimitRule"] = self.limitRule?.toMap()
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.migrateRule != nil {
                    map["MigrateRule"] = self.migrateRule?.toMap()
                }
                if self.mockRule != nil {
                    map["MockRule"] = self.mockRule?.toMap()
                }
                if self.needETag != nil {
                    map["NeedETag"] = self.needETag!
                }
                if self.needEncrypt != nil {
                    map["NeedEncrypt"] = self.needEncrypt!
                }
                if self.needJsonp != nil {
                    map["NeedJsonp"] = self.needJsonp!
                }
                if self.needSign != nil {
                    map["NeedSign"] = self.needSign!
                }
                if self.operationType != nil {
                    map["OperationType"] = self.operationType!
                }
                if self.paramGetMethod != nil {
                    map["ParamGetMethod"] = self.paramGetMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.requestBodyModel != nil {
                    map["RequestBodyModel"] = self.requestBodyModel!
                }
                if self.requestParams != nil {
                    var tmp : [Any] = []
                    for k in self.requestParams! {
                        tmp.append(k.toMap())
                    }
                    map["RequestParams"] = tmp
                }
                if self.responseBodyModel != nil {
                    map["ResponseBodyModel"] = self.responseBodyModel!
                }
                if self.sysId != nil {
                    map["SysId"] = self.sysId!
                }
                if self.sysName != nil {
                    map["SysName"] = self.sysName!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiInvoker") && dict["ApiInvoker"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.ApiInvoker()
                    model.fromMap(dict["ApiInvoker"] as! [String: Any])
                    self.apiInvoker = model
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiStatus") && dict["ApiStatus"] != nil {
                    self.apiStatus = dict["ApiStatus"] as! String
                }
                if dict.keys.contains("ApiType") && dict["ApiType"] != nil {
                    self.apiType = dict["ApiType"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AuthRuleName") && dict["AuthRuleName"] != nil {
                    self.authRuleName = dict["AuthRuleName"] as! String
                }
                if dict.keys.contains("CacheRule") && dict["CacheRule"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.CacheRule()
                    model.fromMap(dict["CacheRule"] as! [String: Any])
                    self.cacheRule = model
                }
                if dict.keys.contains("Charset") && dict["Charset"] != nil {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("CircuitBreakerRule") && dict["CircuitBreakerRule"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.CircuitBreakerRule()
                    model.fromMap(dict["CircuitBreakerRule"] as! [String: Any])
                    self.circuitBreakerRule = model
                }
                if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("HeaderRule") && dict["HeaderRule"] != nil {
                    var tmp : [ListMgsApiResponseBody.ResultContent.Value.HeaderRule] = []
                    for v in dict["HeaderRule"] as! [Any] {
                        var model = ListMgsApiResponseBody.ResultContent.Value.HeaderRule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRule = tmp
                }
                if dict.keys.contains("HeaderRules") && dict["HeaderRules"] != nil {
                    var tmp : [ListMgsApiResponseBody.ResultContent.Value.HeaderRules] = []
                    for v in dict["HeaderRules"] as! [Any] {
                        var model = ListMgsApiResponseBody.ResultContent.Value.HeaderRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRules = tmp
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InterfaceType") && dict["InterfaceType"] != nil {
                    self.interfaceType = dict["InterfaceType"] as! String
                }
                if dict.keys.contains("LimitRule") && dict["LimitRule"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.LimitRule()
                    model.fromMap(dict["LimitRule"] as! [String: Any])
                    self.limitRule = model
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("MethodName") && dict["MethodName"] != nil {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("MigrateRule") && dict["MigrateRule"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.MigrateRule()
                    model.fromMap(dict["MigrateRule"] as! [String: Any])
                    self.migrateRule = model
                }
                if dict.keys.contains("MockRule") && dict["MockRule"] != nil {
                    var model = ListMgsApiResponseBody.ResultContent.Value.MockRule()
                    model.fromMap(dict["MockRule"] as! [String: Any])
                    self.mockRule = model
                }
                if dict.keys.contains("NeedETag") && dict["NeedETag"] != nil {
                    self.needETag = dict["NeedETag"] as! String
                }
                if dict.keys.contains("NeedEncrypt") && dict["NeedEncrypt"] != nil {
                    self.needEncrypt = dict["NeedEncrypt"] as! String
                }
                if dict.keys.contains("NeedJsonp") && dict["NeedJsonp"] != nil {
                    self.needJsonp = dict["NeedJsonp"] as! String
                }
                if dict.keys.contains("NeedSign") && dict["NeedSign"] != nil {
                    self.needSign = dict["NeedSign"] as! String
                }
                if dict.keys.contains("OperationType") && dict["OperationType"] != nil {
                    self.operationType = dict["OperationType"] as! String
                }
                if dict.keys.contains("ParamGetMethod") && dict["ParamGetMethod"] != nil {
                    self.paramGetMethod = dict["ParamGetMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RequestBodyModel") && dict["RequestBodyModel"] != nil {
                    self.requestBodyModel = dict["RequestBodyModel"] as! String
                }
                if dict.keys.contains("RequestParams") && dict["RequestParams"] != nil {
                    var tmp : [ListMgsApiResponseBody.ResultContent.Value.RequestParams] = []
                    for v in dict["RequestParams"] as! [Any] {
                        var model = ListMgsApiResponseBody.ResultContent.Value.RequestParams()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.requestParams = tmp
                }
                if dict.keys.contains("ResponseBodyModel") && dict["ResponseBodyModel"] != nil {
                    self.responseBodyModel = dict["ResponseBodyModel"] as! String
                }
                if dict.keys.contains("SysId") && dict["SysId"] != nil {
                    self.sysId = dict["SysId"] as! Int64
                }
                if dict.keys.contains("SysName") && dict["SysName"] != nil {
                    self.sysName = dict["SysName"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
            }
        }
        public var errorMessage: String?

        public var success: Bool?

        public var value: [ListMgsApiResponseBody.ResultContent.Value]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.value != nil {
                var tmp : [Any] = []
                for k in self.value! {
                    tmp.append(k.toMap())
                }
                map["Value"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                var tmp : [ListMgsApiResponseBody.ResultContent.Value] = []
                for v in dict["Value"] as! [Any] {
                    var model = ListMgsApiResponseBody.ResultContent.Value()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.value = tmp
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: ListMgsApiResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = ListMgsApiResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class ListMgsApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMgsApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMgsApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LogMsaQueryRequest : Tea.TeaModel {
    public var appId: String?

    public var id: String?

    public var onexFlag: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class LogMsaQueryResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: LogMsaQueryResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = LogMsaQueryResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class LogMsaQueryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LogMsaQueryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = LogMsaQueryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiAddActiveCodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiAddActiveCodeReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiAddActiveCodeReqJsonStr != nil {
            map["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"] = self.mpaasMqcpOpenApiAddActiveCodeReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiAddActiveCodeReqJsonStr") && dict["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiAddActiveCodeReqJsonStr = dict["MpaasMqcpOpenApiAddActiveCodeReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiAddActiveCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiAddActiveCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiAddActiveCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiAddActiveCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiAddActiveSceneRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiAddActiveSceneReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiAddActiveSceneReqJsonStr != nil {
            map["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"] = self.mpaasMqcpOpenApiAddActiveSceneReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiAddActiveSceneReqJsonStr") && dict["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiAddActiveSceneReqJsonStr = dict["MpaasMqcpOpenApiAddActiveSceneReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiAddActiveSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiAddActiveSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiAddActiveSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiAddActiveSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiCallbackRequestJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiCallbackRequestJsonStr != nil {
            map["MpaasMqcpOpenApiCallbackRequestJsonStr"] = self.mpaasMqcpOpenApiCallbackRequestJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiCallbackRequestJsonStr") && dict["MpaasMqcpOpenApiCallbackRequestJsonStr"] != nil {
            self.mpaasMqcpOpenApiCallbackRequestJsonStr = dict["MpaasMqcpOpenApiCallbackRequestJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiCallbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiCallbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiDecodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiDecodeRequestJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiDecodeRequestJsonStr != nil {
            map["MpaasMqcpOpenApiDecodeRequestJsonStr"] = self.mpaasMqcpOpenApiDecodeRequestJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiDecodeRequestJsonStr") && dict["MpaasMqcpOpenApiDecodeRequestJsonStr"] != nil {
            self.mpaasMqcpOpenApiDecodeRequestJsonStr = dict["MpaasMqcpOpenApiDecodeRequestJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiDecodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiDecodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiDecodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiDecodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiDeleteActiveCodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr != nil {
            map["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"] = self.mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr") && dict["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr = dict["MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiDeleteActiveCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiDeleteActiveCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiDeleteActiveCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiDeleteActiveCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiEncodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiEncodeRequestJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiEncodeRequestJsonStr != nil {
            map["MpaasMqcpOpenApiEncodeRequestJsonStr"] = self.mpaasMqcpOpenApiEncodeRequestJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiEncodeRequestJsonStr") && dict["MpaasMqcpOpenApiEncodeRequestJsonStr"] != nil {
            self.mpaasMqcpOpenApiEncodeRequestJsonStr = dict["MpaasMqcpOpenApiEncodeRequestJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiEncodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiEncodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiEncodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiEncodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiQueryActiveCodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiQueryActiveCodeReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiQueryActiveCodeReqJsonStr != nil {
            map["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"] = self.mpaasMqcpOpenApiQueryActiveCodeReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiQueryActiveCodeReqJsonStr") && dict["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiQueryActiveCodeReqJsonStr = dict["MpaasMqcpOpenApiQueryActiveCodeReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiQueryActiveCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class OpenApiQueryActiveCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiQueryActiveCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiQueryActiveCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiQueryActiveSceneRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiQueryActiveSceneReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiQueryActiveSceneReqJsonStr != nil {
            map["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"] = self.mpaasMqcpOpenApiQueryActiveSceneReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiQueryActiveSceneReqJsonStr") && dict["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiQueryActiveSceneReqJsonStr = dict["MpaasMqcpOpenApiQueryActiveSceneReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiQueryActiveSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiQueryActiveSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiQueryActiveSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiQueryActiveSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiUniqueEncodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiUniqueEncodeRequestJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiUniqueEncodeRequestJsonStr != nil {
            map["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"] = self.mpaasMqcpOpenApiUniqueEncodeRequestJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiUniqueEncodeRequestJsonStr") && dict["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"] != nil {
            self.mpaasMqcpOpenApiUniqueEncodeRequestJsonStr = dict["MpaasMqcpOpenApiUniqueEncodeRequestJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiUniqueEncodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiUniqueEncodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiUniqueEncodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiUniqueEncodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiUpdateActiveCodeRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr != nil {
            map["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"] = self.mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr") && dict["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr = dict["MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiUpdateActiveCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiUpdateActiveCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiUpdateActiveCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiUpdateActiveCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiUpdateActiveSceneRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr != nil {
            map["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"] = self.mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr") && dict["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"] != nil {
            self.mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr = dict["MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class OpenApiUpdateActiveSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
    }
}

public class OpenApiUpdateActiveSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiUpdateActiveSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenApiUpdateActiveSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushBindRequest : Tea.TeaModel {
    public var appId: String?

    public var deliveryToken: String?

    public var osType: Int32?

    public var phoneNumber: String?

    public var userId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deliveryToken != nil {
            map["DeliveryToken"] = self.deliveryToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeliveryToken") && dict["DeliveryToken"] != nil {
            self.deliveryToken = dict["DeliveryToken"] as! String
        }
        if dict.keys.contains("OsType") && dict["OsType"] != nil {
            self.osType = dict["OsType"] as! Int32
        }
        if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushBindResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushBindResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushBindResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushBroadcastRequest : Tea.TeaModel {
    public var androidChannel: Int32?

    public var appId: String?

    public var bindPeriod: Int32?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var msgkey: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var pushStatus: Int64?

    public var silent: Int64?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var taskName: String?

    public var templateKeyValue: String?

    public var templateName: String?

    public var thirdChannelCategory: [String: Any]?

    public var unBindPeriod: Int64?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.androidChannel != nil {
            map["AndroidChannel"] = self.androidChannel!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bindPeriod != nil {
            map["BindPeriod"] = self.bindPeriod!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.msgkey != nil {
            map["Msgkey"] = self.msgkey!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.pushStatus != nil {
            map["PushStatus"] = self.pushStatus!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateKeyValue != nil {
            map["TemplateKeyValue"] = self.templateKeyValue!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategory != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategory!
        }
        if self.unBindPeriod != nil {
            map["UnBindPeriod"] = self.unBindPeriod!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AndroidChannel") && dict["AndroidChannel"] != nil {
            self.androidChannel = dict["AndroidChannel"] as! Int32
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BindPeriod") && dict["BindPeriod"] != nil {
            self.bindPeriod = dict["BindPeriod"] as! Int32
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("Msgkey") && dict["Msgkey"] != nil {
            self.msgkey = dict["Msgkey"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("PushStatus") && dict["PushStatus"] != nil {
            self.pushStatus = dict["PushStatus"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
            self.templateKeyValue = dict["TemplateKeyValue"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategory = dict["ThirdChannelCategory"] as! [String: Any]
        }
        if dict.keys.contains("UnBindPeriod") && dict["UnBindPeriod"] != nil {
            self.unBindPeriod = dict["UnBindPeriod"] as! Int64
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushBroadcastShrinkRequest : Tea.TeaModel {
    public var androidChannel: Int32?

    public var appId: String?

    public var bindPeriod: Int32?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var msgkey: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var pushStatus: Int64?

    public var silent: Int64?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var taskName: String?

    public var templateKeyValue: String?

    public var templateName: String?

    public var thirdChannelCategoryShrink: String?

    public var unBindPeriod: Int64?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.androidChannel != nil {
            map["AndroidChannel"] = self.androidChannel!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bindPeriod != nil {
            map["BindPeriod"] = self.bindPeriod!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.msgkey != nil {
            map["Msgkey"] = self.msgkey!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.pushStatus != nil {
            map["PushStatus"] = self.pushStatus!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateKeyValue != nil {
            map["TemplateKeyValue"] = self.templateKeyValue!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategoryShrink != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategoryShrink!
        }
        if self.unBindPeriod != nil {
            map["UnBindPeriod"] = self.unBindPeriod!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AndroidChannel") && dict["AndroidChannel"] != nil {
            self.androidChannel = dict["AndroidChannel"] as! Int32
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BindPeriod") && dict["BindPeriod"] != nil {
            self.bindPeriod = dict["BindPeriod"] as! Int32
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("Msgkey") && dict["Msgkey"] != nil {
            self.msgkey = dict["Msgkey"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("PushStatus") && dict["PushStatus"] != nil {
            self.pushStatus = dict["PushStatus"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
            self.templateKeyValue = dict["TemplateKeyValue"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategoryShrink = dict["ThirdChannelCategory"] as! String
        }
        if dict.keys.contains("UnBindPeriod") && dict["UnBindPeriod"] != nil {
            self.unBindPeriod = dict["UnBindPeriod"] as! Int64
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushBroadcastResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushBroadcastResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushBroadcastResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushBroadcastResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushBroadcastResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushBroadcastResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushMultipleRequest : Tea.TeaModel {
    public class TargetMsg : Tea.TeaModel {
        public var extendedParams: String?

        public var msgKey: String?

        public var target: String?

        public var templateKeyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendedParams != nil {
                map["ExtendedParams"] = self.extendedParams!
            }
            if self.msgKey != nil {
                map["MsgKey"] = self.msgKey!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.templateKeyValue != nil {
                map["TemplateKeyValue"] = self.templateKeyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
                self.extendedParams = dict["ExtendedParams"] as! String
            }
            if dict.keys.contains("MsgKey") && dict["MsgKey"] != nil {
                self.msgKey = dict["MsgKey"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
                self.templateKeyValue = dict["TemplateKeyValue"] as! String
            }
        }
    }
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var silent: Int64?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsg: [PushMultipleRequest.TargetMsg]?

    public var taskName: String?

    public var templateName: String?

    public var thirdChannelCategory: [String: Any]?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsg != nil {
            var tmp : [Any] = []
            for k in self.targetMsg! {
                tmp.append(k.toMap())
            }
            map["TargetMsg"] = tmp
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategory != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategory!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsg") && dict["TargetMsg"] != nil {
            var tmp : [PushMultipleRequest.TargetMsg] = []
            for v in dict["TargetMsg"] as! [Any] {
                var model = PushMultipleRequest.TargetMsg()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetMsg = tmp
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategory = dict["ThirdChannelCategory"] as! [String: Any]
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushMultipleShrinkRequest : Tea.TeaModel {
    public class TargetMsg : Tea.TeaModel {
        public var extendedParams: String?

        public var msgKey: String?

        public var target: String?

        public var templateKeyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendedParams != nil {
                map["ExtendedParams"] = self.extendedParams!
            }
            if self.msgKey != nil {
                map["MsgKey"] = self.msgKey!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.templateKeyValue != nil {
                map["TemplateKeyValue"] = self.templateKeyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
                self.extendedParams = dict["ExtendedParams"] as! String
            }
            if dict.keys.contains("MsgKey") && dict["MsgKey"] != nil {
                self.msgKey = dict["MsgKey"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
                self.templateKeyValue = dict["TemplateKeyValue"] as! String
            }
        }
    }
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var silent: Int64?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsg: [PushMultipleShrinkRequest.TargetMsg]?

    public var taskName: String?

    public var templateName: String?

    public var thirdChannelCategoryShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsg != nil {
            var tmp : [Any] = []
            for k in self.targetMsg! {
                tmp.append(k.toMap())
            }
            map["TargetMsg"] = tmp
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategoryShrink != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategoryShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsg") && dict["TargetMsg"] != nil {
            var tmp : [PushMultipleShrinkRequest.TargetMsg] = []
            for v in dict["TargetMsg"] as! [Any] {
                var model = PushMultipleShrinkRequest.TargetMsg()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetMsg = tmp
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategoryShrink = dict["ThirdChannelCategory"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushMultipleResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushMultipleResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushMultipleResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushMultipleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushMultipleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushMultipleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushReportRequest : Tea.TeaModel {
    public var appId: String?

    public var appVersion: String?

    public var channel: String?

    public var connectType: String?

    public var deliveryToken: String?

    public var imei: String?

    public var imsi: String?

    public var model: String?

    public var osType: Int32?

    public var pushVersion: String?

    public var thirdChannel: Int32?

    public var thirdChannelDeviceToken: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appVersion != nil {
            map["AppVersion"] = self.appVersion!
        }
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.connectType != nil {
            map["ConnectType"] = self.connectType!
        }
        if self.deliveryToken != nil {
            map["DeliveryToken"] = self.deliveryToken!
        }
        if self.imei != nil {
            map["Imei"] = self.imei!
        }
        if self.imsi != nil {
            map["Imsi"] = self.imsi!
        }
        if self.model != nil {
            map["Model"] = self.model!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.pushVersion != nil {
            map["PushVersion"] = self.pushVersion!
        }
        if self.thirdChannel != nil {
            map["ThirdChannel"] = self.thirdChannel!
        }
        if self.thirdChannelDeviceToken != nil {
            map["ThirdChannelDeviceToken"] = self.thirdChannelDeviceToken!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
            self.appVersion = dict["AppVersion"] as! String
        }
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("ConnectType") && dict["ConnectType"] != nil {
            self.connectType = dict["ConnectType"] as! String
        }
        if dict.keys.contains("DeliveryToken") && dict["DeliveryToken"] != nil {
            self.deliveryToken = dict["DeliveryToken"] as! String
        }
        if dict.keys.contains("Imei") && dict["Imei"] != nil {
            self.imei = dict["Imei"] as! String
        }
        if dict.keys.contains("Imsi") && dict["Imsi"] != nil {
            self.imsi = dict["Imsi"] as! String
        }
        if dict.keys.contains("Model") && dict["Model"] != nil {
            self.model = dict["Model"] as! String
        }
        if dict.keys.contains("OsType") && dict["OsType"] != nil {
            self.osType = dict["OsType"] as! Int32
        }
        if dict.keys.contains("PushVersion") && dict["PushVersion"] != nil {
            self.pushVersion = dict["PushVersion"] as! String
        }
        if dict.keys.contains("ThirdChannel") && dict["ThirdChannel"] != nil {
            self.thirdChannel = dict["ThirdChannel"] as! Int32
        }
        if dict.keys.contains("ThirdChannelDeviceToken") && dict["ThirdChannelDeviceToken"] != nil {
            self.thirdChannelDeviceToken = dict["ThirdChannelDeviceToken"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushReportResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushReportResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushReportResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushSimpleRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var content: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var iconUrls: String?

    public var imageUrls: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var pushStyle: Int32?

    public var silent: Int64?

    public var smsSignName: String?

    public var smsStrategy: Int32?

    public var smsTemplateCode: String?

    public var smsTemplateParam: String?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsgkey: String?

    public var taskName: String?

    public var thirdChannelCategory: [String: Any]?

    public var title: String?

    public var uri: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.iconUrls != nil {
            map["IconUrls"] = self.iconUrls!
        }
        if self.imageUrls != nil {
            map["ImageUrls"] = self.imageUrls!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.pushStyle != nil {
            map["PushStyle"] = self.pushStyle!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.smsSignName != nil {
            map["SmsSignName"] = self.smsSignName!
        }
        if self.smsStrategy != nil {
            map["SmsStrategy"] = self.smsStrategy!
        }
        if self.smsTemplateCode != nil {
            map["SmsTemplateCode"] = self.smsTemplateCode!
        }
        if self.smsTemplateParam != nil {
            map["SmsTemplateParam"] = self.smsTemplateParam!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsgkey != nil {
            map["TargetMsgkey"] = self.targetMsgkey!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.thirdChannelCategory != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategory!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.uri != nil {
            map["Uri"] = self.uri!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("IconUrls") && dict["IconUrls"] != nil {
            self.iconUrls = dict["IconUrls"] as! String
        }
        if dict.keys.contains("ImageUrls") && dict["ImageUrls"] != nil {
            self.imageUrls = dict["ImageUrls"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("PushStyle") && dict["PushStyle"] != nil {
            self.pushStyle = dict["PushStyle"] as! Int32
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("SmsSignName") && dict["SmsSignName"] != nil {
            self.smsSignName = dict["SmsSignName"] as! String
        }
        if dict.keys.contains("SmsStrategy") && dict["SmsStrategy"] != nil {
            self.smsStrategy = dict["SmsStrategy"] as! Int32
        }
        if dict.keys.contains("SmsTemplateCode") && dict["SmsTemplateCode"] != nil {
            self.smsTemplateCode = dict["SmsTemplateCode"] as! String
        }
        if dict.keys.contains("SmsTemplateParam") && dict["SmsTemplateParam"] != nil {
            self.smsTemplateParam = dict["SmsTemplateParam"] as! String
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsgkey") && dict["TargetMsgkey"] != nil {
            self.targetMsgkey = dict["TargetMsgkey"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategory = dict["ThirdChannelCategory"] as! [String: Any]
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Uri") && dict["Uri"] != nil {
            self.uri = dict["Uri"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushSimpleShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var content: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var iconUrls: String?

    public var imageUrls: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var pushStyle: Int32?

    public var silent: Int64?

    public var smsSignName: String?

    public var smsStrategy: Int32?

    public var smsTemplateCode: String?

    public var smsTemplateParam: String?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsgkey: String?

    public var taskName: String?

    public var thirdChannelCategoryShrink: String?

    public var title: String?

    public var uri: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.iconUrls != nil {
            map["IconUrls"] = self.iconUrls!
        }
        if self.imageUrls != nil {
            map["ImageUrls"] = self.imageUrls!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.pushStyle != nil {
            map["PushStyle"] = self.pushStyle!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.smsSignName != nil {
            map["SmsSignName"] = self.smsSignName!
        }
        if self.smsStrategy != nil {
            map["SmsStrategy"] = self.smsStrategy!
        }
        if self.smsTemplateCode != nil {
            map["SmsTemplateCode"] = self.smsTemplateCode!
        }
        if self.smsTemplateParam != nil {
            map["SmsTemplateParam"] = self.smsTemplateParam!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsgkey != nil {
            map["TargetMsgkey"] = self.targetMsgkey!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.thirdChannelCategoryShrink != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategoryShrink!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.uri != nil {
            map["Uri"] = self.uri!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("IconUrls") && dict["IconUrls"] != nil {
            self.iconUrls = dict["IconUrls"] as! String
        }
        if dict.keys.contains("ImageUrls") && dict["ImageUrls"] != nil {
            self.imageUrls = dict["ImageUrls"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("PushStyle") && dict["PushStyle"] != nil {
            self.pushStyle = dict["PushStyle"] as! Int32
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("SmsSignName") && dict["SmsSignName"] != nil {
            self.smsSignName = dict["SmsSignName"] as! String
        }
        if dict.keys.contains("SmsStrategy") && dict["SmsStrategy"] != nil {
            self.smsStrategy = dict["SmsStrategy"] as! Int32
        }
        if dict.keys.contains("SmsTemplateCode") && dict["SmsTemplateCode"] != nil {
            self.smsTemplateCode = dict["SmsTemplateCode"] as! String
        }
        if dict.keys.contains("SmsTemplateParam") && dict["SmsTemplateParam"] != nil {
            self.smsTemplateParam = dict["SmsTemplateParam"] as! String
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsgkey") && dict["TargetMsgkey"] != nil {
            self.targetMsgkey = dict["TargetMsgkey"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategoryShrink = dict["ThirdChannelCategory"] as! String
        }
        if dict.keys.contains("Title") && dict["Title"] != nil {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("Uri") && dict["Uri"] != nil {
            self.uri = dict["Uri"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushSimpleResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushSimpleResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushSimpleResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushSimpleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushSimpleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushSimpleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushTemplateRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var silent: Int64?

    public var smsSignName: String?

    public var smsStrategy: Int32?

    public var smsTemplateCode: String?

    public var smsTemplateParam: String?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsgkey: String?

    public var taskName: String?

    public var templateKeyValue: String?

    public var templateName: String?

    public var thirdChannelCategory: [String: Any]?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.smsSignName != nil {
            map["SmsSignName"] = self.smsSignName!
        }
        if self.smsStrategy != nil {
            map["SmsStrategy"] = self.smsStrategy!
        }
        if self.smsTemplateCode != nil {
            map["SmsTemplateCode"] = self.smsTemplateCode!
        }
        if self.smsTemplateParam != nil {
            map["SmsTemplateParam"] = self.smsTemplateParam!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsgkey != nil {
            map["TargetMsgkey"] = self.targetMsgkey!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateKeyValue != nil {
            map["TemplateKeyValue"] = self.templateKeyValue!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategory != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategory!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("SmsSignName") && dict["SmsSignName"] != nil {
            self.smsSignName = dict["SmsSignName"] as! String
        }
        if dict.keys.contains("SmsStrategy") && dict["SmsStrategy"] != nil {
            self.smsStrategy = dict["SmsStrategy"] as! Int32
        }
        if dict.keys.contains("SmsTemplateCode") && dict["SmsTemplateCode"] != nil {
            self.smsTemplateCode = dict["SmsTemplateCode"] as! String
        }
        if dict.keys.contains("SmsTemplateParam") && dict["SmsTemplateParam"] != nil {
            self.smsTemplateParam = dict["SmsTemplateParam"] as! String
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsgkey") && dict["TargetMsgkey"] != nil {
            self.targetMsgkey = dict["TargetMsgkey"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
            self.templateKeyValue = dict["TemplateKeyValue"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategory = dict["ThirdChannelCategory"] as! [String: Any]
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushTemplateShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var classification: String?

    public var deliveryType: Int64?

    public var expiredSeconds: Int64?

    public var extendedParams: String?

    public var miChannelId: String?

    public var notifyType: String?

    public var pushAction: Int64?

    public var silent: Int64?

    public var smsSignName: String?

    public var smsStrategy: Int32?

    public var smsTemplateCode: String?

    public var smsTemplateParam: String?

    public var strategyContent: String?

    public var strategyType: Int32?

    public var targetMsgkey: String?

    public var taskName: String?

    public var templateKeyValue: String?

    public var templateName: String?

    public var thirdChannelCategoryShrink: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.classification != nil {
            map["Classification"] = self.classification!
        }
        if self.deliveryType != nil {
            map["DeliveryType"] = self.deliveryType!
        }
        if self.expiredSeconds != nil {
            map["ExpiredSeconds"] = self.expiredSeconds!
        }
        if self.extendedParams != nil {
            map["ExtendedParams"] = self.extendedParams!
        }
        if self.miChannelId != nil {
            map["MiChannelId"] = self.miChannelId!
        }
        if self.notifyType != nil {
            map["NotifyType"] = self.notifyType!
        }
        if self.pushAction != nil {
            map["PushAction"] = self.pushAction!
        }
        if self.silent != nil {
            map["Silent"] = self.silent!
        }
        if self.smsSignName != nil {
            map["SmsSignName"] = self.smsSignName!
        }
        if self.smsStrategy != nil {
            map["SmsStrategy"] = self.smsStrategy!
        }
        if self.smsTemplateCode != nil {
            map["SmsTemplateCode"] = self.smsTemplateCode!
        }
        if self.smsTemplateParam != nil {
            map["SmsTemplateParam"] = self.smsTemplateParam!
        }
        if self.strategyContent != nil {
            map["StrategyContent"] = self.strategyContent!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        if self.targetMsgkey != nil {
            map["TargetMsgkey"] = self.targetMsgkey!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.templateKeyValue != nil {
            map["TemplateKeyValue"] = self.templateKeyValue!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.thirdChannelCategoryShrink != nil {
            map["ThirdChannelCategory"] = self.thirdChannelCategoryShrink!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Classification") && dict["Classification"] != nil {
            self.classification = dict["Classification"] as! String
        }
        if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
            self.deliveryType = dict["DeliveryType"] as! Int64
        }
        if dict.keys.contains("ExpiredSeconds") && dict["ExpiredSeconds"] != nil {
            self.expiredSeconds = dict["ExpiredSeconds"] as! Int64
        }
        if dict.keys.contains("ExtendedParams") && dict["ExtendedParams"] != nil {
            self.extendedParams = dict["ExtendedParams"] as! String
        }
        if dict.keys.contains("MiChannelId") && dict["MiChannelId"] != nil {
            self.miChannelId = dict["MiChannelId"] as! String
        }
        if dict.keys.contains("NotifyType") && dict["NotifyType"] != nil {
            self.notifyType = dict["NotifyType"] as! String
        }
        if dict.keys.contains("PushAction") && dict["PushAction"] != nil {
            self.pushAction = dict["PushAction"] as! Int64
        }
        if dict.keys.contains("Silent") && dict["Silent"] != nil {
            self.silent = dict["Silent"] as! Int64
        }
        if dict.keys.contains("SmsSignName") && dict["SmsSignName"] != nil {
            self.smsSignName = dict["SmsSignName"] as! String
        }
        if dict.keys.contains("SmsStrategy") && dict["SmsStrategy"] != nil {
            self.smsStrategy = dict["SmsStrategy"] as! Int32
        }
        if dict.keys.contains("SmsTemplateCode") && dict["SmsTemplateCode"] != nil {
            self.smsTemplateCode = dict["SmsTemplateCode"] as! String
        }
        if dict.keys.contains("SmsTemplateParam") && dict["SmsTemplateParam"] != nil {
            self.smsTemplateParam = dict["SmsTemplateParam"] as! String
        }
        if dict.keys.contains("StrategyContent") && dict["StrategyContent"] != nil {
            self.strategyContent = dict["StrategyContent"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! Int32
        }
        if dict.keys.contains("TargetMsgkey") && dict["TargetMsgkey"] != nil {
            self.targetMsgkey = dict["TargetMsgkey"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TemplateKeyValue") && dict["TemplateKeyValue"] != nil {
            self.templateKeyValue = dict["TemplateKeyValue"] as! String
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("ThirdChannelCategory") && dict["ThirdChannelCategory"] != nil {
            self.thirdChannelCategoryShrink = dict["ThirdChannelCategory"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushTemplateResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushTemplateResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushTemplateResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushUnBindRequest : Tea.TeaModel {
    public var appId: String?

    public var deliveryToken: String?

    public var userId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deliveryToken != nil {
            map["DeliveryToken"] = self.deliveryToken!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeliveryToken") && dict["DeliveryToken"] != nil {
            self.deliveryToken = dict["DeliveryToken"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class PushUnBindResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: PushUnBindResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = PushUnBindResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class PushUnBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushUnBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushUnBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMappCenterAppRequest : Tea.TeaModel {
    public var appId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMappCenterAppResponseBody : Tea.TeaModel {
    public class QueryMappCenterAppResult : Tea.TeaModel {
        public class MappCenterApp : Tea.TeaModel {
            public class AndroidConfig : Tea.TeaModel {
                public var certRSA: String?

                public var packageName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.certRSA != nil {
                        map["CertRSA"] = self.certRSA!
                    }
                    if self.packageName != nil {
                        map["PackageName"] = self.packageName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CertRSA") && dict["CertRSA"] != nil {
                        self.certRSA = dict["CertRSA"] as! String
                    }
                    if dict.keys.contains("PackageName") && dict["PackageName"] != nil {
                        self.packageName = dict["PackageName"] as! String
                    }
                }
            }
            public class IosConfig : Tea.TeaModel {
                public var bundleId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bundleId != nil {
                        map["BundleId"] = self.bundleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BundleId") && dict["BundleId"] != nil {
                        self.bundleId = dict["BundleId"] as! String
                    }
                }
            }
            public var androidConfig: QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp.AndroidConfig?

            public var appDesc: String?

            public var appIcon: String?

            public var appId: String?

            public var appName: String?

            public var appSecret: String?

            public var creator: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var iosConfig: QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp.IosConfig?

            public var modifier: String?

            public var monitorJson: String?

            public var status: Int64?

            public var tenantId: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.androidConfig?.validate()
                try self.iosConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.androidConfig != nil {
                    map["AndroidConfig"] = self.androidConfig?.toMap()
                }
                if self.appDesc != nil {
                    map["AppDesc"] = self.appDesc!
                }
                if self.appIcon != nil {
                    map["AppIcon"] = self.appIcon!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.appSecret != nil {
                    map["AppSecret"] = self.appSecret!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.iosConfig != nil {
                    map["IosConfig"] = self.iosConfig?.toMap()
                }
                if self.modifier != nil {
                    map["Modifier"] = self.modifier!
                }
                if self.monitorJson != nil {
                    map["MonitorJson"] = self.monitorJson!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AndroidConfig") && dict["AndroidConfig"] != nil {
                    var model = QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp.AndroidConfig()
                    model.fromMap(dict["AndroidConfig"] as! [String: Any])
                    self.androidConfig = model
                }
                if dict.keys.contains("AppDesc") && dict["AppDesc"] != nil {
                    self.appDesc = dict["AppDesc"] as! String
                }
                if dict.keys.contains("AppIcon") && dict["AppIcon"] != nil {
                    self.appIcon = dict["AppIcon"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AppSecret") && dict["AppSecret"] != nil {
                    self.appSecret = dict["AppSecret"] as! String
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IosConfig") && dict["IosConfig"] != nil {
                    var model = QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp.IosConfig()
                    model.fromMap(dict["IosConfig"] as! [String: Any])
                    self.iosConfig = model
                }
                if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                    self.modifier = dict["Modifier"] as! String
                }
                if dict.keys.contains("MonitorJson") && dict["MonitorJson"] != nil {
                    self.monitorJson = dict["MonitorJson"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public var mappCenterApp: QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mappCenterApp?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mappCenterApp != nil {
                map["MappCenterApp"] = self.mappCenterApp?.toMap()
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MappCenterApp") && dict["MappCenterApp"] != nil {
                var model = QueryMappCenterAppResponseBody.QueryMappCenterAppResult.MappCenterApp()
                model.fromMap(dict["MappCenterApp"] as! [String: Any])
                self.mappCenterApp = model
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var queryMappCenterAppResult: QueryMappCenterAppResponseBody.QueryMappCenterAppResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryMappCenterAppResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryMappCenterAppResult != nil {
            map["QueryMappCenterAppResult"] = self.queryMappCenterAppResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QueryMappCenterAppResult") && dict["QueryMappCenterAppResult"] != nil {
            var model = QueryMappCenterAppResponseBody.QueryMappCenterAppResult()
            model.fromMap(dict["QueryMappCenterAppResult"] as! [String: Any])
            self.queryMappCenterAppResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMappCenterAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMappCenterAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMappCenterAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMcdpAimRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMcdpAimResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMcdpAimResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMcdpAimResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMcdpAimResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMcdpAimResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMcdpAimResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMcdpZoneRequest : Tea.TeaModel {
    public var appId: String?

    public var id: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMcdpZoneResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMcdpZoneResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMcdpZoneResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMcdpZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMcdpZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMcdpZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMcubeMiniPackageRequest : Tea.TeaModel {
    public var appId: String?

    public var h5Id: String?

    public var id: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMcubeMiniPackageResponseBody : Tea.TeaModel {
    public class QueryMiniPackageResult : Tea.TeaModel {
        public class MiniPackageInfo : Tea.TeaModel {
            public var appCode: String?

            public var autoInstall: Int64?

            public var clientVersionMax: String?

            public var clientVersionMin: String?

            public var downloadUrl: String?

            public var extendInfo: String?

            public var extraData: String?

            public var fallbackBaseUrl: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var h5Id: String?

            public var h5Name: String?

            public var h5Version: String?

            public var id: Int64?

            public var installType: Int64?

            public var mainUrl: String?

            public var memo: String?

            public var packageType: Int64?

            public var platform: String?

            public var publishPeriod: Int64?

            public var resourceType: Int64?

            public var status: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.autoInstall != nil {
                    map["AutoInstall"] = self.autoInstall!
                }
                if self.clientVersionMax != nil {
                    map["ClientVersionMax"] = self.clientVersionMax!
                }
                if self.clientVersionMin != nil {
                    map["ClientVersionMin"] = self.clientVersionMin!
                }
                if self.downloadUrl != nil {
                    map["DownloadUrl"] = self.downloadUrl!
                }
                if self.extendInfo != nil {
                    map["ExtendInfo"] = self.extendInfo!
                }
                if self.extraData != nil {
                    map["ExtraData"] = self.extraData!
                }
                if self.fallbackBaseUrl != nil {
                    map["FallbackBaseUrl"] = self.fallbackBaseUrl!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.h5Id != nil {
                    map["H5Id"] = self.h5Id!
                }
                if self.h5Name != nil {
                    map["H5Name"] = self.h5Name!
                }
                if self.h5Version != nil {
                    map["H5Version"] = self.h5Version!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.installType != nil {
                    map["InstallType"] = self.installType!
                }
                if self.mainUrl != nil {
                    map["MainUrl"] = self.mainUrl!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.packageType != nil {
                    map["PackageType"] = self.packageType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.publishPeriod != nil {
                    map["PublishPeriod"] = self.publishPeriod!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
                    self.autoInstall = dict["AutoInstall"] as! Int64
                }
                if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
                    self.clientVersionMax = dict["ClientVersionMax"] as! String
                }
                if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
                    self.clientVersionMin = dict["ClientVersionMin"] as! String
                }
                if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                    self.downloadUrl = dict["DownloadUrl"] as! String
                }
                if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
                    self.extendInfo = dict["ExtendInfo"] as! String
                }
                if dict.keys.contains("ExtraData") && dict["ExtraData"] != nil {
                    self.extraData = dict["ExtraData"] as! String
                }
                if dict.keys.contains("FallbackBaseUrl") && dict["FallbackBaseUrl"] != nil {
                    self.fallbackBaseUrl = dict["FallbackBaseUrl"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
                    self.h5Id = dict["H5Id"] as! String
                }
                if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
                    self.h5Name = dict["H5Name"] as! String
                }
                if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
                    self.h5Version = dict["H5Version"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
                    self.installType = dict["InstallType"] as! Int64
                }
                if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
                    self.mainUrl = dict["MainUrl"] as! String
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                    self.packageType = dict["PackageType"] as! Int64
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PublishPeriod") && dict["PublishPeriod"] != nil {
                    self.publishPeriod = dict["PublishPeriod"] as! Int64
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
            }
        }
        public var miniPackageInfo: QueryMcubeMiniPackageResponseBody.QueryMiniPackageResult.MiniPackageInfo?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.miniPackageInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.miniPackageInfo != nil {
                map["MiniPackageInfo"] = self.miniPackageInfo?.toMap()
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MiniPackageInfo") && dict["MiniPackageInfo"] != nil {
                var model = QueryMcubeMiniPackageResponseBody.QueryMiniPackageResult.MiniPackageInfo()
                model.fromMap(dict["MiniPackageInfo"] as! [String: Any])
                self.miniPackageInfo = model
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var queryMiniPackageResult: QueryMcubeMiniPackageResponseBody.QueryMiniPackageResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryMiniPackageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryMiniPackageResult != nil {
            map["QueryMiniPackageResult"] = self.queryMiniPackageResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QueryMiniPackageResult") && dict["QueryMiniPackageResult"] != nil {
            var model = QueryMcubeMiniPackageResponseBody.QueryMiniPackageResult()
            model.fromMap(dict["QueryMiniPackageResult"] as! [String: Any])
            self.queryMiniPackageResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMcubeMiniPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMcubeMiniPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMcubeMiniPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMcubeMiniTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMcubeMiniTaskResponseBody : Tea.TeaModel {
    public class QueryMiniTaskResult : Tea.TeaModel {
        public class MiniTaskInfo : Tea.TeaModel {
            public var appCode: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var greyConfigInfo: String?

            public var greyEndtime: String?

            public var greyEndtimeData: String?

            public var greyNum: Int64?

            public var id: Int64?

            public var memo: String?

            public var packageId: Int64?

            public var platform: String?

            public var productVersion: String?

            public var publishMode: Int64?

            public var publishType: Int64?

            public var status: String?

            public var taskStatus: Int64?

            public var whitelistIds: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.greyConfigInfo != nil {
                    map["GreyConfigInfo"] = self.greyConfigInfo!
                }
                if self.greyEndtime != nil {
                    map["GreyEndtime"] = self.greyEndtime!
                }
                if self.greyEndtimeData != nil {
                    map["GreyEndtimeData"] = self.greyEndtimeData!
                }
                if self.greyNum != nil {
                    map["GreyNum"] = self.greyNum!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.publishMode != nil {
                    map["PublishMode"] = self.publishMode!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                if self.whitelistIds != nil {
                    map["WhitelistIds"] = self.whitelistIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                    self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                }
                if dict.keys.contains("GreyEndtime") && dict["GreyEndtime"] != nil {
                    self.greyEndtime = dict["GreyEndtime"] as! String
                }
                if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                    self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                }
                if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                    self.greyNum = dict["GreyNum"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Memo") && dict["Memo"] != nil {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
                    self.packageId = dict["PackageId"] as! Int64
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                    self.productVersion = dict["ProductVersion"] as! String
                }
                if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                    self.publishMode = dict["PublishMode"] as! Int64
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                    self.taskStatus = dict["TaskStatus"] as! Int64
                }
                if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                    self.whitelistIds = dict["WhitelistIds"] as! String
                }
            }
        }
        public var miniTaskInfo: QueryMcubeMiniTaskResponseBody.QueryMiniTaskResult.MiniTaskInfo?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.miniTaskInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.miniTaskInfo != nil {
                map["MiniTaskInfo"] = self.miniTaskInfo?.toMap()
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MiniTaskInfo") && dict["MiniTaskInfo"] != nil {
                var model = QueryMcubeMiniTaskResponseBody.QueryMiniTaskResult.MiniTaskInfo()
                model.fromMap(dict["MiniTaskInfo"] as! [String: Any])
                self.miniTaskInfo = model
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var queryMiniTaskResult: QueryMcubeMiniTaskResponseBody.QueryMiniTaskResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryMiniTaskResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryMiniTaskResult != nil {
            map["QueryMiniTaskResult"] = self.queryMiniTaskResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QueryMiniTaskResult") && dict["QueryMiniTaskResult"] != nil {
            var model = QueryMcubeMiniTaskResponseBody.QueryMiniTaskResult()
            model.fromMap(dict["QueryMiniTaskResult"] as! [String: Any])
            self.queryMiniTaskResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMcubeMiniTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMcubeMiniTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMcubeMiniTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMcubeVhostRequest : Tea.TeaModel {
    public var appId: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMcubeVhostResponseBody : Tea.TeaModel {
    public class QueryVhostResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var queryVhostResult: QueryMcubeVhostResponseBody.QueryVhostResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.queryVhostResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.queryVhostResult != nil {
            map["QueryVhostResult"] = self.queryVhostResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QueryVhostResult") && dict["QueryVhostResult"] != nil {
            var model = QueryMcubeVhostResponseBody.QueryVhostResult()
            model.fromMap(dict["QueryVhostResult"] as! [String: Any])
            self.queryVhostResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMcubeVhostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMcubeVhostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMcubeVhostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMdsUpgradeTaskDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: Int64?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMdsUpgradeTaskDetailResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Content : Tea.TeaModel {
                public class RuleJsonList : Tea.TeaModel {
                    public var operation: String?

                    public var ruleElement: String?

                    public var ruleType: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operation != nil {
                            map["Operation"] = self.operation!
                        }
                        if self.ruleElement != nil {
                            map["RuleElement"] = self.ruleElement!
                        }
                        if self.ruleType != nil {
                            map["RuleType"] = self.ruleType!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operation") && dict["Operation"] != nil {
                            self.operation = dict["Operation"] as! String
                        }
                        if dict.keys.contains("RuleElement") && dict["RuleElement"] != nil {
                            self.ruleElement = dict["RuleElement"] as! String
                        }
                        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                            self.ruleType = dict["RuleType"] as! String
                        }
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Whitelist : Tea.TeaModel {
                    public var appCode: String?

                    public var business: String?

                    public var gmtModified: String?

                    public var id: Int64?

                    public var idType: String?

                    public var platform: String?

                    public var status: Int64?

                    public var whiteListCount: Int64?

                    public var whiteListName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appCode != nil {
                            map["AppCode"] = self.appCode!
                        }
                        if self.business != nil {
                            map["Business"] = self.business!
                        }
                        if self.gmtModified != nil {
                            map["GmtModified"] = self.gmtModified!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.idType != nil {
                            map["IdType"] = self.idType!
                        }
                        if self.platform != nil {
                            map["Platform"] = self.platform!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.whiteListCount != nil {
                            map["WhiteListCount"] = self.whiteListCount!
                        }
                        if self.whiteListName != nil {
                            map["WhiteListName"] = self.whiteListName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                            self.appCode = dict["AppCode"] as! String
                        }
                        if dict.keys.contains("Business") && dict["Business"] != nil {
                            self.business = dict["Business"] as! String
                        }
                        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                            self.gmtModified = dict["GmtModified"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("IdType") && dict["IdType"] != nil {
                            self.idType = dict["IdType"] as! String
                        }
                        if dict.keys.contains("Platform") && dict["Platform"] != nil {
                            self.platform = dict["Platform"] as! String
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! Int64
                        }
                        if dict.keys.contains("WhiteListCount") && dict["WhiteListCount"] != nil {
                            self.whiteListCount = dict["WhiteListCount"] as! Int64
                        }
                        if dict.keys.contains("WhiteListName") && dict["WhiteListName"] != nil {
                            self.whiteListName = dict["WhiteListName"] as! String
                        }
                    }
                }
                public var appCode: String?

                public var appId: String?

                public var appstoreurl: String?

                public var channelContains: String?

                public var channelExcludes: String?

                public var cityContains: String?

                public var cityExcludes: String?

                public var creator: String?

                public var deviceGreyNum: Int64?

                public var devicePercent: Int64?

                public var downloadUrl: String?

                public var executionOrder: Int64?

                public var gmtCreateStr: String?

                public var greyConfigInfo: String?

                public var greyEndtimeData: String?

                public var greyNotice: Int64?

                public var greyNum: Int64?

                public var greyUv: Int64?

                public var id: Int64?

                public var innerVersion: String?

                public var isEnterprise: Int64?

                public var isOfficial: Int64?

                public var isPush: Int64?

                public var isRc: Int64?

                public var isRelease: Int64?

                public var memo: String?

                public var mobileModelContains: String?

                public var mobileModelExcludes: String?

                public var modifier: String?

                public var netType: String?

                public var osVersion: String?

                public var packageInfoId: Int64?

                public var packageType: String?

                public var platform: String?

                public var productId: String?

                public var productVersion: String?

                public var publishMode: Int64?

                public var publishType: Int64?

                public var pushContent: String?

                public var qrcodeUrl: String?

                public var releaseType: String?

                public var ruleJsonList: [QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.RuleJsonList]?

                public var silentType: Int64?

                public var syncMode: String?

                public var syncResult: String?

                public var taskStatus: Int64?

                public var upgradeContent: String?

                public var upgradeType: Int64?

                public var upgradeValidTime: Int64?

                public var whitelist: [QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.Whitelist]?

                public var whitelistIds: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appstoreurl != nil {
                        map["Appstoreurl"] = self.appstoreurl!
                    }
                    if self.channelContains != nil {
                        map["ChannelContains"] = self.channelContains!
                    }
                    if self.channelExcludes != nil {
                        map["ChannelExcludes"] = self.channelExcludes!
                    }
                    if self.cityContains != nil {
                        map["CityContains"] = self.cityContains!
                    }
                    if self.cityExcludes != nil {
                        map["CityExcludes"] = self.cityExcludes!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.deviceGreyNum != nil {
                        map["DeviceGreyNum"] = self.deviceGreyNum!
                    }
                    if self.devicePercent != nil {
                        map["DevicePercent"] = self.devicePercent!
                    }
                    if self.downloadUrl != nil {
                        map["DownloadUrl"] = self.downloadUrl!
                    }
                    if self.executionOrder != nil {
                        map["ExecutionOrder"] = self.executionOrder!
                    }
                    if self.gmtCreateStr != nil {
                        map["GmtCreateStr"] = self.gmtCreateStr!
                    }
                    if self.greyConfigInfo != nil {
                        map["GreyConfigInfo"] = self.greyConfigInfo!
                    }
                    if self.greyEndtimeData != nil {
                        map["GreyEndtimeData"] = self.greyEndtimeData!
                    }
                    if self.greyNotice != nil {
                        map["GreyNotice"] = self.greyNotice!
                    }
                    if self.greyNum != nil {
                        map["GreyNum"] = self.greyNum!
                    }
                    if self.greyUv != nil {
                        map["GreyUv"] = self.greyUv!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.innerVersion != nil {
                        map["InnerVersion"] = self.innerVersion!
                    }
                    if self.isEnterprise != nil {
                        map["IsEnterprise"] = self.isEnterprise!
                    }
                    if self.isOfficial != nil {
                        map["IsOfficial"] = self.isOfficial!
                    }
                    if self.isPush != nil {
                        map["IsPush"] = self.isPush!
                    }
                    if self.isRc != nil {
                        map["IsRc"] = self.isRc!
                    }
                    if self.isRelease != nil {
                        map["IsRelease"] = self.isRelease!
                    }
                    if self.memo != nil {
                        map["Memo"] = self.memo!
                    }
                    if self.mobileModelContains != nil {
                        map["MobileModelContains"] = self.mobileModelContains!
                    }
                    if self.mobileModelExcludes != nil {
                        map["MobileModelExcludes"] = self.mobileModelExcludes!
                    }
                    if self.modifier != nil {
                        map["Modifier"] = self.modifier!
                    }
                    if self.netType != nil {
                        map["NetType"] = self.netType!
                    }
                    if self.osVersion != nil {
                        map["OsVersion"] = self.osVersion!
                    }
                    if self.packageInfoId != nil {
                        map["PackageInfoId"] = self.packageInfoId!
                    }
                    if self.packageType != nil {
                        map["PackageType"] = self.packageType!
                    }
                    if self.platform != nil {
                        map["Platform"] = self.platform!
                    }
                    if self.productId != nil {
                        map["ProductId"] = self.productId!
                    }
                    if self.productVersion != nil {
                        map["ProductVersion"] = self.productVersion!
                    }
                    if self.publishMode != nil {
                        map["PublishMode"] = self.publishMode!
                    }
                    if self.publishType != nil {
                        map["PublishType"] = self.publishType!
                    }
                    if self.pushContent != nil {
                        map["PushContent"] = self.pushContent!
                    }
                    if self.qrcodeUrl != nil {
                        map["QrcodeUrl"] = self.qrcodeUrl!
                    }
                    if self.releaseType != nil {
                        map["ReleaseType"] = self.releaseType!
                    }
                    if self.ruleJsonList != nil {
                        var tmp : [Any] = []
                        for k in self.ruleJsonList! {
                            tmp.append(k.toMap())
                        }
                        map["RuleJsonList"] = tmp
                    }
                    if self.silentType != nil {
                        map["SilentType"] = self.silentType!
                    }
                    if self.syncMode != nil {
                        map["SyncMode"] = self.syncMode!
                    }
                    if self.syncResult != nil {
                        map["SyncResult"] = self.syncResult!
                    }
                    if self.taskStatus != nil {
                        map["TaskStatus"] = self.taskStatus!
                    }
                    if self.upgradeContent != nil {
                        map["UpgradeContent"] = self.upgradeContent!
                    }
                    if self.upgradeType != nil {
                        map["UpgradeType"] = self.upgradeType!
                    }
                    if self.upgradeValidTime != nil {
                        map["UpgradeValidTime"] = self.upgradeValidTime!
                    }
                    if self.whitelist != nil {
                        var tmp : [Any] = []
                        for k in self.whitelist! {
                            tmp.append(k.toMap())
                        }
                        map["Whitelist"] = tmp
                    }
                    if self.whitelistIds != nil {
                        map["WhitelistIds"] = self.whitelistIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("Appstoreurl") && dict["Appstoreurl"] != nil {
                        self.appstoreurl = dict["Appstoreurl"] as! String
                    }
                    if dict.keys.contains("ChannelContains") && dict["ChannelContains"] != nil {
                        self.channelContains = dict["ChannelContains"] as! String
                    }
                    if dict.keys.contains("ChannelExcludes") && dict["ChannelExcludes"] != nil {
                        self.channelExcludes = dict["ChannelExcludes"] as! String
                    }
                    if dict.keys.contains("CityContains") && dict["CityContains"] != nil {
                        self.cityContains = dict["CityContains"] as! String
                    }
                    if dict.keys.contains("CityExcludes") && dict["CityExcludes"] != nil {
                        self.cityExcludes = dict["CityExcludes"] as! String
                    }
                    if dict.keys.contains("Creator") && dict["Creator"] != nil {
                        self.creator = dict["Creator"] as! String
                    }
                    if dict.keys.contains("DeviceGreyNum") && dict["DeviceGreyNum"] != nil {
                        self.deviceGreyNum = dict["DeviceGreyNum"] as! Int64
                    }
                    if dict.keys.contains("DevicePercent") && dict["DevicePercent"] != nil {
                        self.devicePercent = dict["DevicePercent"] as! Int64
                    }
                    if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                        self.downloadUrl = dict["DownloadUrl"] as! String
                    }
                    if dict.keys.contains("ExecutionOrder") && dict["ExecutionOrder"] != nil {
                        self.executionOrder = dict["ExecutionOrder"] as! Int64
                    }
                    if dict.keys.contains("GmtCreateStr") && dict["GmtCreateStr"] != nil {
                        self.gmtCreateStr = dict["GmtCreateStr"] as! String
                    }
                    if dict.keys.contains("GreyConfigInfo") && dict["GreyConfigInfo"] != nil {
                        self.greyConfigInfo = dict["GreyConfigInfo"] as! String
                    }
                    if dict.keys.contains("GreyEndtimeData") && dict["GreyEndtimeData"] != nil {
                        self.greyEndtimeData = dict["GreyEndtimeData"] as! String
                    }
                    if dict.keys.contains("GreyNotice") && dict["GreyNotice"] != nil {
                        self.greyNotice = dict["GreyNotice"] as! Int64
                    }
                    if dict.keys.contains("GreyNum") && dict["GreyNum"] != nil {
                        self.greyNum = dict["GreyNum"] as! Int64
                    }
                    if dict.keys.contains("GreyUv") && dict["GreyUv"] != nil {
                        self.greyUv = dict["GreyUv"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("InnerVersion") && dict["InnerVersion"] != nil {
                        self.innerVersion = dict["InnerVersion"] as! String
                    }
                    if dict.keys.contains("IsEnterprise") && dict["IsEnterprise"] != nil {
                        self.isEnterprise = dict["IsEnterprise"] as! Int64
                    }
                    if dict.keys.contains("IsOfficial") && dict["IsOfficial"] != nil {
                        self.isOfficial = dict["IsOfficial"] as! Int64
                    }
                    if dict.keys.contains("IsPush") && dict["IsPush"] != nil {
                        self.isPush = dict["IsPush"] as! Int64
                    }
                    if dict.keys.contains("IsRc") && dict["IsRc"] != nil {
                        self.isRc = dict["IsRc"] as! Int64
                    }
                    if dict.keys.contains("IsRelease") && dict["IsRelease"] != nil {
                        self.isRelease = dict["IsRelease"] as! Int64
                    }
                    if dict.keys.contains("Memo") && dict["Memo"] != nil {
                        self.memo = dict["Memo"] as! String
                    }
                    if dict.keys.contains("MobileModelContains") && dict["MobileModelContains"] != nil {
                        self.mobileModelContains = dict["MobileModelContains"] as! String
                    }
                    if dict.keys.contains("MobileModelExcludes") && dict["MobileModelExcludes"] != nil {
                        self.mobileModelExcludes = dict["MobileModelExcludes"] as! String
                    }
                    if dict.keys.contains("Modifier") && dict["Modifier"] != nil {
                        self.modifier = dict["Modifier"] as! String
                    }
                    if dict.keys.contains("NetType") && dict["NetType"] != nil {
                        self.netType = dict["NetType"] as! String
                    }
                    if dict.keys.contains("OsVersion") && dict["OsVersion"] != nil {
                        self.osVersion = dict["OsVersion"] as! String
                    }
                    if dict.keys.contains("PackageInfoId") && dict["PackageInfoId"] != nil {
                        self.packageInfoId = dict["PackageInfoId"] as! Int64
                    }
                    if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
                        self.packageType = dict["PackageType"] as! String
                    }
                    if dict.keys.contains("Platform") && dict["Platform"] != nil {
                        self.platform = dict["Platform"] as! String
                    }
                    if dict.keys.contains("ProductId") && dict["ProductId"] != nil {
                        self.productId = dict["ProductId"] as! String
                    }
                    if dict.keys.contains("ProductVersion") && dict["ProductVersion"] != nil {
                        self.productVersion = dict["ProductVersion"] as! String
                    }
                    if dict.keys.contains("PublishMode") && dict["PublishMode"] != nil {
                        self.publishMode = dict["PublishMode"] as! Int64
                    }
                    if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                        self.publishType = dict["PublishType"] as! Int64
                    }
                    if dict.keys.contains("PushContent") && dict["PushContent"] != nil {
                        self.pushContent = dict["PushContent"] as! String
                    }
                    if dict.keys.contains("QrcodeUrl") && dict["QrcodeUrl"] != nil {
                        self.qrcodeUrl = dict["QrcodeUrl"] as! String
                    }
                    if dict.keys.contains("ReleaseType") && dict["ReleaseType"] != nil {
                        self.releaseType = dict["ReleaseType"] as! String
                    }
                    if dict.keys.contains("RuleJsonList") && dict["RuleJsonList"] != nil {
                        var tmp : [QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.RuleJsonList] = []
                        for v in dict["RuleJsonList"] as! [Any] {
                            var model = QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.RuleJsonList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ruleJsonList = tmp
                    }
                    if dict.keys.contains("SilentType") && dict["SilentType"] != nil {
                        self.silentType = dict["SilentType"] as! Int64
                    }
                    if dict.keys.contains("SyncMode") && dict["SyncMode"] != nil {
                        self.syncMode = dict["SyncMode"] as! String
                    }
                    if dict.keys.contains("SyncResult") && dict["SyncResult"] != nil {
                        self.syncResult = dict["SyncResult"] as! String
                    }
                    if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                        self.taskStatus = dict["TaskStatus"] as! Int64
                    }
                    if dict.keys.contains("UpgradeContent") && dict["UpgradeContent"] != nil {
                        self.upgradeContent = dict["UpgradeContent"] as! String
                    }
                    if dict.keys.contains("UpgradeType") && dict["UpgradeType"] != nil {
                        self.upgradeType = dict["UpgradeType"] as! Int64
                    }
                    if dict.keys.contains("UpgradeValidTime") && dict["UpgradeValidTime"] != nil {
                        self.upgradeValidTime = dict["UpgradeValidTime"] as! Int64
                    }
                    if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
                        var tmp : [QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.Whitelist] = []
                        for v in dict["Whitelist"] as! [Any] {
                            var model = QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content.Whitelist()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.whitelist = tmp
                    }
                    if dict.keys.contains("WhitelistIds") && dict["WhitelistIds"] != nil {
                        self.whitelistIds = dict["WhitelistIds"] as! String
                    }
                }
            }
            public var content: QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content?

            public var errorCode: String?

            public var requestId: String?

            public var resultMsg: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.content?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content?.toMap()
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    var model = QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data.Content()
                    model.fromMap(dict["Content"] as! [String: Any])
                    self.content = model
                }
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryMdsUpgradeTaskDetailResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMdsUpgradeTaskDetailResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMdsUpgradeTaskDetailResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMdsUpgradeTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMdsUpgradeTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMdsUpgradeTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMgsApipageRequest : Tea.TeaModel {
    public var apiStatus: String?

    public var apiType: String?

    public var appId: String?

    public var format: String?

    public var host: String?

    public var needEncrypt: String?

    public var needEtag: String?

    public var needSign: String?

    public var operationType: String?

    public var optFuzzy: String?

    public var pageIndex: Int64?

    public var pageSize: Int64?

    public var sysId: Int64?

    public var sysName: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiStatus != nil {
            map["ApiStatus"] = self.apiStatus!
        }
        if self.apiType != nil {
            map["ApiType"] = self.apiType!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.needEncrypt != nil {
            map["NeedEncrypt"] = self.needEncrypt!
        }
        if self.needEtag != nil {
            map["NeedEtag"] = self.needEtag!
        }
        if self.needSign != nil {
            map["NeedSign"] = self.needSign!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.optFuzzy != nil {
            map["OptFuzzy"] = self.optFuzzy!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sysId != nil {
            map["SysId"] = self.sysId!
        }
        if self.sysName != nil {
            map["SysName"] = self.sysName!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiStatus") && dict["ApiStatus"] != nil {
            self.apiStatus = dict["ApiStatus"] as! String
        }
        if dict.keys.contains("ApiType") && dict["ApiType"] != nil {
            self.apiType = dict["ApiType"] as! String
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("Host") && dict["Host"] != nil {
            self.host = dict["Host"] as! String
        }
        if dict.keys.contains("NeedEncrypt") && dict["NeedEncrypt"] != nil {
            self.needEncrypt = dict["NeedEncrypt"] as! String
        }
        if dict.keys.contains("NeedEtag") && dict["NeedEtag"] != nil {
            self.needEtag = dict["NeedEtag"] as! String
        }
        if dict.keys.contains("NeedSign") && dict["NeedSign"] != nil {
            self.needSign = dict["NeedSign"] as! String
        }
        if dict.keys.contains("OperationType") && dict["OperationType"] != nil {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("OptFuzzy") && dict["OptFuzzy"] != nil {
            self.optFuzzy = dict["OptFuzzy"] as! String
        }
        if dict.keys.contains("PageIndex") && dict["PageIndex"] != nil {
            self.pageIndex = dict["PageIndex"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SysId") && dict["SysId"] != nil {
            self.sysId = dict["SysId"] as! Int64
        }
        if dict.keys.contains("SysName") && dict["SysName"] != nil {
            self.sysName = dict["SysName"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMgsApipageResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class ApiInvoker : Tea.TeaModel {
                public class HttpInvoker : Tea.TeaModel {
                    public var charset: String?

                    public var contentType: String?

                    public var host: String?

                    public var method: String?

                    public var path: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charset != nil {
                            map["Charset"] = self.charset!
                        }
                        if self.contentType != nil {
                            map["ContentType"] = self.contentType!
                        }
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Charset") && dict["Charset"] != nil {
                            self.charset = dict["Charset"] as! String
                        }
                        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                            self.contentType = dict["ContentType"] as! String
                        }
                        if dict.keys.contains("Host") && dict["Host"] != nil {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Method") && dict["Method"] != nil {
                            self.method = dict["Method"] as! String
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                    }
                }
                public var httpInvoker: QueryMgsApipageResponseBody.ResultContent.List.ApiInvoker.HttpInvoker?

                public var rpcInvoker: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpInvoker?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpInvoker != nil {
                        map["HttpInvoker"] = self.httpInvoker?.toMap()
                    }
                    if self.rpcInvoker != nil {
                        map["RpcInvoker"] = self.rpcInvoker!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HttpInvoker") && dict["HttpInvoker"] != nil {
                        var model = QueryMgsApipageResponseBody.ResultContent.List.ApiInvoker.HttpInvoker()
                        model.fromMap(dict["HttpInvoker"] as! [String: Any])
                        self.httpInvoker = model
                    }
                    if dict.keys.contains("RpcInvoker") && dict["RpcInvoker"] != nil {
                        self.rpcInvoker = dict["RpcInvoker"] as! String
                    }
                }
            }
            public class CacheRule : Tea.TeaModel {
                public var cacheKey: String?

                public var needCache: Bool?

                public var ttl: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cacheKey != nil {
                        map["CacheKey"] = self.cacheKey!
                    }
                    if self.needCache != nil {
                        map["NeedCache"] = self.needCache!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CacheKey") && dict["CacheKey"] != nil {
                        self.cacheKey = dict["CacheKey"] as! String
                    }
                    if dict.keys.contains("NeedCache") && dict["NeedCache"] != nil {
                        self.needCache = dict["NeedCache"] as! Bool
                    }
                    if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                        self.ttl = dict["Ttl"] as! Int64
                    }
                }
            }
            public class CircuitBreakerRule : Tea.TeaModel {
                public var appId: String?

                public var defaultResponse: String?

                public var errorThreshold: Int64?

                public var id: Int64?

                public var model: String?

                public var openTimeoutSeconds: Int64?

                public var slowRatioThreshold: Double?

                public var switchStatus: String?

                public var windowsInSeconds: Int64?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.errorThreshold != nil {
                        map["ErrorThreshold"] = self.errorThreshold!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.model != nil {
                        map["Model"] = self.model!
                    }
                    if self.openTimeoutSeconds != nil {
                        map["OpenTimeoutSeconds"] = self.openTimeoutSeconds!
                    }
                    if self.slowRatioThreshold != nil {
                        map["SlowRatioThreshold"] = self.slowRatioThreshold!
                    }
                    if self.switchStatus != nil {
                        map["SwitchStatus"] = self.switchStatus!
                    }
                    if self.windowsInSeconds != nil {
                        map["WindowsInSeconds"] = self.windowsInSeconds!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("ErrorThreshold") && dict["ErrorThreshold"] != nil {
                        self.errorThreshold = dict["ErrorThreshold"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Model") && dict["Model"] != nil {
                        self.model = dict["Model"] as! String
                    }
                    if dict.keys.contains("OpenTimeoutSeconds") && dict["OpenTimeoutSeconds"] != nil {
                        self.openTimeoutSeconds = dict["OpenTimeoutSeconds"] as! Int64
                    }
                    if dict.keys.contains("SlowRatioThreshold") && dict["SlowRatioThreshold"] != nil {
                        self.slowRatioThreshold = dict["SlowRatioThreshold"] as! Double
                    }
                    if dict.keys.contains("SwitchStatus") && dict["SwitchStatus"] != nil {
                        self.switchStatus = dict["SwitchStatus"] as! String
                    }
                    if dict.keys.contains("WindowsInSeconds") && dict["WindowsInSeconds"] != nil {
                        self.windowsInSeconds = dict["WindowsInSeconds"] as! Int64
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public class HeaderRule : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class HeaderRules : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class LimitRule : Tea.TeaModel {
                public var defaultResponse: String?

                public var i18nResponse: String?

                public var interval: Int64?

                public var limit: Int64?

                public var mode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.i18nResponse != nil {
                        map["I18nResponse"] = self.i18nResponse!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.limit != nil {
                        map["Limit"] = self.limit!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("I18nResponse") && dict["I18nResponse"] != nil {
                        self.i18nResponse = dict["I18nResponse"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("Limit") && dict["Limit"] != nil {
                        self.limit = dict["Limit"] as! Int64
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! String
                    }
                }
            }
            public class MigrateRule : Tea.TeaModel {
                public var flowPercent: Int64?

                public var needMigrate: Bool?

                public var needSwitchCompletely: Bool?

                public var sysId: Int64?

                public var sysName: String?

                public var upstreamType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flowPercent != nil {
                        map["FlowPercent"] = self.flowPercent!
                    }
                    if self.needMigrate != nil {
                        map["NeedMigrate"] = self.needMigrate!
                    }
                    if self.needSwitchCompletely != nil {
                        map["NeedSwitchCompletely"] = self.needSwitchCompletely!
                    }
                    if self.sysId != nil {
                        map["SysId"] = self.sysId!
                    }
                    if self.sysName != nil {
                        map["SysName"] = self.sysName!
                    }
                    if self.upstreamType != nil {
                        map["UpstreamType"] = self.upstreamType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FlowPercent") && dict["FlowPercent"] != nil {
                        self.flowPercent = dict["FlowPercent"] as! Int64
                    }
                    if dict.keys.contains("NeedMigrate") && dict["NeedMigrate"] != nil {
                        self.needMigrate = dict["NeedMigrate"] as! Bool
                    }
                    if dict.keys.contains("NeedSwitchCompletely") && dict["NeedSwitchCompletely"] != nil {
                        self.needSwitchCompletely = dict["NeedSwitchCompletely"] as! Bool
                    }
                    if dict.keys.contains("SysId") && dict["SysId"] != nil {
                        self.sysId = dict["SysId"] as! Int64
                    }
                    if dict.keys.contains("SysName") && dict["SysName"] != nil {
                        self.sysName = dict["SysName"] as! String
                    }
                    if dict.keys.contains("UpstreamType") && dict["UpstreamType"] != nil {
                        self.upstreamType = dict["UpstreamType"] as! String
                    }
                }
            }
            public class MockRule : Tea.TeaModel {
                public var mockData: String?

                public var needMock: Bool?

                public var percentage: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mockData != nil {
                        map["MockData"] = self.mockData!
                    }
                    if self.needMock != nil {
                        map["NeedMock"] = self.needMock!
                    }
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MockData") && dict["MockData"] != nil {
                        self.mockData = dict["MockData"] as! String
                    }
                    if dict.keys.contains("NeedMock") && dict["NeedMock"] != nil {
                        self.needMock = dict["NeedMock"] as! Bool
                    }
                    if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                        self.percentage = dict["Percentage"] as! Int64
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RequestParams : Tea.TeaModel {
                public var apiId: String?

                public var appId: String?

                public var defaultValue: String?

                public var description_: String?

                public var id: Int64?

                public var location: String?

                public var name: String?

                public var refType: String?

                public var type: String?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiId != nil {
                        map["ApiId"] = self.apiId!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.refType != nil {
                        map["RefType"] = self.refType!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                        self.apiId = dict["ApiId"] as! String
                    }
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RefType") && dict["RefType"] != nil {
                        self.refType = dict["RefType"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public var apiInvoker: QueryMgsApipageResponseBody.ResultContent.List.ApiInvoker?

            public var apiName: String?

            public var apiStatus: String?

            public var apiType: String?

            public var appId: String?

            public var authRuleName: String?

            public var cacheRule: QueryMgsApipageResponseBody.ResultContent.List.CacheRule?

            public var charset: String?

            public var circuitBreakerRule: QueryMgsApipageResponseBody.ResultContent.List.CircuitBreakerRule?

            public var contentType: String?

            public var description_: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var headerRule: [QueryMgsApipageResponseBody.ResultContent.List.HeaderRule]?

            public var headerRules: [QueryMgsApipageResponseBody.ResultContent.List.HeaderRules]?

            public var host: String?

            public var id: Int64?

            public var interfaceType: String?

            public var limitRule: QueryMgsApipageResponseBody.ResultContent.List.LimitRule?

            public var method: String?

            public var methodName: String?

            public var migrateRule: QueryMgsApipageResponseBody.ResultContent.List.MigrateRule?

            public var mockRule: QueryMgsApipageResponseBody.ResultContent.List.MockRule?

            public var needETag: String?

            public var needEncrypt: String?

            public var needJsonp: String?

            public var needSign: String?

            public var operationType: String?

            public var paramGetMethod: String?

            public var path: String?

            public var requestBodyModel: String?

            public var requestParams: [QueryMgsApipageResponseBody.ResultContent.List.RequestParams]?

            public var responseBodyModel: String?

            public var sysId: Int64?

            public var sysName: String?

            public var timeout: String?

            public var workspaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apiInvoker?.validate()
                try self.cacheRule?.validate()
                try self.circuitBreakerRule?.validate()
                try self.limitRule?.validate()
                try self.migrateRule?.validate()
                try self.mockRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiInvoker != nil {
                    map["ApiInvoker"] = self.apiInvoker?.toMap()
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.apiType != nil {
                    map["ApiType"] = self.apiType!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.authRuleName != nil {
                    map["AuthRuleName"] = self.authRuleName!
                }
                if self.cacheRule != nil {
                    map["CacheRule"] = self.cacheRule?.toMap()
                }
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.circuitBreakerRule != nil {
                    map["CircuitBreakerRule"] = self.circuitBreakerRule?.toMap()
                }
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.headerRule != nil {
                    var tmp : [Any] = []
                    for k in self.headerRule! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRule"] = tmp
                }
                if self.headerRules != nil {
                    var tmp : [Any] = []
                    for k in self.headerRules! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRules"] = tmp
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.interfaceType != nil {
                    map["InterfaceType"] = self.interfaceType!
                }
                if self.limitRule != nil {
                    map["LimitRule"] = self.limitRule?.toMap()
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.migrateRule != nil {
                    map["MigrateRule"] = self.migrateRule?.toMap()
                }
                if self.mockRule != nil {
                    map["MockRule"] = self.mockRule?.toMap()
                }
                if self.needETag != nil {
                    map["NeedETag"] = self.needETag!
                }
                if self.needEncrypt != nil {
                    map["NeedEncrypt"] = self.needEncrypt!
                }
                if self.needJsonp != nil {
                    map["NeedJsonp"] = self.needJsonp!
                }
                if self.needSign != nil {
                    map["NeedSign"] = self.needSign!
                }
                if self.operationType != nil {
                    map["OperationType"] = self.operationType!
                }
                if self.paramGetMethod != nil {
                    map["ParamGetMethod"] = self.paramGetMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.requestBodyModel != nil {
                    map["RequestBodyModel"] = self.requestBodyModel!
                }
                if self.requestParams != nil {
                    var tmp : [Any] = []
                    for k in self.requestParams! {
                        tmp.append(k.toMap())
                    }
                    map["RequestParams"] = tmp
                }
                if self.responseBodyModel != nil {
                    map["ResponseBodyModel"] = self.responseBodyModel!
                }
                if self.sysId != nil {
                    map["SysId"] = self.sysId!
                }
                if self.sysName != nil {
                    map["SysName"] = self.sysName!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiInvoker") && dict["ApiInvoker"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.ApiInvoker()
                    model.fromMap(dict["ApiInvoker"] as! [String: Any])
                    self.apiInvoker = model
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiStatus") && dict["ApiStatus"] != nil {
                    self.apiStatus = dict["ApiStatus"] as! String
                }
                if dict.keys.contains("ApiType") && dict["ApiType"] != nil {
                    self.apiType = dict["ApiType"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AuthRuleName") && dict["AuthRuleName"] != nil {
                    self.authRuleName = dict["AuthRuleName"] as! String
                }
                if dict.keys.contains("CacheRule") && dict["CacheRule"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.CacheRule()
                    model.fromMap(dict["CacheRule"] as! [String: Any])
                    self.cacheRule = model
                }
                if dict.keys.contains("Charset") && dict["Charset"] != nil {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("CircuitBreakerRule") && dict["CircuitBreakerRule"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.CircuitBreakerRule()
                    model.fromMap(dict["CircuitBreakerRule"] as! [String: Any])
                    self.circuitBreakerRule = model
                }
                if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("HeaderRule") && dict["HeaderRule"] != nil {
                    var tmp : [QueryMgsApipageResponseBody.ResultContent.List.HeaderRule] = []
                    for v in dict["HeaderRule"] as! [Any] {
                        var model = QueryMgsApipageResponseBody.ResultContent.List.HeaderRule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRule = tmp
                }
                if dict.keys.contains("HeaderRules") && dict["HeaderRules"] != nil {
                    var tmp : [QueryMgsApipageResponseBody.ResultContent.List.HeaderRules] = []
                    for v in dict["HeaderRules"] as! [Any] {
                        var model = QueryMgsApipageResponseBody.ResultContent.List.HeaderRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRules = tmp
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InterfaceType") && dict["InterfaceType"] != nil {
                    self.interfaceType = dict["InterfaceType"] as! String
                }
                if dict.keys.contains("LimitRule") && dict["LimitRule"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.LimitRule()
                    model.fromMap(dict["LimitRule"] as! [String: Any])
                    self.limitRule = model
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("MethodName") && dict["MethodName"] != nil {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("MigrateRule") && dict["MigrateRule"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.MigrateRule()
                    model.fromMap(dict["MigrateRule"] as! [String: Any])
                    self.migrateRule = model
                }
                if dict.keys.contains("MockRule") && dict["MockRule"] != nil {
                    var model = QueryMgsApipageResponseBody.ResultContent.List.MockRule()
                    model.fromMap(dict["MockRule"] as! [String: Any])
                    self.mockRule = model
                }
                if dict.keys.contains("NeedETag") && dict["NeedETag"] != nil {
                    self.needETag = dict["NeedETag"] as! String
                }
                if dict.keys.contains("NeedEncrypt") && dict["NeedEncrypt"] != nil {
                    self.needEncrypt = dict["NeedEncrypt"] as! String
                }
                if dict.keys.contains("NeedJsonp") && dict["NeedJsonp"] != nil {
                    self.needJsonp = dict["NeedJsonp"] as! String
                }
                if dict.keys.contains("NeedSign") && dict["NeedSign"] != nil {
                    self.needSign = dict["NeedSign"] as! String
                }
                if dict.keys.contains("OperationType") && dict["OperationType"] != nil {
                    self.operationType = dict["OperationType"] as! String
                }
                if dict.keys.contains("ParamGetMethod") && dict["ParamGetMethod"] != nil {
                    self.paramGetMethod = dict["ParamGetMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RequestBodyModel") && dict["RequestBodyModel"] != nil {
                    self.requestBodyModel = dict["RequestBodyModel"] as! String
                }
                if dict.keys.contains("RequestParams") && dict["RequestParams"] != nil {
                    var tmp : [QueryMgsApipageResponseBody.ResultContent.List.RequestParams] = []
                    for v in dict["RequestParams"] as! [Any] {
                        var model = QueryMgsApipageResponseBody.ResultContent.List.RequestParams()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.requestParams = tmp
                }
                if dict.keys.contains("ResponseBodyModel") && dict["ResponseBodyModel"] != nil {
                    self.responseBodyModel = dict["ResponseBodyModel"] as! String
                }
                if dict.keys.contains("SysId") && dict["SysId"] != nil {
                    self.sysId = dict["SysId"] as! Int64
                }
                if dict.keys.contains("SysName") && dict["SysName"] != nil {
                    self.sysName = dict["SysName"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
            }
        }
        public var current: Int64?

        public var list: [QueryMgsApipageResponseBody.ResultContent.List]?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.current != nil {
                map["Current"] = self.current!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Current") && dict["Current"] != nil {
                self.current = dict["Current"] as! Int64
            }
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [QueryMgsApipageResponseBody.ResultContent.List] = []
                for v in dict["List"] as! [Any] {
                    var model = QueryMgsApipageResponseBody.ResultContent.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMgsApipageResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMgsApipageResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMgsApipageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMgsApipageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMgsApipageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMgsApirestRequest : Tea.TeaModel {
    public var appId: String?

    public var format: String?

    public var id: Int64?

    public var tenantId: String?

    public var type: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMgsApirestResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Value : Tea.TeaModel {
            public class ApiInvoker : Tea.TeaModel {
                public class HttpInvoker : Tea.TeaModel {
                    public var charset: String?

                    public var contentType: String?

                    public var host: String?

                    public var method: String?

                    public var path: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.charset != nil {
                            map["Charset"] = self.charset!
                        }
                        if self.contentType != nil {
                            map["ContentType"] = self.contentType!
                        }
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Charset") && dict["Charset"] != nil {
                            self.charset = dict["Charset"] as! String
                        }
                        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                            self.contentType = dict["ContentType"] as! String
                        }
                        if dict.keys.contains("Host") && dict["Host"] != nil {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Method") && dict["Method"] != nil {
                            self.method = dict["Method"] as! String
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                    }
                }
                public var httpInvoker: QueryMgsApirestResponseBody.ResultContent.Value.ApiInvoker.HttpInvoker?

                public var rpcInvoker: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.httpInvoker?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpInvoker != nil {
                        map["HttpInvoker"] = self.httpInvoker?.toMap()
                    }
                    if self.rpcInvoker != nil {
                        map["RpcInvoker"] = self.rpcInvoker!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HttpInvoker") && dict["HttpInvoker"] != nil {
                        var model = QueryMgsApirestResponseBody.ResultContent.Value.ApiInvoker.HttpInvoker()
                        model.fromMap(dict["HttpInvoker"] as! [String: Any])
                        self.httpInvoker = model
                    }
                    if dict.keys.contains("RpcInvoker") && dict["RpcInvoker"] != nil {
                        self.rpcInvoker = dict["RpcInvoker"] as! String
                    }
                }
            }
            public class CacheRule : Tea.TeaModel {
                public var cacheKey: String?

                public var needCache: Bool?

                public var ttl: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cacheKey != nil {
                        map["CacheKey"] = self.cacheKey!
                    }
                    if self.needCache != nil {
                        map["NeedCache"] = self.needCache!
                    }
                    if self.ttl != nil {
                        map["Ttl"] = self.ttl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CacheKey") && dict["CacheKey"] != nil {
                        self.cacheKey = dict["CacheKey"] as! String
                    }
                    if dict.keys.contains("NeedCache") && dict["NeedCache"] != nil {
                        self.needCache = dict["NeedCache"] as! Bool
                    }
                    if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                        self.ttl = dict["Ttl"] as! Int64
                    }
                }
            }
            public class CircuitBreakerRule : Tea.TeaModel {
                public var appId: String?

                public var defaultResponse: String?

                public var errorThreshold: Int64?

                public var id: Int64?

                public var model: String?

                public var openTimeoutSeconds: Int64?

                public var slowRatioThreshold: Double?

                public var switchStatus: String?

                public var windowsInSeconds: Int64?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.errorThreshold != nil {
                        map["ErrorThreshold"] = self.errorThreshold!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.model != nil {
                        map["Model"] = self.model!
                    }
                    if self.openTimeoutSeconds != nil {
                        map["OpenTimeoutSeconds"] = self.openTimeoutSeconds!
                    }
                    if self.slowRatioThreshold != nil {
                        map["SlowRatioThreshold"] = self.slowRatioThreshold!
                    }
                    if self.switchStatus != nil {
                        map["SwitchStatus"] = self.switchStatus!
                    }
                    if self.windowsInSeconds != nil {
                        map["WindowsInSeconds"] = self.windowsInSeconds!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("ErrorThreshold") && dict["ErrorThreshold"] != nil {
                        self.errorThreshold = dict["ErrorThreshold"] as! Int64
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Model") && dict["Model"] != nil {
                        self.model = dict["Model"] as! String
                    }
                    if dict.keys.contains("OpenTimeoutSeconds") && dict["OpenTimeoutSeconds"] != nil {
                        self.openTimeoutSeconds = dict["OpenTimeoutSeconds"] as! Int64
                    }
                    if dict.keys.contains("SlowRatioThreshold") && dict["SlowRatioThreshold"] != nil {
                        self.slowRatioThreshold = dict["SlowRatioThreshold"] as! Double
                    }
                    if dict.keys.contains("SwitchStatus") && dict["SwitchStatus"] != nil {
                        self.switchStatus = dict["SwitchStatus"] as! String
                    }
                    if dict.keys.contains("WindowsInSeconds") && dict["WindowsInSeconds"] != nil {
                        self.windowsInSeconds = dict["WindowsInSeconds"] as! Int64
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public class DefaultLimitRule : Tea.TeaModel {
                public var configId: Int32?

                public var defaultLimit: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configId != nil {
                        map["ConfigId"] = self.configId!
                    }
                    if self.defaultLimit != nil {
                        map["DefaultLimit"] = self.defaultLimit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
                        self.configId = dict["ConfigId"] as! Int32
                    }
                    if dict.keys.contains("DefaultLimit") && dict["DefaultLimit"] != nil {
                        self.defaultLimit = dict["DefaultLimit"] as! Bool
                    }
                }
            }
            public class HeaderRule : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class HeaderRules : Tea.TeaModel {
                public var headerKey: String?

                public var location: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerKey != nil {
                        map["HeaderKey"] = self.headerKey!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderKey") && dict["HeaderKey"] != nil {
                        self.headerKey = dict["HeaderKey"] as! String
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class LimitRule : Tea.TeaModel {
                public var defaultResponse: String?

                public var i18nResponse: String?

                public var interval: Int64?

                public var limit: Int64?

                public var mode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultResponse != nil {
                        map["DefaultResponse"] = self.defaultResponse!
                    }
                    if self.i18nResponse != nil {
                        map["I18nResponse"] = self.i18nResponse!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.limit != nil {
                        map["Limit"] = self.limit!
                    }
                    if self.mode != nil {
                        map["Mode"] = self.mode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultResponse") && dict["DefaultResponse"] != nil {
                        self.defaultResponse = dict["DefaultResponse"] as! String
                    }
                    if dict.keys.contains("I18nResponse") && dict["I18nResponse"] != nil {
                        self.i18nResponse = dict["I18nResponse"] as! String
                    }
                    if dict.keys.contains("Interval") && dict["Interval"] != nil {
                        self.interval = dict["Interval"] as! Int64
                    }
                    if dict.keys.contains("Limit") && dict["Limit"] != nil {
                        self.limit = dict["Limit"] as! Int64
                    }
                    if dict.keys.contains("Mode") && dict["Mode"] != nil {
                        self.mode = dict["Mode"] as! String
                    }
                }
            }
            public class MigrateRule : Tea.TeaModel {
                public var flowPercent: Int64?

                public var needMigrate: Bool?

                public var needSwitchCompletely: Bool?

                public var sysId: Int64?

                public var sysName: String?

                public var upstreamType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flowPercent != nil {
                        map["FlowPercent"] = self.flowPercent!
                    }
                    if self.needMigrate != nil {
                        map["NeedMigrate"] = self.needMigrate!
                    }
                    if self.needSwitchCompletely != nil {
                        map["NeedSwitchCompletely"] = self.needSwitchCompletely!
                    }
                    if self.sysId != nil {
                        map["SysId"] = self.sysId!
                    }
                    if self.sysName != nil {
                        map["SysName"] = self.sysName!
                    }
                    if self.upstreamType != nil {
                        map["UpstreamType"] = self.upstreamType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FlowPercent") && dict["FlowPercent"] != nil {
                        self.flowPercent = dict["FlowPercent"] as! Int64
                    }
                    if dict.keys.contains("NeedMigrate") && dict["NeedMigrate"] != nil {
                        self.needMigrate = dict["NeedMigrate"] as! Bool
                    }
                    if dict.keys.contains("NeedSwitchCompletely") && dict["NeedSwitchCompletely"] != nil {
                        self.needSwitchCompletely = dict["NeedSwitchCompletely"] as! Bool
                    }
                    if dict.keys.contains("SysId") && dict["SysId"] != nil {
                        self.sysId = dict["SysId"] as! Int64
                    }
                    if dict.keys.contains("SysName") && dict["SysName"] != nil {
                        self.sysName = dict["SysName"] as! String
                    }
                    if dict.keys.contains("UpstreamType") && dict["UpstreamType"] != nil {
                        self.upstreamType = dict["UpstreamType"] as! String
                    }
                }
            }
            public class MockRule : Tea.TeaModel {
                public var mockData: String?

                public var needMock: Bool?

                public var percentage: Int64?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mockData != nil {
                        map["MockData"] = self.mockData!
                    }
                    if self.needMock != nil {
                        map["NeedMock"] = self.needMock!
                    }
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MockData") && dict["MockData"] != nil {
                        self.mockData = dict["MockData"] as! String
                    }
                    if dict.keys.contains("NeedMock") && dict["NeedMock"] != nil {
                        self.needMock = dict["NeedMock"] as! Bool
                    }
                    if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                        self.percentage = dict["Percentage"] as! Int64
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RequestParams : Tea.TeaModel {
                public var apiId: String?

                public var appId: String?

                public var defaultValue: String?

                public var description_: String?

                public var id: Int64?

                public var location: String?

                public var name: String?

                public var refType: String?

                public var type: String?

                public var workspaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.apiId != nil {
                        map["ApiId"] = self.apiId!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.refType != nil {
                        map["RefType"] = self.refType!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workspaceId != nil {
                        map["WorkspaceId"] = self.workspaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ApiId") && dict["ApiId"] != nil {
                        self.apiId = dict["ApiId"] as! String
                    }
                    if dict.keys.contains("AppId") && dict["AppId"] != nil {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Location") && dict["Location"] != nil {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RefType") && dict["RefType"] != nil {
                        self.refType = dict["RefType"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                        self.workspaceId = dict["WorkspaceId"] as! String
                    }
                }
            }
            public var apiInvoker: QueryMgsApirestResponseBody.ResultContent.Value.ApiInvoker?

            public var apiName: String?

            public var apiStatus: String?

            public var apiType: String?

            public var appId: String?

            public var authRuleName: String?

            public var cacheRule: QueryMgsApirestResponseBody.ResultContent.Value.CacheRule?

            public var charset: String?

            public var circuitBreakerRule: QueryMgsApirestResponseBody.ResultContent.Value.CircuitBreakerRule?

            public var contentType: String?

            public var defaultLimitRule: QueryMgsApirestResponseBody.ResultContent.Value.DefaultLimitRule?

            public var description_: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var headerRule: [QueryMgsApirestResponseBody.ResultContent.Value.HeaderRule]?

            public var headerRules: [QueryMgsApirestResponseBody.ResultContent.Value.HeaderRules]?

            public var host: String?

            public var id: Int64?

            public var interfaceType: String?

            public var limitRule: QueryMgsApirestResponseBody.ResultContent.Value.LimitRule?

            public var method: String?

            public var methodName: String?

            public var migrateRule: QueryMgsApirestResponseBody.ResultContent.Value.MigrateRule?

            public var mockRule: QueryMgsApirestResponseBody.ResultContent.Value.MockRule?

            public var needETag: String?

            public var needEncrypt: String?

            public var needJsonp: String?

            public var needSign: String?

            public var operationType: String?

            public var paramGetMethod: String?

            public var path: String?

            public var requestBodyModel: String?

            public var requestParams: [QueryMgsApirestResponseBody.ResultContent.Value.RequestParams]?

            public var responseBodyModel: String?

            public var sysId: Int64?

            public var sysName: String?

            public var timeout: String?

            public var workspaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apiInvoker?.validate()
                try self.cacheRule?.validate()
                try self.circuitBreakerRule?.validate()
                try self.defaultLimitRule?.validate()
                try self.limitRule?.validate()
                try self.migrateRule?.validate()
                try self.mockRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiInvoker != nil {
                    map["ApiInvoker"] = self.apiInvoker?.toMap()
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiStatus != nil {
                    map["ApiStatus"] = self.apiStatus!
                }
                if self.apiType != nil {
                    map["ApiType"] = self.apiType!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.authRuleName != nil {
                    map["AuthRuleName"] = self.authRuleName!
                }
                if self.cacheRule != nil {
                    map["CacheRule"] = self.cacheRule?.toMap()
                }
                if self.charset != nil {
                    map["Charset"] = self.charset!
                }
                if self.circuitBreakerRule != nil {
                    map["CircuitBreakerRule"] = self.circuitBreakerRule?.toMap()
                }
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.defaultLimitRule != nil {
                    map["DefaultLimitRule"] = self.defaultLimitRule?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.headerRule != nil {
                    var tmp : [Any] = []
                    for k in self.headerRule! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRule"] = tmp
                }
                if self.headerRules != nil {
                    var tmp : [Any] = []
                    for k in self.headerRules! {
                        tmp.append(k.toMap())
                    }
                    map["HeaderRules"] = tmp
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.interfaceType != nil {
                    map["InterfaceType"] = self.interfaceType!
                }
                if self.limitRule != nil {
                    map["LimitRule"] = self.limitRule?.toMap()
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.methodName != nil {
                    map["MethodName"] = self.methodName!
                }
                if self.migrateRule != nil {
                    map["MigrateRule"] = self.migrateRule?.toMap()
                }
                if self.mockRule != nil {
                    map["MockRule"] = self.mockRule?.toMap()
                }
                if self.needETag != nil {
                    map["NeedETag"] = self.needETag!
                }
                if self.needEncrypt != nil {
                    map["NeedEncrypt"] = self.needEncrypt!
                }
                if self.needJsonp != nil {
                    map["NeedJsonp"] = self.needJsonp!
                }
                if self.needSign != nil {
                    map["NeedSign"] = self.needSign!
                }
                if self.operationType != nil {
                    map["OperationType"] = self.operationType!
                }
                if self.paramGetMethod != nil {
                    map["ParamGetMethod"] = self.paramGetMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.requestBodyModel != nil {
                    map["RequestBodyModel"] = self.requestBodyModel!
                }
                if self.requestParams != nil {
                    var tmp : [Any] = []
                    for k in self.requestParams! {
                        tmp.append(k.toMap())
                    }
                    map["RequestParams"] = tmp
                }
                if self.responseBodyModel != nil {
                    map["ResponseBodyModel"] = self.responseBodyModel!
                }
                if self.sysId != nil {
                    map["SysId"] = self.sysId!
                }
                if self.sysName != nil {
                    map["SysName"] = self.sysName!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.workspaceId != nil {
                    map["WorkspaceId"] = self.workspaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiInvoker") && dict["ApiInvoker"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.ApiInvoker()
                    model.fromMap(dict["ApiInvoker"] as! [String: Any])
                    self.apiInvoker = model
                }
                if dict.keys.contains("ApiName") && dict["ApiName"] != nil {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiStatus") && dict["ApiStatus"] != nil {
                    self.apiStatus = dict["ApiStatus"] as! String
                }
                if dict.keys.contains("ApiType") && dict["ApiType"] != nil {
                    self.apiType = dict["ApiType"] as! String
                }
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AuthRuleName") && dict["AuthRuleName"] != nil {
                    self.authRuleName = dict["AuthRuleName"] as! String
                }
                if dict.keys.contains("CacheRule") && dict["CacheRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.CacheRule()
                    model.fromMap(dict["CacheRule"] as! [String: Any])
                    self.cacheRule = model
                }
                if dict.keys.contains("Charset") && dict["Charset"] != nil {
                    self.charset = dict["Charset"] as! String
                }
                if dict.keys.contains("CircuitBreakerRule") && dict["CircuitBreakerRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.CircuitBreakerRule()
                    model.fromMap(dict["CircuitBreakerRule"] as! [String: Any])
                    self.circuitBreakerRule = model
                }
                if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("DefaultLimitRule") && dict["DefaultLimitRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.DefaultLimitRule()
                    model.fromMap(dict["DefaultLimitRule"] as! [String: Any])
                    self.defaultLimitRule = model
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("HeaderRule") && dict["HeaderRule"] != nil {
                    var tmp : [QueryMgsApirestResponseBody.ResultContent.Value.HeaderRule] = []
                    for v in dict["HeaderRule"] as! [Any] {
                        var model = QueryMgsApirestResponseBody.ResultContent.Value.HeaderRule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRule = tmp
                }
                if dict.keys.contains("HeaderRules") && dict["HeaderRules"] != nil {
                    var tmp : [QueryMgsApirestResponseBody.ResultContent.Value.HeaderRules] = []
                    for v in dict["HeaderRules"] as! [Any] {
                        var model = QueryMgsApirestResponseBody.ResultContent.Value.HeaderRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.headerRules = tmp
                }
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InterfaceType") && dict["InterfaceType"] != nil {
                    self.interfaceType = dict["InterfaceType"] as! String
                }
                if dict.keys.contains("LimitRule") && dict["LimitRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.LimitRule()
                    model.fromMap(dict["LimitRule"] as! [String: Any])
                    self.limitRule = model
                }
                if dict.keys.contains("Method") && dict["Method"] != nil {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("MethodName") && dict["MethodName"] != nil {
                    self.methodName = dict["MethodName"] as! String
                }
                if dict.keys.contains("MigrateRule") && dict["MigrateRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.MigrateRule()
                    model.fromMap(dict["MigrateRule"] as! [String: Any])
                    self.migrateRule = model
                }
                if dict.keys.contains("MockRule") && dict["MockRule"] != nil {
                    var model = QueryMgsApirestResponseBody.ResultContent.Value.MockRule()
                    model.fromMap(dict["MockRule"] as! [String: Any])
                    self.mockRule = model
                }
                if dict.keys.contains("NeedETag") && dict["NeedETag"] != nil {
                    self.needETag = dict["NeedETag"] as! String
                }
                if dict.keys.contains("NeedEncrypt") && dict["NeedEncrypt"] != nil {
                    self.needEncrypt = dict["NeedEncrypt"] as! String
                }
                if dict.keys.contains("NeedJsonp") && dict["NeedJsonp"] != nil {
                    self.needJsonp = dict["NeedJsonp"] as! String
                }
                if dict.keys.contains("NeedSign") && dict["NeedSign"] != nil {
                    self.needSign = dict["NeedSign"] as! String
                }
                if dict.keys.contains("OperationType") && dict["OperationType"] != nil {
                    self.operationType = dict["OperationType"] as! String
                }
                if dict.keys.contains("ParamGetMethod") && dict["ParamGetMethod"] != nil {
                    self.paramGetMethod = dict["ParamGetMethod"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RequestBodyModel") && dict["RequestBodyModel"] != nil {
                    self.requestBodyModel = dict["RequestBodyModel"] as! String
                }
                if dict.keys.contains("RequestParams") && dict["RequestParams"] != nil {
                    var tmp : [QueryMgsApirestResponseBody.ResultContent.Value.RequestParams] = []
                    for v in dict["RequestParams"] as! [Any] {
                        var model = QueryMgsApirestResponseBody.ResultContent.Value.RequestParams()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.requestParams = tmp
                }
                if dict.keys.contains("ResponseBodyModel") && dict["ResponseBodyModel"] != nil {
                    self.responseBodyModel = dict["ResponseBodyModel"] as! String
                }
                if dict.keys.contains("SysId") && dict["SysId"] != nil {
                    self.sysId = dict["SysId"] as! Int64
                }
                if dict.keys.contains("SysName") && dict["SysName"] != nil {
                    self.sysName = dict["SysName"] as! String
                }
                if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
                    self.timeout = dict["Timeout"] as! String
                }
                if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
                    self.workspaceId = dict["WorkspaceId"] as! String
                }
            }
        }
        public var errorMessage: String?

        public var success: Bool?

        public var value: QueryMgsApirestResponseBody.ResultContent.Value?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.value?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.value != nil {
                map["Value"] = self.value?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                var model = QueryMgsApirestResponseBody.ResultContent.Value()
                model.fromMap(dict["Value"] as! [String: Any])
                self.value = model
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMgsApirestResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMgsApirestResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMgsApirestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMgsApirestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMgsApirestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMgsTestreqbodyautogenRequest : Tea.TeaModel {
    public var appId: String?

    public var format: String?

    public var mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.format != nil {
            map["Format"] = self.format!
        }
        if self.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr != nil {
            map["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"] = self.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Format") && dict["Format"] != nil {
            self.format = dict["Format"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr") && dict["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"] != nil {
            self.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr = dict["MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMgsTestreqbodyautogenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            self.resultContent = dict["ResultContent"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMgsTestreqbodyautogenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMgsTestreqbodyautogenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMgsTestreqbodyautogenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMpsSchedulerListRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var type: Int32?

    public var uniqueId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uniqueId != nil {
            map["UniqueId"] = self.uniqueId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UniqueId") && dict["UniqueId"] != nil {
            self.uniqueId = dict["UniqueId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryMpsSchedulerListResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class List : Tea.TeaModel {
                public var createType: Int32?

                public var deliveryType: Int32?

                public var executedStatus: String?

                public var gmtCreate: Int64?

                public var parentId: String?

                public var pushContent: String?

                public var pushTime: Int64?

                public var pushTitle: String?

                public var strategyType: Int32?

                public var type: Int32?

                public var uniqueId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createType != nil {
                        map["CreateType"] = self.createType!
                    }
                    if self.deliveryType != nil {
                        map["DeliveryType"] = self.deliveryType!
                    }
                    if self.executedStatus != nil {
                        map["ExecutedStatus"] = self.executedStatus!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.parentId != nil {
                        map["ParentId"] = self.parentId!
                    }
                    if self.pushContent != nil {
                        map["PushContent"] = self.pushContent!
                    }
                    if self.pushTime != nil {
                        map["PushTime"] = self.pushTime!
                    }
                    if self.pushTitle != nil {
                        map["PushTitle"] = self.pushTitle!
                    }
                    if self.strategyType != nil {
                        map["StrategyType"] = self.strategyType!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.uniqueId != nil {
                        map["UniqueId"] = self.uniqueId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                        self.createType = dict["CreateType"] as! Int32
                    }
                    if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
                        self.deliveryType = dict["DeliveryType"] as! Int32
                    }
                    if dict.keys.contains("ExecutedStatus") && dict["ExecutedStatus"] != nil {
                        self.executedStatus = dict["ExecutedStatus"] as! String
                    }
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! Int64
                    }
                    if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                        self.parentId = dict["ParentId"] as! String
                    }
                    if dict.keys.contains("PushContent") && dict["PushContent"] != nil {
                        self.pushContent = dict["PushContent"] as! String
                    }
                    if dict.keys.contains("PushTime") && dict["PushTime"] != nil {
                        self.pushTime = dict["PushTime"] as! Int64
                    }
                    if dict.keys.contains("PushTitle") && dict["PushTitle"] != nil {
                        self.pushTitle = dict["PushTitle"] as! String
                    }
                    if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
                        self.strategyType = dict["StrategyType"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! Int32
                    }
                    if dict.keys.contains("UniqueId") && dict["UniqueId"] != nil {
                        self.uniqueId = dict["UniqueId"] as! String
                    }
                }
            }
            public var list: [QueryMpsSchedulerListResponseBody.ResultContent.Data.List]?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.list != nil {
                    var tmp : [Any] = []
                    for k in self.list! {
                        tmp.append(k.toMap())
                    }
                    map["List"] = tmp
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("List") && dict["List"] != nil {
                    var tmp : [QueryMpsSchedulerListResponseBody.ResultContent.Data.List] = []
                    for v in dict["List"] as! [Any] {
                        var model = QueryMpsSchedulerListResponseBody.ResultContent.Data.List()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.list = tmp
                }
                if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var data: QueryMpsSchedulerListResponseBody.ResultContent.Data?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryMpsSchedulerListResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryMpsSchedulerListResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryMpsSchedulerListResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryMpsSchedulerListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMpsSchedulerListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryMpsSchedulerListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPushAnalysisCoreIndexRequest : Tea.TeaModel {
    public var appId: String?

    public var channel: String?

    public var endTime: Int64?

    public var platform: String?

    public var startTime: Int64?

    public var taskId: String?

    public var type: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channel != nil {
            map["Channel"] = self.channel!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Channel") && dict["Channel"] != nil {
            self.channel = dict["Channel"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryPushAnalysisCoreIndexResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var arrivalNum: Double?

            public var arrivalRate: Double?

            public var ignoreNum: Double?

            public var ignoreRate: Double?

            public var openNum: Double?

            public var openRate: Double?

            public var pushNum: Double?

            public var pushTotalNum: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arrivalNum != nil {
                    map["ArrivalNum"] = self.arrivalNum!
                }
                if self.arrivalRate != nil {
                    map["ArrivalRate"] = self.arrivalRate!
                }
                if self.ignoreNum != nil {
                    map["IgnoreNum"] = self.ignoreNum!
                }
                if self.ignoreRate != nil {
                    map["IgnoreRate"] = self.ignoreRate!
                }
                if self.openNum != nil {
                    map["OpenNum"] = self.openNum!
                }
                if self.openRate != nil {
                    map["OpenRate"] = self.openRate!
                }
                if self.pushNum != nil {
                    map["PushNum"] = self.pushNum!
                }
                if self.pushTotalNum != nil {
                    map["PushTotalNum"] = self.pushTotalNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArrivalNum") && dict["ArrivalNum"] != nil {
                    self.arrivalNum = dict["ArrivalNum"] as! Double
                }
                if dict.keys.contains("ArrivalRate") && dict["ArrivalRate"] != nil {
                    self.arrivalRate = dict["ArrivalRate"] as! Double
                }
                if dict.keys.contains("IgnoreNum") && dict["IgnoreNum"] != nil {
                    self.ignoreNum = dict["IgnoreNum"] as! Double
                }
                if dict.keys.contains("IgnoreRate") && dict["IgnoreRate"] != nil {
                    self.ignoreRate = dict["IgnoreRate"] as! Double
                }
                if dict.keys.contains("OpenNum") && dict["OpenNum"] != nil {
                    self.openNum = dict["OpenNum"] as! Double
                }
                if dict.keys.contains("OpenRate") && dict["OpenRate"] != nil {
                    self.openRate = dict["OpenRate"] as! Double
                }
                if dict.keys.contains("PushNum") && dict["PushNum"] != nil {
                    self.pushNum = dict["PushNum"] as! Double
                }
                if dict.keys.contains("PushTotalNum") && dict["PushTotalNum"] != nil {
                    self.pushTotalNum = dict["PushTotalNum"] as! Double
                }
            }
        }
        public var data: QueryPushAnalysisCoreIndexResponseBody.ResultContent.Data?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryPushAnalysisCoreIndexResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryPushAnalysisCoreIndexResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryPushAnalysisCoreIndexResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryPushAnalysisCoreIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPushAnalysisCoreIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPushAnalysisCoreIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPushAnalysisTaskDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryPushAnalysisTaskDetailResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var duration: String?

            public var endTime: Int64?

            public var pushArrivalNum: Double?

            public var pushNum: Double?

            public var pushSuccessNum: Double?

            public var startTime: Int64?

            public var taskId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.pushArrivalNum != nil {
                    map["PushArrivalNum"] = self.pushArrivalNum!
                }
                if self.pushNum != nil {
                    map["PushNum"] = self.pushNum!
                }
                if self.pushSuccessNum != nil {
                    map["PushSuccessNum"] = self.pushSuccessNum!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("PushArrivalNum") && dict["PushArrivalNum"] != nil {
                    self.pushArrivalNum = dict["PushArrivalNum"] as! Double
                }
                if dict.keys.contains("PushNum") && dict["PushNum"] != nil {
                    self.pushNum = dict["PushNum"] as! Double
                }
                if dict.keys.contains("PushSuccessNum") && dict["PushSuccessNum"] != nil {
                    self.pushSuccessNum = dict["PushSuccessNum"] as! Double
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! Int64
                }
            }
        }
        public var data: QueryPushAnalysisTaskDetailResponseBody.ResultContent.Data?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryPushAnalysisTaskDetailResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryPushAnalysisTaskDetailResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryPushAnalysisTaskDetailResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryPushAnalysisTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPushAnalysisTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPushAnalysisTaskDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPushAnalysisTaskListRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var taskId: String?

    public var taskName: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryPushAnalysisTaskListResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class List : Tea.TeaModel {
                public var gmtCreate: Int64?

                public var taskId: String?

                public var taskName: String?

                public var templateId: String?

                public var templateName: String?

                public var type: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskName != nil {
                        map["TaskName"] = self.taskName!
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.templateName != nil {
                        map["TemplateName"] = self.templateName!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! Int64
                    }
                    if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                        self.taskId = dict["TaskId"] as! String
                    }
                    if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                        self.taskName = dict["TaskName"] as! String
                    }
                    if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                        self.templateName = dict["TemplateName"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! Int64
                    }
                }
            }
            public var gmtCreate: Int64?

            public var list: [QueryPushAnalysisTaskListResponseBody.ResultContent.Data.List]?

            public var taskId: String?

            public var taskName: String?

            public var templateId: String?

            public var templateName: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.list != nil {
                    var tmp : [Any] = []
                    for k in self.list! {
                        tmp.append(k.toMap())
                    }
                    map["List"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("List") && dict["List"] != nil {
                    var tmp : [QueryPushAnalysisTaskListResponseBody.ResultContent.Data.List] = []
                    for v in dict["List"] as! [Any] {
                        var model = QueryPushAnalysisTaskListResponseBody.ResultContent.Data.List()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.list = tmp
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! Int64
                }
            }
        }
        public var data: [QueryPushAnalysisTaskListResponseBody.ResultContent.Data]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                var tmp : [Any] = []
                for k in self.data! {
                    tmp.append(k.toMap())
                }
                map["Data"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var tmp : [QueryPushAnalysisTaskListResponseBody.ResultContent.Data] = []
                for v in dict["Data"] as! [Any] {
                    var model = QueryPushAnalysisTaskListResponseBody.ResultContent.Data()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.data = tmp
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryPushAnalysisTaskListResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryPushAnalysisTaskListResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryPushAnalysisTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPushAnalysisTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPushAnalysisTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPushSchedulerListRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var type: Int32?

    public var uniqueId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uniqueId != nil {
            map["UniqueId"] = self.uniqueId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UniqueId") && dict["UniqueId"] != nil {
            self.uniqueId = dict["UniqueId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class QueryPushSchedulerListResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class List : Tea.TeaModel {
                public var createType: Int32?

                public var deliveryType: Int32?

                public var executedStatus: String?

                public var gmtCreate: Int64?

                public var parentId: String?

                public var pushContent: String?

                public var pushTime: Int64?

                public var pushTitle: String?

                public var strategyType: Int32?

                public var type: Int32?

                public var uniqueId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createType != nil {
                        map["CreateType"] = self.createType!
                    }
                    if self.deliveryType != nil {
                        map["DeliveryType"] = self.deliveryType!
                    }
                    if self.executedStatus != nil {
                        map["ExecutedStatus"] = self.executedStatus!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.parentId != nil {
                        map["ParentId"] = self.parentId!
                    }
                    if self.pushContent != nil {
                        map["PushContent"] = self.pushContent!
                    }
                    if self.pushTime != nil {
                        map["PushTime"] = self.pushTime!
                    }
                    if self.pushTitle != nil {
                        map["PushTitle"] = self.pushTitle!
                    }
                    if self.strategyType != nil {
                        map["StrategyType"] = self.strategyType!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.uniqueId != nil {
                        map["UniqueId"] = self.uniqueId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                        self.createType = dict["CreateType"] as! Int32
                    }
                    if dict.keys.contains("DeliveryType") && dict["DeliveryType"] != nil {
                        self.deliveryType = dict["DeliveryType"] as! Int32
                    }
                    if dict.keys.contains("ExecutedStatus") && dict["ExecutedStatus"] != nil {
                        self.executedStatus = dict["ExecutedStatus"] as! String
                    }
                    if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                        self.gmtCreate = dict["GmtCreate"] as! Int64
                    }
                    if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                        self.parentId = dict["ParentId"] as! String
                    }
                    if dict.keys.contains("PushContent") && dict["PushContent"] != nil {
                        self.pushContent = dict["PushContent"] as! String
                    }
                    if dict.keys.contains("PushTime") && dict["PushTime"] != nil {
                        self.pushTime = dict["PushTime"] as! Int64
                    }
                    if dict.keys.contains("PushTitle") && dict["PushTitle"] != nil {
                        self.pushTitle = dict["PushTitle"] as! String
                    }
                    if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
                        self.strategyType = dict["StrategyType"] as! Int32
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! Int32
                    }
                    if dict.keys.contains("UniqueId") && dict["UniqueId"] != nil {
                        self.uniqueId = dict["UniqueId"] as! String
                    }
                }
            }
            public var list: [QueryPushSchedulerListResponseBody.ResultContent.Data.List]?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.list != nil {
                    var tmp : [Any] = []
                    for k in self.list! {
                        tmp.append(k.toMap())
                    }
                    map["List"] = tmp
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("List") && dict["List"] != nil {
                    var tmp : [QueryPushSchedulerListResponseBody.ResultContent.Data.List] = []
                    for v in dict["List"] as! [Any] {
                        var model = QueryPushSchedulerListResponseBody.ResultContent.Data.List()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.list = tmp
                }
                if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var data: QueryPushSchedulerListResponseBody.ResultContent.Data?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = QueryPushSchedulerListResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: QueryPushSchedulerListResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = QueryPushSchedulerListResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class QueryPushSchedulerListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPushSchedulerListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPushSchedulerListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokePushMessageRequest : Tea.TeaModel {
    public var appId: String?

    public var messageId: String?

    public var targetId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MessageId") && dict["MessageId"] != nil {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
            self.targetId = dict["TargetId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class RevokePushMessageResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: RevokePushMessageResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = RevokePushMessageResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class RevokePushMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokePushMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokePushMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokePushTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class RevokePushTaskResponseBody : Tea.TeaModel {
    public class PushResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var pushResult: RevokePushTaskResponseBody.PushResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResult != nil {
            map["PushResult"] = self.pushResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
            var model = RevokePushTaskResponseBody.PushResult()
            model.fromMap(dict["PushResult"] as! [String: Any])
            self.pushResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class RevokePushTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokePushTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokePushTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunMsaDiffRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMsaDiffRunJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMsaDiffRunJsonStr != nil {
            map["MpaasMappcenterMsaDiffRunJsonStr"] = self.mpaasMappcenterMsaDiffRunJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMsaDiffRunJsonStr") && dict["MpaasMappcenterMsaDiffRunJsonStr"] != nil {
            self.mpaasMappcenterMsaDiffRunJsonStr = dict["MpaasMappcenterMsaDiffRunJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class RunMsaDiffResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: RunMsaDiffResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = RunMsaDiffResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class RunMsaDiffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunMsaDiffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RunMsaDiffResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveMgsApirestRequest : Tea.TeaModel {
    public var appId: String?

    public var mpaasMappcenterMgsApirestSaveJsonStr: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.mpaasMappcenterMgsApirestSaveJsonStr != nil {
            map["MpaasMappcenterMgsApirestSaveJsonStr"] = self.mpaasMappcenterMgsApirestSaveJsonStr!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MpaasMappcenterMgsApirestSaveJsonStr") && dict["MpaasMappcenterMgsApirestSaveJsonStr"] != nil {
            self.mpaasMappcenterMgsApirestSaveJsonStr = dict["MpaasMappcenterMgsApirestSaveJsonStr"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class SaveMgsApirestResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var errorMessage: String?

        public var success: Bool?

        public var value: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: SaveMgsApirestResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = SaveMgsApirestResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class SaveMgsApirestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveMgsApirestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveMgsApirestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartUserAppAsyncEnhanceInMsaRequest : Tea.TeaModel {
    public var apkProtector: Bool?

    public var appId: String?

    public var assetsFileList: String?

    public var classes: String?

    public var dalvikDebugger: Int32?

    public var emulatorEnvironment: Int32?

    public var id: Int64?

    public var javaHook: Int32?

    public var memoryDump: Int32?

    public var nativeDebugger: Int32?

    public var nativeHook: Int32?

    public var packageTampered: Int32?

    public var root: Int32?

    public var runMode: String?

    public var soFileList: String?

    public var taskType: String?

    public var tenantId: String?

    public var totalSwitch: Bool?

    public var useAShield: Bool?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apkProtector != nil {
            map["ApkProtector"] = self.apkProtector!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.assetsFileList != nil {
            map["AssetsFileList"] = self.assetsFileList!
        }
        if self.classes != nil {
            map["Classes"] = self.classes!
        }
        if self.dalvikDebugger != nil {
            map["DalvikDebugger"] = self.dalvikDebugger!
        }
        if self.emulatorEnvironment != nil {
            map["EmulatorEnvironment"] = self.emulatorEnvironment!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.javaHook != nil {
            map["JavaHook"] = self.javaHook!
        }
        if self.memoryDump != nil {
            map["MemoryDump"] = self.memoryDump!
        }
        if self.nativeDebugger != nil {
            map["NativeDebugger"] = self.nativeDebugger!
        }
        if self.nativeHook != nil {
            map["NativeHook"] = self.nativeHook!
        }
        if self.packageTampered != nil {
            map["PackageTampered"] = self.packageTampered!
        }
        if self.root != nil {
            map["Root"] = self.root!
        }
        if self.runMode != nil {
            map["RunMode"] = self.runMode!
        }
        if self.soFileList != nil {
            map["SoFileList"] = self.soFileList!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.totalSwitch != nil {
            map["TotalSwitch"] = self.totalSwitch!
        }
        if self.useAShield != nil {
            map["UseAShield"] = self.useAShield!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApkProtector") && dict["ApkProtector"] != nil {
            self.apkProtector = dict["ApkProtector"] as! Bool
        }
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AssetsFileList") && dict["AssetsFileList"] != nil {
            self.assetsFileList = dict["AssetsFileList"] as! String
        }
        if dict.keys.contains("Classes") && dict["Classes"] != nil {
            self.classes = dict["Classes"] as! String
        }
        if dict.keys.contains("DalvikDebugger") && dict["DalvikDebugger"] != nil {
            self.dalvikDebugger = dict["DalvikDebugger"] as! Int32
        }
        if dict.keys.contains("EmulatorEnvironment") && dict["EmulatorEnvironment"] != nil {
            self.emulatorEnvironment = dict["EmulatorEnvironment"] as! Int32
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("JavaHook") && dict["JavaHook"] != nil {
            self.javaHook = dict["JavaHook"] as! Int32
        }
        if dict.keys.contains("MemoryDump") && dict["MemoryDump"] != nil {
            self.memoryDump = dict["MemoryDump"] as! Int32
        }
        if dict.keys.contains("NativeDebugger") && dict["NativeDebugger"] != nil {
            self.nativeDebugger = dict["NativeDebugger"] as! Int32
        }
        if dict.keys.contains("NativeHook") && dict["NativeHook"] != nil {
            self.nativeHook = dict["NativeHook"] as! Int32
        }
        if dict.keys.contains("PackageTampered") && dict["PackageTampered"] != nil {
            self.packageTampered = dict["PackageTampered"] as! Int32
        }
        if dict.keys.contains("Root") && dict["Root"] != nil {
            self.root = dict["Root"] as! Int32
        }
        if dict.keys.contains("RunMode") && dict["RunMode"] != nil {
            self.runMode = dict["RunMode"] as! String
        }
        if dict.keys.contains("SoFileList") && dict["SoFileList"] != nil {
            self.soFileList = dict["SoFileList"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("TotalSwitch") && dict["TotalSwitch"] != nil {
            self.totalSwitch = dict["TotalSwitch"] as! Bool
        }
        if dict.keys.contains("UseAShield") && dict["UseAShield"] != nil {
            self.useAShield = dict["UseAShield"] as! Bool
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class StartUserAppAsyncEnhanceInMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class EnhanceMapping : Tea.TeaModel {
                public var info: String?

                public var reason: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        map["Info"] = self.info!
                    }
                    if self.reason != nil {
                        map["Reason"] = self.reason!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Info") && dict["Info"] != nil {
                        self.info = dict["Info"] as! String
                    }
                    if dict.keys.contains("Reason") && dict["Reason"] != nil {
                        self.reason = dict["Reason"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var afterMd5: String?

            public var afterSize: Int64?

            public var appCode: String?

            public var appPackage: String?

            public var assetsFileList: [String]?

            public var beforeMd5: String?

            public var beforeSize: Int64?

            public var classForest: String?

            public var enhanceMapping: [StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent.Data.EnhanceMapping]?

            public var enhanceRules: [String]?

            public var enhancedAssetsFiles: [String]?

            public var enhancedClasses: [String]?

            public var enhancedSoFiles: [String]?

            public var id: Int64?

            public var label: String?

            public var progress: Int64?

            public var soFileList: [String]?

            public var status: Int64?

            public var taskType: String?

            public var versionCode: String?

            public var versionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.afterMd5 != nil {
                    map["AfterMd5"] = self.afterMd5!
                }
                if self.afterSize != nil {
                    map["AfterSize"] = self.afterSize!
                }
                if self.appCode != nil {
                    map["AppCode"] = self.appCode!
                }
                if self.appPackage != nil {
                    map["AppPackage"] = self.appPackage!
                }
                if self.assetsFileList != nil {
                    map["AssetsFileList"] = self.assetsFileList!
                }
                if self.beforeMd5 != nil {
                    map["BeforeMd5"] = self.beforeMd5!
                }
                if self.beforeSize != nil {
                    map["BeforeSize"] = self.beforeSize!
                }
                if self.classForest != nil {
                    map["ClassForest"] = self.classForest!
                }
                if self.enhanceMapping != nil {
                    var tmp : [Any] = []
                    for k in self.enhanceMapping! {
                        tmp.append(k.toMap())
                    }
                    map["EnhanceMapping"] = tmp
                }
                if self.enhanceRules != nil {
                    map["EnhanceRules"] = self.enhanceRules!
                }
                if self.enhancedAssetsFiles != nil {
                    map["EnhancedAssetsFiles"] = self.enhancedAssetsFiles!
                }
                if self.enhancedClasses != nil {
                    map["EnhancedClasses"] = self.enhancedClasses!
                }
                if self.enhancedSoFiles != nil {
                    map["EnhancedSoFiles"] = self.enhancedSoFiles!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.soFileList != nil {
                    map["SoFileList"] = self.soFileList!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.versionCode != nil {
                    map["VersionCode"] = self.versionCode!
                }
                if self.versionName != nil {
                    map["VersionName"] = self.versionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AfterMd5") && dict["AfterMd5"] != nil {
                    self.afterMd5 = dict["AfterMd5"] as! String
                }
                if dict.keys.contains("AfterSize") && dict["AfterSize"] != nil {
                    self.afterSize = dict["AfterSize"] as! Int64
                }
                if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                    self.appCode = dict["AppCode"] as! String
                }
                if dict.keys.contains("AppPackage") && dict["AppPackage"] != nil {
                    self.appPackage = dict["AppPackage"] as! String
                }
                if dict.keys.contains("AssetsFileList") && dict["AssetsFileList"] != nil {
                    self.assetsFileList = dict["AssetsFileList"] as! [String]
                }
                if dict.keys.contains("BeforeMd5") && dict["BeforeMd5"] != nil {
                    self.beforeMd5 = dict["BeforeMd5"] as! String
                }
                if dict.keys.contains("BeforeSize") && dict["BeforeSize"] != nil {
                    self.beforeSize = dict["BeforeSize"] as! Int64
                }
                if dict.keys.contains("ClassForest") && dict["ClassForest"] != nil {
                    self.classForest = dict["ClassForest"] as! String
                }
                if dict.keys.contains("EnhanceMapping") && dict["EnhanceMapping"] != nil {
                    var tmp : [StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent.Data.EnhanceMapping] = []
                    for v in dict["EnhanceMapping"] as! [Any] {
                        var model = StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent.Data.EnhanceMapping()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.enhanceMapping = tmp
                }
                if dict.keys.contains("EnhanceRules") && dict["EnhanceRules"] != nil {
                    self.enhanceRules = dict["EnhanceRules"] as! [String]
                }
                if dict.keys.contains("EnhancedAssetsFiles") && dict["EnhancedAssetsFiles"] != nil {
                    self.enhancedAssetsFiles = dict["EnhancedAssetsFiles"] as! [String]
                }
                if dict.keys.contains("EnhancedClasses") && dict["EnhancedClasses"] != nil {
                    self.enhancedClasses = dict["EnhancedClasses"] as! [String]
                }
                if dict.keys.contains("EnhancedSoFiles") && dict["EnhancedSoFiles"] != nil {
                    self.enhancedSoFiles = dict["EnhancedSoFiles"] as! [String]
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Label") && dict["Label"] != nil {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Progress") && dict["Progress"] != nil {
                    self.progress = dict["Progress"] as! Int64
                }
                if dict.keys.contains("SoFileList") && dict["SoFileList"] != nil {
                    self.soFileList = dict["SoFileList"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
                if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                    self.versionCode = dict["VersionCode"] as! String
                }
                if dict.keys.contains("VersionName") && dict["VersionName"] != nil {
                    self.versionName = dict["VersionName"] as! String
                }
            }
        }
        public var code: String?

        public var data: StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent.Data?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = StartUserAppAsyncEnhanceInMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class StartUserAppAsyncEnhanceInMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartUserAppAsyncEnhanceInMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartUserAppAsyncEnhanceInMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMcubeWhitelistRequest : Tea.TeaModel {
    public var appId: String?

    public var id: String?

    public var keyIds: String?

    public var onexFlag: Bool?

    public var ossUrl: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.keyIds != nil {
            map["KeyIds"] = self.keyIds!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("KeyIds") && dict["KeyIds"] != nil {
            self.keyIds = dict["KeyIds"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
            self.ossUrl = dict["OssUrl"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UpdateMcubeWhitelistResponseBody : Tea.TeaModel {
    public class AddWhitelistResult : Tea.TeaModel {
        public class AddWhitelistInfo : Tea.TeaModel {
            public var failNum: Int64?

            public var failUserIds: String?

            public var successNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failNum != nil {
                    map["FailNum"] = self.failNum!
                }
                if self.failUserIds != nil {
                    map["FailUserIds"] = self.failUserIds!
                }
                if self.successNum != nil {
                    map["SuccessNum"] = self.successNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailNum") && dict["FailNum"] != nil {
                    self.failNum = dict["FailNum"] as! Int64
                }
                if dict.keys.contains("FailUserIds") && dict["FailUserIds"] != nil {
                    self.failUserIds = dict["FailUserIds"] as! String
                }
                if dict.keys.contains("SuccessNum") && dict["SuccessNum"] != nil {
                    self.successNum = dict["SuccessNum"] as! Int64
                }
            }
        }
        public var addWhitelistInfo: UpdateMcubeWhitelistResponseBody.AddWhitelistResult.AddWhitelistInfo?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.addWhitelistInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addWhitelistInfo != nil {
                map["AddWhitelistInfo"] = self.addWhitelistInfo?.toMap()
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddWhitelistInfo") && dict["AddWhitelistInfo"] != nil {
                var model = UpdateMcubeWhitelistResponseBody.AddWhitelistResult.AddWhitelistInfo()
                model.fromMap(dict["AddWhitelistInfo"] as! [String: Any])
                self.addWhitelistInfo = model
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var addWhitelistResult: UpdateMcubeWhitelistResponseBody.AddWhitelistResult?

    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.addWhitelistResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addWhitelistResult != nil {
            map["AddWhitelistResult"] = self.addWhitelistResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddWhitelistResult") && dict["AddWhitelistResult"] != nil {
            var model = UpdateMcubeWhitelistResponseBody.AddWhitelistResult()
            model.fromMap(dict["AddWhitelistResult"] as! [String: Any])
            self.addWhitelistResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class UpdateMcubeWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMcubeWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMcubeWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMpaasAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var iconFileUrl: String?

    public var identifier: String?

    public var onexFlag: Bool?

    public var systemType: String?

    public var tenantId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.iconFileUrl != nil {
            map["IconFileUrl"] = self.iconFileUrl!
        }
        if self.identifier != nil {
            map["Identifier"] = self.identifier!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("IconFileUrl") && dict["IconFileUrl"] != nil {
            self.iconFileUrl = dict["IconFileUrl"] as! String
        }
        if dict.keys.contains("Identifier") && dict["Identifier"] != nil {
            self.identifier = dict["Identifier"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("SystemType") && dict["SystemType"] != nil {
            self.systemType = dict["SystemType"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
    }
}

public class UpdateMpaasAppInfoResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var appId: String?

            public var code: String?

            public var data: String?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") && dict["AppId"] != nil {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Data") && dict["Data"] != nil {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var data: UpdateMpaasAppInfoResponseBody.ResultContent.Data?

        public var requestId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = UpdateMpaasAppInfoResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: UpdateMpaasAppInfoResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = UpdateMpaasAppInfoResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class UpdateMpaasAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMpaasAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateMpaasAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadBitcodeToMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var bitcode: String?

    public var codeVersion: String?

    public var license: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bitcode != nil {
            map["Bitcode"] = self.bitcode!
        }
        if self.codeVersion != nil {
            map["CodeVersion"] = self.codeVersion!
        }
        if self.license != nil {
            map["License"] = self.license!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Bitcode") && dict["Bitcode"] != nil {
            self.bitcode = dict["Bitcode"] as! String
        }
        if dict.keys.contains("CodeVersion") && dict["CodeVersion"] != nil {
            self.codeVersion = dict["CodeVersion"] as! String
        }
        if dict.keys.contains("License") && dict["License"] != nil {
            self.license = dict["License"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UploadBitcodeToMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: UploadBitcodeToMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = UploadBitcodeToMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class UploadBitcodeToMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadBitcodeToMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadBitcodeToMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMcubeMiniPackageRequest : Tea.TeaModel {
    public var appId: String?

    public var autoInstall: Int64?

    public var clientVersionMax: String?

    public var clientVersionMin: String?

    public var enableKeepAlive: String?

    public var enableOptionMenu: String?

    public var enableTabBar: Int64?

    public var extendInfo: String?

    public var h5Id: String?

    public var h5Name: String?

    public var h5Version: String?

    public var iconFileUrl: String?

    public var iconUrl: String?

    public var installType: Int64?

    public var mainUrl: String?

    public var onexFlag: Bool?

    public var packageType: Int64?

    public var platform: String?

    public var resourceFileUrl: String?

    public var resourceType: Int64?

    public var tenantId: String?

    public var userId: String?

    public var uuid: String?

    public var vhost: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoInstall != nil {
            map["AutoInstall"] = self.autoInstall!
        }
        if self.clientVersionMax != nil {
            map["ClientVersionMax"] = self.clientVersionMax!
        }
        if self.clientVersionMin != nil {
            map["ClientVersionMin"] = self.clientVersionMin!
        }
        if self.enableKeepAlive != nil {
            map["EnableKeepAlive"] = self.enableKeepAlive!
        }
        if self.enableOptionMenu != nil {
            map["EnableOptionMenu"] = self.enableOptionMenu!
        }
        if self.enableTabBar != nil {
            map["EnableTabBar"] = self.enableTabBar!
        }
        if self.extendInfo != nil {
            map["ExtendInfo"] = self.extendInfo!
        }
        if self.h5Id != nil {
            map["H5Id"] = self.h5Id!
        }
        if self.h5Name != nil {
            map["H5Name"] = self.h5Name!
        }
        if self.h5Version != nil {
            map["H5Version"] = self.h5Version!
        }
        if self.iconFileUrl != nil {
            map["IconFileUrl"] = self.iconFileUrl!
        }
        if self.iconUrl != nil {
            map["IconUrl"] = self.iconUrl!
        }
        if self.installType != nil {
            map["InstallType"] = self.installType!
        }
        if self.mainUrl != nil {
            map["MainUrl"] = self.mainUrl!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.resourceFileUrl != nil {
            map["ResourceFileUrl"] = self.resourceFileUrl!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.vhost != nil {
            map["Vhost"] = self.vhost!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoInstall") && dict["AutoInstall"] != nil {
            self.autoInstall = dict["AutoInstall"] as! Int64
        }
        if dict.keys.contains("ClientVersionMax") && dict["ClientVersionMax"] != nil {
            self.clientVersionMax = dict["ClientVersionMax"] as! String
        }
        if dict.keys.contains("ClientVersionMin") && dict["ClientVersionMin"] != nil {
            self.clientVersionMin = dict["ClientVersionMin"] as! String
        }
        if dict.keys.contains("EnableKeepAlive") && dict["EnableKeepAlive"] != nil {
            self.enableKeepAlive = dict["EnableKeepAlive"] as! String
        }
        if dict.keys.contains("EnableOptionMenu") && dict["EnableOptionMenu"] != nil {
            self.enableOptionMenu = dict["EnableOptionMenu"] as! String
        }
        if dict.keys.contains("EnableTabBar") && dict["EnableTabBar"] != nil {
            self.enableTabBar = dict["EnableTabBar"] as! Int64
        }
        if dict.keys.contains("ExtendInfo") && dict["ExtendInfo"] != nil {
            self.extendInfo = dict["ExtendInfo"] as! String
        }
        if dict.keys.contains("H5Id") && dict["H5Id"] != nil {
            self.h5Id = dict["H5Id"] as! String
        }
        if dict.keys.contains("H5Name") && dict["H5Name"] != nil {
            self.h5Name = dict["H5Name"] as! String
        }
        if dict.keys.contains("H5Version") && dict["H5Version"] != nil {
            self.h5Version = dict["H5Version"] as! String
        }
        if dict.keys.contains("IconFileUrl") && dict["IconFileUrl"] != nil {
            self.iconFileUrl = dict["IconFileUrl"] as! String
        }
        if dict.keys.contains("IconUrl") && dict["IconUrl"] != nil {
            self.iconUrl = dict["IconUrl"] as! String
        }
        if dict.keys.contains("InstallType") && dict["InstallType"] != nil {
            self.installType = dict["InstallType"] as! Int64
        }
        if dict.keys.contains("MainUrl") && dict["MainUrl"] != nil {
            self.mainUrl = dict["MainUrl"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("PackageType") && dict["PackageType"] != nil {
            self.packageType = dict["PackageType"] as! Int64
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("ResourceFileUrl") && dict["ResourceFileUrl"] != nil {
            self.resourceFileUrl = dict["ResourceFileUrl"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! Int64
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("Vhost") && dict["Vhost"] != nil {
            self.vhost = dict["Vhost"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UploadMcubeMiniPackageResponseBody : Tea.TeaModel {
    public class UploadMiniPackageResult : Tea.TeaModel {
        public class ReturnPackageResult : Tea.TeaModel {
            public var debugUrl: String?

            public var packageId: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.debugUrl != nil {
                    map["DebugUrl"] = self.debugUrl!
                }
                if self.packageId != nil {
                    map["PackageId"] = self.packageId!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DebugUrl") && dict["DebugUrl"] != nil {
                    self.debugUrl = dict["DebugUrl"] as! String
                }
                if dict.keys.contains("PackageId") && dict["PackageId"] != nil {
                    self.packageId = dict["PackageId"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var resultMsg: String?

        public var returnPackageResult: UploadMcubeMiniPackageResponseBody.UploadMiniPackageResult.ReturnPackageResult?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.returnPackageResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.returnPackageResult != nil {
                map["ReturnPackageResult"] = self.returnPackageResult?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("ReturnPackageResult") && dict["ReturnPackageResult"] != nil {
                var model = UploadMcubeMiniPackageResponseBody.UploadMiniPackageResult.ReturnPackageResult()
                model.fromMap(dict["ReturnPackageResult"] as! [String: Any])
                self.returnPackageResult = model
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public var uploadMiniPackageResult: UploadMcubeMiniPackageResponseBody.UploadMiniPackageResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadMiniPackageResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.uploadMiniPackageResult != nil {
            map["UploadMiniPackageResult"] = self.uploadMiniPackageResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("UploadMiniPackageResult") && dict["UploadMiniPackageResult"] != nil {
            var model = UploadMcubeMiniPackageResponseBody.UploadMiniPackageResult()
            model.fromMap(dict["UploadMiniPackageResult"] as! [String: Any])
            self.uploadMiniPackageResult = model
        }
    }
}

public class UploadMcubeMiniPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMcubeMiniPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMcubeMiniPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadMcubeRsaKeyRequest : Tea.TeaModel {
    public var appId: String?

    public var fileUrl: String?

    public var onexFlag: Bool?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.onexFlag != nil {
            map["OnexFlag"] = self.onexFlag!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("OnexFlag") && dict["OnexFlag"] != nil {
            self.onexFlag = dict["OnexFlag"] as! Bool
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UploadMcubeRsaKeyResponseBody : Tea.TeaModel {
    public class UploadRsaResult : Tea.TeaModel {
        public var data: String?

        public var resultMsg: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.resultMsg != nil {
                map["ResultMsg"] = self.resultMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") && dict["Data"] != nil {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                self.resultMsg = dict["ResultMsg"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultMessage: String?

    public var uploadRsaResult: UploadMcubeRsaKeyResponseBody.UploadRsaResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadRsaResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.uploadRsaResult != nil {
            map["UploadRsaResult"] = self.uploadRsaResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("UploadRsaResult") && dict["UploadRsaResult"] != nil {
            var model = UploadMcubeRsaKeyResponseBody.UploadRsaResult()
            model.fromMap(dict["UploadRsaResult"] as! [String: Any])
            self.uploadRsaResult = model
        }
    }
}

public class UploadMcubeRsaKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadMcubeRsaKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadMcubeRsaKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadUserAppToMsaRequest : Tea.TeaModel {
    public var appId: String?

    public var fileUrl: String?

    public var tenantId: String?

    public var workspaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fileUrl != nil {
            map["FileUrl"] = self.fileUrl!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.workspaceId != nil {
            map["WorkspaceId"] = self.workspaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
            self.fileUrl = dict["FileUrl"] as! String
        }
        if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
            self.tenantId = dict["TenantId"] as! String
        }
        if dict.keys.contains("WorkspaceId") && dict["WorkspaceId"] != nil {
            self.workspaceId = dict["WorkspaceId"] as! String
        }
    }
}

public class UploadUserAppToMsaResponseBody : Tea.TeaModel {
    public class ResultContent : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class ApkInfo : Tea.TeaModel {
                public class EnhanceMapping : Tea.TeaModel {
                    public var info: String?

                    public var reason: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.info != nil {
                            map["Info"] = self.info!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Info") && dict["Info"] != nil {
                            self.info = dict["Info"] as! String
                        }
                        if dict.keys.contains("Reason") && dict["Reason"] != nil {
                            self.reason = dict["Reason"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var afterMd5: String?

                public var afterSize: Int64?

                public var appCode: String?

                public var appPackage: String?

                public var beforeMd5: String?

                public var beforeSize: Int64?

                public var classForest: String?

                public var enhanceMapping: UploadUserAppToMsaResponseBody.ResultContent.Data.ApkInfo.EnhanceMapping?

                public var enhanceRules: [String]?

                public var enhancedClasses: [String]?

                public var id: Int64?

                public var label: String?

                public var progress: Int64?

                public var status: Int64?

                public var taskType: String?

                public var versionCode: String?

                public var versionName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.enhanceMapping?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.afterMd5 != nil {
                        map["AfterMd5"] = self.afterMd5!
                    }
                    if self.afterSize != nil {
                        map["AfterSize"] = self.afterSize!
                    }
                    if self.appCode != nil {
                        map["AppCode"] = self.appCode!
                    }
                    if self.appPackage != nil {
                        map["AppPackage"] = self.appPackage!
                    }
                    if self.beforeMd5 != nil {
                        map["BeforeMd5"] = self.beforeMd5!
                    }
                    if self.beforeSize != nil {
                        map["BeforeSize"] = self.beforeSize!
                    }
                    if self.classForest != nil {
                        map["ClassForest"] = self.classForest!
                    }
                    if self.enhanceMapping != nil {
                        map["EnhanceMapping"] = self.enhanceMapping?.toMap()
                    }
                    if self.enhanceRules != nil {
                        map["EnhanceRules"] = self.enhanceRules!
                    }
                    if self.enhancedClasses != nil {
                        map["EnhancedClasses"] = self.enhancedClasses!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.versionCode != nil {
                        map["VersionCode"] = self.versionCode!
                    }
                    if self.versionName != nil {
                        map["VersionName"] = self.versionName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AfterMd5") && dict["AfterMd5"] != nil {
                        self.afterMd5 = dict["AfterMd5"] as! String
                    }
                    if dict.keys.contains("AfterSize") && dict["AfterSize"] != nil {
                        self.afterSize = dict["AfterSize"] as! Int64
                    }
                    if dict.keys.contains("AppCode") && dict["AppCode"] != nil {
                        self.appCode = dict["AppCode"] as! String
                    }
                    if dict.keys.contains("AppPackage") && dict["AppPackage"] != nil {
                        self.appPackage = dict["AppPackage"] as! String
                    }
                    if dict.keys.contains("BeforeMd5") && dict["BeforeMd5"] != nil {
                        self.beforeMd5 = dict["BeforeMd5"] as! String
                    }
                    if dict.keys.contains("BeforeSize") && dict["BeforeSize"] != nil {
                        self.beforeSize = dict["BeforeSize"] as! Int64
                    }
                    if dict.keys.contains("ClassForest") && dict["ClassForest"] != nil {
                        self.classForest = dict["ClassForest"] as! String
                    }
                    if dict.keys.contains("EnhanceMapping") && dict["EnhanceMapping"] != nil {
                        var model = UploadUserAppToMsaResponseBody.ResultContent.Data.ApkInfo.EnhanceMapping()
                        model.fromMap(dict["EnhanceMapping"] as! [String: Any])
                        self.enhanceMapping = model
                    }
                    if dict.keys.contains("EnhanceRules") && dict["EnhanceRules"] != nil {
                        self.enhanceRules = dict["EnhanceRules"] as! [String]
                    }
                    if dict.keys.contains("EnhancedClasses") && dict["EnhancedClasses"] != nil {
                        self.enhancedClasses = dict["EnhancedClasses"] as! [String]
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Label") && dict["Label"] != nil {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Progress") && dict["Progress"] != nil {
                        self.progress = dict["Progress"] as! Int64
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int64
                    }
                    if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                        self.taskType = dict["TaskType"] as! String
                    }
                    if dict.keys.contains("VersionCode") && dict["VersionCode"] != nil {
                        self.versionCode = dict["VersionCode"] as! String
                    }
                    if dict.keys.contains("VersionName") && dict["VersionName"] != nil {
                        self.versionName = dict["VersionName"] as! String
                    }
                }
            }
            public var apkInfo: UploadUserAppToMsaResponseBody.ResultContent.Data.ApkInfo?

            public var enhanceTaskId: Int64?

            public var id: Int64?

            public var progress: Int64?

            public var status: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.apkInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apkInfo != nil {
                    map["ApkInfo"] = self.apkInfo?.toMap()
                }
                if self.enhanceTaskId != nil {
                    map["EnhanceTaskId"] = self.enhanceTaskId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApkInfo") && dict["ApkInfo"] != nil {
                    var model = UploadUserAppToMsaResponseBody.ResultContent.Data.ApkInfo()
                    model.fromMap(dict["ApkInfo"] as! [String: Any])
                    self.apkInfo = model
                }
                if dict.keys.contains("EnhanceTaskId") && dict["EnhanceTaskId"] != nil {
                    self.enhanceTaskId = dict["EnhanceTaskId"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Progress") && dict["Progress"] != nil {
                    self.progress = dict["Progress"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int64
                }
            }
        }
        public var code: String?

        public var data: UploadUserAppToMsaResponseBody.ResultContent.Data?

        public var extra: String?

        public var message: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") && dict["Data"] != nil {
                var model = UploadUserAppToMsaResponseBody.ResultContent.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("Extra") && dict["Extra"] != nil {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Success") && dict["Success"] != nil {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var resultCode: String?

    public var resultContent: UploadUserAppToMsaResponseBody.ResultContent?

    public var resultMessage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resultContent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultContent != nil {
            map["ResultContent"] = self.resultContent?.toMap()
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultContent") && dict["ResultContent"] != nil {
            var model = UploadUserAppToMsaResponseBody.ResultContent()
            model.fromMap(dict["ResultContent"] as! [String: Any])
            self.resultContent = model
        }
        if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
            self.resultMessage = dict["ResultMessage"] as! String
        }
    }
}

public class UploadUserAppToMsaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadUserAppToMsaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UploadUserAppToMsaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
