import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ProblemLevelGroupValue : Tea.TeaModel {
    public var childRuleRelation: Int32?

    public var matchCount: Int64?

    public var timeWindow: Int64?

    public var timeWindowUnit: String?

    public var enableUpgrade: Bool?

    public var upgradeTimeWindow: Int64?

    public var upgradeTimeWindowUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.childRuleRelation != nil {
            map["childRuleRelation"] = self.childRuleRelation!
        }
        if self.matchCount != nil {
            map["matchCount"] = self.matchCount!
        }
        if self.timeWindow != nil {
            map["timeWindow"] = self.timeWindow!
        }
        if self.timeWindowUnit != nil {
            map["timeWindowUnit"] = self.timeWindowUnit!
        }
        if self.enableUpgrade != nil {
            map["enableUpgrade"] = self.enableUpgrade!
        }
        if self.upgradeTimeWindow != nil {
            map["upgradeTimeWindow"] = self.upgradeTimeWindow!
        }
        if self.upgradeTimeWindowUnit != nil {
            map["upgradeTimeWindowUnit"] = self.upgradeTimeWindowUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("childRuleRelation") && dict["childRuleRelation"] != nil {
            self.childRuleRelation = dict["childRuleRelation"] as! Int32
        }
        if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
            self.matchCount = dict["matchCount"] as! Int64
        }
        if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
            self.timeWindow = dict["timeWindow"] as! Int64
        }
        if dict.keys.contains("timeWindowUnit") && dict["timeWindowUnit"] != nil {
            self.timeWindowUnit = dict["timeWindowUnit"] as! String
        }
        if dict.keys.contains("enableUpgrade") && dict["enableUpgrade"] != nil {
            self.enableUpgrade = dict["enableUpgrade"] as! Bool
        }
        if dict.keys.contains("upgradeTimeWindow") && dict["upgradeTimeWindow"] != nil {
            self.upgradeTimeWindow = dict["upgradeTimeWindow"] as! Int64
        }
        if dict.keys.contains("upgradeTimeWindowUnit") && dict["upgradeTimeWindowUnit"] != nil {
            self.upgradeTimeWindowUnit = dict["upgradeTimeWindowUnit"] as! String
        }
    }
}

public class DataProblemLevelGroupValue : Tea.TeaModel {
    public var childRuleRelation: Int32?

    public var matchCount: Int64?

    public var timeWindow: Int64?

    public var timeWindowUnit: String?

    public var enableUpgrade: Bool?

    public var upgradeTimeWindow: Int64?

    public var upgradeTimeWindowUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.childRuleRelation != nil {
            map["childRuleRelation"] = self.childRuleRelation!
        }
        if self.matchCount != nil {
            map["matchCount"] = self.matchCount!
        }
        if self.timeWindow != nil {
            map["timeWindow"] = self.timeWindow!
        }
        if self.timeWindowUnit != nil {
            map["timeWindowUnit"] = self.timeWindowUnit!
        }
        if self.enableUpgrade != nil {
            map["enableUpgrade"] = self.enableUpgrade!
        }
        if self.upgradeTimeWindow != nil {
            map["upgradeTimeWindow"] = self.upgradeTimeWindow!
        }
        if self.upgradeTimeWindowUnit != nil {
            map["upgradeTimeWindowUnit"] = self.upgradeTimeWindowUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("childRuleRelation") && dict["childRuleRelation"] != nil {
            self.childRuleRelation = dict["childRuleRelation"] as! Int32
        }
        if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
            self.matchCount = dict["matchCount"] as! Int64
        }
        if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
            self.timeWindow = dict["timeWindow"] as! Int64
        }
        if dict.keys.contains("timeWindowUnit") && dict["timeWindowUnit"] != nil {
            self.timeWindowUnit = dict["timeWindowUnit"] as! String
        }
        if dict.keys.contains("enableUpgrade") && dict["enableUpgrade"] != nil {
            self.enableUpgrade = dict["enableUpgrade"] as! Bool
        }
        if dict.keys.contains("upgradeTimeWindow") && dict["upgradeTimeWindow"] != nil {
            self.upgradeTimeWindow = dict["upgradeTimeWindow"] as! Int64
        }
        if dict.keys.contains("upgradeTimeWindowUnit") && dict["upgradeTimeWindowUnit"] != nil {
            self.upgradeTimeWindowUnit = dict["upgradeTimeWindowUnit"] as! String
        }
    }
}

public class DataValue : Tea.TeaModel {
    public var code: String?

    public var description_: String?

    public var configDescription: String?

    public var configCode: String?

    public var parentCode: String?

    public var configKey: String?

    public var configValue: String?

    public var requirement: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.configDescription != nil {
            map["configDescription"] = self.configDescription!
        }
        if self.configCode != nil {
            map["configCode"] = self.configCode!
        }
        if self.parentCode != nil {
            map["parentCode"] = self.parentCode!
        }
        if self.configKey != nil {
            map["configKey"] = self.configKey!
        }
        if self.configValue != nil {
            map["configValue"] = self.configValue!
        }
        if self.requirement != nil {
            map["requirement"] = self.requirement!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") && dict["code"] != nil {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("configDescription") && dict["configDescription"] != nil {
            self.configDescription = dict["configDescription"] as! String
        }
        if dict.keys.contains("configCode") && dict["configCode"] != nil {
            self.configCode = dict["configCode"] as! String
        }
        if dict.keys.contains("parentCode") && dict["parentCode"] != nil {
            self.parentCode = dict["parentCode"] as! String
        }
        if dict.keys.contains("configKey") && dict["configKey"] != nil {
            self.configKey = dict["configKey"] as! String
        }
        if dict.keys.contains("configValue") && dict["configValue"] != nil {
            self.configValue = dict["configValue"] as! String
        }
        if dict.keys.contains("requirement") && dict["requirement"] != nil {
            self.requirement = dict["requirement"] as! Bool
        }
    }
}

public class AddProblemServiceGroupRequest : Tea.TeaModel {
    public var problemId: Int64?

    public var serviceGroupIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.serviceGroupIds != nil {
            map["serviceGroupIds"] = self.serviceGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
            self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
        }
    }
}

public class AddProblemServiceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class AddProblemServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddProblemServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddProblemServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BillingStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appUserCount: Int64?

        public var appUserCountFree: Int64?

        public var emailSend: Int64?

        public var emailSendFree: Int64?

        public var escalationPlanCount: Int64?

        public var escalationPlanCountFree: Int64?

        public var eventReportApi: Int64?

        public var eventReportApiFree: Int64?

        public var hasScheduleServiceGroupCount: Int64?

        public var hasScheduleServiceGroupCountFree: Int64?

        public var imMsgSend: Int64?

        public var imMsgSendFree: Int64?

        public var ruleCount: Int64?

        public var ruleCountFree: Int64?

        public var smsSend: Int64?

        public var smsSendFree: Int64?

        public var subscriptionNotifyCount: Int64?

        public var subscriptionNotifyCountFree: Int64?

        public var type: Bool?

        public var voiceSend: Int64?

        public var voiceSendFree: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUserCount != nil {
                map["appUserCount"] = self.appUserCount!
            }
            if self.appUserCountFree != nil {
                map["appUserCountFree"] = self.appUserCountFree!
            }
            if self.emailSend != nil {
                map["emailSend"] = self.emailSend!
            }
            if self.emailSendFree != nil {
                map["emailSendFree"] = self.emailSendFree!
            }
            if self.escalationPlanCount != nil {
                map["escalationPlanCount"] = self.escalationPlanCount!
            }
            if self.escalationPlanCountFree != nil {
                map["escalationPlanCountFree"] = self.escalationPlanCountFree!
            }
            if self.eventReportApi != nil {
                map["eventReportApi"] = self.eventReportApi!
            }
            if self.eventReportApiFree != nil {
                map["eventReportApiFree"] = self.eventReportApiFree!
            }
            if self.hasScheduleServiceGroupCount != nil {
                map["hasScheduleServiceGroupCount"] = self.hasScheduleServiceGroupCount!
            }
            if self.hasScheduleServiceGroupCountFree != nil {
                map["hasScheduleServiceGroupCountFree"] = self.hasScheduleServiceGroupCountFree!
            }
            if self.imMsgSend != nil {
                map["imMsgSend"] = self.imMsgSend!
            }
            if self.imMsgSendFree != nil {
                map["imMsgSendFree"] = self.imMsgSendFree!
            }
            if self.ruleCount != nil {
                map["ruleCount"] = self.ruleCount!
            }
            if self.ruleCountFree != nil {
                map["ruleCountFree"] = self.ruleCountFree!
            }
            if self.smsSend != nil {
                map["smsSend"] = self.smsSend!
            }
            if self.smsSendFree != nil {
                map["smsSendFree"] = self.smsSendFree!
            }
            if self.subscriptionNotifyCount != nil {
                map["subscriptionNotifyCount"] = self.subscriptionNotifyCount!
            }
            if self.subscriptionNotifyCountFree != nil {
                map["subscriptionNotifyCountFree"] = self.subscriptionNotifyCountFree!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.voiceSend != nil {
                map["voiceSend"] = self.voiceSend!
            }
            if self.voiceSendFree != nil {
                map["voiceSendFree"] = self.voiceSendFree!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appUserCount") && dict["appUserCount"] != nil {
                self.appUserCount = dict["appUserCount"] as! Int64
            }
            if dict.keys.contains("appUserCountFree") && dict["appUserCountFree"] != nil {
                self.appUserCountFree = dict["appUserCountFree"] as! Int64
            }
            if dict.keys.contains("emailSend") && dict["emailSend"] != nil {
                self.emailSend = dict["emailSend"] as! Int64
            }
            if dict.keys.contains("emailSendFree") && dict["emailSendFree"] != nil {
                self.emailSendFree = dict["emailSendFree"] as! Int64
            }
            if dict.keys.contains("escalationPlanCount") && dict["escalationPlanCount"] != nil {
                self.escalationPlanCount = dict["escalationPlanCount"] as! Int64
            }
            if dict.keys.contains("escalationPlanCountFree") && dict["escalationPlanCountFree"] != nil {
                self.escalationPlanCountFree = dict["escalationPlanCountFree"] as! Int64
            }
            if dict.keys.contains("eventReportApi") && dict["eventReportApi"] != nil {
                self.eventReportApi = dict["eventReportApi"] as! Int64
            }
            if dict.keys.contains("eventReportApiFree") && dict["eventReportApiFree"] != nil {
                self.eventReportApiFree = dict["eventReportApiFree"] as! Int64
            }
            if dict.keys.contains("hasScheduleServiceGroupCount") && dict["hasScheduleServiceGroupCount"] != nil {
                self.hasScheduleServiceGroupCount = dict["hasScheduleServiceGroupCount"] as! Int64
            }
            if dict.keys.contains("hasScheduleServiceGroupCountFree") && dict["hasScheduleServiceGroupCountFree"] != nil {
                self.hasScheduleServiceGroupCountFree = dict["hasScheduleServiceGroupCountFree"] as! Int64
            }
            if dict.keys.contains("imMsgSend") && dict["imMsgSend"] != nil {
                self.imMsgSend = dict["imMsgSend"] as! Int64
            }
            if dict.keys.contains("imMsgSendFree") && dict["imMsgSendFree"] != nil {
                self.imMsgSendFree = dict["imMsgSendFree"] as! Int64
            }
            if dict.keys.contains("ruleCount") && dict["ruleCount"] != nil {
                self.ruleCount = dict["ruleCount"] as! Int64
            }
            if dict.keys.contains("ruleCountFree") && dict["ruleCountFree"] != nil {
                self.ruleCountFree = dict["ruleCountFree"] as! Int64
            }
            if dict.keys.contains("smsSend") && dict["smsSend"] != nil {
                self.smsSend = dict["smsSend"] as! Int64
            }
            if dict.keys.contains("smsSendFree") && dict["smsSendFree"] != nil {
                self.smsSendFree = dict["smsSendFree"] as! Int64
            }
            if dict.keys.contains("subscriptionNotifyCount") && dict["subscriptionNotifyCount"] != nil {
                self.subscriptionNotifyCount = dict["subscriptionNotifyCount"] as! Int64
            }
            if dict.keys.contains("subscriptionNotifyCountFree") && dict["subscriptionNotifyCountFree"] != nil {
                self.subscriptionNotifyCountFree = dict["subscriptionNotifyCountFree"] as! Int64
            }
            if dict.keys.contains("type") && dict["type"] != nil {
                self.type = dict["type"] as! Bool
            }
            if dict.keys.contains("voiceSend") && dict["voiceSend"] != nil {
                self.voiceSend = dict["voiceSend"] as! Int64
            }
            if dict.keys.contains("voiceSendFree") && dict["voiceSendFree"] != nil {
                self.voiceSendFree = dict["voiceSendFree"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var data: BillingStatisticsResponseBody.Data?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = BillingStatisticsResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
    }
}

public class BillingStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BillingStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BillingStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelProblemRequest : Tea.TeaModel {
    public var cancelReason: Int64?

    public var cancelReasonDescription: String?

    public var clientToken: String?

    public var problemId: Int64?

    public var problemNotifyType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cancelReason != nil {
            map["cancelReason"] = self.cancelReason!
        }
        if self.cancelReasonDescription != nil {
            map["cancelReasonDescription"] = self.cancelReasonDescription!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cancelReason") && dict["cancelReason"] != nil {
            self.cancelReason = dict["cancelReason"] as! Int64
        }
        if dict.keys.contains("cancelReasonDescription") && dict["cancelReasonDescription"] != nil {
            self.cancelReasonDescription = dict["cancelReasonDescription"] as! String
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! Int64
        }
    }
}

public class CancelProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CancelProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckWebhookRequest : Tea.TeaModel {
    public var clientToken: String?

    public var webhook: String?

    public var webhookType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.webhook != nil {
            map["webhook"] = self.webhook!
        }
        if self.webhookType != nil {
            map["webhookType"] = self.webhookType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("webhook") && dict["webhook"] != nil {
            self.webhook = dict["webhook"] as! String
        }
        if dict.keys.contains("webhookType") && dict["webhookType"] != nil {
            self.webhookType = dict["webhookType"] as! String
        }
    }
}

public class CheckWebhookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CheckWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class ConfirmIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ConfirmIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEscalationPlanRequest : Tea.TeaModel {
    public class EscalationPlanRules : Tea.TeaModel {
        public class EscalationPlanConditions : Tea.TeaModel {
            public var effection: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.effection != nil {
                    map["effection"] = self.effection!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("effection") && dict["effection"] != nil {
                    self.effection = dict["effection"] as! String
                }
                if dict.keys.contains("level") && dict["level"] != nil {
                    self.level = dict["level"] as! String
                }
            }
        }
        public class EscalationPlanStrategies : Tea.TeaModel {
            public var enableWebhook: Bool?

            public var escalationPlanType: String?

            public var noticeChannels: [String]?

            public var noticeObjects: [Int64]?

            public var noticeRoleList: [Int64]?

            public var noticeTime: String?

            public var serviceGroupIds: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableWebhook != nil {
                    map["enableWebhook"] = self.enableWebhook!
                }
                if self.escalationPlanType != nil {
                    map["escalationPlanType"] = self.escalationPlanType!
                }
                if self.noticeChannels != nil {
                    map["noticeChannels"] = self.noticeChannels!
                }
                if self.noticeObjects != nil {
                    map["noticeObjects"] = self.noticeObjects!
                }
                if self.noticeRoleList != nil {
                    map["noticeRoleList"] = self.noticeRoleList!
                }
                if self.noticeTime != nil {
                    map["noticeTime"] = self.noticeTime!
                }
                if self.serviceGroupIds != nil {
                    map["serviceGroupIds"] = self.serviceGroupIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
                    self.enableWebhook = dict["enableWebhook"] as! Bool
                }
                if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                    self.escalationPlanType = dict["escalationPlanType"] as! String
                }
                if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                    self.noticeChannels = dict["noticeChannels"] as! [String]
                }
                if dict.keys.contains("noticeObjects") && dict["noticeObjects"] != nil {
                    self.noticeObjects = dict["noticeObjects"] as! [Int64]
                }
                if dict.keys.contains("noticeRoleList") && dict["noticeRoleList"] != nil {
                    self.noticeRoleList = dict["noticeRoleList"] as! [Int64]
                }
                if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                    self.noticeTime = dict["noticeTime"] as! String
                }
                if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
                    self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
                }
            }
        }
        public var escalationPlanConditions: [CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions]?

        public var escalationPlanStrategies: [CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies]?

        public var escalationPlanType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanConditions != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanConditions! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanConditions"] = tmp
            }
            if self.escalationPlanStrategies != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanStrategies! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanStrategies"] = tmp
            }
            if self.escalationPlanType != nil {
                map["escalationPlanType"] = self.escalationPlanType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanConditions") && dict["escalationPlanConditions"] != nil {
                var tmp : [CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions] = []
                for v in dict["escalationPlanConditions"] as! [Any] {
                    var model = CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanConditions = tmp
            }
            if dict.keys.contains("escalationPlanStrategies") && dict["escalationPlanStrategies"] != nil {
                var tmp : [CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies] = []
                for v in dict["escalationPlanStrategies"] as! [Any] {
                    var model = CreateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanStrategies = tmp
            }
            if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                self.escalationPlanType = dict["escalationPlanType"] as! String
            }
        }
    }
    public class EscalationPlanScopeObjects : Tea.TeaModel {
        public var scope: String?

        public var scopeObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.scopeObjectId != nil {
                map["scopeObjectId"] = self.scopeObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("scope") && dict["scope"] != nil {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                self.scopeObjectId = dict["scopeObjectId"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var escalationPlanDescription: String?

    public var escalationPlanName: String?

    public var escalationPlanRules: [CreateEscalationPlanRequest.EscalationPlanRules]?

    public var escalationPlanScopeObjects: [CreateEscalationPlanRequest.EscalationPlanScopeObjects]?

    public var isGlobal: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanDescription != nil {
            map["escalationPlanDescription"] = self.escalationPlanDescription!
        }
        if self.escalationPlanName != nil {
            map["escalationPlanName"] = self.escalationPlanName!
        }
        if self.escalationPlanRules != nil {
            var tmp : [Any] = []
            for k in self.escalationPlanRules! {
                tmp.append(k.toMap())
            }
            map["escalationPlanRules"] = tmp
        }
        if self.escalationPlanScopeObjects != nil {
            var tmp : [Any] = []
            for k in self.escalationPlanScopeObjects! {
                tmp.append(k.toMap())
            }
            map["escalationPlanScopeObjects"] = tmp
        }
        if self.isGlobal != nil {
            map["isGlobal"] = self.isGlobal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanDescription") && dict["escalationPlanDescription"] != nil {
            self.escalationPlanDescription = dict["escalationPlanDescription"] as! String
        }
        if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
            self.escalationPlanName = dict["escalationPlanName"] as! String
        }
        if dict.keys.contains("escalationPlanRules") && dict["escalationPlanRules"] != nil {
            var tmp : [CreateEscalationPlanRequest.EscalationPlanRules] = []
            for v in dict["escalationPlanRules"] as! [Any] {
                var model = CreateEscalationPlanRequest.EscalationPlanRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.escalationPlanRules = tmp
        }
        if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
            var tmp : [CreateEscalationPlanRequest.EscalationPlanScopeObjects] = []
            for v in dict["escalationPlanScopeObjects"] as! [Any] {
                var model = CreateEscalationPlanRequest.EscalationPlanScopeObjects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.escalationPlanScopeObjects = tmp
        }
        if dict.keys.contains("isGlobal") && dict["isGlobal"] != nil {
            self.isGlobal = dict["isGlobal"] as! Bool
        }
    }
}

public class CreateEscalationPlanResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var escalationPlanId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
        }
    }
    public var data: CreateEscalationPlanResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateEscalationPlanResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIncidentRequest : Tea.TeaModel {
    public var assignUserId: Int64?

    public var channels: [String]?

    public var clientToken: String?

    public var effect: String?

    public var incidentDescription: String?

    public var incidentLevel: String?

    public var incidentTitle: String?

    public var relatedServiceId: Int64?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignUserId != nil {
            map["assignUserId"] = self.assignUserId!
        }
        if self.channels != nil {
            map["channels"] = self.channels!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.effect != nil {
            map["effect"] = self.effect!
        }
        if self.incidentDescription != nil {
            map["incidentDescription"] = self.incidentDescription!
        }
        if self.incidentLevel != nil {
            map["incidentLevel"] = self.incidentLevel!
        }
        if self.incidentTitle != nil {
            map["incidentTitle"] = self.incidentTitle!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
            self.assignUserId = dict["assignUserId"] as! Int64
        }
        if dict.keys.contains("channels") && dict["channels"] != nil {
            self.channels = dict["channels"] as! [String]
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("effect") && dict["effect"] != nil {
            self.effect = dict["effect"] as! String
        }
        if dict.keys.contains("incidentDescription") && dict["incidentDescription"] != nil {
            self.incidentDescription = dict["incidentDescription"] as! String
        }
        if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
            self.incidentLevel = dict["incidentLevel"] as! String
        }
        if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
            self.incidentTitle = dict["incidentTitle"] as! String
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class CreateIncidentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var incidentId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
        }
    }
    public var data: CreateIncidentResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateIncidentResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIncidentSubtotalRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class CreateIncidentSubtotalResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var subtotalId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subtotalId != nil {
                map["subtotalId"] = self.subtotalId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("subtotalId") && dict["subtotalId"] != nil {
                self.subtotalId = dict["subtotalId"] as! Int64
            }
        }
    }
    public var data: CreateIncidentSubtotalResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateIncidentSubtotalResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateIncidentSubtotalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIncidentSubtotalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIncidentSubtotalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var monitorSourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.monitorSourceId != nil {
            map["monitorSourceId"] = self.monitorSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
            self.monitorSourceId = dict["monitorSourceId"] as! Int64
        }
    }
}

public class CreateIntegrationConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var integrationConfigId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.integrationConfigId != nil {
                map["integrationConfigId"] = self.integrationConfigId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
                self.integrationConfigId = dict["integrationConfigId"] as! Int64
            }
        }
    }
    public var data: CreateIntegrationConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateIntegrationConfigResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemRequest : Tea.TeaModel {
    public var affectServiceIds: [Int64]?

    public var clientToken: String?

    public var discoverTime: String?

    public var incidentId: Int64?

    public var mainHandlerId: Int64?

    public var preliminaryReason: String?

    public var problemLevel: String?

    public var problemName: String?

    public var problemNotifyType: String?

    public var problemStatus: String?

    public var progressSummary: String?

    public var progressSummaryRichTextId: Int64?

    public var recoveryTime: String?

    public var relatedServiceId: Int64?

    public var serviceGroupIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectServiceIds != nil {
            map["affectServiceIds"] = self.affectServiceIds!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.discoverTime != nil {
            map["discoverTime"] = self.discoverTime!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        if self.mainHandlerId != nil {
            map["mainHandlerId"] = self.mainHandlerId!
        }
        if self.preliminaryReason != nil {
            map["preliminaryReason"] = self.preliminaryReason!
        }
        if self.problemLevel != nil {
            map["problemLevel"] = self.problemLevel!
        }
        if self.problemName != nil {
            map["problemName"] = self.problemName!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        if self.problemStatus != nil {
            map["problemStatus"] = self.problemStatus!
        }
        if self.progressSummary != nil {
            map["progressSummary"] = self.progressSummary!
        }
        if self.progressSummaryRichTextId != nil {
            map["progressSummaryRichTextId"] = self.progressSummaryRichTextId!
        }
        if self.recoveryTime != nil {
            map["recoveryTime"] = self.recoveryTime!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.serviceGroupIds != nil {
            map["serviceGroupIds"] = self.serviceGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("affectServiceIds") && dict["affectServiceIds"] != nil {
            self.affectServiceIds = dict["affectServiceIds"] as! [Int64]
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("discoverTime") && dict["discoverTime"] != nil {
            self.discoverTime = dict["discoverTime"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
        if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
            self.mainHandlerId = dict["mainHandlerId"] as! Int64
        }
        if dict.keys.contains("preliminaryReason") && dict["preliminaryReason"] != nil {
            self.preliminaryReason = dict["preliminaryReason"] as! String
        }
        if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
            self.problemLevel = dict["problemLevel"] as! String
        }
        if dict.keys.contains("problemName") && dict["problemName"] != nil {
            self.problemName = dict["problemName"] as! String
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! String
        }
        if dict.keys.contains("problemStatus") && dict["problemStatus"] != nil {
            self.problemStatus = dict["problemStatus"] as! String
        }
        if dict.keys.contains("progressSummary") && dict["progressSummary"] != nil {
            self.progressSummary = dict["progressSummary"] as! String
        }
        if dict.keys.contains("progressSummaryRichTextId") && dict["progressSummaryRichTextId"] != nil {
            self.progressSummaryRichTextId = dict["progressSummaryRichTextId"] as! Int64
        }
        if dict.keys.contains("recoveryTime") && dict["recoveryTime"] != nil {
            self.recoveryTime = dict["recoveryTime"] as! String
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
            self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
        }
    }
}

public class CreateProblemResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var problemId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
        }
    }
    public var data: CreateProblemResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemEffectionServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var level: String?

    public var pictureUrl: [String]?

    public var problemId: Int64?

    public var serviceId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.level != nil {
            map["level"] = self.level!
        }
        if self.pictureUrl != nil {
            map["pictureUrl"] = self.pictureUrl!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("level") && dict["level"] != nil {
            self.level = dict["level"] as! String
        }
        if dict.keys.contains("pictureUrl") && dict["pictureUrl"] != nil {
            self.pictureUrl = dict["pictureUrl"] as! [String]
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
    }
}

public class CreateProblemEffectionServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var effectionServiceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectionServiceId != nil {
                map["effectionServiceId"] = self.effectionServiceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
                self.effectionServiceId = dict["effectionServiceId"] as! Int64
            }
        }
    }
    public var data: CreateProblemEffectionServiceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemEffectionServiceResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemEffectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemEffectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemEffectionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemMeasureRequest : Tea.TeaModel {
    public var checkStandard: String?

    public var checkUserId: Int64?

    public var clientToken: String?

    public var content: String?

    public var directorId: Int64?

    public var planFinishTime: String?

    public var problemId: Int64?

    public var stalkerId: Int64?

    public var status: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkStandard != nil {
            map["checkStandard"] = self.checkStandard!
        }
        if self.checkUserId != nil {
            map["checkUserId"] = self.checkUserId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.directorId != nil {
            map["directorId"] = self.directorId!
        }
        if self.planFinishTime != nil {
            map["planFinishTime"] = self.planFinishTime!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.stalkerId != nil {
            map["stalkerId"] = self.stalkerId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("checkStandard") && dict["checkStandard"] != nil {
            self.checkStandard = dict["checkStandard"] as! String
        }
        if dict.keys.contains("checkUserId") && dict["checkUserId"] != nil {
            self.checkUserId = dict["checkUserId"] as! Int64
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("content") && dict["content"] != nil {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("directorId") && dict["directorId"] != nil {
            self.directorId = dict["directorId"] as! Int64
        }
        if dict.keys.contains("planFinishTime") && dict["planFinishTime"] != nil {
            self.planFinishTime = dict["planFinishTime"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("stalkerId") && dict["stalkerId"] != nil {
            self.stalkerId = dict["stalkerId"] as! Int64
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! Int32
        }
    }
}

public class CreateProblemMeasureResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var measureId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.measureId != nil {
                map["measureId"] = self.measureId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("measureId") && dict["measureId"] != nil {
                self.measureId = dict["measureId"] as! Int64
            }
        }
    }
    public var data: CreateProblemMeasureResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemMeasureResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemMeasureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemMeasureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemMeasureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemSubtotalRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class CreateProblemSubtotalResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var subtotalId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subtotalId != nil {
                map["subtotalId"] = self.subtotalId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("subtotalId") && dict["subtotalId"] != nil {
                self.subtotalId = dict["subtotalId"] as! Int64
            }
        }
    }
    public var data: CreateProblemSubtotalResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemSubtotalResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemSubtotalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemSubtotalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemSubtotalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemTimelineRequest : Tea.TeaModel {
    public var clientToken: String?

    public var content: String?

    public var keyNode: String?

    public var problemId: Int64?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.keyNode != nil {
            map["keyNode"] = self.keyNode!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.time != nil {
            map["time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("content") && dict["content"] != nil {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("keyNode") && dict["keyNode"] != nil {
            self.keyNode = dict["keyNode"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("time") && dict["time"] != nil {
            self.time = dict["time"] as! String
        }
    }
}

public class CreateProblemTimelineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var problemTimelineId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.problemTimelineId != nil {
                map["problemTimelineId"] = self.problemTimelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("problemTimelineId") && dict["problemTimelineId"] != nil {
                self.problemTimelineId = dict["problemTimelineId"] as! Int64
            }
        }
    }
    public var data: CreateProblemTimelineResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemTimelineResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProblemTimelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public var timelineNodes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.timelineNodes != nil {
            map["timelineNodes"] = self.timelineNodes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("timelineNodes") && dict["timelineNodes"] != nil {
            self.timelineNodes = dict["timelineNodes"] as! String
        }
    }
}

public class CreateProblemTimelinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var problemTimelineIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.problemTimelineIds != nil {
                map["problemTimelineIds"] = self.problemTimelineIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("problemTimelineIds") && dict["problemTimelineIds"] != nil {
                self.problemTimelineIds = dict["problemTimelineIds"] as! [Int64]
            }
        }
    }
    public var data: CreateProblemTimelinesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateProblemTimelinesResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateProblemTimelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProblemTimelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateProblemTimelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRichTextRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var instanceType: String?

    public var richText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.richText != nil {
            map["richText"] = self.richText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("richText") && dict["richText"] != nil {
            self.richText = dict["richText"] as! String
        }
    }
}

public class CreateRichTextResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceType: Int64?

        public var richText: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["instanceType"] = self.instanceType!
            }
            if self.richText != nil {
                map["richText"] = self.richText!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
                self.instanceId = dict["instanceId"] as! Int64
            }
            if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                self.instanceType = dict["instanceType"] as! Int64
            }
            if dict.keys.contains("richText") && dict["richText"] != nil {
                self.richText = dict["richText"] as! String
            }
        }
    }
    public var data: CreateRichTextResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateRichTextResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateRichTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRichTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateRichTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteRuleRequest : Tea.TeaModel {
    public class RouteChildRules : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var key: String?

            public var operationSymbol: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.operationSymbol != nil {
                    map["operationSymbol"] = self.operationSymbol!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") && dict["key"] != nil {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("operationSymbol") && dict["operationSymbol"] != nil {
                    self.operationSymbol = dict["operationSymbol"] as! String
                }
                if dict.keys.contains("value") && dict["value"] != nil {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var childConditionRelation: Int64?

        public var conditions: [CreateRouteRuleRequest.RouteChildRules.Conditions]?

        public var monitorSourceId: Int64?

        public var problemLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.childConditionRelation != nil {
                map["childConditionRelation"] = self.childConditionRelation!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["conditions"] = tmp
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.problemLevel != nil {
                map["problemLevel"] = self.problemLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("childConditionRelation") && dict["childConditionRelation"] != nil {
                self.childConditionRelation = dict["childConditionRelation"] as! Int64
            }
            if dict.keys.contains("conditions") && dict["conditions"] != nil {
                var tmp : [CreateRouteRuleRequest.RouteChildRules.Conditions] = []
                for v in dict["conditions"] as! [Any] {
                    var model = CreateRouteRuleRequest.RouteChildRules.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                self.problemLevel = dict["problemLevel"] as! String
            }
        }
    }
    public var assignObjectId: Int64?

    public var assignObjectType: String?

    public var childRuleRelation: String?

    public var clientToken: String?

    public var convergenceFields: [String]?

    public var convergenceType: Int32?

    public var coverageProblemLevels: [String]?

    public var effection: String?

    public var enableStatus: String?

    public var incidentLevel: String?

    public var matchCount: Int32?

    public var notifyChannels: [String]?

    public var problemEffectionServices: [Int64]?

    public var problemLevelGroup: [String: ProblemLevelGroupValue]?

    public var relatedServiceId: Int64?

    public var routeChildRules: [CreateRouteRuleRequest.RouteChildRules]?

    public var routeType: String?

    public var ruleName: String?

    public var timeWindow: Int64?

    public var timeWindowUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignObjectId != nil {
            map["assignObjectId"] = self.assignObjectId!
        }
        if self.assignObjectType != nil {
            map["assignObjectType"] = self.assignObjectType!
        }
        if self.childRuleRelation != nil {
            map["childRuleRelation"] = self.childRuleRelation!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.convergenceFields != nil {
            map["convergenceFields"] = self.convergenceFields!
        }
        if self.convergenceType != nil {
            map["convergenceType"] = self.convergenceType!
        }
        if self.coverageProblemLevels != nil {
            map["coverageProblemLevels"] = self.coverageProblemLevels!
        }
        if self.effection != nil {
            map["effection"] = self.effection!
        }
        if self.enableStatus != nil {
            map["enableStatus"] = self.enableStatus!
        }
        if self.incidentLevel != nil {
            map["incidentLevel"] = self.incidentLevel!
        }
        if self.matchCount != nil {
            map["matchCount"] = self.matchCount!
        }
        if self.notifyChannels != nil {
            map["notifyChannels"] = self.notifyChannels!
        }
        if self.problemEffectionServices != nil {
            map["problemEffectionServices"] = self.problemEffectionServices!
        }
        if self.problemLevelGroup != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.problemLevelGroup! {
                tmp[k] = v.toMap()
            }
            map["problemLevelGroup"] = tmp
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.routeChildRules != nil {
            var tmp : [Any] = []
            for k in self.routeChildRules! {
                tmp.append(k.toMap())
            }
            map["routeChildRules"] = tmp
        }
        if self.routeType != nil {
            map["routeType"] = self.routeType!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.timeWindow != nil {
            map["timeWindow"] = self.timeWindow!
        }
        if self.timeWindowUnit != nil {
            map["timeWindowUnit"] = self.timeWindowUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignObjectId") && dict["assignObjectId"] != nil {
            self.assignObjectId = dict["assignObjectId"] as! Int64
        }
        if dict.keys.contains("assignObjectType") && dict["assignObjectType"] != nil {
            self.assignObjectType = dict["assignObjectType"] as! String
        }
        if dict.keys.contains("childRuleRelation") && dict["childRuleRelation"] != nil {
            self.childRuleRelation = dict["childRuleRelation"] as! String
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("convergenceFields") && dict["convergenceFields"] != nil {
            self.convergenceFields = dict["convergenceFields"] as! [String]
        }
        if dict.keys.contains("convergenceType") && dict["convergenceType"] != nil {
            self.convergenceType = dict["convergenceType"] as! Int32
        }
        if dict.keys.contains("coverageProblemLevels") && dict["coverageProblemLevels"] != nil {
            self.coverageProblemLevels = dict["coverageProblemLevels"] as! [String]
        }
        if dict.keys.contains("effection") && dict["effection"] != nil {
            self.effection = dict["effection"] as! String
        }
        if dict.keys.contains("enableStatus") && dict["enableStatus"] != nil {
            self.enableStatus = dict["enableStatus"] as! String
        }
        if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
            self.incidentLevel = dict["incidentLevel"] as! String
        }
        if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
            self.matchCount = dict["matchCount"] as! Int32
        }
        if dict.keys.contains("notifyChannels") && dict["notifyChannels"] != nil {
            self.notifyChannels = dict["notifyChannels"] as! [String]
        }
        if dict.keys.contains("problemEffectionServices") && dict["problemEffectionServices"] != nil {
            self.problemEffectionServices = dict["problemEffectionServices"] as! [Int64]
        }
        if dict.keys.contains("problemLevelGroup") && dict["problemLevelGroup"] != nil {
            var tmp : [String: ProblemLevelGroupValue] = [:]
            for (k, v) in dict["problemLevelGroup"] as! [String: Any] {
                if v != nil {
                    var model = ProblemLevelGroupValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.problemLevelGroup = tmp
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("routeChildRules") && dict["routeChildRules"] != nil {
            var tmp : [CreateRouteRuleRequest.RouteChildRules] = []
            for v in dict["routeChildRules"] as! [Any] {
                var model = CreateRouteRuleRequest.RouteChildRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeChildRules = tmp
        }
        if dict.keys.contains("routeType") && dict["routeType"] != nil {
            self.routeType = dict["routeType"] as! String
        }
        if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
            self.timeWindow = dict["timeWindow"] as! Int64
        }
        if dict.keys.contains("timeWindowUnit") && dict["timeWindowUnit"] != nil {
            self.timeWindowUnit = dict["timeWindowUnit"] as! String
        }
    }
}

public class CreateRouteRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var routeRuleId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
        }
    }
    public var data: CreateRouteRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateRouteRuleResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public var serviceDescription: String?

    public var serviceGroupIdList: [Int64]?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        if self.serviceDescription != nil {
            map["serviceDescription"] = self.serviceDescription!
        }
        if self.serviceGroupIdList != nil {
            map["serviceGroupIdList"] = self.serviceGroupIdList!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
        if dict.keys.contains("serviceDescription") && dict["serviceDescription"] != nil {
            self.serviceDescription = dict["serviceDescription"] as! String
        }
        if dict.keys.contains("serviceGroupIdList") && dict["serviceGroupIdList"] != nil {
            self.serviceGroupIdList = dict["serviceGroupIdList"] as! [Int64]
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
    }
}

public class CreateServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var serviceId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                self.serviceId = dict["serviceId"] as! Int64
            }
        }
    }
    public var data: CreateServiceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateServiceResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceGroupRequest : Tea.TeaModel {
    public class MonitorSourceTemplates : Tea.TeaModel {
        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var templateContent: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.templateContent != nil {
                map["templateContent"] = self.templateContent!
            }
            if self.templateId != nil {
                map["templateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("templateContent") && dict["templateContent"] != nil {
                self.templateContent = dict["templateContent"] as! String
            }
            if dict.keys.contains("templateId") && dict["templateId"] != nil {
                self.templateId = dict["templateId"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var enableWebhook: String?

    public var monitorSourceTemplates: [CreateServiceGroupRequest.MonitorSourceTemplates]?

    public var serviceGroupDescription: String?

    public var serviceGroupName: String?

    public var userIds: [Int64]?

    public var webhookLink: String?

    public var webhookType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.enableWebhook != nil {
            map["enableWebhook"] = self.enableWebhook!
        }
        if self.monitorSourceTemplates != nil {
            var tmp : [Any] = []
            for k in self.monitorSourceTemplates! {
                tmp.append(k.toMap())
            }
            map["monitorSourceTemplates"] = tmp
        }
        if self.serviceGroupDescription != nil {
            map["serviceGroupDescription"] = self.serviceGroupDescription!
        }
        if self.serviceGroupName != nil {
            map["serviceGroupName"] = self.serviceGroupName!
        }
        if self.userIds != nil {
            map["userIds"] = self.userIds!
        }
        if self.webhookLink != nil {
            map["webhookLink"] = self.webhookLink!
        }
        if self.webhookType != nil {
            map["webhookType"] = self.webhookType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
            self.enableWebhook = dict["enableWebhook"] as! String
        }
        if dict.keys.contains("monitorSourceTemplates") && dict["monitorSourceTemplates"] != nil {
            var tmp : [CreateServiceGroupRequest.MonitorSourceTemplates] = []
            for v in dict["monitorSourceTemplates"] as! [Any] {
                var model = CreateServiceGroupRequest.MonitorSourceTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitorSourceTemplates = tmp
        }
        if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
            self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
        }
        if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
            self.serviceGroupName = dict["serviceGroupName"] as! String
        }
        if dict.keys.contains("userIds") && dict["userIds"] != nil {
            self.userIds = dict["userIds"] as! [Int64]
        }
        if dict.keys.contains("webhookLink") && dict["webhookLink"] != nil {
            self.webhookLink = dict["webhookLink"] as! String
        }
        if dict.keys.contains("webhookType") && dict["webhookType"] != nil {
            self.webhookType = dict["webhookType"] as! String
        }
    }
}

public class CreateServiceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var serviceGroupId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
        }
    }
    public var data: CreateServiceGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateServiceGroupResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceGroupSchedulingRequest : Tea.TeaModel {
    public class FastScheduling : Tea.TeaModel {
        public class SchedulingUsers : Tea.TeaModel {
            public var schedulingObjectType: String?

            public var schedulingOrder: Int64?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int64
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
            }
        }
        public var dutyPlan: String?

        public var schedulingUsers: [CreateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers]?

        public var singleDuration: Int32?

        public var singleDurationUnit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dutyPlan != nil {
                map["dutyPlan"] = self.dutyPlan!
            }
            if self.schedulingUsers != nil {
                var tmp : [Any] = []
                for k in self.schedulingUsers! {
                    tmp.append(k.toMap())
                }
                map["schedulingUsers"] = tmp
            }
            if self.singleDuration != nil {
                map["singleDuration"] = self.singleDuration!
            }
            if self.singleDurationUnit != nil {
                map["singleDurationUnit"] = self.singleDurationUnit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dutyPlan") && dict["dutyPlan"] != nil {
                self.dutyPlan = dict["dutyPlan"] as! String
            }
            if dict.keys.contains("schedulingUsers") && dict["schedulingUsers"] != nil {
                var tmp : [CreateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers] = []
                for v in dict["schedulingUsers"] as! [Any] {
                    var model = CreateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingUsers = tmp
            }
            if dict.keys.contains("singleDuration") && dict["singleDuration"] != nil {
                self.singleDuration = dict["singleDuration"] as! Int32
            }
            if dict.keys.contains("singleDurationUnit") && dict["singleDurationUnit"] != nil {
                self.singleDurationUnit = dict["singleDurationUnit"] as! String
            }
        }
    }
    public class FineScheduling : Tea.TeaModel {
        public class SchedulingFineShifts : Tea.TeaModel {
            public var cycleOrder: Int32?

            public var schedulingEndTime: String?

            public var schedulingObjectType: String?

            public var schedulingOrder: Int32?

            public var schedulingStartTime: String?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public var shiftName: String?

            public var skipOneDay: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleOrder != nil {
                    map["cycleOrder"] = self.cycleOrder!
                }
                if self.schedulingEndTime != nil {
                    map["schedulingEndTime"] = self.schedulingEndTime!
                }
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingStartTime != nil {
                    map["schedulingStartTime"] = self.schedulingStartTime!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                if self.shiftName != nil {
                    map["shiftName"] = self.shiftName!
                }
                if self.skipOneDay != nil {
                    map["skipOneDay"] = self.skipOneDay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cycleOrder") && dict["cycleOrder"] != nil {
                    self.cycleOrder = dict["cycleOrder"] as! Int32
                }
                if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                    self.schedulingEndTime = dict["schedulingEndTime"] as! String
                }
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int32
                }
                if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                    self.schedulingStartTime = dict["schedulingStartTime"] as! String
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
                if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                    self.shiftName = dict["shiftName"] as! String
                }
                if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                    self.skipOneDay = dict["skipOneDay"] as! Bool
                }
            }
        }
        public class SchedulingTemplateFineShifts : Tea.TeaModel {
            public var schedulingEndTime: String?

            public var schedulingObjectType: String?

            public var schedulingOrder: Int64?

            public var schedulingStartTime: String?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public var schedulingUserName: String?

            public var skipOneDay: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingEndTime != nil {
                    map["schedulingEndTime"] = self.schedulingEndTime!
                }
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingStartTime != nil {
                    map["schedulingStartTime"] = self.schedulingStartTime!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                if self.schedulingUserName != nil {
                    map["schedulingUserName"] = self.schedulingUserName!
                }
                if self.skipOneDay != nil {
                    map["skipOneDay"] = self.skipOneDay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                    self.schedulingEndTime = dict["schedulingEndTime"] as! String
                }
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int64
                }
                if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                    self.schedulingStartTime = dict["schedulingStartTime"] as! String
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
                if dict.keys.contains("schedulingUserName") && dict["schedulingUserName"] != nil {
                    self.schedulingUserName = dict["schedulingUserName"] as! String
                }
                if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                    self.skipOneDay = dict["skipOneDay"] as! Bool
                }
            }
        }
        public var period: Int32?

        public var periodUnit: String?

        public var schedulingFineShifts: [CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts]?

        public var schedulingTemplateFineShifts: [CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts]?

        public var shiftType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.period != nil {
                map["period"] = self.period!
            }
            if self.periodUnit != nil {
                map["periodUnit"] = self.periodUnit!
            }
            if self.schedulingFineShifts != nil {
                var tmp : [Any] = []
                for k in self.schedulingFineShifts! {
                    tmp.append(k.toMap())
                }
                map["schedulingFineShifts"] = tmp
            }
            if self.schedulingTemplateFineShifts != nil {
                var tmp : [Any] = []
                for k in self.schedulingTemplateFineShifts! {
                    tmp.append(k.toMap())
                }
                map["schedulingTemplateFineShifts"] = tmp
            }
            if self.shiftType != nil {
                map["shiftType"] = self.shiftType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("period") && dict["period"] != nil {
                self.period = dict["period"] as! Int32
            }
            if dict.keys.contains("periodUnit") && dict["periodUnit"] != nil {
                self.periodUnit = dict["periodUnit"] as! String
            }
            if dict.keys.contains("schedulingFineShifts") && dict["schedulingFineShifts"] != nil {
                var tmp : [CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts] = []
                for v in dict["schedulingFineShifts"] as! [Any] {
                    var model = CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingFineShifts = tmp
            }
            if dict.keys.contains("schedulingTemplateFineShifts") && dict["schedulingTemplateFineShifts"] != nil {
                var tmp : [CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts] = []
                for v in dict["schedulingTemplateFineShifts"] as! [Any] {
                    var model = CreateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingTemplateFineShifts = tmp
            }
            if dict.keys.contains("shiftType") && dict["shiftType"] != nil {
                self.shiftType = dict["shiftType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var fastScheduling: CreateServiceGroupSchedulingRequest.FastScheduling?

    public var fineScheduling: CreateServiceGroupSchedulingRequest.FineScheduling?

    public var schedulingWay: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fastScheduling?.validate()
        try self.fineScheduling?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.fastScheduling != nil {
            map["fastScheduling"] = self.fastScheduling?.toMap()
        }
        if self.fineScheduling != nil {
            map["fineScheduling"] = self.fineScheduling?.toMap()
        }
        if self.schedulingWay != nil {
            map["schedulingWay"] = self.schedulingWay!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("fastScheduling") && dict["fastScheduling"] != nil {
            var model = CreateServiceGroupSchedulingRequest.FastScheduling()
            model.fromMap(dict["fastScheduling"] as! [String: Any])
            self.fastScheduling = model
        }
        if dict.keys.contains("fineScheduling") && dict["fineScheduling"] != nil {
            var model = CreateServiceGroupSchedulingRequest.FineScheduling()
            model.fromMap(dict["fineScheduling"] as! [String: Any])
            self.fineScheduling = model
        }
        if dict.keys.contains("schedulingWay") && dict["schedulingWay"] != nil {
            self.schedulingWay = dict["schedulingWay"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class CreateServiceGroupSchedulingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateServiceGroupSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceGroupSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateServiceGroupSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSubscriptionRequest : Tea.TeaModel {
    public class NotifyObjectList : Tea.TeaModel {
        public var notifyObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notifyObjectId != nil {
                map["notifyObjectId"] = self.notifyObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("notifyObjectId") && dict["notifyObjectId"] != nil {
                self.notifyObjectId = dict["notifyObjectId"] as! Int64
            }
        }
    }
    public class NotifyStrategyList : Tea.TeaModel {
        public class PeriodChannel : Tea.TeaModel {
            public var nonWorkday: String?

            public var workday: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nonWorkday != nil {
                    map["nonWorkday"] = self.nonWorkday!
                }
                if self.workday != nil {
                    map["workday"] = self.workday!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("nonWorkday") && dict["nonWorkday"] != nil {
                    self.nonWorkday = dict["nonWorkday"] as! String
                }
                if dict.keys.contains("workday") && dict["workday"] != nil {
                    self.workday = dict["workday"] as! String
                }
            }
        }
        public class Strategies : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var action: String?

                public var effection: String?

                public var level: String?

                public var problemNotifyType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["action"] = self.action!
                    }
                    if self.effection != nil {
                        map["effection"] = self.effection!
                    }
                    if self.level != nil {
                        map["level"] = self.level!
                    }
                    if self.problemNotifyType != nil {
                        map["problemNotifyType"] = self.problemNotifyType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("action") && dict["action"] != nil {
                        self.action = dict["action"] as! String
                    }
                    if dict.keys.contains("effection") && dict["effection"] != nil {
                        self.effection = dict["effection"] as! String
                    }
                    if dict.keys.contains("level") && dict["level"] != nil {
                        self.level = dict["level"] as! String
                    }
                    if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
                        self.problemNotifyType = dict["problemNotifyType"] as! String
                    }
                }
            }
            public var conditions: [CreateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["conditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("conditions") && dict["conditions"] != nil {
                    var tmp : [CreateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions] = []
                    for v in dict["conditions"] as! [Any] {
                        var model = CreateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
            }
        }
        public var channels: String?

        public var instanceType: Int64?

        public var periodChannel: CreateSubscriptionRequest.NotifyStrategyList.PeriodChannel?

        public var strategies: [CreateSubscriptionRequest.NotifyStrategyList.Strategies]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.periodChannel?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["channels"] = self.channels!
            }
            if self.instanceType != nil {
                map["instanceType"] = self.instanceType!
            }
            if self.periodChannel != nil {
                map["periodChannel"] = self.periodChannel?.toMap()
            }
            if self.strategies != nil {
                var tmp : [Any] = []
                for k in self.strategies! {
                    tmp.append(k.toMap())
                }
                map["strategies"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("channels") && dict["channels"] != nil {
                self.channels = dict["channels"] as! String
            }
            if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                self.instanceType = dict["instanceType"] as! Int64
            }
            if dict.keys.contains("periodChannel") && dict["periodChannel"] != nil {
                var model = CreateSubscriptionRequest.NotifyStrategyList.PeriodChannel()
                model.fromMap(dict["periodChannel"] as! [String: Any])
                self.periodChannel = model
            }
            if dict.keys.contains("strategies") && dict["strategies"] != nil {
                var tmp : [CreateSubscriptionRequest.NotifyStrategyList.Strategies] = []
                for v in dict["strategies"] as! [Any] {
                    var model = CreateSubscriptionRequest.NotifyStrategyList.Strategies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.strategies = tmp
            }
        }
    }
    public class ScopeObjectList : Tea.TeaModel {
        public var scopeObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scopeObjectId != nil {
                map["scopeObjectId"] = self.scopeObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                self.scopeObjectId = dict["scopeObjectId"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var endTime: String?

    public var expiredType: Int64?

    public var notifyObjectList: [CreateSubscriptionRequest.NotifyObjectList]?

    public var notifyObjectType: Int64?

    public var notifyStrategyList: [CreateSubscriptionRequest.NotifyStrategyList]?

    public var period: String?

    public var scope: Int64?

    public var scopeObjectList: [CreateSubscriptionRequest.ScopeObjectList]?

    public var startTime: String?

    public var subscriptionTitle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.expiredType != nil {
            map["expiredType"] = self.expiredType!
        }
        if self.notifyObjectList != nil {
            var tmp : [Any] = []
            for k in self.notifyObjectList! {
                tmp.append(k.toMap())
            }
            map["notifyObjectList"] = tmp
        }
        if self.notifyObjectType != nil {
            map["notifyObjectType"] = self.notifyObjectType!
        }
        if self.notifyStrategyList != nil {
            var tmp : [Any] = []
            for k in self.notifyStrategyList! {
                tmp.append(k.toMap())
            }
            map["notifyStrategyList"] = tmp
        }
        if self.period != nil {
            map["period"] = self.period!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.scopeObjectList != nil {
            var tmp : [Any] = []
            for k in self.scopeObjectList! {
                tmp.append(k.toMap())
            }
            map["scopeObjectList"] = tmp
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscriptionTitle != nil {
            map["subscriptionTitle"] = self.subscriptionTitle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("expiredType") && dict["expiredType"] != nil {
            self.expiredType = dict["expiredType"] as! Int64
        }
        if dict.keys.contains("notifyObjectList") && dict["notifyObjectList"] != nil {
            var tmp : [CreateSubscriptionRequest.NotifyObjectList] = []
            for v in dict["notifyObjectList"] as! [Any] {
                var model = CreateSubscriptionRequest.NotifyObjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notifyObjectList = tmp
        }
        if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
            self.notifyObjectType = dict["notifyObjectType"] as! Int64
        }
        if dict.keys.contains("notifyStrategyList") && dict["notifyStrategyList"] != nil {
            var tmp : [CreateSubscriptionRequest.NotifyStrategyList] = []
            for v in dict["notifyStrategyList"] as! [Any] {
                var model = CreateSubscriptionRequest.NotifyStrategyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notifyStrategyList = tmp
        }
        if dict.keys.contains("period") && dict["period"] != nil {
            self.period = dict["period"] as! String
        }
        if dict.keys.contains("scope") && dict["scope"] != nil {
            self.scope = dict["scope"] as! Int64
        }
        if dict.keys.contains("scopeObjectList") && dict["scopeObjectList"] != nil {
            var tmp : [CreateSubscriptionRequest.ScopeObjectList] = []
            for v in dict["scopeObjectList"] as! [Any] {
                var model = CreateSubscriptionRequest.ScopeObjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scopeObjectList = tmp
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
        if dict.keys.contains("subscriptionTitle") && dict["subscriptionTitle"] != nil {
            self.subscriptionTitle = dict["subscriptionTitle"] as! String
        }
    }
}

public class CreateSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var subscriptionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subscriptionId != nil {
                map["subscriptionId"] = self.subscriptionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
                self.subscriptionId = dict["subscriptionId"] as! Int64
            }
        }
    }
    public var data: CreateSubscriptionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateSubscriptionResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTenantApplicationRequest : Tea.TeaModel {
    public var channel: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channel != nil {
            map["channel"] = self.channel!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("channel") && dict["channel"] != nil {
            self.channel = dict["channel"] as! String
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CreateTenantApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var openUrl: String?

        public var progress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.openUrl != nil {
                map["openUrl"] = self.openUrl!
            }
            if self.progress != nil {
                map["progress"] = self.progress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("openUrl") && dict["openUrl"] != nil {
                self.openUrl = dict["openUrl"] as! String
            }
            if dict.keys.contains("progress") && dict["progress"] != nil {
                self.progress = dict["progress"] as! String
            }
        }
    }
    public var data: CreateTenantApplicationResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateTenantApplicationResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateTenantApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTenantApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateTenantApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var email: String?

    public var phone: String?

    public var ramId: Int64?

    public var roleIdList: [Int64]?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.email != nil {
            map["email"] = self.email!
        }
        if self.phone != nil {
            map["phone"] = self.phone!
        }
        if self.ramId != nil {
            map["ramId"] = self.ramId!
        }
        if self.roleIdList != nil {
            map["roleIdList"] = self.roleIdList!
        }
        if self.username != nil {
            map["username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("email") && dict["email"] != nil {
            self.email = dict["email"] as! String
        }
        if dict.keys.contains("phone") && dict["phone"] != nil {
            self.phone = dict["phone"] as! String
        }
        if dict.keys.contains("ramId") && dict["ramId"] != nil {
            self.ramId = dict["ramId"] as! Int64
        }
        if dict.keys.contains("roleIdList") && dict["roleIdList"] != nil {
            self.roleIdList = dict["roleIdList"] as! [Int64]
        }
        if dict.keys.contains("username") && dict["username"] != nil {
            self.username = dict["username"] as! String
        }
    }
}

public class CreateUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("userId") && dict["userId"] != nil {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var data: CreateUserResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = CreateUserResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CreateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEscalationPlanRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
    }
}

public class DeleteEscalationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIncidentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class DeleteIncidentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class DeleteIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProblemRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class DeleteProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProblemEffectionServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var effectionServiceId: Int64?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.effectionServiceId != nil {
            map["effectionServiceId"] = self.effectionServiceId!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
            self.effectionServiceId = dict["effectionServiceId"] as! Int64
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class DeleteProblemEffectionServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteProblemEffectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProblemEffectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProblemEffectionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProblemMeasureRequest : Tea.TeaModel {
    public var clientToken: String?

    public var measureId: Int64?

    public var problemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.measureId != nil {
            map["measureId"] = self.measureId!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("measureId") && dict["measureId"] != nil {
            self.measureId = dict["measureId"] as! Int64
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! String
        }
    }
}

public class DeleteProblemMeasureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteProblemMeasureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProblemMeasureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProblemMeasureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProblemTimelineRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public var problemTimelineId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemTimelineId != nil {
            map["problemTimelineId"] = self.problemTimelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemTimelineId") && dict["problemTimelineId"] != nil {
            self.problemTimelineId = dict["problemTimelineId"] as! Int64
        }
    }
}

public class DeleteProblemTimelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteProblemTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProblemTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteProblemTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var routeRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
    }
}

public class DeleteRouteRuleResponseBody : Tea.TeaModel {
    public var requestId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! Int64
        }
    }
}

public class DeleteRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
    }
}

public class DeleteServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class DeleteServiceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceGroupSchedulingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteServiceGroupSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceGroupSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceGroupSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceGroupUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newUserId: Int64?

    public var oldUserId: Int64?

    public var removeUser: Bool?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.newUserId != nil {
            map["newUserId"] = self.newUserId!
        }
        if self.oldUserId != nil {
            map["oldUserId"] = self.oldUserId!
        }
        if self.removeUser != nil {
            map["removeUser"] = self.removeUser!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("newUserId") && dict["newUserId"] != nil {
            self.newUserId = dict["newUserId"] as! Int64
        }
        if dict.keys.contains("oldUserId") && dict["oldUserId"] != nil {
            self.oldUserId = dict["oldUserId"] as! Int64
        }
        if dict.keys.contains("removeUser") && dict["removeUser"] != nil {
            self.removeUser = dict["removeUser"] as! Bool
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class DeleteServiceGroupUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteServiceGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceGroupUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubscriptionRequest : Tea.TeaModel {
    public var subscriptionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subscriptionId != nil {
            map["subscriptionId"] = self.subscriptionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
            self.subscriptionId = dict["subscriptionId"] as! Int64
        }
    }
}

public class DeleteSubscriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class DeleteUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeleteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeliverIncidentRequest : Tea.TeaModel {
    public var assignUserId: Int64?

    public var clientToken: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignUserId != nil {
            map["assignUserId"] = self.assignUserId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
            self.assignUserId = dict["assignUserId"] as! Int64
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class DeliverIncidentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DeliverIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeliverIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeliverIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableEscalationPlanRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
    }
}

public class DisableEscalationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DisableEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class DisableIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DisableIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableRouteRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var routeRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
    }
}

public class DisableRouteRuleResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DisableRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableServiceGroupWebhookRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class DisableServiceGroupWebhookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DisableServiceGroupWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableServiceGroupWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableServiceGroupWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableSubscriptionRequest : Tea.TeaModel {
    public var subscriptionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subscriptionId != nil {
            map["subscriptionId"] = self.subscriptionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
            self.subscriptionId = dict["subscriptionId"] as! Int64
        }
    }
}

public class DisableSubscriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class DisableSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableEscalationPlanRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
    }
}

public class EnableEscalationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class EnableEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class EnableIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class EnableIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableRouteRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var routeRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
    }
}

public class EnableRouteRuleResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class EnableRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableServiceGroupWebhookRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class EnableServiceGroupWebhookResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class EnableServiceGroupWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableServiceGroupWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableServiceGroupWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableSubscriptionRequest : Tea.TeaModel {
    public var subscriptionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.subscriptionId != nil {
            map["subscriptionId"] = self.subscriptionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
            self.subscriptionId = dict["subscriptionId"] as! Int64
        }
    }
}

public class EnableSubscriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class EnableSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FinishIncidentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentFinishReason: Int32?

    public var incidentFinishReasonDescription: String?

    public var incidentFinishSolution: Int32?

    public var incidentFinishSolutionDescription: String?

    public var incidentIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentFinishReason != nil {
            map["incidentFinishReason"] = self.incidentFinishReason!
        }
        if self.incidentFinishReasonDescription != nil {
            map["incidentFinishReasonDescription"] = self.incidentFinishReasonDescription!
        }
        if self.incidentFinishSolution != nil {
            map["incidentFinishSolution"] = self.incidentFinishSolution!
        }
        if self.incidentFinishSolutionDescription != nil {
            map["incidentFinishSolutionDescription"] = self.incidentFinishSolutionDescription!
        }
        if self.incidentIds != nil {
            map["incidentIds"] = self.incidentIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentFinishReason") && dict["incidentFinishReason"] != nil {
            self.incidentFinishReason = dict["incidentFinishReason"] as! Int32
        }
        if dict.keys.contains("incidentFinishReasonDescription") && dict["incidentFinishReasonDescription"] != nil {
            self.incidentFinishReasonDescription = dict["incidentFinishReasonDescription"] as! String
        }
        if dict.keys.contains("incidentFinishSolution") && dict["incidentFinishSolution"] != nil {
            self.incidentFinishSolution = dict["incidentFinishSolution"] as! Int32
        }
        if dict.keys.contains("incidentFinishSolutionDescription") && dict["incidentFinishSolutionDescription"] != nil {
            self.incidentFinishSolutionDescription = dict["incidentFinishSolutionDescription"] as! String
        }
        if dict.keys.contains("incidentIds") && dict["incidentIds"] != nil {
            self.incidentIds = dict["incidentIds"] as! [Int64]
        }
    }
}

public class FinishIncidentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class FinishIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FinishIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FinishIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FinishProblemRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class FinishProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class FinishProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FinishProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FinishProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GeneratePictureLinkRequest : Tea.TeaModel {
    public var keys: [String]?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keys != nil {
            map["keys"] = self.keys!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("keys") && dict["keys"] != nil {
            self.keys = dict["keys"] as! [String]
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class GeneratePictureLinkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Links : Tea.TeaModel {
            public var key: String?

            public var link: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.link != nil {
                    map["link"] = self.link!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") && dict["key"] != nil {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("link") && dict["link"] != nil {
                    self.link = dict["link"] as! String
                }
            }
        }
        public var links: [GeneratePictureLinkResponseBody.Data.Links]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.links != nil {
                var tmp : [Any] = []
                for k in self.links! {
                    tmp.append(k.toMap())
                }
                map["links"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("links") && dict["links"] != nil {
                var tmp : [GeneratePictureLinkResponseBody.Data.Links] = []
                for v in dict["links"] as! [Any] {
                    var model = GeneratePictureLinkResponseBody.Data.Links()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.links = tmp
            }
        }
    }
    public var data: GeneratePictureLinkResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GeneratePictureLinkResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GeneratePictureLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GeneratePictureLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GeneratePictureLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GeneratePictureUploadSignRequest : Tea.TeaModel {
    public class Files : Tea.TeaModel {
        public var fileName: String?

        public var fileSize: Int64?

        public var fileType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.fileType != nil {
                map["fileType"] = self.fileType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileName") && dict["fileName"] != nil {
                self.fileName = dict["fileName"] as! String
            }
            if dict.keys.contains("fileSize") && dict["fileSize"] != nil {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("fileType") && dict["fileType"] != nil {
                self.fileType = dict["fileType"] as! String
            }
        }
    }
    public var files: [GeneratePictureUploadSignRequest.Files]?

    public var instanceId: Int64?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.files != nil {
            var tmp : [Any] = []
            for k in self.files! {
                tmp.append(k.toMap())
            }
            map["files"] = tmp
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("files") && dict["files"] != nil {
            var tmp : [GeneratePictureUploadSignRequest.Files] = []
            for v in dict["files"] as! [Any] {
                var model = GeneratePictureUploadSignRequest.Files()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.files = tmp
        }
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
    }
}

public class GeneratePictureUploadSignResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Files : Tea.TeaModel {
            public var fileName: String?

            public var fileSize: Int64?

            public var fileType: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.fileType != nil {
                    map["fileType"] = self.fileType!
                }
                if self.key != nil {
                    map["key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileName") && dict["fileName"] != nil {
                    self.fileName = dict["fileName"] as! String
                }
                if dict.keys.contains("fileSize") && dict["fileSize"] != nil {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("fileType") && dict["fileType"] != nil {
                    self.fileType = dict["fileType"] as! String
                }
                if dict.keys.contains("key") && dict["key"] != nil {
                    self.key = dict["key"] as! String
                }
            }
        }
        public var accessKeyId: String?

        public var bucketName: String?

        public var files: [GeneratePictureUploadSignResponseBody.Data.Files]?

        public var policy: String?

        public var signature: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["accessKeyId"] = self.accessKeyId!
            }
            if self.bucketName != nil {
                map["bucketName"] = self.bucketName!
            }
            if self.files != nil {
                var tmp : [Any] = []
                for k in self.files! {
                    tmp.append(k.toMap())
                }
                map["files"] = tmp
            }
            if self.policy != nil {
                map["policy"] = self.policy!
            }
            if self.signature != nil {
                map["signature"] = self.signature!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessKeyId") && dict["accessKeyId"] != nil {
                self.accessKeyId = dict["accessKeyId"] as! String
            }
            if dict.keys.contains("bucketName") && dict["bucketName"] != nil {
                self.bucketName = dict["bucketName"] as! String
            }
            if dict.keys.contains("files") && dict["files"] != nil {
                var tmp : [GeneratePictureUploadSignResponseBody.Data.Files] = []
                for v in dict["files"] as! [Any] {
                    var model = GeneratePictureUploadSignResponseBody.Data.Files()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.files = tmp
            }
            if dict.keys.contains("policy") && dict["policy"] != nil {
                self.policy = dict["policy"] as! String
            }
            if dict.keys.contains("signature") && dict["signature"] != nil {
                self.signature = dict["signature"] as! String
            }
            if dict.keys.contains("url") && dict["url"] != nil {
                self.url = dict["url"] as! String
            }
        }
    }
    public var data: GeneratePictureUploadSignResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GeneratePictureUploadSignResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GeneratePictureUploadSignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GeneratePictureUploadSignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GeneratePictureUploadSignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateProblemPictureLinkRequest : Tea.TeaModel {
    public var keys: [String]?

    public var problemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keys != nil {
            map["keys"] = self.keys!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("keys") && dict["keys"] != nil {
            self.keys = dict["keys"] as! [String]
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! String
        }
    }
}

public class GenerateProblemPictureLinkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Links : Tea.TeaModel {
            public var key: String?

            public var link: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.link != nil {
                    map["link"] = self.link!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") && dict["key"] != nil {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("link") && dict["link"] != nil {
                    self.link = dict["link"] as! String
                }
            }
        }
        public var links: [GenerateProblemPictureLinkResponseBody.Data.Links]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.links != nil {
                var tmp : [Any] = []
                for k in self.links! {
                    tmp.append(k.toMap())
                }
                map["links"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("links") && dict["links"] != nil {
                var tmp : [GenerateProblemPictureLinkResponseBody.Data.Links] = []
                for v in dict["links"] as! [Any] {
                    var model = GenerateProblemPictureLinkResponseBody.Data.Links()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.links = tmp
            }
        }
    }
    public var data: GenerateProblemPictureLinkResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GenerateProblemPictureLinkResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GenerateProblemPictureLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateProblemPictureLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateProblemPictureLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateProblemPictureUploadSignRequest : Tea.TeaModel {
    public var fileName: String?

    public var fileSize: Int64?

    public var fileType: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.fileType != nil {
            map["fileType"] = self.fileType!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fileName") && dict["fileName"] != nil {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("fileSize") && dict["fileSize"] != nil {
            self.fileSize = dict["fileSize"] as! Int64
        }
        if dict.keys.contains("fileType") && dict["fileType"] != nil {
            self.fileType = dict["fileType"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class GenerateProblemPictureUploadSignResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var bucketName: String?

        public var key: String?

        public var policy: String?

        public var signature: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["accessKeyId"] = self.accessKeyId!
            }
            if self.bucketName != nil {
                map["bucketName"] = self.bucketName!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.policy != nil {
                map["policy"] = self.policy!
            }
            if self.signature != nil {
                map["signature"] = self.signature!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessKeyId") && dict["accessKeyId"] != nil {
                self.accessKeyId = dict["accessKeyId"] as! String
            }
            if dict.keys.contains("bucketName") && dict["bucketName"] != nil {
                self.bucketName = dict["bucketName"] as! String
            }
            if dict.keys.contains("key") && dict["key"] != nil {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("policy") && dict["policy"] != nil {
                self.policy = dict["policy"] as! String
            }
            if dict.keys.contains("signature") && dict["signature"] != nil {
                self.signature = dict["signature"] as! String
            }
            if dict.keys.contains("url") && dict["url"] != nil {
                self.url = dict["url"] as! String
            }
        }
    }
    public var data: GenerateProblemPictureUploadSignResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GenerateProblemPictureUploadSignResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GenerateProblemPictureUploadSignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateProblemPictureUploadSignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateProblemPictureUploadSignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEscalationPlanRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
    }
}

public class GetEscalationPlanResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EscalationPlanRules : Tea.TeaModel {
            public class EscalationPlanConditions : Tea.TeaModel {
                public var effection: String?

                public var level: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.effection != nil {
                        map["effection"] = self.effection!
                    }
                    if self.level != nil {
                        map["level"] = self.level!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("effection") && dict["effection"] != nil {
                        self.effection = dict["effection"] as! String
                    }
                    if dict.keys.contains("level") && dict["level"] != nil {
                        self.level = dict["level"] as! String
                    }
                }
            }
            public class EscalationPlanStrategies : Tea.TeaModel {
                public class NoticeObjectList : Tea.TeaModel {
                    public var noticeObjectId: Int64?

                    public var noticeObjectName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.noticeObjectId != nil {
                            map["noticeObjectId"] = self.noticeObjectId!
                        }
                        if self.noticeObjectName != nil {
                            map["noticeObjectName"] = self.noticeObjectName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("noticeObjectId") && dict["noticeObjectId"] != nil {
                            self.noticeObjectId = dict["noticeObjectId"] as! Int64
                        }
                        if dict.keys.contains("noticeObjectName") && dict["noticeObjectName"] != nil {
                            self.noticeObjectName = dict["noticeObjectName"] as! String
                        }
                    }
                }
                public class NoticeRoleObjectList : Tea.TeaModel {
                    public var id: Int64?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("id") && dict["id"] != nil {
                            self.id = dict["id"] as! Int64
                        }
                        if dict.keys.contains("name") && dict["name"] != nil {
                            self.name = dict["name"] as! String
                        }
                    }
                }
                public class ServiceGroups : Tea.TeaModel {
                    public var id: Int64?

                    public var serviceGroupName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.serviceGroupName != nil {
                            map["serviceGroupName"] = self.serviceGroupName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("id") && dict["id"] != nil {
                            self.id = dict["id"] as! Int64
                        }
                        if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                            self.serviceGroupName = dict["serviceGroupName"] as! String
                        }
                    }
                }
                public var enableWebhook: Bool?

                public var escalationPlanType: String?

                public var noticeChannels: String?

                public var noticeObjectList: [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeObjectList]?

                public var noticeObjects: [Int64]?

                public var noticeRoleList: [Int64]?

                public var noticeRoleObjectList: [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeRoleObjectList]?

                public var noticeTime: Int64?

                public var serviceGroups: [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.ServiceGroups]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableWebhook != nil {
                        map["enableWebhook"] = self.enableWebhook!
                    }
                    if self.escalationPlanType != nil {
                        map["escalationPlanType"] = self.escalationPlanType!
                    }
                    if self.noticeChannels != nil {
                        map["noticeChannels"] = self.noticeChannels!
                    }
                    if self.noticeObjectList != nil {
                        var tmp : [Any] = []
                        for k in self.noticeObjectList! {
                            tmp.append(k.toMap())
                        }
                        map["noticeObjectList"] = tmp
                    }
                    if self.noticeObjects != nil {
                        map["noticeObjects"] = self.noticeObjects!
                    }
                    if self.noticeRoleList != nil {
                        map["noticeRoleList"] = self.noticeRoleList!
                    }
                    if self.noticeRoleObjectList != nil {
                        var tmp : [Any] = []
                        for k in self.noticeRoleObjectList! {
                            tmp.append(k.toMap())
                        }
                        map["noticeRoleObjectList"] = tmp
                    }
                    if self.noticeTime != nil {
                        map["noticeTime"] = self.noticeTime!
                    }
                    if self.serviceGroups != nil {
                        var tmp : [Any] = []
                        for k in self.serviceGroups! {
                            tmp.append(k.toMap())
                        }
                        map["serviceGroups"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
                        self.enableWebhook = dict["enableWebhook"] as! Bool
                    }
                    if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                        self.escalationPlanType = dict["escalationPlanType"] as! String
                    }
                    if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                        self.noticeChannels = dict["noticeChannels"] as! String
                    }
                    if dict.keys.contains("noticeObjectList") && dict["noticeObjectList"] != nil {
                        var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeObjectList] = []
                        for v in dict["noticeObjectList"] as! [Any] {
                            var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeObjectList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.noticeObjectList = tmp
                    }
                    if dict.keys.contains("noticeObjects") && dict["noticeObjects"] != nil {
                        self.noticeObjects = dict["noticeObjects"] as! [Int64]
                    }
                    if dict.keys.contains("noticeRoleList") && dict["noticeRoleList"] != nil {
                        self.noticeRoleList = dict["noticeRoleList"] as! [Int64]
                    }
                    if dict.keys.contains("noticeRoleObjectList") && dict["noticeRoleObjectList"] != nil {
                        var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeRoleObjectList] = []
                        for v in dict["noticeRoleObjectList"] as! [Any] {
                            var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.NoticeRoleObjectList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.noticeRoleObjectList = tmp
                    }
                    if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                        self.noticeTime = dict["noticeTime"] as! Int64
                    }
                    if dict.keys.contains("serviceGroups") && dict["serviceGroups"] != nil {
                        var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.ServiceGroups] = []
                        for v in dict["serviceGroups"] as! [Any] {
                            var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies.ServiceGroups()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serviceGroups = tmp
                    }
                }
            }
            public var escalationPlanConditions: [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanConditions]?

            public var escalationPlanRuleId: Int64?

            public var escalationPlanStrategies: [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanConditions != nil {
                    var tmp : [Any] = []
                    for k in self.escalationPlanConditions! {
                        tmp.append(k.toMap())
                    }
                    map["escalationPlanConditions"] = tmp
                }
                if self.escalationPlanRuleId != nil {
                    map["escalationPlanRuleId"] = self.escalationPlanRuleId!
                }
                if self.escalationPlanStrategies != nil {
                    var tmp : [Any] = []
                    for k in self.escalationPlanStrategies! {
                        tmp.append(k.toMap())
                    }
                    map["escalationPlanStrategies"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanConditions") && dict["escalationPlanConditions"] != nil {
                    var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanConditions] = []
                    for v in dict["escalationPlanConditions"] as! [Any] {
                        var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.escalationPlanConditions = tmp
                }
                if dict.keys.contains("escalationPlanRuleId") && dict["escalationPlanRuleId"] != nil {
                    self.escalationPlanRuleId = dict["escalationPlanRuleId"] as! Int64
                }
                if dict.keys.contains("escalationPlanStrategies") && dict["escalationPlanStrategies"] != nil {
                    var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies] = []
                    for v in dict["escalationPlanStrategies"] as! [Any] {
                        var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules.EscalationPlanStrategies()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.escalationPlanStrategies = tmp
                }
            }
        }
        public class EscalationPlanScopeObjects : Tea.TeaModel {
            public var escalationPlanScopeObjects: Int32?

            public var scope: String?

            public var scopeObjectDeletedType: Int32?

            public var scopeObjectId: Int64?

            public var scopeObjectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanScopeObjects != nil {
                    map["escalationPlanScopeObjects"] = self.escalationPlanScopeObjects!
                }
                if self.scope != nil {
                    map["scope"] = self.scope!
                }
                if self.scopeObjectDeletedType != nil {
                    map["scopeObjectDeletedType"] = self.scopeObjectDeletedType!
                }
                if self.scopeObjectId != nil {
                    map["scopeObjectId"] = self.scopeObjectId!
                }
                if self.scopeObjectName != nil {
                    map["scopeObjectName"] = self.scopeObjectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
                    self.escalationPlanScopeObjects = dict["escalationPlanScopeObjects"] as! Int32
                }
                if dict.keys.contains("scope") && dict["scope"] != nil {
                    self.scope = dict["scope"] as! String
                }
                if dict.keys.contains("scopeObjectDeletedType") && dict["scopeObjectDeletedType"] != nil {
                    self.scopeObjectDeletedType = dict["scopeObjectDeletedType"] as! Int32
                }
                if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                    self.scopeObjectId = dict["scopeObjectId"] as! Int64
                }
                if dict.keys.contains("scopeObjectName") && dict["scopeObjectName"] != nil {
                    self.scopeObjectName = dict["scopeObjectName"] as! String
                }
            }
        }
        public var createTime: String?

        public var escalationPlanDescription: String?

        public var escalationPlanId: Int64?

        public var escalationPlanName: String?

        public var escalationPlanRules: [GetEscalationPlanResponseBody.Data.EscalationPlanRules]?

        public var escalationPlanScopeObjects: [GetEscalationPlanResponseBody.Data.EscalationPlanScopeObjects]?

        public var isGlobal: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.escalationPlanDescription != nil {
                map["escalationPlanDescription"] = self.escalationPlanDescription!
            }
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.escalationPlanName != nil {
                map["escalationPlanName"] = self.escalationPlanName!
            }
            if self.escalationPlanRules != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanRules! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanRules"] = tmp
            }
            if self.escalationPlanScopeObjects != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanScopeObjects! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanScopeObjects"] = tmp
            }
            if self.isGlobal != nil {
                map["isGlobal"] = self.isGlobal!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("escalationPlanDescription") && dict["escalationPlanDescription"] != nil {
                self.escalationPlanDescription = dict["escalationPlanDescription"] as! String
            }
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                self.escalationPlanName = dict["escalationPlanName"] as! String
            }
            if dict.keys.contains("escalationPlanRules") && dict["escalationPlanRules"] != nil {
                var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanRules] = []
                for v in dict["escalationPlanRules"] as! [Any] {
                    var model = GetEscalationPlanResponseBody.Data.EscalationPlanRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanRules = tmp
            }
            if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
                var tmp : [GetEscalationPlanResponseBody.Data.EscalationPlanScopeObjects] = []
                for v in dict["escalationPlanScopeObjects"] as! [Any] {
                    var model = GetEscalationPlanResponseBody.Data.EscalationPlanScopeObjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanScopeObjects = tmp
            }
            if dict.keys.contains("isGlobal") && dict["isGlobal"] != nil {
                self.isGlobal = dict["isGlobal"] as! Bool
            }
        }
    }
    public var data: GetEscalationPlanResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetEscalationPlanResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventRequest : Tea.TeaModel {
    public var monitorSourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorSourceId != nil {
            map["monitorSourceId"] = self.monitorSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
            self.monitorSourceId = dict["monitorSourceId"] as! Int64
        }
    }
}

public class GetEventResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventJson: String?

        public var eventTime: String?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventJson != nil {
                map["eventJson"] = self.eventJson!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventJson") && dict["eventJson"] != nil {
                self.eventJson = dict["eventJson"] as! String
            }
            if dict.keys.contains("eventTime") && dict["eventTime"] != nil {
                self.eventTime = dict["eventTime"] as! String
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
        }
    }
    public var data: GetEventResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetEventResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHomePageGuidanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class GetHomePageGuidanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var notifySubscriptionStatus: Bool?

        public var serviceGroupStatus: Bool?

        public var serviceStatus: Bool?

        public var usersStatus: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notifySubscriptionStatus != nil {
                map["notifySubscriptionStatus"] = self.notifySubscriptionStatus!
            }
            if self.serviceGroupStatus != nil {
                map["serviceGroupStatus"] = self.serviceGroupStatus!
            }
            if self.serviceStatus != nil {
                map["serviceStatus"] = self.serviceStatus!
            }
            if self.usersStatus != nil {
                map["usersStatus"] = self.usersStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("notifySubscriptionStatus") && dict["notifySubscriptionStatus"] != nil {
                self.notifySubscriptionStatus = dict["notifySubscriptionStatus"] as! Bool
            }
            if dict.keys.contains("serviceGroupStatus") && dict["serviceGroupStatus"] != nil {
                self.serviceGroupStatus = dict["serviceGroupStatus"] as! Bool
            }
            if dict.keys.contains("serviceStatus") && dict["serviceStatus"] != nil {
                self.serviceStatus = dict["serviceStatus"] as! Bool
            }
            if dict.keys.contains("usersStatus") && dict["usersStatus"] != nil {
                self.usersStatus = dict["usersStatus"] as! Bool
            }
        }
    }
    public var data: GetHomePageGuidanceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetHomePageGuidanceResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetHomePageGuidanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHomePageGuidanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHomePageGuidanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIncidentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class GetIncidentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var assignToWhoIsValid: Int32?

        public var assignUserId: Int64?

        public var assignUserName: String?

        public var assignUserPhone: String?

        public var createTime: String?

        public var defaultAssignToWho: Int32?

        public var defaultAssignToWhoIsValid: Int32?

        public var defaultAssignToWhoName: String?

        public var durationTime: Int64?

        public var effect: String?

        public var incidentDescription: String?

        public var incidentId: Int64?

        public var incidentLevel: String?

        public var incidentNumber: String?

        public var incidentStatus: String?

        public var incidentTitle: String?

        public var isManual: Bool?

        public var isUpgrade: Bool?

        public var notifyChannels: [String]?

        public var problemId: Int64?

        public var problemNumber: String?

        public var relRouteRuleDeleteType: Int32?

        public var relServiceDeleteType: Int32?

        public var relServiceGroupIsValid: Int32?

        public var relatedServiceDescription: String?

        public var relatedServiceGroupId: Int64?

        public var relatedServiceGroupName: String?

        public var relatedServiceId: Int64?

        public var relatedServiceName: String?

        public var routeRuleId: Int64?

        public var routeRuleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignToWhoIsValid != nil {
                map["assignToWhoIsValid"] = self.assignToWhoIsValid!
            }
            if self.assignUserId != nil {
                map["assignUserId"] = self.assignUserId!
            }
            if self.assignUserName != nil {
                map["assignUserName"] = self.assignUserName!
            }
            if self.assignUserPhone != nil {
                map["assignUserPhone"] = self.assignUserPhone!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.defaultAssignToWho != nil {
                map["defaultAssignToWho"] = self.defaultAssignToWho!
            }
            if self.defaultAssignToWhoIsValid != nil {
                map["defaultAssignToWhoIsValid"] = self.defaultAssignToWhoIsValid!
            }
            if self.defaultAssignToWhoName != nil {
                map["defaultAssignToWhoName"] = self.defaultAssignToWhoName!
            }
            if self.durationTime != nil {
                map["durationTime"] = self.durationTime!
            }
            if self.effect != nil {
                map["effect"] = self.effect!
            }
            if self.incidentDescription != nil {
                map["incidentDescription"] = self.incidentDescription!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.incidentLevel != nil {
                map["incidentLevel"] = self.incidentLevel!
            }
            if self.incidentNumber != nil {
                map["incidentNumber"] = self.incidentNumber!
            }
            if self.incidentStatus != nil {
                map["incidentStatus"] = self.incidentStatus!
            }
            if self.incidentTitle != nil {
                map["incidentTitle"] = self.incidentTitle!
            }
            if self.isManual != nil {
                map["isManual"] = self.isManual!
            }
            if self.isUpgrade != nil {
                map["isUpgrade"] = self.isUpgrade!
            }
            if self.notifyChannels != nil {
                map["notifyChannels"] = self.notifyChannels!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemNumber != nil {
                map["problemNumber"] = self.problemNumber!
            }
            if self.relRouteRuleDeleteType != nil {
                map["relRouteRuleDeleteType"] = self.relRouteRuleDeleteType!
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relServiceGroupIsValid != nil {
                map["relServiceGroupIsValid"] = self.relServiceGroupIsValid!
            }
            if self.relatedServiceDescription != nil {
                map["relatedServiceDescription"] = self.relatedServiceDescription!
            }
            if self.relatedServiceGroupId != nil {
                map["relatedServiceGroupId"] = self.relatedServiceGroupId!
            }
            if self.relatedServiceGroupName != nil {
                map["relatedServiceGroupName"] = self.relatedServiceGroupName!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeRuleName != nil {
                map["routeRuleName"] = self.routeRuleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignToWhoIsValid") && dict["assignToWhoIsValid"] != nil {
                self.assignToWhoIsValid = dict["assignToWhoIsValid"] as! Int32
            }
            if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
                self.assignUserId = dict["assignUserId"] as! Int64
            }
            if dict.keys.contains("assignUserName") && dict["assignUserName"] != nil {
                self.assignUserName = dict["assignUserName"] as! String
            }
            if dict.keys.contains("assignUserPhone") && dict["assignUserPhone"] != nil {
                self.assignUserPhone = dict["assignUserPhone"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("defaultAssignToWho") && dict["defaultAssignToWho"] != nil {
                self.defaultAssignToWho = dict["defaultAssignToWho"] as! Int32
            }
            if dict.keys.contains("defaultAssignToWhoIsValid") && dict["defaultAssignToWhoIsValid"] != nil {
                self.defaultAssignToWhoIsValid = dict["defaultAssignToWhoIsValid"] as! Int32
            }
            if dict.keys.contains("defaultAssignToWhoName") && dict["defaultAssignToWhoName"] != nil {
                self.defaultAssignToWhoName = dict["defaultAssignToWhoName"] as! String
            }
            if dict.keys.contains("durationTime") && dict["durationTime"] != nil {
                self.durationTime = dict["durationTime"] as! Int64
            }
            if dict.keys.contains("effect") && dict["effect"] != nil {
                self.effect = dict["effect"] as! String
            }
            if dict.keys.contains("incidentDescription") && dict["incidentDescription"] != nil {
                self.incidentDescription = dict["incidentDescription"] as! String
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
                self.incidentLevel = dict["incidentLevel"] as! String
            }
            if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                self.incidentNumber = dict["incidentNumber"] as! String
            }
            if dict.keys.contains("incidentStatus") && dict["incidentStatus"] != nil {
                self.incidentStatus = dict["incidentStatus"] as! String
            }
            if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                self.incidentTitle = dict["incidentTitle"] as! String
            }
            if dict.keys.contains("isManual") && dict["isManual"] != nil {
                self.isManual = dict["isManual"] as! Bool
            }
            if dict.keys.contains("isUpgrade") && dict["isUpgrade"] != nil {
                self.isUpgrade = dict["isUpgrade"] as! Bool
            }
            if dict.keys.contains("notifyChannels") && dict["notifyChannels"] != nil {
                self.notifyChannels = dict["notifyChannels"] as! [String]
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
            if dict.keys.contains("problemNumber") && dict["problemNumber"] != nil {
                self.problemNumber = dict["problemNumber"] as! String
            }
            if dict.keys.contains("relRouteRuleDeleteType") && dict["relRouteRuleDeleteType"] != nil {
                self.relRouteRuleDeleteType = dict["relRouteRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relServiceGroupIsValid") && dict["relServiceGroupIsValid"] != nil {
                self.relServiceGroupIsValid = dict["relServiceGroupIsValid"] as! Int32
            }
            if dict.keys.contains("relatedServiceDescription") && dict["relatedServiceDescription"] != nil {
                self.relatedServiceDescription = dict["relatedServiceDescription"] as! String
            }
            if dict.keys.contains("relatedServiceGroupId") && dict["relatedServiceGroupId"] != nil {
                self.relatedServiceGroupId = dict["relatedServiceGroupId"] as! Int64
            }
            if dict.keys.contains("relatedServiceGroupName") && dict["relatedServiceGroupName"] != nil {
                self.relatedServiceGroupName = dict["relatedServiceGroupName"] as! String
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeRuleName") && dict["routeRuleName"] != nil {
                self.routeRuleName = dict["routeRuleName"] as! String
            }
        }
    }
    public var data: GetIncidentResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetIncidentResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIncidentListByIdListRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentIdList: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentIdList != nil {
            map["incidentIdList"] = self.incidentIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentIdList") && dict["incidentIdList"] != nil {
            self.incidentIdList = dict["incidentIdList"] as! [Int64]
        }
    }
}

public class GetIncidentListByIdListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var assignToWhoIsValid: Int32?

        public var assignUserId: Int64?

        public var assignUserName: String?

        public var assignUserPhone: String?

        public var createTime: String?

        public var defaultAssignToWho: Int32?

        public var defaultAssignToWhoIsValid: Int32?

        public var defaultAssignToWhoName: String?

        public var durationTime: String?

        public var effect: String?

        public var incidentDescription: String?

        public var incidentId: Int64?

        public var incidentLevel: String?

        public var incidentNumber: String?

        public var incidentStatus: String?

        public var incidentTitle: String?

        public var isManual: Bool?

        public var isUpgrade: Bool?

        public var notifyChannels: [String]?

        public var problemId: Int64?

        public var problemNumber: String?

        public var relRouteRuleDeleteType: Int32?

        public var relServiceDeleteType: Int32?

        public var relServiceGroupIsValid: Int32?

        public var relatedServiceDescription: String?

        public var relatedServiceGroupId: Int64?

        public var relatedServiceGroupName: String?

        public var relatedServiceId: Int64?

        public var relatedServiceName: String?

        public var routeRuleId: Int64?

        public var routeRuleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignToWhoIsValid != nil {
                map["assignToWhoIsValid"] = self.assignToWhoIsValid!
            }
            if self.assignUserId != nil {
                map["assignUserId"] = self.assignUserId!
            }
            if self.assignUserName != nil {
                map["assignUserName"] = self.assignUserName!
            }
            if self.assignUserPhone != nil {
                map["assignUserPhone"] = self.assignUserPhone!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.defaultAssignToWho != nil {
                map["defaultAssignToWho"] = self.defaultAssignToWho!
            }
            if self.defaultAssignToWhoIsValid != nil {
                map["defaultAssignToWhoIsValid"] = self.defaultAssignToWhoIsValid!
            }
            if self.defaultAssignToWhoName != nil {
                map["defaultAssignToWhoName"] = self.defaultAssignToWhoName!
            }
            if self.durationTime != nil {
                map["durationTime"] = self.durationTime!
            }
            if self.effect != nil {
                map["effect"] = self.effect!
            }
            if self.incidentDescription != nil {
                map["incidentDescription"] = self.incidentDescription!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.incidentLevel != nil {
                map["incidentLevel"] = self.incidentLevel!
            }
            if self.incidentNumber != nil {
                map["incidentNumber"] = self.incidentNumber!
            }
            if self.incidentStatus != nil {
                map["incidentStatus"] = self.incidentStatus!
            }
            if self.incidentTitle != nil {
                map["incidentTitle"] = self.incidentTitle!
            }
            if self.isManual != nil {
                map["isManual"] = self.isManual!
            }
            if self.isUpgrade != nil {
                map["isUpgrade"] = self.isUpgrade!
            }
            if self.notifyChannels != nil {
                map["notifyChannels"] = self.notifyChannels!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemNumber != nil {
                map["problemNumber"] = self.problemNumber!
            }
            if self.relRouteRuleDeleteType != nil {
                map["relRouteRuleDeleteType"] = self.relRouteRuleDeleteType!
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relServiceGroupIsValid != nil {
                map["relServiceGroupIsValid"] = self.relServiceGroupIsValid!
            }
            if self.relatedServiceDescription != nil {
                map["relatedServiceDescription"] = self.relatedServiceDescription!
            }
            if self.relatedServiceGroupId != nil {
                map["relatedServiceGroupId"] = self.relatedServiceGroupId!
            }
            if self.relatedServiceGroupName != nil {
                map["relatedServiceGroupName"] = self.relatedServiceGroupName!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeRuleName != nil {
                map["routeRuleName"] = self.routeRuleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignToWhoIsValid") && dict["assignToWhoIsValid"] != nil {
                self.assignToWhoIsValid = dict["assignToWhoIsValid"] as! Int32
            }
            if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
                self.assignUserId = dict["assignUserId"] as! Int64
            }
            if dict.keys.contains("assignUserName") && dict["assignUserName"] != nil {
                self.assignUserName = dict["assignUserName"] as! String
            }
            if dict.keys.contains("assignUserPhone") && dict["assignUserPhone"] != nil {
                self.assignUserPhone = dict["assignUserPhone"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("defaultAssignToWho") && dict["defaultAssignToWho"] != nil {
                self.defaultAssignToWho = dict["defaultAssignToWho"] as! Int32
            }
            if dict.keys.contains("defaultAssignToWhoIsValid") && dict["defaultAssignToWhoIsValid"] != nil {
                self.defaultAssignToWhoIsValid = dict["defaultAssignToWhoIsValid"] as! Int32
            }
            if dict.keys.contains("defaultAssignToWhoName") && dict["defaultAssignToWhoName"] != nil {
                self.defaultAssignToWhoName = dict["defaultAssignToWhoName"] as! String
            }
            if dict.keys.contains("durationTime") && dict["durationTime"] != nil {
                self.durationTime = dict["durationTime"] as! String
            }
            if dict.keys.contains("effect") && dict["effect"] != nil {
                self.effect = dict["effect"] as! String
            }
            if dict.keys.contains("incidentDescription") && dict["incidentDescription"] != nil {
                self.incidentDescription = dict["incidentDescription"] as! String
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
                self.incidentLevel = dict["incidentLevel"] as! String
            }
            if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                self.incidentNumber = dict["incidentNumber"] as! String
            }
            if dict.keys.contains("incidentStatus") && dict["incidentStatus"] != nil {
                self.incidentStatus = dict["incidentStatus"] as! String
            }
            if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                self.incidentTitle = dict["incidentTitle"] as! String
            }
            if dict.keys.contains("isManual") && dict["isManual"] != nil {
                self.isManual = dict["isManual"] as! Bool
            }
            if dict.keys.contains("isUpgrade") && dict["isUpgrade"] != nil {
                self.isUpgrade = dict["isUpgrade"] as! Bool
            }
            if dict.keys.contains("notifyChannels") && dict["notifyChannels"] != nil {
                self.notifyChannels = dict["notifyChannels"] as! [String]
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
            if dict.keys.contains("problemNumber") && dict["problemNumber"] != nil {
                self.problemNumber = dict["problemNumber"] as! String
            }
            if dict.keys.contains("relRouteRuleDeleteType") && dict["relRouteRuleDeleteType"] != nil {
                self.relRouteRuleDeleteType = dict["relRouteRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relServiceGroupIsValid") && dict["relServiceGroupIsValid"] != nil {
                self.relServiceGroupIsValid = dict["relServiceGroupIsValid"] as! Int32
            }
            if dict.keys.contains("relatedServiceDescription") && dict["relatedServiceDescription"] != nil {
                self.relatedServiceDescription = dict["relatedServiceDescription"] as! String
            }
            if dict.keys.contains("relatedServiceGroupId") && dict["relatedServiceGroupId"] != nil {
                self.relatedServiceGroupId = dict["relatedServiceGroupId"] as! Int64
            }
            if dict.keys.contains("relatedServiceGroupName") && dict["relatedServiceGroupName"] != nil {
                self.relatedServiceGroupName = dict["relatedServiceGroupName"] as! String
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeRuleName") && dict["routeRuleName"] != nil {
                self.routeRuleName = dict["routeRuleName"] as! String
            }
        }
    }
    public var data: [GetIncidentListByIdListResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetIncidentListByIdListResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetIncidentListByIdListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetIncidentListByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIncidentListByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIncidentListByIdListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIncidentStatisticsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class GetIncidentStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var allFinish: Int32?

        public var allResponse: Int32?

        public var myFinish: Int32?

        public var myResponse: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allFinish != nil {
                map["allFinish"] = self.allFinish!
            }
            if self.allResponse != nil {
                map["allResponse"] = self.allResponse!
            }
            if self.myFinish != nil {
                map["myFinish"] = self.myFinish!
            }
            if self.myResponse != nil {
                map["myResponse"] = self.myResponse!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allFinish") && dict["allFinish"] != nil {
                self.allFinish = dict["allFinish"] as! Int32
            }
            if dict.keys.contains("allResponse") && dict["allResponse"] != nil {
                self.allResponse = dict["allResponse"] as! Int32
            }
            if dict.keys.contains("myFinish") && dict["myFinish"] != nil {
                self.myFinish = dict["myFinish"] as! Int32
            }
            if dict.keys.contains("myResponse") && dict["myResponse"] != nil {
                self.myResponse = dict["myResponse"] as! Int32
            }
        }
    }
    public var data: GetIncidentStatisticsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetIncidentStatisticsResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetIncidentStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIncidentStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIncidentStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIncidentSubtotalCountRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentIds != nil {
            map["incidentIds"] = self.incidentIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentIds") && dict["incidentIds"] != nil {
            self.incidentIds = dict["incidentIds"] as! [Int64]
        }
    }
}

public class GetIncidentSubtotalCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var requestId: String?

        public var subtotalCount: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestId != nil {
                map["requestId"] = self.requestId!
            }
            if self.subtotalCount != nil {
                map["subtotalCount"] = self.subtotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("requestId") && dict["requestId"] != nil {
                self.requestId = dict["requestId"] as! String
            }
            if dict.keys.contains("subtotalCount") && dict["subtotalCount"] != nil {
                self.subtotalCount = dict["subtotalCount"] as! [String: Any]
            }
        }
    }
    public var data: GetIncidentSubtotalCountResponseBody.Data?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetIncidentSubtotalCountResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
    }
}

public class GetIncidentSubtotalCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIncidentSubtotalCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIncidentSubtotalCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class GetIntegrationConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKey: String?

        public var integrationConfigId: Int64?

        public var isReceivedEvent: Bool?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var monitorSourceShortName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKey != nil {
                map["accessKey"] = self.accessKey!
            }
            if self.integrationConfigId != nil {
                map["integrationConfigId"] = self.integrationConfigId!
            }
            if self.isReceivedEvent != nil {
                map["isReceivedEvent"] = self.isReceivedEvent!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.monitorSourceShortName != nil {
                map["monitorSourceShortName"] = self.monitorSourceShortName!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessKey") && dict["accessKey"] != nil {
                self.accessKey = dict["accessKey"] as! String
            }
            if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
                self.integrationConfigId = dict["integrationConfigId"] as! Int64
            }
            if dict.keys.contains("isReceivedEvent") && dict["isReceivedEvent"] != nil {
                self.isReceivedEvent = dict["isReceivedEvent"] as! Bool
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("monitorSourceShortName") && dict["monitorSourceShortName"] != nil {
                self.monitorSourceShortName = dict["monitorSourceShortName"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
        }
    }
    public var data: GetIntegrationConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetIntegrationConfigResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProblemRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class GetProblemResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CancelProblemOperateLogs : Tea.TeaModel {
            public var actionName: String?

            public var actionTime: String?

            public var operator_: String?

            public var userId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["actionName"] = self.actionName!
                }
                if self.actionTime != nil {
                    map["actionTime"] = self.actionTime!
                }
                if self.operator_ != nil {
                    map["operator"] = self.operator_!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("actionName") && dict["actionName"] != nil {
                    self.actionName = dict["actionName"] as! String
                }
                if dict.keys.contains("actionTime") && dict["actionTime"] != nil {
                    self.actionTime = dict["actionTime"] as! String
                }
                if dict.keys.contains("operator") && dict["operator"] != nil {
                    self.operator_ = dict["operator"] as! String
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
            }
        }
        public class CoordinationGroups : Tea.TeaModel {
            public var isValid: Int64?

            public var serviceGroupId: Int64?

            public var serviceGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isValid != nil {
                    map["isValid"] = self.isValid!
                }
                if self.serviceGroupId != nil {
                    map["serviceGroupId"] = self.serviceGroupId!
                }
                if self.serviceGroupName != nil {
                    map["serviceGroupName"] = self.serviceGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("isValid") && dict["isValid"] != nil {
                    self.isValid = dict["isValid"] as! Int64
                }
                if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                    self.serviceGroupId = dict["serviceGroupId"] as! Int64
                }
                if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                    self.serviceGroupName = dict["serviceGroupName"] as! String
                }
            }
        }
        public class EffectionServices : Tea.TeaModel {
            public var description_: String?

            public var effectionLevel: Int64?

            public var effectionServiceId: Int64?

            public var effectionStatus: Int32?

            public var serviceDeleteType: Int32?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.effectionLevel != nil {
                    map["effectionLevel"] = self.effectionLevel!
                }
                if self.effectionServiceId != nil {
                    map["effectionServiceId"] = self.effectionServiceId!
                }
                if self.effectionStatus != nil {
                    map["effectionStatus"] = self.effectionStatus!
                }
                if self.serviceDeleteType != nil {
                    map["serviceDeleteType"] = self.serviceDeleteType!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("description") && dict["description"] != nil {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("effectionLevel") && dict["effectionLevel"] != nil {
                    self.effectionLevel = dict["effectionLevel"] as! Int64
                }
                if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
                    self.effectionServiceId = dict["effectionServiceId"] as! Int64
                }
                if dict.keys.contains("effectionStatus") && dict["effectionStatus"] != nil {
                    self.effectionStatus = dict["effectionStatus"] as! Int32
                }
                if dict.keys.contains("serviceDeleteType") && dict["serviceDeleteType"] != nil {
                    self.serviceDeleteType = dict["serviceDeleteType"] as! Int32
                }
                if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                    self.serviceName = dict["serviceName"] as! String
                }
            }
        }
        public class HandingProblemOperateLogs : Tea.TeaModel {
            public var actionName: String?

            public var actionTime: String?

            public var operator_: String?

            public var userId: Int64?

            public var userIsValid: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["actionName"] = self.actionName!
                }
                if self.actionTime != nil {
                    map["actionTime"] = self.actionTime!
                }
                if self.operator_ != nil {
                    map["operator"] = self.operator_!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userIsValid != nil {
                    map["userIsValid"] = self.userIsValid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("actionName") && dict["actionName"] != nil {
                    self.actionName = dict["actionName"] as! String
                }
                if dict.keys.contains("actionTime") && dict["actionTime"] != nil {
                    self.actionTime = dict["actionTime"] as! String
                }
                if dict.keys.contains("operator") && dict["operator"] != nil {
                    self.operator_ = dict["operator"] as! String
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userIsValid") && dict["userIsValid"] != nil {
                    self.userIsValid = dict["userIsValid"] as! Int64
                }
            }
        }
        public class ReplayProblemOperateLogs : Tea.TeaModel {
            public var actionName: String?

            public var actionTime: String?

            public var operator_: String?

            public var userId: Int64?

            public var userIsValid: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["actionName"] = self.actionName!
                }
                if self.actionTime != nil {
                    map["actionTime"] = self.actionTime!
                }
                if self.operator_ != nil {
                    map["operator"] = self.operator_!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userIsValid != nil {
                    map["userIsValid"] = self.userIsValid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("actionName") && dict["actionName"] != nil {
                    self.actionName = dict["actionName"] as! String
                }
                if dict.keys.contains("actionTime") && dict["actionTime"] != nil {
                    self.actionTime = dict["actionTime"] as! String
                }
                if dict.keys.contains("operator") && dict["operator"] != nil {
                    self.operator_ = dict["operator"] as! String
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userIsValid") && dict["userIsValid"] != nil {
                    self.userIsValid = dict["userIsValid"] as! Int64
                }
            }
        }
        public class ReplayingProblemOperateLogs : Tea.TeaModel {
            public var actionName: String?

            public var actionTime: String?

            public var operator_: String?

            public var userId: Int64?

            public var userIsValid: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["actionName"] = self.actionName!
                }
                if self.actionTime != nil {
                    map["actionTime"] = self.actionTime!
                }
                if self.operator_ != nil {
                    map["operator"] = self.operator_!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userIsValid != nil {
                    map["userIsValid"] = self.userIsValid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("actionName") && dict["actionName"] != nil {
                    self.actionName = dict["actionName"] as! String
                }
                if dict.keys.contains("actionTime") && dict["actionTime"] != nil {
                    self.actionTime = dict["actionTime"] as! String
                }
                if dict.keys.contains("operator") && dict["operator"] != nil {
                    self.operator_ = dict["operator"] as! String
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userIsValid") && dict["userIsValid"] != nil {
                    self.userIsValid = dict["userIsValid"] as! Int64
                }
            }
        }
        public class RestoredProblemOperateLogs : Tea.TeaModel {
            public var actionName: String?

            public var actionTime: String?

            public var operator_: String?

            public var userId: Int64?

            public var userIsValid: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionName != nil {
                    map["actionName"] = self.actionName!
                }
                if self.actionTime != nil {
                    map["actionTime"] = self.actionTime!
                }
                if self.operator_ != nil {
                    map["operator"] = self.operator_!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userIsValid != nil {
                    map["userIsValid"] = self.userIsValid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("actionName") && dict["actionName"] != nil {
                    self.actionName = dict["actionName"] as! String
                }
                if dict.keys.contains("actionTime") && dict["actionTime"] != nil {
                    self.actionTime = dict["actionTime"] as! String
                }
                if dict.keys.contains("operator") && dict["operator"] != nil {
                    self.operator_ = dict["operator"] as! String
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userIsValid") && dict["userIsValid"] != nil {
                    self.userIsValid = dict["userIsValid"] as! Int64
                }
            }
        }
        public class Timelines : Tea.TeaModel {
            public var keyNode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyNode != nil {
                    map["keyNode"] = self.keyNode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("keyNode") && dict["keyNode"] != nil {
                    self.keyNode = dict["keyNode"] as! String
                }
            }
        }
        public var cancelProblemOperateLogs: [GetProblemResponseBody.Data.CancelProblemOperateLogs]?

        public var cancelReason: Int64?

        public var cancelReasonDescription: String?

        public var coordinationGroups: [GetProblemResponseBody.Data.CoordinationGroups]?

        public var createTime: String?

        public var discoverTime: String?

        public var durationTime: Int64?

        public var effectionServices: [GetProblemResponseBody.Data.EffectionServices]?

        public var feedback: String?

        public var handingProblemOperateLogs: [GetProblemResponseBody.Data.HandingProblemOperateLogs]?

        public var incidentId: Int64?

        public var incidentNumber: String?

        public var isRuleTrigger: Bool?

        public var mainHandler: Int64?

        public var mainHandlerId: Int64?

        public var mainHandlerIsValid: Int64?

        public var mainHandlerPhone: String?

        public var preliminaryReason: String?

        public var problemId: Int64?

        public var problemLevel: Int32?

        public var problemName: String?

        public var problemNumber: String?

        public var problemStatus: Int32?

        public var progressSummary: String?

        public var progressSummaryRichTextId: Int64?

        public var recoveryTime: String?

        public var relatedServiceId: Int64?

        public var replayProblemOperateLogs: [GetProblemResponseBody.Data.ReplayProblemOperateLogs]?

        public var replayingProblemOperateLogs: [GetProblemResponseBody.Data.ReplayingProblemOperateLogs]?

        public var restoredProblemOperateLogs: [GetProblemResponseBody.Data.RestoredProblemOperateLogs]?

        public var serviceDeleteType: Int32?

        public var serviceName: String?

        public var timelines: [GetProblemResponseBody.Data.Timelines]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cancelProblemOperateLogs != nil {
                var tmp : [Any] = []
                for k in self.cancelProblemOperateLogs! {
                    tmp.append(k.toMap())
                }
                map["cancelProblemOperateLogs"] = tmp
            }
            if self.cancelReason != nil {
                map["cancelReason"] = self.cancelReason!
            }
            if self.cancelReasonDescription != nil {
                map["cancelReasonDescription"] = self.cancelReasonDescription!
            }
            if self.coordinationGroups != nil {
                var tmp : [Any] = []
                for k in self.coordinationGroups! {
                    tmp.append(k.toMap())
                }
                map["coordinationGroups"] = tmp
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.discoverTime != nil {
                map["discoverTime"] = self.discoverTime!
            }
            if self.durationTime != nil {
                map["durationTime"] = self.durationTime!
            }
            if self.effectionServices != nil {
                var tmp : [Any] = []
                for k in self.effectionServices! {
                    tmp.append(k.toMap())
                }
                map["effectionServices"] = tmp
            }
            if self.feedback != nil {
                map["feedback"] = self.feedback!
            }
            if self.handingProblemOperateLogs != nil {
                var tmp : [Any] = []
                for k in self.handingProblemOperateLogs! {
                    tmp.append(k.toMap())
                }
                map["handingProblemOperateLogs"] = tmp
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.incidentNumber != nil {
                map["incidentNumber"] = self.incidentNumber!
            }
            if self.isRuleTrigger != nil {
                map["isRuleTrigger"] = self.isRuleTrigger!
            }
            if self.mainHandler != nil {
                map["mainHandler"] = self.mainHandler!
            }
            if self.mainHandlerId != nil {
                map["mainHandlerId"] = self.mainHandlerId!
            }
            if self.mainHandlerIsValid != nil {
                map["mainHandlerIsValid"] = self.mainHandlerIsValid!
            }
            if self.mainHandlerPhone != nil {
                map["mainHandlerPhone"] = self.mainHandlerPhone!
            }
            if self.preliminaryReason != nil {
                map["preliminaryReason"] = self.preliminaryReason!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemLevel != nil {
                map["problemLevel"] = self.problemLevel!
            }
            if self.problemName != nil {
                map["problemName"] = self.problemName!
            }
            if self.problemNumber != nil {
                map["problemNumber"] = self.problemNumber!
            }
            if self.problemStatus != nil {
                map["problemStatus"] = self.problemStatus!
            }
            if self.progressSummary != nil {
                map["progressSummary"] = self.progressSummary!
            }
            if self.progressSummaryRichTextId != nil {
                map["progressSummaryRichTextId"] = self.progressSummaryRichTextId!
            }
            if self.recoveryTime != nil {
                map["recoveryTime"] = self.recoveryTime!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.replayProblemOperateLogs != nil {
                var tmp : [Any] = []
                for k in self.replayProblemOperateLogs! {
                    tmp.append(k.toMap())
                }
                map["replayProblemOperateLogs"] = tmp
            }
            if self.replayingProblemOperateLogs != nil {
                var tmp : [Any] = []
                for k in self.replayingProblemOperateLogs! {
                    tmp.append(k.toMap())
                }
                map["replayingProblemOperateLogs"] = tmp
            }
            if self.restoredProblemOperateLogs != nil {
                var tmp : [Any] = []
                for k in self.restoredProblemOperateLogs! {
                    tmp.append(k.toMap())
                }
                map["restoredProblemOperateLogs"] = tmp
            }
            if self.serviceDeleteType != nil {
                map["serviceDeleteType"] = self.serviceDeleteType!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.timelines != nil {
                var tmp : [Any] = []
                for k in self.timelines! {
                    tmp.append(k.toMap())
                }
                map["timelines"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cancelProblemOperateLogs") && dict["cancelProblemOperateLogs"] != nil {
                var tmp : [GetProblemResponseBody.Data.CancelProblemOperateLogs] = []
                for v in dict["cancelProblemOperateLogs"] as! [Any] {
                    var model = GetProblemResponseBody.Data.CancelProblemOperateLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cancelProblemOperateLogs = tmp
            }
            if dict.keys.contains("cancelReason") && dict["cancelReason"] != nil {
                self.cancelReason = dict["cancelReason"] as! Int64
            }
            if dict.keys.contains("cancelReasonDescription") && dict["cancelReasonDescription"] != nil {
                self.cancelReasonDescription = dict["cancelReasonDescription"] as! String
            }
            if dict.keys.contains("coordinationGroups") && dict["coordinationGroups"] != nil {
                var tmp : [GetProblemResponseBody.Data.CoordinationGroups] = []
                for v in dict["coordinationGroups"] as! [Any] {
                    var model = GetProblemResponseBody.Data.CoordinationGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.coordinationGroups = tmp
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("discoverTime") && dict["discoverTime"] != nil {
                self.discoverTime = dict["discoverTime"] as! String
            }
            if dict.keys.contains("durationTime") && dict["durationTime"] != nil {
                self.durationTime = dict["durationTime"] as! Int64
            }
            if dict.keys.contains("effectionServices") && dict["effectionServices"] != nil {
                var tmp : [GetProblemResponseBody.Data.EffectionServices] = []
                for v in dict["effectionServices"] as! [Any] {
                    var model = GetProblemResponseBody.Data.EffectionServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.effectionServices = tmp
            }
            if dict.keys.contains("feedback") && dict["feedback"] != nil {
                self.feedback = dict["feedback"] as! String
            }
            if dict.keys.contains("handingProblemOperateLogs") && dict["handingProblemOperateLogs"] != nil {
                var tmp : [GetProblemResponseBody.Data.HandingProblemOperateLogs] = []
                for v in dict["handingProblemOperateLogs"] as! [Any] {
                    var model = GetProblemResponseBody.Data.HandingProblemOperateLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.handingProblemOperateLogs = tmp
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                self.incidentNumber = dict["incidentNumber"] as! String
            }
            if dict.keys.contains("isRuleTrigger") && dict["isRuleTrigger"] != nil {
                self.isRuleTrigger = dict["isRuleTrigger"] as! Bool
            }
            if dict.keys.contains("mainHandler") && dict["mainHandler"] != nil {
                self.mainHandler = dict["mainHandler"] as! Int64
            }
            if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
                self.mainHandlerId = dict["mainHandlerId"] as! Int64
            }
            if dict.keys.contains("mainHandlerIsValid") && dict["mainHandlerIsValid"] != nil {
                self.mainHandlerIsValid = dict["mainHandlerIsValid"] as! Int64
            }
            if dict.keys.contains("mainHandlerPhone") && dict["mainHandlerPhone"] != nil {
                self.mainHandlerPhone = dict["mainHandlerPhone"] as! String
            }
            if dict.keys.contains("preliminaryReason") && dict["preliminaryReason"] != nil {
                self.preliminaryReason = dict["preliminaryReason"] as! String
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
            if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                self.problemLevel = dict["problemLevel"] as! Int32
            }
            if dict.keys.contains("problemName") && dict["problemName"] != nil {
                self.problemName = dict["problemName"] as! String
            }
            if dict.keys.contains("problemNumber") && dict["problemNumber"] != nil {
                self.problemNumber = dict["problemNumber"] as! String
            }
            if dict.keys.contains("problemStatus") && dict["problemStatus"] != nil {
                self.problemStatus = dict["problemStatus"] as! Int32
            }
            if dict.keys.contains("progressSummary") && dict["progressSummary"] != nil {
                self.progressSummary = dict["progressSummary"] as! String
            }
            if dict.keys.contains("progressSummaryRichTextId") && dict["progressSummaryRichTextId"] != nil {
                self.progressSummaryRichTextId = dict["progressSummaryRichTextId"] as! Int64
            }
            if dict.keys.contains("recoveryTime") && dict["recoveryTime"] != nil {
                self.recoveryTime = dict["recoveryTime"] as! String
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("replayProblemOperateLogs") && dict["replayProblemOperateLogs"] != nil {
                var tmp : [GetProblemResponseBody.Data.ReplayProblemOperateLogs] = []
                for v in dict["replayProblemOperateLogs"] as! [Any] {
                    var model = GetProblemResponseBody.Data.ReplayProblemOperateLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.replayProblemOperateLogs = tmp
            }
            if dict.keys.contains("replayingProblemOperateLogs") && dict["replayingProblemOperateLogs"] != nil {
                var tmp : [GetProblemResponseBody.Data.ReplayingProblemOperateLogs] = []
                for v in dict["replayingProblemOperateLogs"] as! [Any] {
                    var model = GetProblemResponseBody.Data.ReplayingProblemOperateLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.replayingProblemOperateLogs = tmp
            }
            if dict.keys.contains("restoredProblemOperateLogs") && dict["restoredProblemOperateLogs"] != nil {
                var tmp : [GetProblemResponseBody.Data.RestoredProblemOperateLogs] = []
                for v in dict["restoredProblemOperateLogs"] as! [Any] {
                    var model = GetProblemResponseBody.Data.RestoredProblemOperateLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.restoredProblemOperateLogs = tmp
            }
            if dict.keys.contains("serviceDeleteType") && dict["serviceDeleteType"] != nil {
                self.serviceDeleteType = dict["serviceDeleteType"] as! Int32
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("timelines") && dict["timelines"] != nil {
                var tmp : [GetProblemResponseBody.Data.Timelines] = []
                for v in dict["timelines"] as! [Any] {
                    var model = GetProblemResponseBody.Data.Timelines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.timelines = tmp
            }
        }
    }
    public var data: GetProblemResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetProblemResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProblemEffectionServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var effectionServiceId: Int64?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.effectionServiceId != nil {
            map["effectionServiceId"] = self.effectionServiceId!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
            self.effectionServiceId = dict["effectionServiceId"] as! Int64
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class GetProblemEffectionServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var effectionServiceId: Int64?

        public var level: Int64?

        public var picUrl: [String]?

        public var serviceId: Int64?

        public var serviceName: String?

        public var status: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.effectionServiceId != nil {
                map["effectionServiceId"] = self.effectionServiceId!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.picUrl != nil {
                map["picUrl"] = self.picUrl!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
                self.effectionServiceId = dict["effectionServiceId"] as! Int64
            }
            if dict.keys.contains("level") && dict["level"] != nil {
                self.level = dict["level"] as! Int64
            }
            if dict.keys.contains("picUrl") && dict["picUrl"] != nil {
                self.picUrl = dict["picUrl"] as! [String]
            }
            if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                self.serviceId = dict["serviceId"] as! Int64
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! Int64
            }
        }
    }
    public var data: GetProblemEffectionServiceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetProblemEffectionServiceResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetProblemEffectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProblemEffectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProblemEffectionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProblemImprovementRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! String
        }
    }
}

public class GetProblemImprovementResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class MeasureList : Tea.TeaModel {
            public var checkStandard: String?

            public var checkUserId: Int64?

            public var checkUserIsValid: Int32?

            public var checkUserName: String?

            public var content: String?

            public var directorId: Int64?

            public var directorIsValid: Int32?

            public var directorName: String?

            public var measureId: Int64?

            public var planFinishTime: String?

            public var stalkerId: Int64?

            public var stalkerIsValid: Int32?

            public var stalkerName: String?

            public var status: String?

            public var type: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkStandard != nil {
                    map["checkStandard"] = self.checkStandard!
                }
                if self.checkUserId != nil {
                    map["checkUserId"] = self.checkUserId!
                }
                if self.checkUserIsValid != nil {
                    map["checkUserIsValid"] = self.checkUserIsValid!
                }
                if self.checkUserName != nil {
                    map["checkUserName"] = self.checkUserName!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.directorId != nil {
                    map["directorId"] = self.directorId!
                }
                if self.directorIsValid != nil {
                    map["directorIsValid"] = self.directorIsValid!
                }
                if self.directorName != nil {
                    map["directorName"] = self.directorName!
                }
                if self.measureId != nil {
                    map["measureId"] = self.measureId!
                }
                if self.planFinishTime != nil {
                    map["planFinishTime"] = self.planFinishTime!
                }
                if self.stalkerId != nil {
                    map["stalkerId"] = self.stalkerId!
                }
                if self.stalkerIsValid != nil {
                    map["stalkerIsValid"] = self.stalkerIsValid!
                }
                if self.stalkerName != nil {
                    map["stalkerName"] = self.stalkerName!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkStandard") && dict["checkStandard"] != nil {
                    self.checkStandard = dict["checkStandard"] as! String
                }
                if dict.keys.contains("checkUserId") && dict["checkUserId"] != nil {
                    self.checkUserId = dict["checkUserId"] as! Int64
                }
                if dict.keys.contains("checkUserIsValid") && dict["checkUserIsValid"] != nil {
                    self.checkUserIsValid = dict["checkUserIsValid"] as! Int32
                }
                if dict.keys.contains("checkUserName") && dict["checkUserName"] != nil {
                    self.checkUserName = dict["checkUserName"] as! String
                }
                if dict.keys.contains("content") && dict["content"] != nil {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("directorId") && dict["directorId"] != nil {
                    self.directorId = dict["directorId"] as! Int64
                }
                if dict.keys.contains("directorIsValid") && dict["directorIsValid"] != nil {
                    self.directorIsValid = dict["directorIsValid"] as! Int32
                }
                if dict.keys.contains("directorName") && dict["directorName"] != nil {
                    self.directorName = dict["directorName"] as! String
                }
                if dict.keys.contains("measureId") && dict["measureId"] != nil {
                    self.measureId = dict["measureId"] as! Int64
                }
                if dict.keys.contains("planFinishTime") && dict["planFinishTime"] != nil {
                    self.planFinishTime = dict["planFinishTime"] as! String
                }
                if dict.keys.contains("stalkerId") && dict["stalkerId"] != nil {
                    self.stalkerId = dict["stalkerId"] as! Int64
                }
                if dict.keys.contains("stalkerIsValid") && dict["stalkerIsValid"] != nil {
                    self.stalkerIsValid = dict["stalkerIsValid"] as! Int32
                }
                if dict.keys.contains("stalkerName") && dict["stalkerName"] != nil {
                    self.stalkerName = dict["stalkerName"] as! String
                }
                if dict.keys.contains("status") && dict["status"] != nil {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("type") && dict["type"] != nil {
                    self.type = dict["type"] as! Int64
                }
            }
        }
        public var customProblemReason: String?

        public var discoverSource: String?

        public var dutyDepartmentId: String?

        public var dutyDepartmentName: String?

        public var dutyUserId: Int64?

        public var dutyUserIsValid: Int64?

        public var dutyUserName: String?

        public var dutyUserPhone: String?

        public var injectionMode: String?

        public var isManual: Bool?

        public var measureList: [GetProblemImprovementResponseBody.Data.MeasureList]?

        public var monitorSourceName: String?

        public var problemId: String?

        public var problemReason: String?

        public var recentActivity: String?

        public var recoveryMode: String?

        public var relationChanges: String?

        public var remark: String?

        public var replayDutyUserId: Int64?

        public var replayDutyUserIsValid: Int64?

        public var replayDutyUserName: String?

        public var replayDutyUserPhone: String?

        public var userReport: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customProblemReason != nil {
                map["customProblemReason"] = self.customProblemReason!
            }
            if self.discoverSource != nil {
                map["discoverSource"] = self.discoverSource!
            }
            if self.dutyDepartmentId != nil {
                map["dutyDepartmentId"] = self.dutyDepartmentId!
            }
            if self.dutyDepartmentName != nil {
                map["dutyDepartmentName"] = self.dutyDepartmentName!
            }
            if self.dutyUserId != nil {
                map["dutyUserId"] = self.dutyUserId!
            }
            if self.dutyUserIsValid != nil {
                map["dutyUserIsValid"] = self.dutyUserIsValid!
            }
            if self.dutyUserName != nil {
                map["dutyUserName"] = self.dutyUserName!
            }
            if self.dutyUserPhone != nil {
                map["dutyUserPhone"] = self.dutyUserPhone!
            }
            if self.injectionMode != nil {
                map["injectionMode"] = self.injectionMode!
            }
            if self.isManual != nil {
                map["isManual"] = self.isManual!
            }
            if self.measureList != nil {
                var tmp : [Any] = []
                for k in self.measureList! {
                    tmp.append(k.toMap())
                }
                map["measureList"] = tmp
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemReason != nil {
                map["problemReason"] = self.problemReason!
            }
            if self.recentActivity != nil {
                map["recentActivity"] = self.recentActivity!
            }
            if self.recoveryMode != nil {
                map["recoveryMode"] = self.recoveryMode!
            }
            if self.relationChanges != nil {
                map["relationChanges"] = self.relationChanges!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.replayDutyUserId != nil {
                map["replayDutyUserId"] = self.replayDutyUserId!
            }
            if self.replayDutyUserIsValid != nil {
                map["replayDutyUserIsValid"] = self.replayDutyUserIsValid!
            }
            if self.replayDutyUserName != nil {
                map["replayDutyUserName"] = self.replayDutyUserName!
            }
            if self.replayDutyUserPhone != nil {
                map["replayDutyUserPhone"] = self.replayDutyUserPhone!
            }
            if self.userReport != nil {
                map["userReport"] = self.userReport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("customProblemReason") && dict["customProblemReason"] != nil {
                self.customProblemReason = dict["customProblemReason"] as! String
            }
            if dict.keys.contains("discoverSource") && dict["discoverSource"] != nil {
                self.discoverSource = dict["discoverSource"] as! String
            }
            if dict.keys.contains("dutyDepartmentId") && dict["dutyDepartmentId"] != nil {
                self.dutyDepartmentId = dict["dutyDepartmentId"] as! String
            }
            if dict.keys.contains("dutyDepartmentName") && dict["dutyDepartmentName"] != nil {
                self.dutyDepartmentName = dict["dutyDepartmentName"] as! String
            }
            if dict.keys.contains("dutyUserId") && dict["dutyUserId"] != nil {
                self.dutyUserId = dict["dutyUserId"] as! Int64
            }
            if dict.keys.contains("dutyUserIsValid") && dict["dutyUserIsValid"] != nil {
                self.dutyUserIsValid = dict["dutyUserIsValid"] as! Int64
            }
            if dict.keys.contains("dutyUserName") && dict["dutyUserName"] != nil {
                self.dutyUserName = dict["dutyUserName"] as! String
            }
            if dict.keys.contains("dutyUserPhone") && dict["dutyUserPhone"] != nil {
                self.dutyUserPhone = dict["dutyUserPhone"] as! String
            }
            if dict.keys.contains("injectionMode") && dict["injectionMode"] != nil {
                self.injectionMode = dict["injectionMode"] as! String
            }
            if dict.keys.contains("isManual") && dict["isManual"] != nil {
                self.isManual = dict["isManual"] as! Bool
            }
            if dict.keys.contains("measureList") && dict["measureList"] != nil {
                var tmp : [GetProblemImprovementResponseBody.Data.MeasureList] = []
                for v in dict["measureList"] as! [Any] {
                    var model = GetProblemImprovementResponseBody.Data.MeasureList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.measureList = tmp
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! String
            }
            if dict.keys.contains("problemReason") && dict["problemReason"] != nil {
                self.problemReason = dict["problemReason"] as! String
            }
            if dict.keys.contains("recentActivity") && dict["recentActivity"] != nil {
                self.recentActivity = dict["recentActivity"] as! String
            }
            if dict.keys.contains("recoveryMode") && dict["recoveryMode"] != nil {
                self.recoveryMode = dict["recoveryMode"] as! String
            }
            if dict.keys.contains("relationChanges") && dict["relationChanges"] != nil {
                self.relationChanges = dict["relationChanges"] as! String
            }
            if dict.keys.contains("remark") && dict["remark"] != nil {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("replayDutyUserId") && dict["replayDutyUserId"] != nil {
                self.replayDutyUserId = dict["replayDutyUserId"] as! Int64
            }
            if dict.keys.contains("replayDutyUserIsValid") && dict["replayDutyUserIsValid"] != nil {
                self.replayDutyUserIsValid = dict["replayDutyUserIsValid"] as! Int64
            }
            if dict.keys.contains("replayDutyUserName") && dict["replayDutyUserName"] != nil {
                self.replayDutyUserName = dict["replayDutyUserName"] as! String
            }
            if dict.keys.contains("replayDutyUserPhone") && dict["replayDutyUserPhone"] != nil {
                self.replayDutyUserPhone = dict["replayDutyUserPhone"] as! String
            }
            if dict.keys.contains("userReport") && dict["userReport"] != nil {
                self.userReport = dict["userReport"] as! Int64
            }
        }
    }
    public var data: GetProblemImprovementResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetProblemImprovementResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetProblemImprovementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProblemImprovementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProblemImprovementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProblemPreviewRequest : Tea.TeaModel {
    public var clientToken: String?

    public var effectServiceIds: [Int64]?

    public var incidentId: Int64?

    public var problemId: Int64?

    public var problemLevel: String?

    public var problemNotifyType: String?

    public var relatedServiceId: Int64?

    public var serviceGroupIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.effectServiceIds != nil {
            map["effectServiceIds"] = self.effectServiceIds!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemLevel != nil {
            map["problemLevel"] = self.problemLevel!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.serviceGroupIds != nil {
            map["serviceGroupIds"] = self.serviceGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("effectServiceIds") && dict["effectServiceIds"] != nil {
            self.effectServiceIds = dict["effectServiceIds"] as! [Int64]
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
            self.problemLevel = dict["problemLevel"] as! String
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! String
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
            self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
        }
    }
}

public class GetProblemPreviewResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Mail : Tea.TeaModel {
            public class Users : Tea.TeaModel {
                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("username") && dict["username"] != nil {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var count: Int64?

            public var users: [GetProblemPreviewResponseBody.Data.Mail.Users]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.users != nil {
                    var tmp : [Any] = []
                    for k in self.users! {
                        tmp.append(k.toMap())
                    }
                    map["users"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") && dict["count"] != nil {
                    self.count = dict["count"] as! Int64
                }
                if dict.keys.contains("users") && dict["users"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Mail.Users] = []
                    for v in dict["users"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Mail.Users()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.users = tmp
                }
            }
        }
        public class Problem : Tea.TeaModel {
            public class CoordinationGroups : Tea.TeaModel {
                public var serviceGroupDescription: String?

                public var serviceGroupId: Int64?

                public var serviceGroupName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serviceGroupDescription != nil {
                        map["serviceGroupDescription"] = self.serviceGroupDescription!
                    }
                    if self.serviceGroupId != nil {
                        map["serviceGroupId"] = self.serviceGroupId!
                    }
                    if self.serviceGroupName != nil {
                        map["serviceGroupName"] = self.serviceGroupName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
                        self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
                    }
                    if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                        self.serviceGroupId = dict["serviceGroupId"] as! Int64
                    }
                    if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                        self.serviceGroupName = dict["serviceGroupName"] as! String
                    }
                }
            }
            public class EffectionServices : Tea.TeaModel {
                public var serviceId: Int64?

                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serviceId != nil {
                        map["serviceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                        self.serviceId = dict["serviceId"] as! Int64
                    }
                    if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                        self.serviceName = dict["serviceName"] as! String
                    }
                }
            }
            public var coordinationGroups: [GetProblemPreviewResponseBody.Data.Problem.CoordinationGroups]?

            public var createTime: String?

            public var discoverTime: String?

            public var effectionServices: [GetProblemPreviewResponseBody.Data.Problem.EffectionServices]?

            public var isManual: Bool?

            public var isUpgrade: Bool?

            public var mainHandlerId: String?

            public var mainHandlerName: String?

            public var preliminaryReason: String?

            public var problemId: Int64?

            public var problemLevel: String?

            public var problemName: String?

            public var problemStatus: String?

            public var progressSummary: String?

            public var progressSummaryRichTextId: Int64?

            public var recoveryTime: String?

            public var relatedServiceId: Int64?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coordinationGroups != nil {
                    var tmp : [Any] = []
                    for k in self.coordinationGroups! {
                        tmp.append(k.toMap())
                    }
                    map["coordinationGroups"] = tmp
                }
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.discoverTime != nil {
                    map["discoverTime"] = self.discoverTime!
                }
                if self.effectionServices != nil {
                    var tmp : [Any] = []
                    for k in self.effectionServices! {
                        tmp.append(k.toMap())
                    }
                    map["effectionServices"] = tmp
                }
                if self.isManual != nil {
                    map["isManual"] = self.isManual!
                }
                if self.isUpgrade != nil {
                    map["isUpgrade"] = self.isUpgrade!
                }
                if self.mainHandlerId != nil {
                    map["mainHandlerId"] = self.mainHandlerId!
                }
                if self.mainHandlerName != nil {
                    map["mainHandlerName"] = self.mainHandlerName!
                }
                if self.preliminaryReason != nil {
                    map["preliminaryReason"] = self.preliminaryReason!
                }
                if self.problemId != nil {
                    map["problemId"] = self.problemId!
                }
                if self.problemLevel != nil {
                    map["problemLevel"] = self.problemLevel!
                }
                if self.problemName != nil {
                    map["problemName"] = self.problemName!
                }
                if self.problemStatus != nil {
                    map["problemStatus"] = self.problemStatus!
                }
                if self.progressSummary != nil {
                    map["progressSummary"] = self.progressSummary!
                }
                if self.progressSummaryRichTextId != nil {
                    map["progressSummaryRichTextId"] = self.progressSummaryRichTextId!
                }
                if self.recoveryTime != nil {
                    map["recoveryTime"] = self.recoveryTime!
                }
                if self.relatedServiceId != nil {
                    map["relatedServiceId"] = self.relatedServiceId!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("coordinationGroups") && dict["coordinationGroups"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Problem.CoordinationGroups] = []
                    for v in dict["coordinationGroups"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Problem.CoordinationGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.coordinationGroups = tmp
                }
                if dict.keys.contains("createTime") && dict["createTime"] != nil {
                    self.createTime = dict["createTime"] as! String
                }
                if dict.keys.contains("discoverTime") && dict["discoverTime"] != nil {
                    self.discoverTime = dict["discoverTime"] as! String
                }
                if dict.keys.contains("effectionServices") && dict["effectionServices"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Problem.EffectionServices] = []
                    for v in dict["effectionServices"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Problem.EffectionServices()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.effectionServices = tmp
                }
                if dict.keys.contains("isManual") && dict["isManual"] != nil {
                    self.isManual = dict["isManual"] as! Bool
                }
                if dict.keys.contains("isUpgrade") && dict["isUpgrade"] != nil {
                    self.isUpgrade = dict["isUpgrade"] as! Bool
                }
                if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
                    self.mainHandlerId = dict["mainHandlerId"] as! String
                }
                if dict.keys.contains("mainHandlerName") && dict["mainHandlerName"] != nil {
                    self.mainHandlerName = dict["mainHandlerName"] as! String
                }
                if dict.keys.contains("preliminaryReason") && dict["preliminaryReason"] != nil {
                    self.preliminaryReason = dict["preliminaryReason"] as! String
                }
                if dict.keys.contains("problemId") && dict["problemId"] != nil {
                    self.problemId = dict["problemId"] as! Int64
                }
                if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                    self.problemLevel = dict["problemLevel"] as! String
                }
                if dict.keys.contains("problemName") && dict["problemName"] != nil {
                    self.problemName = dict["problemName"] as! String
                }
                if dict.keys.contains("problemStatus") && dict["problemStatus"] != nil {
                    self.problemStatus = dict["problemStatus"] as! String
                }
                if dict.keys.contains("progressSummary") && dict["progressSummary"] != nil {
                    self.progressSummary = dict["progressSummary"] as! String
                }
                if dict.keys.contains("progressSummaryRichTextId") && dict["progressSummaryRichTextId"] != nil {
                    self.progressSummaryRichTextId = dict["progressSummaryRichTextId"] as! Int64
                }
                if dict.keys.contains("recoveryTime") && dict["recoveryTime"] != nil {
                    self.recoveryTime = dict["recoveryTime"] as! String
                }
                if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                    self.relatedServiceId = dict["relatedServiceId"] as! Int64
                }
                if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                    self.serviceName = dict["serviceName"] as! String
                }
            }
        }
        public class Sms : Tea.TeaModel {
            public class Users : Tea.TeaModel {
                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("username") && dict["username"] != nil {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var count: Int64?

            public var users: [GetProblemPreviewResponseBody.Data.Sms.Users]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.users != nil {
                    var tmp : [Any] = []
                    for k in self.users! {
                        tmp.append(k.toMap())
                    }
                    map["users"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") && dict["count"] != nil {
                    self.count = dict["count"] as! Int64
                }
                if dict.keys.contains("users") && dict["users"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Sms.Users] = []
                    for v in dict["users"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Sms.Users()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.users = tmp
                }
            }
        }
        public class Voice : Tea.TeaModel {
            public class Users : Tea.TeaModel {
                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("username") && dict["username"] != nil {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var count: Int64?

            public var users: [GetProblemPreviewResponseBody.Data.Voice.Users]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.users != nil {
                    var tmp : [Any] = []
                    for k in self.users! {
                        tmp.append(k.toMap())
                    }
                    map["users"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") && dict["count"] != nil {
                    self.count = dict["count"] as! Int64
                }
                if dict.keys.contains("users") && dict["users"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Voice.Users] = []
                    for v in dict["users"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Voice.Users()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.users = tmp
                }
            }
        }
        public class Webhook : Tea.TeaModel {
            public class ServiceGroups : Tea.TeaModel {
                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                        self.serviceName = dict["serviceName"] as! String
                    }
                }
            }
            public var count: Int64?

            public var serviceGroups: [GetProblemPreviewResponseBody.Data.Webhook.ServiceGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.serviceGroups != nil {
                    var tmp : [Any] = []
                    for k in self.serviceGroups! {
                        tmp.append(k.toMap())
                    }
                    map["serviceGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") && dict["count"] != nil {
                    self.count = dict["count"] as! Int64
                }
                if dict.keys.contains("serviceGroups") && dict["serviceGroups"] != nil {
                    var tmp : [GetProblemPreviewResponseBody.Data.Webhook.ServiceGroups] = []
                    for v in dict["serviceGroups"] as! [Any] {
                        var model = GetProblemPreviewResponseBody.Data.Webhook.ServiceGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceGroups = tmp
                }
            }
        }
        public var deAfterData: String?

        public var deBeforeData: String?

        public var mail: GetProblemPreviewResponseBody.Data.Mail?

        public var problem: GetProblemPreviewResponseBody.Data.Problem?

        public var sms: GetProblemPreviewResponseBody.Data.Sms?

        public var upAfterData: String?

        public var upBeforeData: String?

        public var voice: GetProblemPreviewResponseBody.Data.Voice?

        public var webhook: GetProblemPreviewResponseBody.Data.Webhook?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mail?.validate()
            try self.problem?.validate()
            try self.sms?.validate()
            try self.voice?.validate()
            try self.webhook?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deAfterData != nil {
                map["deAfterData"] = self.deAfterData!
            }
            if self.deBeforeData != nil {
                map["deBeforeData"] = self.deBeforeData!
            }
            if self.mail != nil {
                map["mail"] = self.mail?.toMap()
            }
            if self.problem != nil {
                map["problem"] = self.problem?.toMap()
            }
            if self.sms != nil {
                map["sms"] = self.sms?.toMap()
            }
            if self.upAfterData != nil {
                map["upAfterData"] = self.upAfterData!
            }
            if self.upBeforeData != nil {
                map["upBeforeData"] = self.upBeforeData!
            }
            if self.voice != nil {
                map["voice"] = self.voice?.toMap()
            }
            if self.webhook != nil {
                map["webhook"] = self.webhook?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deAfterData") && dict["deAfterData"] != nil {
                self.deAfterData = dict["deAfterData"] as! String
            }
            if dict.keys.contains("deBeforeData") && dict["deBeforeData"] != nil {
                self.deBeforeData = dict["deBeforeData"] as! String
            }
            if dict.keys.contains("mail") && dict["mail"] != nil {
                var model = GetProblemPreviewResponseBody.Data.Mail()
                model.fromMap(dict["mail"] as! [String: Any])
                self.mail = model
            }
            if dict.keys.contains("problem") && dict["problem"] != nil {
                var model = GetProblemPreviewResponseBody.Data.Problem()
                model.fromMap(dict["problem"] as! [String: Any])
                self.problem = model
            }
            if dict.keys.contains("sms") && dict["sms"] != nil {
                var model = GetProblemPreviewResponseBody.Data.Sms()
                model.fromMap(dict["sms"] as! [String: Any])
                self.sms = model
            }
            if dict.keys.contains("upAfterData") && dict["upAfterData"] != nil {
                self.upAfterData = dict["upAfterData"] as! String
            }
            if dict.keys.contains("upBeforeData") && dict["upBeforeData"] != nil {
                self.upBeforeData = dict["upBeforeData"] as! String
            }
            if dict.keys.contains("voice") && dict["voice"] != nil {
                var model = GetProblemPreviewResponseBody.Data.Voice()
                model.fromMap(dict["voice"] as! [String: Any])
                self.voice = model
            }
            if dict.keys.contains("webhook") && dict["webhook"] != nil {
                var model = GetProblemPreviewResponseBody.Data.Webhook()
                model.fromMap(dict["webhook"] as! [String: Any])
                self.webhook = model
            }
        }
    }
    public var data: GetProblemPreviewResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetProblemPreviewResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetProblemPreviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProblemPreviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetProblemPreviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetResourceStatisticsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class GetResourceStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alertCount: Int32?

        public var incidentCount: Int32?

        public var integrationCount: Int32?

        public var problemCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertCount != nil {
                map["alertCount"] = self.alertCount!
            }
            if self.incidentCount != nil {
                map["incidentCount"] = self.incidentCount!
            }
            if self.integrationCount != nil {
                map["integrationCount"] = self.integrationCount!
            }
            if self.problemCount != nil {
                map["problemCount"] = self.problemCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("alertCount") && dict["alertCount"] != nil {
                self.alertCount = dict["alertCount"] as! Int32
            }
            if dict.keys.contains("incidentCount") && dict["incidentCount"] != nil {
                self.incidentCount = dict["incidentCount"] as! Int32
            }
            if dict.keys.contains("integrationCount") && dict["integrationCount"] != nil {
                self.integrationCount = dict["integrationCount"] as! Int32
            }
            if dict.keys.contains("problemCount") && dict["problemCount"] != nil {
                self.problemCount = dict["problemCount"] as! Int32
            }
        }
    }
    public var data: GetResourceStatisticsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetResourceStatisticsResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetResourceStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetResourceStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRichTextRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var instanceType: String?

    public var richTextId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.richTextId != nil {
            map["richTextId"] = self.richTextId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("richTextId") && dict["richTextId"] != nil {
            self.richTextId = dict["richTextId"] as! Int64
        }
    }
}

public class GetRichTextResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: Int64?

        public var instanceType: Int64?

        public var richText: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["instanceType"] = self.instanceType!
            }
            if self.richText != nil {
                map["richText"] = self.richText!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
                self.instanceId = dict["instanceId"] as! Int64
            }
            if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                self.instanceType = dict["instanceType"] as! Int64
            }
            if dict.keys.contains("richText") && dict["richText"] != nil {
                self.richText = dict["richText"] as! String
            }
        }
    }
    public var data: GetRichTextResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetRichTextResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetRichTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRichTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRichTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRouteRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var routeRuleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
    }
}

public class GetRouteRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EventRouteChildRules : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var key: String?

                public var operationSymbol: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["key"] = self.key!
                    }
                    if self.operationSymbol != nil {
                        map["operationSymbol"] = self.operationSymbol!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("key") && dict["key"] != nil {
                        self.key = dict["key"] as! String
                    }
                    if dict.keys.contains("operationSymbol") && dict["operationSymbol"] != nil {
                        self.operationSymbol = dict["operationSymbol"] as! String
                    }
                    if dict.keys.contains("value") && dict["value"] != nil {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var childConditionRelation: Int64?

            public var childRouteRuleId: Int64?

            public var conditions: [GetRouteRuleResponseBody.Data.EventRouteChildRules.Conditions]?

            public var isValidChildRule: Bool?

            public var monitorIntegrationConfigId: Int64?

            public var monitorSourceId: Int64?

            public var monitorSourceName: String?

            public var parentRuleId: Int64?

            public var problemLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.childConditionRelation != nil {
                    map["childConditionRelation"] = self.childConditionRelation!
                }
                if self.childRouteRuleId != nil {
                    map["childRouteRuleId"] = self.childRouteRuleId!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["conditions"] = tmp
                }
                if self.isValidChildRule != nil {
                    map["isValidChildRule"] = self.isValidChildRule!
                }
                if self.monitorIntegrationConfigId != nil {
                    map["monitorIntegrationConfigId"] = self.monitorIntegrationConfigId!
                }
                if self.monitorSourceId != nil {
                    map["monitorSourceId"] = self.monitorSourceId!
                }
                if self.monitorSourceName != nil {
                    map["monitorSourceName"] = self.monitorSourceName!
                }
                if self.parentRuleId != nil {
                    map["parentRuleId"] = self.parentRuleId!
                }
                if self.problemLevel != nil {
                    map["problemLevel"] = self.problemLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("childConditionRelation") && dict["childConditionRelation"] != nil {
                    self.childConditionRelation = dict["childConditionRelation"] as! Int64
                }
                if dict.keys.contains("childRouteRuleId") && dict["childRouteRuleId"] != nil {
                    self.childRouteRuleId = dict["childRouteRuleId"] as! Int64
                }
                if dict.keys.contains("conditions") && dict["conditions"] != nil {
                    var tmp : [GetRouteRuleResponseBody.Data.EventRouteChildRules.Conditions] = []
                    for v in dict["conditions"] as! [Any] {
                        var model = GetRouteRuleResponseBody.Data.EventRouteChildRules.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("isValidChildRule") && dict["isValidChildRule"] != nil {
                    self.isValidChildRule = dict["isValidChildRule"] as! Bool
                }
                if dict.keys.contains("monitorIntegrationConfigId") && dict["monitorIntegrationConfigId"] != nil {
                    self.monitorIntegrationConfigId = dict["monitorIntegrationConfigId"] as! Int64
                }
                if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                    self.monitorSourceId = dict["monitorSourceId"] as! Int64
                }
                if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                    self.monitorSourceName = dict["monitorSourceName"] as! String
                }
                if dict.keys.contains("parentRuleId") && dict["parentRuleId"] != nil {
                    self.parentRuleId = dict["parentRuleId"] as! Int64
                }
                if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                    self.problemLevel = dict["problemLevel"] as! String
                }
            }
        }
        public var assignObjectId: Int64?

        public var assignObjectName: String?

        public var assignObjectType: String?

        public var childRuleRelation: String?

        public var convergenceFields: [String]?

        public var convergenceType: Int32?

        public var coverageProblemLevels: [String]?

        public var createTime: String?

        public var effection: String?

        public var enableStatus: String?

        public var eventRouteChildRules: [GetRouteRuleResponseBody.Data.EventRouteChildRules]?

        public var incidentLevel: String?

        public var matchCount: Int64?

        public var notifyChannelNames: [String]?

        public var notifyChannels: [String]?

        public var problemEffectionServices: [Int64]?

        public var problemLevelGroup: [String: DataProblemLevelGroupValue]?

        public var relServiceDeleteType: Int32?

        public var relatedServiceId: Int64?

        public var relatedServiceName: String?

        public var routeRuleId: Int64?

        public var routeType: String?

        public var ruleName: String?

        public var timeWindow: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignObjectId != nil {
                map["assignObjectId"] = self.assignObjectId!
            }
            if self.assignObjectName != nil {
                map["assignObjectName"] = self.assignObjectName!
            }
            if self.assignObjectType != nil {
                map["assignObjectType"] = self.assignObjectType!
            }
            if self.childRuleRelation != nil {
                map["childRuleRelation"] = self.childRuleRelation!
            }
            if self.convergenceFields != nil {
                map["convergenceFields"] = self.convergenceFields!
            }
            if self.convergenceType != nil {
                map["convergenceType"] = self.convergenceType!
            }
            if self.coverageProblemLevels != nil {
                map["coverageProblemLevels"] = self.coverageProblemLevels!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.effection != nil {
                map["effection"] = self.effection!
            }
            if self.enableStatus != nil {
                map["enableStatus"] = self.enableStatus!
            }
            if self.eventRouteChildRules != nil {
                var tmp : [Any] = []
                for k in self.eventRouteChildRules! {
                    tmp.append(k.toMap())
                }
                map["eventRouteChildRules"] = tmp
            }
            if self.incidentLevel != nil {
                map["incidentLevel"] = self.incidentLevel!
            }
            if self.matchCount != nil {
                map["matchCount"] = self.matchCount!
            }
            if self.notifyChannelNames != nil {
                map["notifyChannelNames"] = self.notifyChannelNames!
            }
            if self.notifyChannels != nil {
                map["notifyChannels"] = self.notifyChannels!
            }
            if self.problemEffectionServices != nil {
                map["problemEffectionServices"] = self.problemEffectionServices!
            }
            if self.problemLevelGroup != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.problemLevelGroup! {
                    tmp[k] = v.toMap()
                }
                map["problemLevelGroup"] = tmp
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeType != nil {
                map["routeType"] = self.routeType!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.timeWindow != nil {
                map["timeWindow"] = self.timeWindow!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignObjectId") && dict["assignObjectId"] != nil {
                self.assignObjectId = dict["assignObjectId"] as! Int64
            }
            if dict.keys.contains("assignObjectName") && dict["assignObjectName"] != nil {
                self.assignObjectName = dict["assignObjectName"] as! String
            }
            if dict.keys.contains("assignObjectType") && dict["assignObjectType"] != nil {
                self.assignObjectType = dict["assignObjectType"] as! String
            }
            if dict.keys.contains("childRuleRelation") && dict["childRuleRelation"] != nil {
                self.childRuleRelation = dict["childRuleRelation"] as! String
            }
            if dict.keys.contains("convergenceFields") && dict["convergenceFields"] != nil {
                self.convergenceFields = dict["convergenceFields"] as! [String]
            }
            if dict.keys.contains("convergenceType") && dict["convergenceType"] != nil {
                self.convergenceType = dict["convergenceType"] as! Int32
            }
            if dict.keys.contains("coverageProblemLevels") && dict["coverageProblemLevels"] != nil {
                self.coverageProblemLevels = dict["coverageProblemLevels"] as! [String]
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("effection") && dict["effection"] != nil {
                self.effection = dict["effection"] as! String
            }
            if dict.keys.contains("enableStatus") && dict["enableStatus"] != nil {
                self.enableStatus = dict["enableStatus"] as! String
            }
            if dict.keys.contains("eventRouteChildRules") && dict["eventRouteChildRules"] != nil {
                var tmp : [GetRouteRuleResponseBody.Data.EventRouteChildRules] = []
                for v in dict["eventRouteChildRules"] as! [Any] {
                    var model = GetRouteRuleResponseBody.Data.EventRouteChildRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventRouteChildRules = tmp
            }
            if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
                self.incidentLevel = dict["incidentLevel"] as! String
            }
            if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
                self.matchCount = dict["matchCount"] as! Int64
            }
            if dict.keys.contains("notifyChannelNames") && dict["notifyChannelNames"] != nil {
                self.notifyChannelNames = dict["notifyChannelNames"] as! [String]
            }
            if dict.keys.contains("notifyChannels") && dict["notifyChannels"] != nil {
                self.notifyChannels = dict["notifyChannels"] as! [String]
            }
            if dict.keys.contains("problemEffectionServices") && dict["problemEffectionServices"] != nil {
                self.problemEffectionServices = dict["problemEffectionServices"] as! [Int64]
            }
            if dict.keys.contains("problemLevelGroup") && dict["problemLevelGroup"] != nil {
                var tmp : [String: DataProblemLevelGroupValue] = [:]
                for (k, v) in dict["problemLevelGroup"] as! [String: Any] {
                    if v != nil {
                        var model = DataProblemLevelGroupValue()
                        model.fromMap(v as! [String: Any])
                        tmp[k] = model
                    }
                }
                self.problemLevelGroup = tmp
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeType") && dict["routeType"] != nil {
                self.routeType = dict["routeType"] as! String
            }
            if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
                self.timeWindow = dict["timeWindow"] as! Int32
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var data: GetRouteRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetRouteRuleResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
    }
}

public class GetServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var escalationPlanId: Int64?

        public var serviceDescription: String?

        public var serviceGroupIdList: [Int64]?

        public var serviceId: Int64?

        public var serviceName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.serviceDescription != nil {
                map["serviceDescription"] = self.serviceDescription!
            }
            if self.serviceGroupIdList != nil {
                map["serviceGroupIdList"] = self.serviceGroupIdList!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("serviceDescription") && dict["serviceDescription"] != nil {
                self.serviceDescription = dict["serviceDescription"] as! String
            }
            if dict.keys.contains("serviceGroupIdList") && dict["serviceGroupIdList"] != nil {
                self.serviceGroupIdList = dict["serviceGroupIdList"] as! [Int64]
            }
            if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                self.serviceId = dict["serviceId"] as! Int64
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var data: GetServiceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetServiceResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class GetServiceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Users : Tea.TeaModel {
            public var phone: String?

            public var roleNameList: [String]?

            public var serviceGroupId: Int64?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.phone != nil {
                    map["phone"] = self.phone!
                }
                if self.roleNameList != nil {
                    map["roleNameList"] = self.roleNameList!
                }
                if self.serviceGroupId != nil {
                    map["serviceGroupId"] = self.serviceGroupId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("phone") && dict["phone"] != nil {
                    self.phone = dict["phone"] as! String
                }
                if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                    self.roleNameList = dict["roleNameList"] as! [String]
                }
                if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                    self.serviceGroupId = dict["serviceGroupId"] as! Int64
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userName") && dict["userName"] != nil {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var createTime: String?

        public var enableWebhook: String?

        public var serviceGroupDescription: String?

        public var serviceGroupId: Int64?

        public var serviceGroupName: String?

        public var updateTime: String?

        public var users: [GetServiceGroupResponseBody.Data.Users]?

        public var webhookLink: String?

        public var webhookType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.enableWebhook != nil {
                map["enableWebhook"] = self.enableWebhook!
            }
            if self.serviceGroupDescription != nil {
                map["serviceGroupDescription"] = self.serviceGroupDescription!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.serviceGroupName != nil {
                map["serviceGroupName"] = self.serviceGroupName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.users != nil {
                var tmp : [Any] = []
                for k in self.users! {
                    tmp.append(k.toMap())
                }
                map["users"] = tmp
            }
            if self.webhookLink != nil {
                map["webhookLink"] = self.webhookLink!
            }
            if self.webhookType != nil {
                map["webhookType"] = self.webhookType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
                self.enableWebhook = dict["enableWebhook"] as! String
            }
            if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
                self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                self.serviceGroupName = dict["serviceGroupName"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("users") && dict["users"] != nil {
                var tmp : [GetServiceGroupResponseBody.Data.Users] = []
                for v in dict["users"] as! [Any] {
                    var model = GetServiceGroupResponseBody.Data.Users()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.users = tmp
            }
            if dict.keys.contains("webhookLink") && dict["webhookLink"] != nil {
                self.webhookLink = dict["webhookLink"] as! String
            }
            if dict.keys.contains("webhookType") && dict["webhookType"] != nil {
                self.webhookType = dict["webhookType"] as! String
            }
        }
    }
    public var data: GetServiceGroupResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetServiceGroupResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceGroupPersonSchedulingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endTime: String?

    public var serviceGroupId: Int64?

    public var startTime: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class GetServiceGroupPersonSchedulingResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String: Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceGroupPersonSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceGroupPersonSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceGroupPersonSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceGroupSchedulingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class GetServiceGroupSchedulingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FastScheduling : Tea.TeaModel {
            public class SchedulingUsers : Tea.TeaModel {
                public var schedulingObjectType: String?

                public var schedulingOrder: Int32?

                public var schedulingUserId: Int64?

                public var schedulingUserIdList: [Int64]?

                public var schedulingUserName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.schedulingObjectType != nil {
                        map["schedulingObjectType"] = self.schedulingObjectType!
                    }
                    if self.schedulingOrder != nil {
                        map["schedulingOrder"] = self.schedulingOrder!
                    }
                    if self.schedulingUserId != nil {
                        map["schedulingUserId"] = self.schedulingUserId!
                    }
                    if self.schedulingUserIdList != nil {
                        map["schedulingUserIdList"] = self.schedulingUserIdList!
                    }
                    if self.schedulingUserName != nil {
                        map["schedulingUserName"] = self.schedulingUserName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                        self.schedulingObjectType = dict["schedulingObjectType"] as! String
                    }
                    if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                        self.schedulingOrder = dict["schedulingOrder"] as! Int32
                    }
                    if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                        self.schedulingUserId = dict["schedulingUserId"] as! Int64
                    }
                    if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                        self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                    }
                    if dict.keys.contains("schedulingUserName") && dict["schedulingUserName"] != nil {
                        self.schedulingUserName = dict["schedulingUserName"] as! String
                    }
                }
            }
            public var dutyPlan: String?

            public var id: Int64?

            public var schedulingUsers: [GetServiceGroupSchedulingResponseBody.Data.FastScheduling.SchedulingUsers]?

            public var singleDuration: Int32?

            public var singleDurationUnit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dutyPlan != nil {
                    map["dutyPlan"] = self.dutyPlan!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.schedulingUsers != nil {
                    var tmp : [Any] = []
                    for k in self.schedulingUsers! {
                        tmp.append(k.toMap())
                    }
                    map["schedulingUsers"] = tmp
                }
                if self.singleDuration != nil {
                    map["singleDuration"] = self.singleDuration!
                }
                if self.singleDurationUnit != nil {
                    map["singleDurationUnit"] = self.singleDurationUnit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dutyPlan") && dict["dutyPlan"] != nil {
                    self.dutyPlan = dict["dutyPlan"] as! String
                }
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("schedulingUsers") && dict["schedulingUsers"] != nil {
                    var tmp : [GetServiceGroupSchedulingResponseBody.Data.FastScheduling.SchedulingUsers] = []
                    for v in dict["schedulingUsers"] as! [Any] {
                        var model = GetServiceGroupSchedulingResponseBody.Data.FastScheduling.SchedulingUsers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedulingUsers = tmp
                }
                if dict.keys.contains("singleDuration") && dict["singleDuration"] != nil {
                    self.singleDuration = dict["singleDuration"] as! Int32
                }
                if dict.keys.contains("singleDurationUnit") && dict["singleDurationUnit"] != nil {
                    self.singleDurationUnit = dict["singleDurationUnit"] as! String
                }
            }
        }
        public class FineScheduling : Tea.TeaModel {
            public class SchedulingFineShifts : Tea.TeaModel {
                public var cycleOrder: Int64?

                public var schedulingEndTime: String?

                public var schedulingObjectType: String?

                public var schedulingOrder: Int32?

                public var schedulingStartTime: String?

                public var schedulingUserId: Int64?

                public var schedulingUserIdList: [Int64]?

                public var schedulingUserName: String?

                public var shiftName: String?

                public var skipOneDay: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleOrder != nil {
                        map["cycleOrder"] = self.cycleOrder!
                    }
                    if self.schedulingEndTime != nil {
                        map["schedulingEndTime"] = self.schedulingEndTime!
                    }
                    if self.schedulingObjectType != nil {
                        map["schedulingObjectType"] = self.schedulingObjectType!
                    }
                    if self.schedulingOrder != nil {
                        map["schedulingOrder"] = self.schedulingOrder!
                    }
                    if self.schedulingStartTime != nil {
                        map["schedulingStartTime"] = self.schedulingStartTime!
                    }
                    if self.schedulingUserId != nil {
                        map["schedulingUserId"] = self.schedulingUserId!
                    }
                    if self.schedulingUserIdList != nil {
                        map["schedulingUserIdList"] = self.schedulingUserIdList!
                    }
                    if self.schedulingUserName != nil {
                        map["schedulingUserName"] = self.schedulingUserName!
                    }
                    if self.shiftName != nil {
                        map["shiftName"] = self.shiftName!
                    }
                    if self.skipOneDay != nil {
                        map["skipOneDay"] = self.skipOneDay!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cycleOrder") && dict["cycleOrder"] != nil {
                        self.cycleOrder = dict["cycleOrder"] as! Int64
                    }
                    if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                        self.schedulingEndTime = dict["schedulingEndTime"] as! String
                    }
                    if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                        self.schedulingObjectType = dict["schedulingObjectType"] as! String
                    }
                    if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                        self.schedulingOrder = dict["schedulingOrder"] as! Int32
                    }
                    if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                        self.schedulingStartTime = dict["schedulingStartTime"] as! String
                    }
                    if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                        self.schedulingUserId = dict["schedulingUserId"] as! Int64
                    }
                    if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                        self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                    }
                    if dict.keys.contains("schedulingUserName") && dict["schedulingUserName"] != nil {
                        self.schedulingUserName = dict["schedulingUserName"] as! String
                    }
                    if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                        self.shiftName = dict["shiftName"] as! String
                    }
                    if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                        self.skipOneDay = dict["skipOneDay"] as! Bool
                    }
                }
            }
            public class SchedulingTemplateFineShifts : Tea.TeaModel {
                public var schedulingEndTime: String?

                public var schedulingObjectType: String?

                public var schedulingOrder: Int64?

                public var schedulingStartTime: String?

                public var schedulingUserId: String?

                public var schedulingUserIdList: [Int64]?

                public var schedulingUserName: String?

                public var shiftName: String?

                public var skipOneDay: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.schedulingEndTime != nil {
                        map["schedulingEndTime"] = self.schedulingEndTime!
                    }
                    if self.schedulingObjectType != nil {
                        map["schedulingObjectType"] = self.schedulingObjectType!
                    }
                    if self.schedulingOrder != nil {
                        map["schedulingOrder"] = self.schedulingOrder!
                    }
                    if self.schedulingStartTime != nil {
                        map["schedulingStartTime"] = self.schedulingStartTime!
                    }
                    if self.schedulingUserId != nil {
                        map["schedulingUserId"] = self.schedulingUserId!
                    }
                    if self.schedulingUserIdList != nil {
                        map["schedulingUserIdList"] = self.schedulingUserIdList!
                    }
                    if self.schedulingUserName != nil {
                        map["schedulingUserName"] = self.schedulingUserName!
                    }
                    if self.shiftName != nil {
                        map["shiftName"] = self.shiftName!
                    }
                    if self.skipOneDay != nil {
                        map["skipOneDay"] = self.skipOneDay!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                        self.schedulingEndTime = dict["schedulingEndTime"] as! String
                    }
                    if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                        self.schedulingObjectType = dict["schedulingObjectType"] as! String
                    }
                    if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                        self.schedulingOrder = dict["schedulingOrder"] as! Int64
                    }
                    if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                        self.schedulingStartTime = dict["schedulingStartTime"] as! String
                    }
                    if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                        self.schedulingUserId = dict["schedulingUserId"] as! String
                    }
                    if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                        self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                    }
                    if dict.keys.contains("schedulingUserName") && dict["schedulingUserName"] != nil {
                        self.schedulingUserName = dict["schedulingUserName"] as! String
                    }
                    if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                        self.shiftName = dict["shiftName"] as! String
                    }
                    if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                        self.skipOneDay = dict["skipOneDay"] as! Bool
                    }
                }
            }
            public var id: Int64?

            public var period: Int32?

            public var periodUnit: String?

            public var schedulingFineShifts: [GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingFineShifts]?

            public var schedulingTemplateFineShifts: [GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingTemplateFineShifts]?

            public var shiftType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.period != nil {
                    map["period"] = self.period!
                }
                if self.periodUnit != nil {
                    map["periodUnit"] = self.periodUnit!
                }
                if self.schedulingFineShifts != nil {
                    var tmp : [Any] = []
                    for k in self.schedulingFineShifts! {
                        tmp.append(k.toMap())
                    }
                    map["schedulingFineShifts"] = tmp
                }
                if self.schedulingTemplateFineShifts != nil {
                    var tmp : [Any] = []
                    for k in self.schedulingTemplateFineShifts! {
                        tmp.append(k.toMap())
                    }
                    map["schedulingTemplateFineShifts"] = tmp
                }
                if self.shiftType != nil {
                    map["shiftType"] = self.shiftType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("period") && dict["period"] != nil {
                    self.period = dict["period"] as! Int32
                }
                if dict.keys.contains("periodUnit") && dict["periodUnit"] != nil {
                    self.periodUnit = dict["periodUnit"] as! String
                }
                if dict.keys.contains("schedulingFineShifts") && dict["schedulingFineShifts"] != nil {
                    var tmp : [GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingFineShifts] = []
                    for v in dict["schedulingFineShifts"] as! [Any] {
                        var model = GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingFineShifts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedulingFineShifts = tmp
                }
                if dict.keys.contains("schedulingTemplateFineShifts") && dict["schedulingTemplateFineShifts"] != nil {
                    var tmp : [GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingTemplateFineShifts] = []
                    for v in dict["schedulingTemplateFineShifts"] as! [Any] {
                        var model = GetServiceGroupSchedulingResponseBody.Data.FineScheduling.SchedulingTemplateFineShifts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedulingTemplateFineShifts = tmp
                }
                if dict.keys.contains("shiftType") && dict["shiftType"] != nil {
                    self.shiftType = dict["shiftType"] as! String
                }
            }
        }
        public class Users : Tea.TeaModel {
            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userName") && dict["userName"] != nil {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var fastScheduling: GetServiceGroupSchedulingResponseBody.Data.FastScheduling?

        public var fineScheduling: GetServiceGroupSchedulingResponseBody.Data.FineScheduling?

        public var schedulingWay: String?

        public var serviceGroupId: Int64?

        public var users: [GetServiceGroupSchedulingResponseBody.Data.Users]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fastScheduling?.validate()
            try self.fineScheduling?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fastScheduling != nil {
                map["fastScheduling"] = self.fastScheduling?.toMap()
            }
            if self.fineScheduling != nil {
                map["fineScheduling"] = self.fineScheduling?.toMap()
            }
            if self.schedulingWay != nil {
                map["schedulingWay"] = self.schedulingWay!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.users != nil {
                var tmp : [Any] = []
                for k in self.users! {
                    tmp.append(k.toMap())
                }
                map["users"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fastScheduling") && dict["fastScheduling"] != nil {
                var model = GetServiceGroupSchedulingResponseBody.Data.FastScheduling()
                model.fromMap(dict["fastScheduling"] as! [String: Any])
                self.fastScheduling = model
            }
            if dict.keys.contains("fineScheduling") && dict["fineScheduling"] != nil {
                var model = GetServiceGroupSchedulingResponseBody.Data.FineScheduling()
                model.fromMap(dict["fineScheduling"] as! [String: Any])
                self.fineScheduling = model
            }
            if dict.keys.contains("schedulingWay") && dict["schedulingWay"] != nil {
                self.schedulingWay = dict["schedulingWay"] as! String
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("users") && dict["users"] != nil {
                var tmp : [GetServiceGroupSchedulingResponseBody.Data.Users] = []
                for v in dict["users"] as! [Any] {
                    var model = GetServiceGroupSchedulingResponseBody.Data.Users()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.users = tmp
            }
        }
    }
    public var data: GetServiceGroupSchedulingResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetServiceGroupSchedulingResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceGroupSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceGroupSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceGroupSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceGroupSchedulingPreviewRequest : Tea.TeaModel {
    public class FastScheduling : Tea.TeaModel {
        public class SchedulingUsers : Tea.TeaModel {
            public var schedulingOrder: Int32?

            public var schedulingUserId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int32
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
            }
        }
        public var dutyPlan: String?

        public var schedulingUsers: [GetServiceGroupSchedulingPreviewRequest.FastScheduling.SchedulingUsers]?

        public var singleDuration: Int32?

        public var singleDurationUnit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dutyPlan != nil {
                map["dutyPlan"] = self.dutyPlan!
            }
            if self.schedulingUsers != nil {
                var tmp : [Any] = []
                for k in self.schedulingUsers! {
                    tmp.append(k.toMap())
                }
                map["schedulingUsers"] = tmp
            }
            if self.singleDuration != nil {
                map["singleDuration"] = self.singleDuration!
            }
            if self.singleDurationUnit != nil {
                map["singleDurationUnit"] = self.singleDurationUnit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dutyPlan") && dict["dutyPlan"] != nil {
                self.dutyPlan = dict["dutyPlan"] as! String
            }
            if dict.keys.contains("schedulingUsers") && dict["schedulingUsers"] != nil {
                var tmp : [GetServiceGroupSchedulingPreviewRequest.FastScheduling.SchedulingUsers] = []
                for v in dict["schedulingUsers"] as! [Any] {
                    var model = GetServiceGroupSchedulingPreviewRequest.FastScheduling.SchedulingUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingUsers = tmp
            }
            if dict.keys.contains("singleDuration") && dict["singleDuration"] != nil {
                self.singleDuration = dict["singleDuration"] as! Int32
            }
            if dict.keys.contains("singleDurationUnit") && dict["singleDurationUnit"] != nil {
                self.singleDurationUnit = dict["singleDurationUnit"] as! String
            }
        }
    }
    public class FineScheduling : Tea.TeaModel {
        public class SchedulingFineShifts : Tea.TeaModel {
            public var schedulingEndTime: String?

            public var schedulingOrder: Int64?

            public var schedulingStartTime: String?

            public var shiftName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingEndTime != nil {
                    map["schedulingEndTime"] = self.schedulingEndTime!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingStartTime != nil {
                    map["schedulingStartTime"] = self.schedulingStartTime!
                }
                if self.shiftName != nil {
                    map["shiftName"] = self.shiftName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                    self.schedulingEndTime = dict["schedulingEndTime"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int64
                }
                if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                    self.schedulingStartTime = dict["schedulingStartTime"] as! String
                }
                if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                    self.shiftName = dict["shiftName"] as! String
                }
            }
        }
        public var period: Int32?

        public var periodUnit: String?

        public var schedulingFineShifts: [GetServiceGroupSchedulingPreviewRequest.FineScheduling.SchedulingFineShifts]?

        public var shiftType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.period != nil {
                map["period"] = self.period!
            }
            if self.periodUnit != nil {
                map["periodUnit"] = self.periodUnit!
            }
            if self.schedulingFineShifts != nil {
                var tmp : [Any] = []
                for k in self.schedulingFineShifts! {
                    tmp.append(k.toMap())
                }
                map["schedulingFineShifts"] = tmp
            }
            if self.shiftType != nil {
                map["shiftType"] = self.shiftType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("period") && dict["period"] != nil {
                self.period = dict["period"] as! Int32
            }
            if dict.keys.contains("periodUnit") && dict["periodUnit"] != nil {
                self.periodUnit = dict["periodUnit"] as! String
            }
            if dict.keys.contains("schedulingFineShifts") && dict["schedulingFineShifts"] != nil {
                var tmp : [GetServiceGroupSchedulingPreviewRequest.FineScheduling.SchedulingFineShifts] = []
                for v in dict["schedulingFineShifts"] as! [Any] {
                    var model = GetServiceGroupSchedulingPreviewRequest.FineScheduling.SchedulingFineShifts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingFineShifts = tmp
            }
            if dict.keys.contains("shiftType") && dict["shiftType"] != nil {
                self.shiftType = dict["shiftType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var endTime: String?

    public var fastScheduling: GetServiceGroupSchedulingPreviewRequest.FastScheduling?

    public var fineScheduling: GetServiceGroupSchedulingPreviewRequest.FineScheduling?

    public var schedulingWay: String?

    public var serviceGroupId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fastScheduling?.validate()
        try self.fineScheduling?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.fastScheduling != nil {
            map["fastScheduling"] = self.fastScheduling?.toMap()
        }
        if self.fineScheduling != nil {
            map["fineScheduling"] = self.fineScheduling?.toMap()
        }
        if self.schedulingWay != nil {
            map["schedulingWay"] = self.schedulingWay!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("fastScheduling") && dict["fastScheduling"] != nil {
            var model = GetServiceGroupSchedulingPreviewRequest.FastScheduling()
            model.fromMap(dict["fastScheduling"] as! [String: Any])
            self.fastScheduling = model
        }
        if dict.keys.contains("fineScheduling") && dict["fineScheduling"] != nil {
            var model = GetServiceGroupSchedulingPreviewRequest.FineScheduling()
            model.fromMap(dict["fineScheduling"] as! [String: Any])
            self.fineScheduling = model
        }
        if dict.keys.contains("schedulingWay") && dict["schedulingWay"] != nil {
            self.schedulingWay = dict["schedulingWay"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class GetServiceGroupSchedulingPreviewResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String: Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceGroupSchedulingPreviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceGroupSchedulingPreviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceGroupSchedulingPreviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceGroupSpecialPersonSchedulingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceGroupId: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class GetServiceGroupSpecialPersonSchedulingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var schedulingDate: String?

        public var schedulingEndTime: String?

        public var schedulingStartTime: String?

        public var schedulingUserId: Int64?

        public var serviceGroupId: Int64?

        public var serviceGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedulingDate != nil {
                map["schedulingDate"] = self.schedulingDate!
            }
            if self.schedulingEndTime != nil {
                map["schedulingEndTime"] = self.schedulingEndTime!
            }
            if self.schedulingStartTime != nil {
                map["schedulingStartTime"] = self.schedulingStartTime!
            }
            if self.schedulingUserId != nil {
                map["schedulingUserId"] = self.schedulingUserId!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.serviceGroupName != nil {
                map["serviceGroupName"] = self.serviceGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("schedulingDate") && dict["schedulingDate"] != nil {
                self.schedulingDate = dict["schedulingDate"] as! String
            }
            if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                self.schedulingEndTime = dict["schedulingEndTime"] as! String
            }
            if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                self.schedulingStartTime = dict["schedulingStartTime"] as! String
            }
            if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                self.schedulingUserId = dict["schedulingUserId"] as! Int64
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                self.serviceGroupName = dict["serviceGroupName"] as! String
            }
        }
    }
    public var data: [GetServiceGroupSpecialPersonSchedulingResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [GetServiceGroupSpecialPersonSchedulingResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = GetServiceGroupSpecialPersonSchedulingResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetServiceGroupSpecialPersonSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceGroupSpecialPersonSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceGroupSpecialPersonSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSimilarIncidentStatisticsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var createTime: String?

    public var events: [String]?

    public var incidentId: Int64?

    public var incidentTitle: String?

    public var relatedServiceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.events != nil {
            map["events"] = self.events!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        if self.incidentTitle != nil {
            map["incidentTitle"] = self.incidentTitle!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("createTime") && dict["createTime"] != nil {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("events") && dict["events"] != nil {
            self.events = dict["events"] as! [String]
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
        if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
            self.incidentTitle = dict["incidentTitle"] as! String
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
    }
}

public class GetSimilarIncidentStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DailySimilarIncidents : Tea.TeaModel {
            public class SimilarIncidents : Tea.TeaModel {
                public var assignUserId: Int64?

                public var assignUserName: String?

                public var createTime: String?

                public var durationTime: Int64?

                public var finishReason: Int64?

                public var finishReasonDescription: String?

                public var finishSolutionDescription: String?

                public var incidentFinishSolution: Int64?

                public var incidentId: Int64?

                public var incidentNumber: String?

                public var incidentTitle: String?

                public var relatedRouteRuleId: Int64?

                public var relatedRouteRuleName: String?

                public var similarScore: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assignUserId != nil {
                        map["assignUserId"] = self.assignUserId!
                    }
                    if self.assignUserName != nil {
                        map["assignUserName"] = self.assignUserName!
                    }
                    if self.createTime != nil {
                        map["createTime"] = self.createTime!
                    }
                    if self.durationTime != nil {
                        map["durationTime"] = self.durationTime!
                    }
                    if self.finishReason != nil {
                        map["finishReason"] = self.finishReason!
                    }
                    if self.finishReasonDescription != nil {
                        map["finishReasonDescription"] = self.finishReasonDescription!
                    }
                    if self.finishSolutionDescription != nil {
                        map["finishSolutionDescription"] = self.finishSolutionDescription!
                    }
                    if self.incidentFinishSolution != nil {
                        map["incidentFinishSolution"] = self.incidentFinishSolution!
                    }
                    if self.incidentId != nil {
                        map["incidentId"] = self.incidentId!
                    }
                    if self.incidentNumber != nil {
                        map["incidentNumber"] = self.incidentNumber!
                    }
                    if self.incidentTitle != nil {
                        map["incidentTitle"] = self.incidentTitle!
                    }
                    if self.relatedRouteRuleId != nil {
                        map["relatedRouteRuleId"] = self.relatedRouteRuleId!
                    }
                    if self.relatedRouteRuleName != nil {
                        map["relatedRouteRuleName"] = self.relatedRouteRuleName!
                    }
                    if self.similarScore != nil {
                        map["similarScore"] = self.similarScore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
                        self.assignUserId = dict["assignUserId"] as! Int64
                    }
                    if dict.keys.contains("assignUserName") && dict["assignUserName"] != nil {
                        self.assignUserName = dict["assignUserName"] as! String
                    }
                    if dict.keys.contains("createTime") && dict["createTime"] != nil {
                        self.createTime = dict["createTime"] as! String
                    }
                    if dict.keys.contains("durationTime") && dict["durationTime"] != nil {
                        self.durationTime = dict["durationTime"] as! Int64
                    }
                    if dict.keys.contains("finishReason") && dict["finishReason"] != nil {
                        self.finishReason = dict["finishReason"] as! Int64
                    }
                    if dict.keys.contains("finishReasonDescription") && dict["finishReasonDescription"] != nil {
                        self.finishReasonDescription = dict["finishReasonDescription"] as! String
                    }
                    if dict.keys.contains("finishSolutionDescription") && dict["finishSolutionDescription"] != nil {
                        self.finishSolutionDescription = dict["finishSolutionDescription"] as! String
                    }
                    if dict.keys.contains("incidentFinishSolution") && dict["incidentFinishSolution"] != nil {
                        self.incidentFinishSolution = dict["incidentFinishSolution"] as! Int64
                    }
                    if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                        self.incidentId = dict["incidentId"] as! Int64
                    }
                    if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                        self.incidentNumber = dict["incidentNumber"] as! String
                    }
                    if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                        self.incidentTitle = dict["incidentTitle"] as! String
                    }
                    if dict.keys.contains("relatedRouteRuleId") && dict["relatedRouteRuleId"] != nil {
                        self.relatedRouteRuleId = dict["relatedRouteRuleId"] as! Int64
                    }
                    if dict.keys.contains("relatedRouteRuleName") && dict["relatedRouteRuleName"] != nil {
                        self.relatedRouteRuleName = dict["relatedRouteRuleName"] as! String
                    }
                    if dict.keys.contains("similarScore") && dict["similarScore"] != nil {
                        self.similarScore = dict["similarScore"] as! String
                    }
                }
            }
            public var commitment: Int64?

            public var date: String?

            public var day: Int64?

            public var month: Int64?

            public var similarIncidents: [GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents.SimilarIncidents]?

            public var week: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitment != nil {
                    map["commitment"] = self.commitment!
                }
                if self.date != nil {
                    map["date"] = self.date!
                }
                if self.day != nil {
                    map["day"] = self.day!
                }
                if self.month != nil {
                    map["month"] = self.month!
                }
                if self.similarIncidents != nil {
                    var tmp : [Any] = []
                    for k in self.similarIncidents! {
                        tmp.append(k.toMap())
                    }
                    map["similarIncidents"] = tmp
                }
                if self.week != nil {
                    map["week"] = self.week!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("commitment") && dict["commitment"] != nil {
                    self.commitment = dict["commitment"] as! Int64
                }
                if dict.keys.contains("date") && dict["date"] != nil {
                    self.date = dict["date"] as! String
                }
                if dict.keys.contains("day") && dict["day"] != nil {
                    self.day = dict["day"] as! Int64
                }
                if dict.keys.contains("month") && dict["month"] != nil {
                    self.month = dict["month"] as! Int64
                }
                if dict.keys.contains("similarIncidents") && dict["similarIncidents"] != nil {
                    var tmp : [GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents.SimilarIncidents] = []
                    for v in dict["similarIncidents"] as! [Any] {
                        var model = GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents.SimilarIncidents()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.similarIncidents = tmp
                }
                if dict.keys.contains("week") && dict["week"] != nil {
                    self.week = dict["week"] as! String
                }
            }
        }
        public class TopFiveIncidents : Tea.TeaModel {
            public var assignUserId: String?

            public var assignUserName: String?

            public var createTime: String?

            public var durationTime: Int64?

            public var finishReason: Int64?

            public var finishReasonDescription: String?

            public var finishSolutionDescription: String?

            public var incidentFinishSolution: Int64?

            public var incidentId: Int64?

            public var incidentNumber: String?

            public var incidentTitle: String?

            public var relatedRouteRuleId: Int64?

            public var relatedRouteRuleName: String?

            public var similarScore: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignUserId != nil {
                    map["assignUserId"] = self.assignUserId!
                }
                if self.assignUserName != nil {
                    map["assignUserName"] = self.assignUserName!
                }
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.durationTime != nil {
                    map["durationTime"] = self.durationTime!
                }
                if self.finishReason != nil {
                    map["finishReason"] = self.finishReason!
                }
                if self.finishReasonDescription != nil {
                    map["finishReasonDescription"] = self.finishReasonDescription!
                }
                if self.finishSolutionDescription != nil {
                    map["finishSolutionDescription"] = self.finishSolutionDescription!
                }
                if self.incidentFinishSolution != nil {
                    map["incidentFinishSolution"] = self.incidentFinishSolution!
                }
                if self.incidentId != nil {
                    map["incidentId"] = self.incidentId!
                }
                if self.incidentNumber != nil {
                    map["incidentNumber"] = self.incidentNumber!
                }
                if self.incidentTitle != nil {
                    map["incidentTitle"] = self.incidentTitle!
                }
                if self.relatedRouteRuleId != nil {
                    map["relatedRouteRuleId"] = self.relatedRouteRuleId!
                }
                if self.relatedRouteRuleName != nil {
                    map["relatedRouteRuleName"] = self.relatedRouteRuleName!
                }
                if self.similarScore != nil {
                    map["similarScore"] = self.similarScore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
                    self.assignUserId = dict["assignUserId"] as! String
                }
                if dict.keys.contains("assignUserName") && dict["assignUserName"] != nil {
                    self.assignUserName = dict["assignUserName"] as! String
                }
                if dict.keys.contains("createTime") && dict["createTime"] != nil {
                    self.createTime = dict["createTime"] as! String
                }
                if dict.keys.contains("durationTime") && dict["durationTime"] != nil {
                    self.durationTime = dict["durationTime"] as! Int64
                }
                if dict.keys.contains("finishReason") && dict["finishReason"] != nil {
                    self.finishReason = dict["finishReason"] as! Int64
                }
                if dict.keys.contains("finishReasonDescription") && dict["finishReasonDescription"] != nil {
                    self.finishReasonDescription = dict["finishReasonDescription"] as! String
                }
                if dict.keys.contains("finishSolutionDescription") && dict["finishSolutionDescription"] != nil {
                    self.finishSolutionDescription = dict["finishSolutionDescription"] as! String
                }
                if dict.keys.contains("incidentFinishSolution") && dict["incidentFinishSolution"] != nil {
                    self.incidentFinishSolution = dict["incidentFinishSolution"] as! Int64
                }
                if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                    self.incidentId = dict["incidentId"] as! Int64
                }
                if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                    self.incidentNumber = dict["incidentNumber"] as! String
                }
                if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                    self.incidentTitle = dict["incidentTitle"] as! String
                }
                if dict.keys.contains("relatedRouteRuleId") && dict["relatedRouteRuleId"] != nil {
                    self.relatedRouteRuleId = dict["relatedRouteRuleId"] as! Int64
                }
                if dict.keys.contains("relatedRouteRuleName") && dict["relatedRouteRuleName"] != nil {
                    self.relatedRouteRuleName = dict["relatedRouteRuleName"] as! String
                }
                if dict.keys.contains("similarScore") && dict["similarScore"] != nil {
                    self.similarScore = dict["similarScore"] as! String
                }
            }
        }
        public var countInSevenDays: Int64?

        public var countInSixMonths: Int64?

        public var dailySimilarIncidents: [GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents]?

        public var requestId: String?

        public var topFiveIncidents: [GetSimilarIncidentStatisticsResponseBody.Data.TopFiveIncidents]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.countInSevenDays != nil {
                map["countInSevenDays"] = self.countInSevenDays!
            }
            if self.countInSixMonths != nil {
                map["countInSixMonths"] = self.countInSixMonths!
            }
            if self.dailySimilarIncidents != nil {
                var tmp : [Any] = []
                for k in self.dailySimilarIncidents! {
                    tmp.append(k.toMap())
                }
                map["dailySimilarIncidents"] = tmp
            }
            if self.requestId != nil {
                map["requestId"] = self.requestId!
            }
            if self.topFiveIncidents != nil {
                var tmp : [Any] = []
                for k in self.topFiveIncidents! {
                    tmp.append(k.toMap())
                }
                map["topFiveIncidents"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("countInSevenDays") && dict["countInSevenDays"] != nil {
                self.countInSevenDays = dict["countInSevenDays"] as! Int64
            }
            if dict.keys.contains("countInSixMonths") && dict["countInSixMonths"] != nil {
                self.countInSixMonths = dict["countInSixMonths"] as! Int64
            }
            if dict.keys.contains("dailySimilarIncidents") && dict["dailySimilarIncidents"] != nil {
                var tmp : [GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents] = []
                for v in dict["dailySimilarIncidents"] as! [Any] {
                    var model = GetSimilarIncidentStatisticsResponseBody.Data.DailySimilarIncidents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dailySimilarIncidents = tmp
            }
            if dict.keys.contains("requestId") && dict["requestId"] != nil {
                self.requestId = dict["requestId"] as! String
            }
            if dict.keys.contains("topFiveIncidents") && dict["topFiveIncidents"] != nil {
                var tmp : [GetSimilarIncidentStatisticsResponseBody.Data.TopFiveIncidents] = []
                for v in dict["topFiveIncidents"] as! [Any] {
                    var model = GetSimilarIncidentStatisticsResponseBody.Data.TopFiveIncidents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topFiveIncidents = tmp
            }
        }
    }
    public var data: GetSimilarIncidentStatisticsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetSimilarIncidentStatisticsResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetSimilarIncidentStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSimilarIncidentStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSimilarIncidentStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSubscriptionRequest : Tea.TeaModel {
    public var notFilterScopeObjectDeleted: Bool?

    public var subscriptionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notFilterScopeObjectDeleted != nil {
            map["notFilterScopeObjectDeleted"] = self.notFilterScopeObjectDeleted!
        }
        if self.subscriptionId != nil {
            map["subscriptionId"] = self.subscriptionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("notFilterScopeObjectDeleted") && dict["notFilterScopeObjectDeleted"] != nil {
            self.notFilterScopeObjectDeleted = dict["notFilterScopeObjectDeleted"] as! Bool
        }
        if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
            self.subscriptionId = dict["subscriptionId"] as! Int64
        }
    }
}

public class GetSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NotifyObjectList : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public var notifyObjectId: Int64?

            public var notifyObjectType: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.notifyObjectId != nil {
                    map["notifyObjectId"] = self.notifyObjectId!
                }
                if self.notifyObjectType != nil {
                    map["notifyObjectType"] = self.notifyObjectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") && dict["name"] != nil {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("notifyObjectId") && dict["notifyObjectId"] != nil {
                    self.notifyObjectId = dict["notifyObjectId"] as! Int64
                }
                if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
                    self.notifyObjectType = dict["notifyObjectType"] as! Int64
                }
            }
        }
        public class NotifyStrategyList : Tea.TeaModel {
            public class Strategies : Tea.TeaModel {
                public class Conditions : Tea.TeaModel {
                    public var action: String?

                    public var effection: String?

                    public var level: String?

                    public var problemNotifyType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.action != nil {
                            map["action"] = self.action!
                        }
                        if self.effection != nil {
                            map["effection"] = self.effection!
                        }
                        if self.level != nil {
                            map["level"] = self.level!
                        }
                        if self.problemNotifyType != nil {
                            map["problemNotifyType"] = self.problemNotifyType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("action") && dict["action"] != nil {
                            self.action = dict["action"] as! String
                        }
                        if dict.keys.contains("effection") && dict["effection"] != nil {
                            self.effection = dict["effection"] as! String
                        }
                        if dict.keys.contains("level") && dict["level"] != nil {
                            self.level = dict["level"] as! String
                        }
                        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
                            self.problemNotifyType = dict["problemNotifyType"] as! String
                        }
                    }
                }
                public class PeriodChannel : Tea.TeaModel {
                    public var nonWorkday: String?

                    public var workday: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nonWorkday != nil {
                            map["nonWorkday"] = self.nonWorkday!
                        }
                        if self.workday != nil {
                            map["workday"] = self.workday!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("nonWorkday") && dict["nonWorkday"] != nil {
                            self.nonWorkday = dict["nonWorkday"] as! String
                        }
                        if dict.keys.contains("workday") && dict["workday"] != nil {
                            self.workday = dict["workday"] as! String
                        }
                    }
                }
                public var channels: String?

                public var conditions: [GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies.Conditions]?

                public var id: Int64?

                public var periodChannel: GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies.PeriodChannel?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.periodChannel?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["channels"] = self.channels!
                    }
                    if self.conditions != nil {
                        var tmp : [Any] = []
                        for k in self.conditions! {
                            tmp.append(k.toMap())
                        }
                        map["conditions"] = tmp
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.periodChannel != nil {
                        map["periodChannel"] = self.periodChannel?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("channels") && dict["channels"] != nil {
                        self.channels = dict["channels"] as! String
                    }
                    if dict.keys.contains("conditions") && dict["conditions"] != nil {
                        var tmp : [GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies.Conditions] = []
                        for v in dict["conditions"] as! [Any] {
                            var model = GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies.Conditions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.conditions = tmp
                    }
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("periodChannel") && dict["periodChannel"] != nil {
                        var model = GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies.PeriodChannel()
                        model.fromMap(dict["periodChannel"] as! [String: Any])
                        self.periodChannel = model
                    }
                }
            }
            public var instanceType: Int64?

            public var strategies: [GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.strategies != nil {
                    var tmp : [Any] = []
                    for k in self.strategies! {
                        tmp.append(k.toMap())
                    }
                    map["strategies"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                    self.instanceType = dict["instanceType"] as! Int64
                }
                if dict.keys.contains("strategies") && dict["strategies"] != nil {
                    var tmp : [GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies] = []
                    for v in dict["strategies"] as! [Any] {
                        var model = GetSubscriptionResponseBody.Data.NotifyStrategyList.Strategies()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.strategies = tmp
                }
            }
        }
        public class ScopeObjectList : Tea.TeaModel {
            public var id: Int64?

            public var isValid: Int64?

            public var scope: String?

            public var scopeObject: String?

            public var scopeObjectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.isValid != nil {
                    map["isValid"] = self.isValid!
                }
                if self.scope != nil {
                    map["scope"] = self.scope!
                }
                if self.scopeObject != nil {
                    map["scopeObject"] = self.scopeObject!
                }
                if self.scopeObjectId != nil {
                    map["scopeObjectId"] = self.scopeObjectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("isValid") && dict["isValid"] != nil {
                    self.isValid = dict["isValid"] as! Int64
                }
                if dict.keys.contains("scope") && dict["scope"] != nil {
                    self.scope = dict["scope"] as! String
                }
                if dict.keys.contains("scopeObject") && dict["scopeObject"] != nil {
                    self.scopeObject = dict["scopeObject"] as! String
                }
                if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                    self.scopeObjectId = dict["scopeObjectId"] as! Int64
                }
            }
        }
        public var endTime: String?

        public var expiredType: String?

        public var notifyObjectList: [GetSubscriptionResponseBody.Data.NotifyObjectList]?

        public var notifyObjectType: String?

        public var notifyStrategyList: [GetSubscriptionResponseBody.Data.NotifyStrategyList]?

        public var period: String?

        public var scope: String?

        public var scopeObjectList: [GetSubscriptionResponseBody.Data.ScopeObjectList]?

        public var startTime: String?

        public var status: String?

        public var subscriptionId: Int64?

        public var subscriptionTitle: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.expiredType != nil {
                map["expiredType"] = self.expiredType!
            }
            if self.notifyObjectList != nil {
                var tmp : [Any] = []
                for k in self.notifyObjectList! {
                    tmp.append(k.toMap())
                }
                map["notifyObjectList"] = tmp
            }
            if self.notifyObjectType != nil {
                map["notifyObjectType"] = self.notifyObjectType!
            }
            if self.notifyStrategyList != nil {
                var tmp : [Any] = []
                for k in self.notifyStrategyList! {
                    tmp.append(k.toMap())
                }
                map["notifyStrategyList"] = tmp
            }
            if self.period != nil {
                map["period"] = self.period!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.scopeObjectList != nil {
                var tmp : [Any] = []
                for k in self.scopeObjectList! {
                    tmp.append(k.toMap())
                }
                map["scopeObjectList"] = tmp
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscriptionId != nil {
                map["subscriptionId"] = self.subscriptionId!
            }
            if self.subscriptionTitle != nil {
                map["subscriptionTitle"] = self.subscriptionTitle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("endTime") && dict["endTime"] != nil {
                self.endTime = dict["endTime"] as! String
            }
            if dict.keys.contains("expiredType") && dict["expiredType"] != nil {
                self.expiredType = dict["expiredType"] as! String
            }
            if dict.keys.contains("notifyObjectList") && dict["notifyObjectList"] != nil {
                var tmp : [GetSubscriptionResponseBody.Data.NotifyObjectList] = []
                for v in dict["notifyObjectList"] as! [Any] {
                    var model = GetSubscriptionResponseBody.Data.NotifyObjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyObjectList = tmp
            }
            if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
                self.notifyObjectType = dict["notifyObjectType"] as! String
            }
            if dict.keys.contains("notifyStrategyList") && dict["notifyStrategyList"] != nil {
                var tmp : [GetSubscriptionResponseBody.Data.NotifyStrategyList] = []
                for v in dict["notifyStrategyList"] as! [Any] {
                    var model = GetSubscriptionResponseBody.Data.NotifyStrategyList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyStrategyList = tmp
            }
            if dict.keys.contains("period") && dict["period"] != nil {
                self.period = dict["period"] as! String
            }
            if dict.keys.contains("scope") && dict["scope"] != nil {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("scopeObjectList") && dict["scopeObjectList"] != nil {
                var tmp : [GetSubscriptionResponseBody.Data.ScopeObjectList] = []
                for v in dict["scopeObjectList"] as! [Any] {
                    var model = GetSubscriptionResponseBody.Data.ScopeObjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scopeObjectList = tmp
            }
            if dict.keys.contains("startTime") && dict["startTime"] != nil {
                self.startTime = dict["startTime"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
                self.subscriptionId = dict["subscriptionId"] as! Int64
            }
            if dict.keys.contains("subscriptionTitle") && dict["subscriptionTitle"] != nil {
                self.subscriptionTitle = dict["subscriptionTitle"] as! String
            }
        }
    }
    public var data: GetSubscriptionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetSubscriptionResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTenantApplicationRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class GetTenantApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var bizId: String?

        public var channel: String?

        public var corporationId: String?

        public var originalCorpId: String?

        public var progress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["bizId"] = self.bizId!
            }
            if self.channel != nil {
                map["channel"] = self.channel!
            }
            if self.corporationId != nil {
                map["corporationId"] = self.corporationId!
            }
            if self.originalCorpId != nil {
                map["originalCorpId"] = self.originalCorpId!
            }
            if self.progress != nil {
                map["progress"] = self.progress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizId") && dict["bizId"] != nil {
                self.bizId = dict["bizId"] as! String
            }
            if dict.keys.contains("channel") && dict["channel"] != nil {
                self.channel = dict["channel"] as! String
            }
            if dict.keys.contains("corporationId") && dict["corporationId"] != nil {
                self.corporationId = dict["corporationId"] as! String
            }
            if dict.keys.contains("originalCorpId") && dict["originalCorpId"] != nil {
                self.originalCorpId = dict["originalCorpId"] as! String
            }
            if dict.keys.contains("progress") && dict["progress"] != nil {
                self.progress = dict["progress"] as! String
            }
        }
    }
    public var data: GetTenantApplicationResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetTenantApplicationResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetTenantApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTenantApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTenantApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTenantStatusRequest : Tea.TeaModel {
    public var tenantRamId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tenantRamId != nil {
            map["tenantRamId"] = self.tenantRamId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("tenantRamId") && dict["tenantRamId"] != nil {
            self.tenantRamId = dict["tenantRamId"] as! Int64
        }
    }
}

public class GetTenantStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var tenantStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tenantStatus != nil {
                map["tenantStatus"] = self.tenantStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tenantStatus") && dict["tenantStatus"] != nil {
                self.tenantStatus = dict["tenantStatus"] as! Int32
            }
        }
    }
    public var data: GetTenantStatusResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetTenantStatusResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetTenantStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTenantStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTenantStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ServiceGroups : Tea.TeaModel {
            public var name: String?

            public var serviceGroupId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.serviceGroupId != nil {
                    map["serviceGroupId"] = self.serviceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("name") && dict["name"] != nil {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                    self.serviceGroupId = dict["serviceGroupId"] as! Int64
                }
            }
        }
        public var accountType: String?

        public var createTime: String?

        public var email: String?

        public var isEditableUser: Bool?

        public var isRelated: String?

        public var phone: String?

        public var ramId: String?

        public var roleIdList: [Int64]?

        public var roleNameList: [String]?

        public var serviceGroups: [GetUserResponseBody.Data.ServiceGroups]?

        public var userId: Int64?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountType != nil {
                map["accountType"] = self.accountType!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.isEditableUser != nil {
                map["isEditableUser"] = self.isEditableUser!
            }
            if self.isRelated != nil {
                map["isRelated"] = self.isRelated!
            }
            if self.phone != nil {
                map["phone"] = self.phone!
            }
            if self.ramId != nil {
                map["ramId"] = self.ramId!
            }
            if self.roleIdList != nil {
                map["roleIdList"] = self.roleIdList!
            }
            if self.roleNameList != nil {
                map["roleNameList"] = self.roleNameList!
            }
            if self.serviceGroups != nil {
                var tmp : [Any] = []
                for k in self.serviceGroups! {
                    tmp.append(k.toMap())
                }
                map["serviceGroups"] = tmp
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountType") && dict["accountType"] != nil {
                self.accountType = dict["accountType"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("email") && dict["email"] != nil {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("isEditableUser") && dict["isEditableUser"] != nil {
                self.isEditableUser = dict["isEditableUser"] as! Bool
            }
            if dict.keys.contains("isRelated") && dict["isRelated"] != nil {
                self.isRelated = dict["isRelated"] as! String
            }
            if dict.keys.contains("phone") && dict["phone"] != nil {
                self.phone = dict["phone"] as! String
            }
            if dict.keys.contains("ramId") && dict["ramId"] != nil {
                self.ramId = dict["ramId"] as! String
            }
            if dict.keys.contains("roleIdList") && dict["roleIdList"] != nil {
                self.roleIdList = dict["roleIdList"] as! [Int64]
            }
            if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                self.roleNameList = dict["roleNameList"] as! [String]
            }
            if dict.keys.contains("serviceGroups") && dict["serviceGroups"] != nil {
                var tmp : [GetUserResponseBody.Data.ServiceGroups] = []
                for v in dict["serviceGroups"] as! [Any] {
                    var model = GetUserResponseBody.Data.ServiceGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceGroups = tmp
            }
            if dict.keys.contains("userId") && dict["userId"] != nil {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("username") && dict["username"] != nil {
                self.username = dict["username"] as! String
            }
        }
    }
    public var data: GetUserResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = GetUserResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserGuideStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class GetUserGuideStatusResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! [String: Any]
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetUserGuideStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserGuideStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserGuideStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertsRequest : Tea.TeaModel {
    public var alertLevel: String?

    public var alertName: String?

    public var alertSourceName: String?

    public var endTime: String?

    public var monitorSourceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var relatedServiceId: Int64?

    public var ruleName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLevel != nil {
            map["alertLevel"] = self.alertLevel!
        }
        if self.alertName != nil {
            map["alertName"] = self.alertName!
        }
        if self.alertSourceName != nil {
            map["alertSourceName"] = self.alertSourceName!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.monitorSourceId != nil {
            map["monitorSourceId"] = self.monitorSourceId!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("alertLevel") && dict["alertLevel"] != nil {
            self.alertLevel = dict["alertLevel"] as! String
        }
        if dict.keys.contains("alertName") && dict["alertName"] != nil {
            self.alertName = dict["alertName"] as! String
        }
        if dict.keys.contains("alertSourceName") && dict["alertSourceName"] != nil {
            self.alertSourceName = dict["alertSourceName"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
            self.monitorSourceId = dict["monitorSourceId"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ListAlertsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alertId: Int64?

        public var alertLevel: String?

        public var alertNumber: String?

        public var alertSourceName: String?

        public var createTime: String?

        public var firstEventTime: String?

        public var monitorSourceName: String?

        public var relServiceDeleteType: Int32?

        public var relatedServiceName: String?

        public var routeRuleDeleteType: Int32?

        public var routeRuleId: Int64?

        public var routeRuleName: String?

        public var sourceEventCount: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertId != nil {
                map["alertId"] = self.alertId!
            }
            if self.alertLevel != nil {
                map["alertLevel"] = self.alertLevel!
            }
            if self.alertNumber != nil {
                map["alertNumber"] = self.alertNumber!
            }
            if self.alertSourceName != nil {
                map["alertSourceName"] = self.alertSourceName!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.firstEventTime != nil {
                map["firstEventTime"] = self.firstEventTime!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleDeleteType != nil {
                map["routeRuleDeleteType"] = self.routeRuleDeleteType!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeRuleName != nil {
                map["routeRuleName"] = self.routeRuleName!
            }
            if self.sourceEventCount != nil {
                map["sourceEventCount"] = self.sourceEventCount!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("alertId") && dict["alertId"] != nil {
                self.alertId = dict["alertId"] as! Int64
            }
            if dict.keys.contains("alertLevel") && dict["alertLevel"] != nil {
                self.alertLevel = dict["alertLevel"] as! String
            }
            if dict.keys.contains("alertNumber") && dict["alertNumber"] != nil {
                self.alertNumber = dict["alertNumber"] as! String
            }
            if dict.keys.contains("alertSourceName") && dict["alertSourceName"] != nil {
                self.alertSourceName = dict["alertSourceName"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("firstEventTime") && dict["firstEventTime"] != nil {
                self.firstEventTime = dict["firstEventTime"] as! String
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleDeleteType") && dict["routeRuleDeleteType"] != nil {
                self.routeRuleDeleteType = dict["routeRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeRuleName") && dict["routeRuleName"] != nil {
                self.routeRuleName = dict["routeRuleName"] as! String
            }
            if dict.keys.contains("sourceEventCount") && dict["sourceEventCount"] != nil {
                self.sourceEventCount = dict["sourceEventCount"] as! Int64
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListAlertsResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListAlertsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListAlertsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListByMonitorSourceIdRequest : Tea.TeaModel {
    public var monitorSourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorSourceId != nil {
            map["monitorSourceId"] = self.monitorSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
            self.monitorSourceId = dict["monitorSourceId"] as! String
        }
    }
}

public class ListByMonitorSourceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
                self.ruleName = dict["ruleName"] as! String
            }
        }
    }
    public var data: [ListByMonitorSourceIdResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListByMonitorSourceIdResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListByMonitorSourceIdResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListByMonitorSourceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListByMonitorSourceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListByMonitorSourceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChartDataForServiceGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ListChartDataForServiceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var effectionLevel: [String: Any]?

        public var escalationIncidentCount: Int64?

        public var incidentCount: Int64?

        public var meanTimeToAcknowledge: Int64?

        public var meanTimeToRepair: Int64?

        public var time: String?

        public var totalMeanTimeToAcknowledge: Int64?

        public var totalMeanTimeToRepair: Int64?

        public var unAcknowledgedEscalationIncidentCount: Int64?

        public var unFinishEscalationIncidentCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectionLevel != nil {
                map["effectionLevel"] = self.effectionLevel!
            }
            if self.escalationIncidentCount != nil {
                map["escalationIncidentCount"] = self.escalationIncidentCount!
            }
            if self.incidentCount != nil {
                map["incidentCount"] = self.incidentCount!
            }
            if self.meanTimeToAcknowledge != nil {
                map["meanTimeToAcknowledge"] = self.meanTimeToAcknowledge!
            }
            if self.meanTimeToRepair != nil {
                map["meanTimeToRepair"] = self.meanTimeToRepair!
            }
            if self.time != nil {
                map["time"] = self.time!
            }
            if self.totalMeanTimeToAcknowledge != nil {
                map["totalMeanTimeToAcknowledge"] = self.totalMeanTimeToAcknowledge!
            }
            if self.totalMeanTimeToRepair != nil {
                map["totalMeanTimeToRepair"] = self.totalMeanTimeToRepair!
            }
            if self.unAcknowledgedEscalationIncidentCount != nil {
                map["unAcknowledgedEscalationIncidentCount"] = self.unAcknowledgedEscalationIncidentCount!
            }
            if self.unFinishEscalationIncidentCount != nil {
                map["unFinishEscalationIncidentCount"] = self.unFinishEscalationIncidentCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("effectionLevel") && dict["effectionLevel"] != nil {
                self.effectionLevel = dict["effectionLevel"] as! [String: Any]
            }
            if dict.keys.contains("escalationIncidentCount") && dict["escalationIncidentCount"] != nil {
                self.escalationIncidentCount = dict["escalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("incidentCount") && dict["incidentCount"] != nil {
                self.incidentCount = dict["incidentCount"] as! Int64
            }
            if dict.keys.contains("meanTimeToAcknowledge") && dict["meanTimeToAcknowledge"] != nil {
                self.meanTimeToAcknowledge = dict["meanTimeToAcknowledge"] as! Int64
            }
            if dict.keys.contains("meanTimeToRepair") && dict["meanTimeToRepair"] != nil {
                self.meanTimeToRepair = dict["meanTimeToRepair"] as! Int64
            }
            if dict.keys.contains("time") && dict["time"] != nil {
                self.time = dict["time"] as! String
            }
            if dict.keys.contains("totalMeanTimeToAcknowledge") && dict["totalMeanTimeToAcknowledge"] != nil {
                self.totalMeanTimeToAcknowledge = dict["totalMeanTimeToAcknowledge"] as! Int64
            }
            if dict.keys.contains("totalMeanTimeToRepair") && dict["totalMeanTimeToRepair"] != nil {
                self.totalMeanTimeToRepair = dict["totalMeanTimeToRepair"] as! Int64
            }
            if dict.keys.contains("unAcknowledgedEscalationIncidentCount") && dict["unAcknowledgedEscalationIncidentCount"] != nil {
                self.unAcknowledgedEscalationIncidentCount = dict["unAcknowledgedEscalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("unFinishEscalationIncidentCount") && dict["unFinishEscalationIncidentCount"] != nil {
                self.unFinishEscalationIncidentCount = dict["unFinishEscalationIncidentCount"] as! Int64
            }
        }
    }
    public var data: [ListChartDataForServiceGroupResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListChartDataForServiceGroupResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListChartDataForServiceGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListChartDataForServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChartDataForServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListChartDataForServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChartDataForUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ListChartDataForUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var effectionLevel: [String: Any]?

        public var escalationIncidentCount: Int64?

        public var incidentCount: Int64?

        public var meanTimeToAcknowledge: Int64?

        public var meanTimeToRepair: Int64?

        public var time: String?

        public var totalMeanTimeToAcknowledge: Int64?

        public var totalMeanTimeToRepair: Int64?

        public var unAcknowledgedEscalationIncidentCount: Int64?

        public var unFinishEscalationIncidentCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectionLevel != nil {
                map["effectionLevel"] = self.effectionLevel!
            }
            if self.escalationIncidentCount != nil {
                map["escalationIncidentCount"] = self.escalationIncidentCount!
            }
            if self.incidentCount != nil {
                map["incidentCount"] = self.incidentCount!
            }
            if self.meanTimeToAcknowledge != nil {
                map["meanTimeToAcknowledge"] = self.meanTimeToAcknowledge!
            }
            if self.meanTimeToRepair != nil {
                map["meanTimeToRepair"] = self.meanTimeToRepair!
            }
            if self.time != nil {
                map["time"] = self.time!
            }
            if self.totalMeanTimeToAcknowledge != nil {
                map["totalMeanTimeToAcknowledge"] = self.totalMeanTimeToAcknowledge!
            }
            if self.totalMeanTimeToRepair != nil {
                map["totalMeanTimeToRepair"] = self.totalMeanTimeToRepair!
            }
            if self.unAcknowledgedEscalationIncidentCount != nil {
                map["unAcknowledgedEscalationIncidentCount"] = self.unAcknowledgedEscalationIncidentCount!
            }
            if self.unFinishEscalationIncidentCount != nil {
                map["unFinishEscalationIncidentCount"] = self.unFinishEscalationIncidentCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("effectionLevel") && dict["effectionLevel"] != nil {
                self.effectionLevel = dict["effectionLevel"] as! [String: Any]
            }
            if dict.keys.contains("escalationIncidentCount") && dict["escalationIncidentCount"] != nil {
                self.escalationIncidentCount = dict["escalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("incidentCount") && dict["incidentCount"] != nil {
                self.incidentCount = dict["incidentCount"] as! Int64
            }
            if dict.keys.contains("meanTimeToAcknowledge") && dict["meanTimeToAcknowledge"] != nil {
                self.meanTimeToAcknowledge = dict["meanTimeToAcknowledge"] as! Int64
            }
            if dict.keys.contains("meanTimeToRepair") && dict["meanTimeToRepair"] != nil {
                self.meanTimeToRepair = dict["meanTimeToRepair"] as! Int64
            }
            if dict.keys.contains("time") && dict["time"] != nil {
                self.time = dict["time"] as! String
            }
            if dict.keys.contains("totalMeanTimeToAcknowledge") && dict["totalMeanTimeToAcknowledge"] != nil {
                self.totalMeanTimeToAcknowledge = dict["totalMeanTimeToAcknowledge"] as! Int64
            }
            if dict.keys.contains("totalMeanTimeToRepair") && dict["totalMeanTimeToRepair"] != nil {
                self.totalMeanTimeToRepair = dict["totalMeanTimeToRepair"] as! Int64
            }
            if dict.keys.contains("unAcknowledgedEscalationIncidentCount") && dict["unAcknowledgedEscalationIncidentCount"] != nil {
                self.unAcknowledgedEscalationIncidentCount = dict["unAcknowledgedEscalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("unFinishEscalationIncidentCount") && dict["unFinishEscalationIncidentCount"] != nil {
                self.unFinishEscalationIncidentCount = dict["unFinishEscalationIncidentCount"] as! Int64
            }
        }
    }
    public var data: [ListChartDataForUserResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListChartDataForUserResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListChartDataForUserResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListChartDataForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChartDataForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListChartDataForUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ListConfigsResponseBody : Tea.TeaModel {
    public var data: [String: [DataValue]]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in dict["data"] as! [String: Any] {
                var l1 : [DataValue] = []
                for v1 in v as! [Any] {
                    var model = DataValue()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataReportForServiceGroupRequest : Tea.TeaModel {
    public var endTime: String?

    public var serviceGroupName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.serviceGroupName != nil {
            map["serviceGroupName"] = self.serviceGroupName!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
            self.serviceGroupName = dict["serviceGroupName"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ListDataReportForServiceGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var escalationIncidentCount: Int64?

        public var finishIncidentCount: Int64?

        public var finishProportion: String?

        public var incidentCount: Int64?

        public var meanTimeToAcknowledge: Int64?

        public var meanTimeToRepair: Int64?

        public var serviceGroupId: Int64?

        public var serviceGroupName: String?

        public var unAcknowledgedEscalationIncidentCount: Int64?

        public var unFinishEscalationIncidentCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationIncidentCount != nil {
                map["escalationIncidentCount"] = self.escalationIncidentCount!
            }
            if self.finishIncidentCount != nil {
                map["finishIncidentCount"] = self.finishIncidentCount!
            }
            if self.finishProportion != nil {
                map["finishProportion"] = self.finishProportion!
            }
            if self.incidentCount != nil {
                map["incidentCount"] = self.incidentCount!
            }
            if self.meanTimeToAcknowledge != nil {
                map["meanTimeToAcknowledge"] = self.meanTimeToAcknowledge!
            }
            if self.meanTimeToRepair != nil {
                map["meanTimeToRepair"] = self.meanTimeToRepair!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.serviceGroupName != nil {
                map["serviceGroupName"] = self.serviceGroupName!
            }
            if self.unAcknowledgedEscalationIncidentCount != nil {
                map["unAcknowledgedEscalationIncidentCount"] = self.unAcknowledgedEscalationIncidentCount!
            }
            if self.unFinishEscalationIncidentCount != nil {
                map["unFinishEscalationIncidentCount"] = self.unFinishEscalationIncidentCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationIncidentCount") && dict["escalationIncidentCount"] != nil {
                self.escalationIncidentCount = dict["escalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("finishIncidentCount") && dict["finishIncidentCount"] != nil {
                self.finishIncidentCount = dict["finishIncidentCount"] as! Int64
            }
            if dict.keys.contains("finishProportion") && dict["finishProportion"] != nil {
                self.finishProportion = dict["finishProportion"] as! String
            }
            if dict.keys.contains("incidentCount") && dict["incidentCount"] != nil {
                self.incidentCount = dict["incidentCount"] as! Int64
            }
            if dict.keys.contains("meanTimeToAcknowledge") && dict["meanTimeToAcknowledge"] != nil {
                self.meanTimeToAcknowledge = dict["meanTimeToAcknowledge"] as! Int64
            }
            if dict.keys.contains("meanTimeToRepair") && dict["meanTimeToRepair"] != nil {
                self.meanTimeToRepair = dict["meanTimeToRepair"] as! Int64
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                self.serviceGroupName = dict["serviceGroupName"] as! String
            }
            if dict.keys.contains("unAcknowledgedEscalationIncidentCount") && dict["unAcknowledgedEscalationIncidentCount"] != nil {
                self.unAcknowledgedEscalationIncidentCount = dict["unAcknowledgedEscalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("unFinishEscalationIncidentCount") && dict["unFinishEscalationIncidentCount"] != nil {
                self.unFinishEscalationIncidentCount = dict["unFinishEscalationIncidentCount"] as! Int64
            }
        }
    }
    public var data: [ListDataReportForServiceGroupResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSIze: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSIze != nil {
            map["pageSIze"] = self.pageSIze!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListDataReportForServiceGroupResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListDataReportForServiceGroupResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSIze") && dict["pageSIze"] != nil {
            self.pageSIze = dict["pageSIze"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListDataReportForServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataReportForServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataReportForServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataReportForUserRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ListDataReportForUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var distributionIncidentCount: Int64?

        public var escalationIncidentCount: Int64?

        public var finishIncidentNumber: Int64?

        public var finishProportion: String?

        public var meanTimeToAcknowledge: String?

        public var meanTimeToRepair: String?

        public var unAcknowledgedEscalationIncidentCount: Int64?

        public var unDistributionIncidentCount: Int64?

        public var unFinishEscalationIncidentCount: Int64?

        public var userId: Int64?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distributionIncidentCount != nil {
                map["distributionIncidentCount"] = self.distributionIncidentCount!
            }
            if self.escalationIncidentCount != nil {
                map["escalationIncidentCount"] = self.escalationIncidentCount!
            }
            if self.finishIncidentNumber != nil {
                map["finishIncidentNumber"] = self.finishIncidentNumber!
            }
            if self.finishProportion != nil {
                map["finishProportion"] = self.finishProportion!
            }
            if self.meanTimeToAcknowledge != nil {
                map["meanTimeToAcknowledge"] = self.meanTimeToAcknowledge!
            }
            if self.meanTimeToRepair != nil {
                map["meanTimeToRepair"] = self.meanTimeToRepair!
            }
            if self.unAcknowledgedEscalationIncidentCount != nil {
                map["unAcknowledgedEscalationIncidentCount"] = self.unAcknowledgedEscalationIncidentCount!
            }
            if self.unDistributionIncidentCount != nil {
                map["unDistributionIncidentCount"] = self.unDistributionIncidentCount!
            }
            if self.unFinishEscalationIncidentCount != nil {
                map["unFinishEscalationIncidentCount"] = self.unFinishEscalationIncidentCount!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("distributionIncidentCount") && dict["distributionIncidentCount"] != nil {
                self.distributionIncidentCount = dict["distributionIncidentCount"] as! Int64
            }
            if dict.keys.contains("escalationIncidentCount") && dict["escalationIncidentCount"] != nil {
                self.escalationIncidentCount = dict["escalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("finishIncidentNumber") && dict["finishIncidentNumber"] != nil {
                self.finishIncidentNumber = dict["finishIncidentNumber"] as! Int64
            }
            if dict.keys.contains("finishProportion") && dict["finishProportion"] != nil {
                self.finishProportion = dict["finishProportion"] as! String
            }
            if dict.keys.contains("meanTimeToAcknowledge") && dict["meanTimeToAcknowledge"] != nil {
                self.meanTimeToAcknowledge = dict["meanTimeToAcknowledge"] as! String
            }
            if dict.keys.contains("meanTimeToRepair") && dict["meanTimeToRepair"] != nil {
                self.meanTimeToRepair = dict["meanTimeToRepair"] as! String
            }
            if dict.keys.contains("unAcknowledgedEscalationIncidentCount") && dict["unAcknowledgedEscalationIncidentCount"] != nil {
                self.unAcknowledgedEscalationIncidentCount = dict["unAcknowledgedEscalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("unDistributionIncidentCount") && dict["unDistributionIncidentCount"] != nil {
                self.unDistributionIncidentCount = dict["unDistributionIncidentCount"] as! Int64
            }
            if dict.keys.contains("unFinishEscalationIncidentCount") && dict["unFinishEscalationIncidentCount"] != nil {
                self.unFinishEscalationIncidentCount = dict["unFinishEscalationIncidentCount"] as! Int64
            }
            if dict.keys.contains("userId") && dict["userId"] != nil {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("userName") && dict["userName"] != nil {
                self.userName = dict["userName"] as! String
            }
        }
    }
    public var data: [ListDataReportForUserResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListDataReportForUserResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListDataReportForUserResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListDataReportForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataReportForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDataReportForUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDictionariesRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ListDictionariesResponseBody : Tea.TeaModel {
    public var data: [String: [DataValue]]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in dict["data"] as! [String: Any] {
                var l1 : [DataValue] = []
                for v1 in v as! [Any] {
                    var model = DataValue()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListDictionariesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDictionariesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDictionariesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEscalationPlanServicesRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ListEscalationPlanServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var scope: String?

        public var scopeObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.scopeObjectId != nil {
                map["scopeObjectId"] = self.scopeObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("scope") && dict["scope"] != nil {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                self.scopeObjectId = dict["scopeObjectId"] as! Int64
            }
        }
    }
    public var data: [ListEscalationPlanServicesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListEscalationPlanServicesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListEscalationPlanServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListEscalationPlanServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEscalationPlanServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEscalationPlanServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEscalationPlansRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanName: String?

    public var isGlobal: Bool?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var serviceName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanName != nil {
            map["escalationPlanName"] = self.escalationPlanName!
        }
        if self.isGlobal != nil {
            map["isGlobal"] = self.isGlobal!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
            self.escalationPlanName = dict["escalationPlanName"] as! String
        }
        if dict.keys.contains("isGlobal") && dict["isGlobal"] != nil {
            self.isGlobal = dict["isGlobal"] as! Bool
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
    }
}

public class ListEscalationPlansResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EscalationPlanScopeObjects : Tea.TeaModel {
            public var scope: String?

            public var scopeObjectDeletedType: Int32?

            public var scopeObjectId: Int64?

            public var scopeObjectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scope != nil {
                    map["scope"] = self.scope!
                }
                if self.scopeObjectDeletedType != nil {
                    map["scopeObjectDeletedType"] = self.scopeObjectDeletedType!
                }
                if self.scopeObjectId != nil {
                    map["scopeObjectId"] = self.scopeObjectId!
                }
                if self.scopeObjectName != nil {
                    map["scopeObjectName"] = self.scopeObjectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("scope") && dict["scope"] != nil {
                    self.scope = dict["scope"] as! String
                }
                if dict.keys.contains("scopeObjectDeletedType") && dict["scopeObjectDeletedType"] != nil {
                    self.scopeObjectDeletedType = dict["scopeObjectDeletedType"] as! Int32
                }
                if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                    self.scopeObjectId = dict["scopeObjectId"] as! Int64
                }
                if dict.keys.contains("scopeObjectName") && dict["scopeObjectName"] != nil {
                    self.scopeObjectName = dict["scopeObjectName"] as! String
                }
            }
        }
        public var escalationPlanId: Int64?

        public var escalationPlanName: String?

        public var escalationPlanScopeObjects: [ListEscalationPlansResponseBody.Data.EscalationPlanScopeObjects]?

        public var isGlobal: Bool?

        public var modifyTime: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.escalationPlanName != nil {
                map["escalationPlanName"] = self.escalationPlanName!
            }
            if self.escalationPlanScopeObjects != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanScopeObjects! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanScopeObjects"] = tmp
            }
            if self.isGlobal != nil {
                map["isGlobal"] = self.isGlobal!
            }
            if self.modifyTime != nil {
                map["modifyTime"] = self.modifyTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                self.escalationPlanName = dict["escalationPlanName"] as! String
            }
            if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
                var tmp : [ListEscalationPlansResponseBody.Data.EscalationPlanScopeObjects] = []
                for v in dict["escalationPlanScopeObjects"] as! [Any] {
                    var model = ListEscalationPlansResponseBody.Data.EscalationPlanScopeObjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanScopeObjects = tmp
            }
            if dict.keys.contains("isGlobal") && dict["isGlobal"] != nil {
                self.isGlobal = dict["isGlobal"] as! Bool
            }
            if dict.keys.contains("modifyTime") && dict["modifyTime"] != nil {
                self.modifyTime = dict["modifyTime"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
        }
    }
    public var data: [ListEscalationPlansResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListEscalationPlansResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListEscalationPlansResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListEscalationPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEscalationPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEscalationPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEscalationPlansByNoticeObjectRequest : Tea.TeaModel {
    public var noticeObjectId: Int64?

    public var noticeObjectType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.noticeObjectId != nil {
            map["noticeObjectId"] = self.noticeObjectId!
        }
        if self.noticeObjectType != nil {
            map["noticeObjectType"] = self.noticeObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("noticeObjectId") && dict["noticeObjectId"] != nil {
            self.noticeObjectId = dict["noticeObjectId"] as! Int64
        }
        if dict.keys.contains("noticeObjectType") && dict["noticeObjectType"] != nil {
            self.noticeObjectType = dict["noticeObjectType"] as! Int64
        }
    }
}

public class ListEscalationPlansByNoticeObjectResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EscalationPlanScopeObjects : Tea.TeaModel {
            public var scope: String?

            public var scopeObjectDeletedType: Int32?

            public var scopeObjectId: Int64?

            public var scopeObjectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scope != nil {
                    map["scope"] = self.scope!
                }
                if self.scopeObjectDeletedType != nil {
                    map["scopeObjectDeletedType"] = self.scopeObjectDeletedType!
                }
                if self.scopeObjectId != nil {
                    map["scopeObjectId"] = self.scopeObjectId!
                }
                if self.scopeObjectName != nil {
                    map["scopeObjectName"] = self.scopeObjectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("scope") && dict["scope"] != nil {
                    self.scope = dict["scope"] as! String
                }
                if dict.keys.contains("scopeObjectDeletedType") && dict["scopeObjectDeletedType"] != nil {
                    self.scopeObjectDeletedType = dict["scopeObjectDeletedType"] as! Int32
                }
                if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                    self.scopeObjectId = dict["scopeObjectId"] as! Int64
                }
                if dict.keys.contains("scopeObjectName") && dict["scopeObjectName"] != nil {
                    self.scopeObjectName = dict["scopeObjectName"] as! String
                }
            }
        }
        public var escalationPlanId: Int64?

        public var escalationPlanName: String?

        public var escalationPlanScopeObjects: [ListEscalationPlansByNoticeObjectResponseBody.Data.EscalationPlanScopeObjects]?

        public var modifyTime: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.escalationPlanName != nil {
                map["escalationPlanName"] = self.escalationPlanName!
            }
            if self.escalationPlanScopeObjects != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanScopeObjects! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanScopeObjects"] = tmp
            }
            if self.modifyTime != nil {
                map["modifyTime"] = self.modifyTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                self.escalationPlanName = dict["escalationPlanName"] as! String
            }
            if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
                var tmp : [ListEscalationPlansByNoticeObjectResponseBody.Data.EscalationPlanScopeObjects] = []
                for v in dict["escalationPlanScopeObjects"] as! [Any] {
                    var model = ListEscalationPlansByNoticeObjectResponseBody.Data.EscalationPlanScopeObjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanScopeObjects = tmp
            }
            if dict.keys.contains("modifyTime") && dict["modifyTime"] != nil {
                self.modifyTime = dict["modifyTime"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
        }
    }
    public var data: [ListEscalationPlansByNoticeObjectResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListEscalationPlansByNoticeObjectResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListEscalationPlansByNoticeObjectResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListEscalationPlansByNoticeObjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEscalationPlansByNoticeObjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEscalationPlansByNoticeObjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIncidentDetailEscalationPlansRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class ListIncidentDetailEscalationPlansResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConvergenceEscalationPlan : Tea.TeaModel {
            public class NoticeObjectList : Tea.TeaModel {
                public var noticeObjectId: Int64?

                public var noticeObjectName: String?

                public var noticeObjectPhone: String?

                public var roleNameList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.noticeObjectId != nil {
                        map["noticeObjectId"] = self.noticeObjectId!
                    }
                    if self.noticeObjectName != nil {
                        map["noticeObjectName"] = self.noticeObjectName!
                    }
                    if self.noticeObjectPhone != nil {
                        map["noticeObjectPhone"] = self.noticeObjectPhone!
                    }
                    if self.roleNameList != nil {
                        map["roleNameList"] = self.roleNameList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("noticeObjectId") && dict["noticeObjectId"] != nil {
                        self.noticeObjectId = dict["noticeObjectId"] as! Int64
                    }
                    if dict.keys.contains("noticeObjectName") && dict["noticeObjectName"] != nil {
                        self.noticeObjectName = dict["noticeObjectName"] as! String
                    }
                    if dict.keys.contains("noticeObjectPhone") && dict["noticeObjectPhone"] != nil {
                        self.noticeObjectPhone = dict["noticeObjectPhone"] as! String
                    }
                    if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                        self.roleNameList = dict["roleNameList"] as! [String]
                    }
                }
            }
            public class ServiceGroupList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var escalationPlanType: String?

            public var noticeChannels: [String]?

            public var noticeObjectList: [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.NoticeObjectList]?

            public var noticeTime: Int64?

            public var serviceGroupList: [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.ServiceGroupList]?

            public var startTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanType != nil {
                    map["escalationPlanType"] = self.escalationPlanType!
                }
                if self.noticeChannels != nil {
                    map["noticeChannels"] = self.noticeChannels!
                }
                if self.noticeObjectList != nil {
                    var tmp : [Any] = []
                    for k in self.noticeObjectList! {
                        tmp.append(k.toMap())
                    }
                    map["noticeObjectList"] = tmp
                }
                if self.noticeTime != nil {
                    map["noticeTime"] = self.noticeTime!
                }
                if self.serviceGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.serviceGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["serviceGroupList"] = tmp
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                    self.escalationPlanType = dict["escalationPlanType"] as! String
                }
                if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                    self.noticeChannels = dict["noticeChannels"] as! [String]
                }
                if dict.keys.contains("noticeObjectList") && dict["noticeObjectList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.NoticeObjectList] = []
                    for v in dict["noticeObjectList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.NoticeObjectList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.noticeObjectList = tmp
                }
                if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                    self.noticeTime = dict["noticeTime"] as! Int64
                }
                if dict.keys.contains("serviceGroupList") && dict["serviceGroupList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.ServiceGroupList] = []
                    for v in dict["serviceGroupList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan.ServiceGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceGroupList = tmp
                }
                if dict.keys.contains("startTime") && dict["startTime"] != nil {
                    self.startTime = dict["startTime"] as! Int64
                }
                if dict.keys.contains("status") && dict["status"] != nil {
                    self.status = dict["status"] as! String
                }
            }
        }
        public class NuAcknowledgeEscalationPlan : Tea.TeaModel {
            public class NoticeObjectList : Tea.TeaModel {
                public var noticeObjectId: Int64?

                public var noticeObjectName: String?

                public var noticeObjectPhone: String?

                public var roleNameList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.noticeObjectId != nil {
                        map["noticeObjectId"] = self.noticeObjectId!
                    }
                    if self.noticeObjectName != nil {
                        map["noticeObjectName"] = self.noticeObjectName!
                    }
                    if self.noticeObjectPhone != nil {
                        map["noticeObjectPhone"] = self.noticeObjectPhone!
                    }
                    if self.roleNameList != nil {
                        map["roleNameList"] = self.roleNameList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("noticeObjectId") && dict["noticeObjectId"] != nil {
                        self.noticeObjectId = dict["noticeObjectId"] as! Int64
                    }
                    if dict.keys.contains("noticeObjectName") && dict["noticeObjectName"] != nil {
                        self.noticeObjectName = dict["noticeObjectName"] as! String
                    }
                    if dict.keys.contains("noticeObjectPhone") && dict["noticeObjectPhone"] != nil {
                        self.noticeObjectPhone = dict["noticeObjectPhone"] as! String
                    }
                    if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                        self.roleNameList = dict["roleNameList"] as! [String]
                    }
                }
            }
            public class NoticeRoleObjectList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public class ServiceGroupList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var escalationPlanType: String?

            public var noticeChannels: [String]?

            public var noticeObjectList: [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeObjectList]?

            public var noticeRoleList: [Int64]?

            public var noticeRoleObjectList: [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeRoleObjectList]?

            public var noticeTime: Int64?

            public var serviceGroupList: [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.ServiceGroupList]?

            public var startTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanType != nil {
                    map["escalationPlanType"] = self.escalationPlanType!
                }
                if self.noticeChannels != nil {
                    map["noticeChannels"] = self.noticeChannels!
                }
                if self.noticeObjectList != nil {
                    var tmp : [Any] = []
                    for k in self.noticeObjectList! {
                        tmp.append(k.toMap())
                    }
                    map["noticeObjectList"] = tmp
                }
                if self.noticeRoleList != nil {
                    map["noticeRoleList"] = self.noticeRoleList!
                }
                if self.noticeRoleObjectList != nil {
                    var tmp : [Any] = []
                    for k in self.noticeRoleObjectList! {
                        tmp.append(k.toMap())
                    }
                    map["noticeRoleObjectList"] = tmp
                }
                if self.noticeTime != nil {
                    map["noticeTime"] = self.noticeTime!
                }
                if self.serviceGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.serviceGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["serviceGroupList"] = tmp
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                    self.escalationPlanType = dict["escalationPlanType"] as! String
                }
                if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                    self.noticeChannels = dict["noticeChannels"] as! [String]
                }
                if dict.keys.contains("noticeObjectList") && dict["noticeObjectList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeObjectList] = []
                    for v in dict["noticeObjectList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeObjectList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.noticeObjectList = tmp
                }
                if dict.keys.contains("noticeRoleList") && dict["noticeRoleList"] != nil {
                    self.noticeRoleList = dict["noticeRoleList"] as! [Int64]
                }
                if dict.keys.contains("noticeRoleObjectList") && dict["noticeRoleObjectList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeRoleObjectList] = []
                    for v in dict["noticeRoleObjectList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.NoticeRoleObjectList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.noticeRoleObjectList = tmp
                }
                if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                    self.noticeTime = dict["noticeTime"] as! Int64
                }
                if dict.keys.contains("serviceGroupList") && dict["serviceGroupList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.ServiceGroupList] = []
                    for v in dict["serviceGroupList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan.ServiceGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceGroupList = tmp
                }
                if dict.keys.contains("startTime") && dict["startTime"] != nil {
                    self.startTime = dict["startTime"] as! Int64
                }
                if dict.keys.contains("status") && dict["status"] != nil {
                    self.status = dict["status"] as! String
                }
            }
        }
        public class UnFinishEscalationPlan : Tea.TeaModel {
            public class NoticeObjectList : Tea.TeaModel {
                public var noticeObjectId: Int64?

                public var noticeObjectName: String?

                public var noticeObjectPhone: String?

                public var roleNameList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.noticeObjectId != nil {
                        map["noticeObjectId"] = self.noticeObjectId!
                    }
                    if self.noticeObjectName != nil {
                        map["noticeObjectName"] = self.noticeObjectName!
                    }
                    if self.noticeObjectPhone != nil {
                        map["noticeObjectPhone"] = self.noticeObjectPhone!
                    }
                    if self.roleNameList != nil {
                        map["roleNameList"] = self.roleNameList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("noticeObjectId") && dict["noticeObjectId"] != nil {
                        self.noticeObjectId = dict["noticeObjectId"] as! Int64
                    }
                    if dict.keys.contains("noticeObjectName") && dict["noticeObjectName"] != nil {
                        self.noticeObjectName = dict["noticeObjectName"] as! String
                    }
                    if dict.keys.contains("noticeObjectPhone") && dict["noticeObjectPhone"] != nil {
                        self.noticeObjectPhone = dict["noticeObjectPhone"] as! String
                    }
                    if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                        self.roleNameList = dict["roleNameList"] as! [String]
                    }
                }
            }
            public class NoticeRoleObjectList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public class ServiceGroupList : Tea.TeaModel {
                public var id: Int64?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("id") && dict["id"] != nil {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var escalationPlanType: String?

            public var noticeChannels: [String]?

            public var noticeObjectList: [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeObjectList]?

            public var noticeRoleList: [Int64]?

            public var noticeRoleObjectList: [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeRoleObjectList]?

            public var noticeTime: Int32?

            public var serviceGroupList: [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.ServiceGroupList]?

            public var startTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanType != nil {
                    map["escalationPlanType"] = self.escalationPlanType!
                }
                if self.noticeChannels != nil {
                    map["noticeChannels"] = self.noticeChannels!
                }
                if self.noticeObjectList != nil {
                    var tmp : [Any] = []
                    for k in self.noticeObjectList! {
                        tmp.append(k.toMap())
                    }
                    map["noticeObjectList"] = tmp
                }
                if self.noticeRoleList != nil {
                    map["noticeRoleList"] = self.noticeRoleList!
                }
                if self.noticeRoleObjectList != nil {
                    var tmp : [Any] = []
                    for k in self.noticeRoleObjectList! {
                        tmp.append(k.toMap())
                    }
                    map["noticeRoleObjectList"] = tmp
                }
                if self.noticeTime != nil {
                    map["noticeTime"] = self.noticeTime!
                }
                if self.serviceGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.serviceGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["serviceGroupList"] = tmp
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                    self.escalationPlanType = dict["escalationPlanType"] as! String
                }
                if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                    self.noticeChannels = dict["noticeChannels"] as! [String]
                }
                if dict.keys.contains("noticeObjectList") && dict["noticeObjectList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeObjectList] = []
                    for v in dict["noticeObjectList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeObjectList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.noticeObjectList = tmp
                }
                if dict.keys.contains("noticeRoleList") && dict["noticeRoleList"] != nil {
                    self.noticeRoleList = dict["noticeRoleList"] as! [Int64]
                }
                if dict.keys.contains("noticeRoleObjectList") && dict["noticeRoleObjectList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeRoleObjectList] = []
                    for v in dict["noticeRoleObjectList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.NoticeRoleObjectList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.noticeRoleObjectList = tmp
                }
                if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                    self.noticeTime = dict["noticeTime"] as! Int32
                }
                if dict.keys.contains("serviceGroupList") && dict["serviceGroupList"] != nil {
                    var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.ServiceGroupList] = []
                    for v in dict["serviceGroupList"] as! [Any] {
                        var model = ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan.ServiceGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceGroupList = tmp
                }
                if dict.keys.contains("startTime") && dict["startTime"] != nil {
                    self.startTime = dict["startTime"] as! Int64
                }
                if dict.keys.contains("status") && dict["status"] != nil {
                    self.status = dict["status"] as! String
                }
            }
        }
        public var convergenceEscalationPlan: [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan]?

        public var escalationPlanId: Int64?

        public var escalationPlanName: String?

        public var nuAcknowledgeEscalationPlan: [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan]?

        public var unFinishEscalationPlan: [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.convergenceEscalationPlan != nil {
                var tmp : [Any] = []
                for k in self.convergenceEscalationPlan! {
                    tmp.append(k.toMap())
                }
                map["convergenceEscalationPlan"] = tmp
            }
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.escalationPlanName != nil {
                map["escalationPlanName"] = self.escalationPlanName!
            }
            if self.nuAcknowledgeEscalationPlan != nil {
                var tmp : [Any] = []
                for k in self.nuAcknowledgeEscalationPlan! {
                    tmp.append(k.toMap())
                }
                map["nuAcknowledgeEscalationPlan"] = tmp
            }
            if self.unFinishEscalationPlan != nil {
                var tmp : [Any] = []
                for k in self.unFinishEscalationPlan! {
                    tmp.append(k.toMap())
                }
                map["unFinishEscalationPlan"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("convergenceEscalationPlan") && dict["convergenceEscalationPlan"] != nil {
                var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan] = []
                for v in dict["convergenceEscalationPlan"] as! [Any] {
                    var model = ListIncidentDetailEscalationPlansResponseBody.Data.ConvergenceEscalationPlan()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.convergenceEscalationPlan = tmp
            }
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                self.escalationPlanName = dict["escalationPlanName"] as! String
            }
            if dict.keys.contains("nuAcknowledgeEscalationPlan") && dict["nuAcknowledgeEscalationPlan"] != nil {
                var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan] = []
                for v in dict["nuAcknowledgeEscalationPlan"] as! [Any] {
                    var model = ListIncidentDetailEscalationPlansResponseBody.Data.NuAcknowledgeEscalationPlan()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nuAcknowledgeEscalationPlan = tmp
            }
            if dict.keys.contains("unFinishEscalationPlan") && dict["unFinishEscalationPlan"] != nil {
                var tmp : [ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan] = []
                for v in dict["unFinishEscalationPlan"] as! [Any] {
                    var model = ListIncidentDetailEscalationPlansResponseBody.Data.UnFinishEscalationPlan()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.unFinishEscalationPlan = tmp
            }
        }
    }
    public var data: ListIncidentDetailEscalationPlansResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = ListIncidentDetailEscalationPlansResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListIncidentDetailEscalationPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIncidentDetailEscalationPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIncidentDetailEscalationPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIncidentDetailTimelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var idSort: String?

    public var incidentId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.idSort != nil {
            map["idSort"] = self.idSort!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("idSort") && dict["idSort"] != nil {
            self.idSort = dict["idSort"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
    }
}

public class ListIncidentDetailTimelinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var createTime: String?

        public var description_: String?

        public var incidentId: Int64?

        public var relRouteRuleDeleteType: Int32?

        public var relatedServiceName: String?

        public var remark: String?

        public var snapshotData: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.relRouteRuleDeleteType != nil {
                map["relRouteRuleDeleteType"] = self.relRouteRuleDeleteType!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.snapshotData != nil {
                map["snapshotData"] = self.snapshotData!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("action") && dict["action"] != nil {
                self.action = dict["action"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("relRouteRuleDeleteType") && dict["relRouteRuleDeleteType"] != nil {
                self.relRouteRuleDeleteType = dict["relRouteRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("remark") && dict["remark"] != nil {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("snapshotData") && dict["snapshotData"] != nil {
                self.snapshotData = dict["snapshotData"] as! String
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListIncidentDetailTimelinesResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIncidentDetailTimelinesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIncidentDetailTimelinesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListIncidentDetailTimelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIncidentDetailTimelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIncidentDetailTimelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIncidentSubtotalsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
    }
}

public class ListIncidentSubtotalsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: String?

        public var createUserId: Int64?

        public var createUserName: String?

        public var createUserPhone: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.createUserId != nil {
                map["createUserId"] = self.createUserId!
            }
            if self.createUserName != nil {
                map["createUserName"] = self.createUserName!
            }
            if self.createUserPhone != nil {
                map["createUserPhone"] = self.createUserPhone!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("createUserId") && dict["createUserId"] != nil {
                self.createUserId = dict["createUserId"] as! Int64
            }
            if dict.keys.contains("createUserName") && dict["createUserName"] != nil {
                self.createUserName = dict["createUserName"] as! String
            }
            if dict.keys.contains("createUserPhone") && dict["createUserPhone"] != nil {
                self.createUserPhone = dict["createUserPhone"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
        }
    }
    public var data: [ListIncidentSubtotalsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIncidentSubtotalsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIncidentSubtotalsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListIncidentSubtotalsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIncidentSubtotalsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIncidentSubtotalsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIncidentTimelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
    }
}

public class ListIncidentTimelinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var createTime: String?

        public var description_: Int64?

        public var incidentId: Int64?

        public var incidentNumber: String?

        public var incidentTitle: String?

        public var relRouteRuleDeleteType: Int32?

        public var relatedServiceName: String?

        public var remark: String?

        public var snapshotData: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.incidentNumber != nil {
                map["incidentNumber"] = self.incidentNumber!
            }
            if self.incidentTitle != nil {
                map["incidentTitle"] = self.incidentTitle!
            }
            if self.relRouteRuleDeleteType != nil {
                map["relRouteRuleDeleteType"] = self.relRouteRuleDeleteType!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.snapshotData != nil {
                map["snapshotData"] = self.snapshotData!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("action") && dict["action"] != nil {
                self.action = dict["action"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! Int64
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                self.incidentNumber = dict["incidentNumber"] as! String
            }
            if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                self.incidentTitle = dict["incidentTitle"] as! String
            }
            if dict.keys.contains("relRouteRuleDeleteType") && dict["relRouteRuleDeleteType"] != nil {
                self.relRouteRuleDeleteType = dict["relRouteRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("remark") && dict["remark"] != nil {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("snapshotData") && dict["snapshotData"] != nil {
                self.snapshotData = dict["snapshotData"] as! String
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListIncidentTimelinesResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIncidentTimelinesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIncidentTimelinesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListIncidentTimelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIncidentTimelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIncidentTimelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIncidentsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var createEndTime: String?

    public var createStartTime: String?

    public var effect: String?

    public var incidentLevel: String?

    public var incidentStatus: String?

    public var me: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var relationServiceId: Int64?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.effect != nil {
            map["effect"] = self.effect!
        }
        if self.incidentLevel != nil {
            map["incidentLevel"] = self.incidentLevel!
        }
        if self.incidentStatus != nil {
            map["incidentStatus"] = self.incidentStatus!
        }
        if self.me != nil {
            map["me"] = self.me!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.relationServiceId != nil {
            map["relationServiceId"] = self.relationServiceId!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("createEndTime") && dict["createEndTime"] != nil {
            self.createEndTime = dict["createEndTime"] as! String
        }
        if dict.keys.contains("createStartTime") && dict["createStartTime"] != nil {
            self.createStartTime = dict["createStartTime"] as! String
        }
        if dict.keys.contains("effect") && dict["effect"] != nil {
            self.effect = dict["effect"] as! String
        }
        if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
            self.incidentLevel = dict["incidentLevel"] as! String
        }
        if dict.keys.contains("incidentStatus") && dict["incidentStatus"] != nil {
            self.incidentStatus = dict["incidentStatus"] as! String
        }
        if dict.keys.contains("me") && dict["me"] != nil {
            self.me = dict["me"] as! Int32
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("relationServiceId") && dict["relationServiceId"] != nil {
            self.relationServiceId = dict["relationServiceId"] as! Int64
        }
        if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
            self.ruleName = dict["ruleName"] as! String
        }
    }
}

public class ListIncidentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var assignToWhoIsValid: Int64?

        public var assignUserId: Int64?

        public var assignUserName: String?

        public var assignUserPhone: String?

        public var createTime: String?

        public var effect: String?

        public var incidentId: Int64?

        public var incidentLevel: String?

        public var incidentNumber: String?

        public var incidentStatus: String?

        public var incidentTitle: String?

        public var isManual: Bool?

        public var relRouteRuleDeleteType: Int32?

        public var relServiceDeleteType: Int32?

        public var relatedServiceId: Int64?

        public var relatedServiceName: String?

        public var routeRuleId: Int64?

        public var routeRuleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignToWhoIsValid != nil {
                map["assignToWhoIsValid"] = self.assignToWhoIsValid!
            }
            if self.assignUserId != nil {
                map["assignUserId"] = self.assignUserId!
            }
            if self.assignUserName != nil {
                map["assignUserName"] = self.assignUserName!
            }
            if self.assignUserPhone != nil {
                map["assignUserPhone"] = self.assignUserPhone!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.effect != nil {
                map["effect"] = self.effect!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.incidentLevel != nil {
                map["incidentLevel"] = self.incidentLevel!
            }
            if self.incidentNumber != nil {
                map["incidentNumber"] = self.incidentNumber!
            }
            if self.incidentStatus != nil {
                map["incidentStatus"] = self.incidentStatus!
            }
            if self.incidentTitle != nil {
                map["incidentTitle"] = self.incidentTitle!
            }
            if self.isManual != nil {
                map["isManual"] = self.isManual!
            }
            if self.relRouteRuleDeleteType != nil {
                map["relRouteRuleDeleteType"] = self.relRouteRuleDeleteType!
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeRuleName != nil {
                map["routeRuleName"] = self.routeRuleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignToWhoIsValid") && dict["assignToWhoIsValid"] != nil {
                self.assignToWhoIsValid = dict["assignToWhoIsValid"] as! Int64
            }
            if dict.keys.contains("assignUserId") && dict["assignUserId"] != nil {
                self.assignUserId = dict["assignUserId"] as! Int64
            }
            if dict.keys.contains("assignUserName") && dict["assignUserName"] != nil {
                self.assignUserName = dict["assignUserName"] as! String
            }
            if dict.keys.contains("assignUserPhone") && dict["assignUserPhone"] != nil {
                self.assignUserPhone = dict["assignUserPhone"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("effect") && dict["effect"] != nil {
                self.effect = dict["effect"] as! String
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
                self.incidentLevel = dict["incidentLevel"] as! String
            }
            if dict.keys.contains("incidentNumber") && dict["incidentNumber"] != nil {
                self.incidentNumber = dict["incidentNumber"] as! String
            }
            if dict.keys.contains("incidentStatus") && dict["incidentStatus"] != nil {
                self.incidentStatus = dict["incidentStatus"] as! String
            }
            if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
                self.incidentTitle = dict["incidentTitle"] as! String
            }
            if dict.keys.contains("isManual") && dict["isManual"] != nil {
                self.isManual = dict["isManual"] as! Bool
            }
            if dict.keys.contains("relRouteRuleDeleteType") && dict["relRouteRuleDeleteType"] != nil {
                self.relRouteRuleDeleteType = dict["relRouteRuleDeleteType"] as! Int32
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeRuleName") && dict["routeRuleName"] != nil {
                self.routeRuleName = dict["routeRuleName"] as! String
            }
        }
    }
    public var data: [ListIncidentsResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIncidentsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIncidentsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListIncidentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIncidentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIncidentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntegrationConfigTimelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
    }
}

public class ListIntegrationConfigTimelinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: String?

        public var description_: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListIntegrationConfigTimelinesResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIntegrationConfigTimelinesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIntegrationConfigTimelinesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListIntegrationConfigTimelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntegrationConfigTimelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntegrationConfigTimelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntegrationConfigsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var monitorSourceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.monitorSourceName != nil {
            map["monitorSourceName"] = self.monitorSourceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
            self.monitorSourceName = dict["monitorSourceName"] as! String
        }
    }
}

public class ListIntegrationConfigsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var integrationConfigId: Int64?

        public var isReceivedEvent: Bool?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var monitorSourceShortName: String?

        public var monitorSourceType: Int32?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.integrationConfigId != nil {
                map["integrationConfigId"] = self.integrationConfigId!
            }
            if self.isReceivedEvent != nil {
                map["isReceivedEvent"] = self.isReceivedEvent!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.monitorSourceShortName != nil {
                map["monitorSourceShortName"] = self.monitorSourceShortName!
            }
            if self.monitorSourceType != nil {
                map["monitorSourceType"] = self.monitorSourceType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
                self.integrationConfigId = dict["integrationConfigId"] as! Int64
            }
            if dict.keys.contains("isReceivedEvent") && dict["isReceivedEvent"] != nil {
                self.isReceivedEvent = dict["isReceivedEvent"] as! Bool
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("monitorSourceShortName") && dict["monitorSourceShortName"] != nil {
                self.monitorSourceShortName = dict["monitorSourceShortName"] as! String
            }
            if dict.keys.contains("monitorSourceType") && dict["monitorSourceType"] != nil {
                self.monitorSourceType = dict["monitorSourceType"] as! Int32
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
        }
    }
    public var data: [ListIntegrationConfigsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListIntegrationConfigsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListIntegrationConfigsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListIntegrationConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntegrationConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntegrationConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMonitorSourcesRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ListMonitorSourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fieldKeys: [String]?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldKeys != nil {
                map["fieldKeys"] = self.fieldKeys!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldKeys") && dict["fieldKeys"] != nil {
                self.fieldKeys = dict["fieldKeys"] as! [String]
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
        }
    }
    public var data: [ListMonitorSourcesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListMonitorSourcesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListMonitorSourcesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListMonitorSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMonitorSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMonitorSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProblemDetailOperationsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var createTimeSort: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.createTimeSort != nil {
            map["createTimeSort"] = self.createTimeSort!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("createTimeSort") && dict["createTimeSort"] != nil {
            self.createTimeSort = dict["createTimeSort"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class ListProblemDetailOperationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var createTime: String?

        public var description_: String?

        public var relatedServiceName: String?

        public var remark: String?

        public var snapshotData: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.remark != nil {
                map["remark"] = self.remark!
            }
            if self.snapshotData != nil {
                map["snapshotData"] = self.snapshotData!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("action") && dict["action"] != nil {
                self.action = dict["action"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("remark") && dict["remark"] != nil {
                self.remark = dict["remark"] as! String
            }
            if dict.keys.contains("snapshotData") && dict["snapshotData"] != nil {
                self.snapshotData = dict["snapshotData"] as! String
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListProblemDetailOperationsResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListProblemDetailOperationsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListProblemDetailOperationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListProblemDetailOperationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProblemDetailOperationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProblemDetailOperationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProblemOperationsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
    }
}

public class ListProblemOperationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var createTime: String?

        public var description_: String?

        public var problemId: Int64?

        public var problemName: String?

        public var problemNumber: String?

        public var relatedServiceName: String?

        public var snapshotData: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemName != nil {
                map["problemName"] = self.problemName!
            }
            if self.problemNumber != nil {
                map["problemNumber"] = self.problemNumber!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.snapshotData != nil {
                map["snapshotData"] = self.snapshotData!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("action") && dict["action"] != nil {
                self.action = dict["action"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
            if dict.keys.contains("problemName") && dict["problemName"] != nil {
                self.problemName = dict["problemName"] as! String
            }
            if dict.keys.contains("problemNumber") && dict["problemNumber"] != nil {
                self.problemNumber = dict["problemNumber"] as! String
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("snapshotData") && dict["snapshotData"] != nil {
                self.snapshotData = dict["snapshotData"] as! String
            }
            if dict.keys.contains("title") && dict["title"] != nil {
                self.title = dict["title"] as! String
            }
        }
    }
    public var data: [ListProblemOperationsResponseBody.Data]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListProblemOperationsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListProblemOperationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListProblemOperationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProblemOperationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProblemOperationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProblemSubtotalsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class ListProblemSubtotalsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createRamName: String?

        public var createTime: String?

        public var createUserId: Int64?

        public var createUserPhone: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createRamName != nil {
                map["createRamName"] = self.createRamName!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.createUserId != nil {
                map["createUserId"] = self.createUserId!
            }
            if self.createUserPhone != nil {
                map["createUserPhone"] = self.createUserPhone!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createRamName") && dict["createRamName"] != nil {
                self.createRamName = dict["createRamName"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("createUserId") && dict["createUserId"] != nil {
                self.createUserId = dict["createUserId"] as! Int64
            }
            if dict.keys.contains("createUserPhone") && dict["createUserPhone"] != nil {
                self.createUserPhone = dict["createUserPhone"] as! String
            }
            if dict.keys.contains("description") && dict["description"] != nil {
                self.description_ = dict["description"] as! String
            }
        }
    }
    public var data: [ListProblemSubtotalsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListProblemSubtotalsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListProblemSubtotalsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListProblemSubtotalsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProblemSubtotalsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProblemSubtotalsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProblemTimeLinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
    }
}

public class ListProblemTimeLinesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class UsersInContent : Tea.TeaModel {
            public var isValid: Int64?

            public var userId: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isValid != nil {
                    map["isValid"] = self.isValid!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("isValid") && dict["isValid"] != nil {
                    self.isValid = dict["isValid"] as! Int64
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("username") && dict["username"] != nil {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var content: String?

        public var createTime: String?

        public var isKey: Bool?

        public var keyNode: String?

        public var problemTimelineId: Int64?

        public var time: String?

        public var updateTime: String?

        public var usersInContent: [ListProblemTimeLinesResponseBody.Data.UsersInContent]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.isKey != nil {
                map["isKey"] = self.isKey!
            }
            if self.keyNode != nil {
                map["keyNode"] = self.keyNode!
            }
            if self.problemTimelineId != nil {
                map["problemTimelineId"] = self.problemTimelineId!
            }
            if self.time != nil {
                map["time"] = self.time!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.usersInContent != nil {
                var tmp : [Any] = []
                for k in self.usersInContent! {
                    tmp.append(k.toMap())
                }
                map["usersInContent"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") && dict["content"] != nil {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("isKey") && dict["isKey"] != nil {
                self.isKey = dict["isKey"] as! Bool
            }
            if dict.keys.contains("keyNode") && dict["keyNode"] != nil {
                self.keyNode = dict["keyNode"] as! String
            }
            if dict.keys.contains("problemTimelineId") && dict["problemTimelineId"] != nil {
                self.problemTimelineId = dict["problemTimelineId"] as! Int64
            }
            if dict.keys.contains("time") && dict["time"] != nil {
                self.time = dict["time"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("usersInContent") && dict["usersInContent"] != nil {
                var tmp : [ListProblemTimeLinesResponseBody.Data.UsersInContent] = []
                for v in dict["usersInContent"] as! [Any] {
                    var model = ListProblemTimeLinesResponseBody.Data.UsersInContent()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.usersInContent = tmp
            }
        }
    }
    public var data: [ListProblemTimeLinesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListProblemTimeLinesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListProblemTimeLinesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListProblemTimeLinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProblemTimeLinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProblemTimeLinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProblemsRequest : Tea.TeaModel {
    public var affectServiceId: Int64?

    public var clientToken: String?

    public var discoveryEndTime: String?

    public var discoveryStartTime: String?

    public var mainHandlerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var problemLevel: String?

    public var problemStatus: String?

    public var queryType: String?

    public var repeaterId: Int64?

    public var restoreEndTime: String?

    public var restoreStartTime: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectServiceId != nil {
            map["affectServiceId"] = self.affectServiceId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.discoveryEndTime != nil {
            map["discoveryEndTime"] = self.discoveryEndTime!
        }
        if self.discoveryStartTime != nil {
            map["discoveryStartTime"] = self.discoveryStartTime!
        }
        if self.mainHandlerId != nil {
            map["mainHandlerId"] = self.mainHandlerId!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.problemLevel != nil {
            map["problemLevel"] = self.problemLevel!
        }
        if self.problemStatus != nil {
            map["problemStatus"] = self.problemStatus!
        }
        if self.queryType != nil {
            map["queryType"] = self.queryType!
        }
        if self.repeaterId != nil {
            map["repeaterId"] = self.repeaterId!
        }
        if self.restoreEndTime != nil {
            map["restoreEndTime"] = self.restoreEndTime!
        }
        if self.restoreStartTime != nil {
            map["restoreStartTime"] = self.restoreStartTime!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("affectServiceId") && dict["affectServiceId"] != nil {
            self.affectServiceId = dict["affectServiceId"] as! Int64
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("discoveryEndTime") && dict["discoveryEndTime"] != nil {
            self.discoveryEndTime = dict["discoveryEndTime"] as! String
        }
        if dict.keys.contains("discoveryStartTime") && dict["discoveryStartTime"] != nil {
            self.discoveryStartTime = dict["discoveryStartTime"] as! String
        }
        if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
            self.mainHandlerId = dict["mainHandlerId"] as! Int64
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
            self.problemLevel = dict["problemLevel"] as! String
        }
        if dict.keys.contains("problemStatus") && dict["problemStatus"] != nil {
            self.problemStatus = dict["problemStatus"] as! String
        }
        if dict.keys.contains("queryType") && dict["queryType"] != nil {
            self.queryType = dict["queryType"] as! String
        }
        if dict.keys.contains("repeaterId") && dict["repeaterId"] != nil {
            self.repeaterId = dict["repeaterId"] as! Int64
        }
        if dict.keys.contains("restoreEndTime") && dict["restoreEndTime"] != nil {
            self.restoreEndTime = dict["restoreEndTime"] as! String
        }
        if dict.keys.contains("restoreStartTime") && dict["restoreStartTime"] != nil {
            self.restoreStartTime = dict["restoreStartTime"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class ListProblemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AffectServices : Tea.TeaModel {
            public var serviceDescription: String?

            public var serviceId: Int64?

            public var serviceName: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.serviceDescription != nil {
                    map["serviceDescription"] = self.serviceDescription!
                }
                if self.serviceId != nil {
                    map["serviceId"] = self.serviceId!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                if self.updateTime != nil {
                    map["updateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("serviceDescription") && dict["serviceDescription"] != nil {
                    self.serviceDescription = dict["serviceDescription"] as! String
                }
                if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                    self.serviceId = dict["serviceId"] as! Int64
                }
                if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                    self.serviceName = dict["serviceName"] as! String
                }
                if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                    self.updateTime = dict["updateTime"] as! String
                }
            }
        }
        public var affectServices: [ListProblemsResponseBody.Data.AffectServices]?

        public var cancelTime: String?

        public var createTime: String?

        public var discoverTime: String?

        public var finishTime: String?

        public var incidentId: Int64?

        public var isManual: Bool?

        public var isUpgrade: Bool?

        public var mainHandlerId: Int64?

        public var mainHandlerIsValid: Int64?

        public var mainHandlerName: String?

        public var problemId: Int64?

        public var problemLevel: String?

        public var problemName: String?

        public var problemNumber: String?

        public var problemStatus: String?

        public var recoveryTime: String?

        public var relatedServiceId: String?

        public var replayTime: String?

        public var serviceDeletedType: Int32?

        public var serviceName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectServices != nil {
                var tmp : [Any] = []
                for k in self.affectServices! {
                    tmp.append(k.toMap())
                }
                map["affectServices"] = tmp
            }
            if self.cancelTime != nil {
                map["cancelTime"] = self.cancelTime!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.discoverTime != nil {
                map["discoverTime"] = self.discoverTime!
            }
            if self.finishTime != nil {
                map["finishTime"] = self.finishTime!
            }
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            if self.isManual != nil {
                map["isManual"] = self.isManual!
            }
            if self.isUpgrade != nil {
                map["isUpgrade"] = self.isUpgrade!
            }
            if self.mainHandlerId != nil {
                map["mainHandlerId"] = self.mainHandlerId!
            }
            if self.mainHandlerIsValid != nil {
                map["mainHandlerIsValid"] = self.mainHandlerIsValid!
            }
            if self.mainHandlerName != nil {
                map["mainHandlerName"] = self.mainHandlerName!
            }
            if self.problemId != nil {
                map["problemId"] = self.problemId!
            }
            if self.problemLevel != nil {
                map["problemLevel"] = self.problemLevel!
            }
            if self.problemName != nil {
                map["problemName"] = self.problemName!
            }
            if self.problemNumber != nil {
                map["problemNumber"] = self.problemNumber!
            }
            if self.problemStatus != nil {
                map["problemStatus"] = self.problemStatus!
            }
            if self.recoveryTime != nil {
                map["recoveryTime"] = self.recoveryTime!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.replayTime != nil {
                map["replayTime"] = self.replayTime!
            }
            if self.serviceDeletedType != nil {
                map["serviceDeletedType"] = self.serviceDeletedType!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("affectServices") && dict["affectServices"] != nil {
                var tmp : [ListProblemsResponseBody.Data.AffectServices] = []
                for v in dict["affectServices"] as! [Any] {
                    var model = ListProblemsResponseBody.Data.AffectServices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.affectServices = tmp
            }
            if dict.keys.contains("cancelTime") && dict["cancelTime"] != nil {
                self.cancelTime = dict["cancelTime"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("discoverTime") && dict["discoverTime"] != nil {
                self.discoverTime = dict["discoverTime"] as! String
            }
            if dict.keys.contains("finishTime") && dict["finishTime"] != nil {
                self.finishTime = dict["finishTime"] as! String
            }
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
            if dict.keys.contains("isManual") && dict["isManual"] != nil {
                self.isManual = dict["isManual"] as! Bool
            }
            if dict.keys.contains("isUpgrade") && dict["isUpgrade"] != nil {
                self.isUpgrade = dict["isUpgrade"] as! Bool
            }
            if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
                self.mainHandlerId = dict["mainHandlerId"] as! Int64
            }
            if dict.keys.contains("mainHandlerIsValid") && dict["mainHandlerIsValid"] != nil {
                self.mainHandlerIsValid = dict["mainHandlerIsValid"] as! Int64
            }
            if dict.keys.contains("mainHandlerName") && dict["mainHandlerName"] != nil {
                self.mainHandlerName = dict["mainHandlerName"] as! String
            }
            if dict.keys.contains("problemId") && dict["problemId"] != nil {
                self.problemId = dict["problemId"] as! Int64
            }
            if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                self.problemLevel = dict["problemLevel"] as! String
            }
            if dict.keys.contains("problemName") && dict["problemName"] != nil {
                self.problemName = dict["problemName"] as! String
            }
            if dict.keys.contains("problemNumber") && dict["problemNumber"] != nil {
                self.problemNumber = dict["problemNumber"] as! String
            }
            if dict.keys.contains("problemStatus") && dict["problemStatus"] != nil {
                self.problemStatus = dict["problemStatus"] as! String
            }
            if dict.keys.contains("recoveryTime") && dict["recoveryTime"] != nil {
                self.recoveryTime = dict["recoveryTime"] as! String
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! String
            }
            if dict.keys.contains("replayTime") && dict["replayTime"] != nil {
                self.replayTime = dict["replayTime"] as! String
            }
            if dict.keys.contains("serviceDeletedType") && dict["serviceDeletedType"] != nil {
                self.serviceDeletedType = dict["serviceDeletedType"] as! Int32
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var data: [ListProblemsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListProblemsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListProblemsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListProblemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProblemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListProblemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRouteRulesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var notFilterRouteRuleDeleted: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var routeType: Int64?

    public var ruleName: [UInt8]?

    public var serviceName: [UInt8]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.notFilterRouteRuleDeleted != nil {
            map["notFilterRouteRuleDeleted"] = self.notFilterRouteRuleDeleted!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.routeType != nil {
            map["routeType"] = self.routeType!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("notFilterRouteRuleDeleted") && dict["notFilterRouteRuleDeleted"] != nil {
            self.notFilterRouteRuleDeleted = dict["notFilterRouteRuleDeleted"] as! Bool
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("routeType") && dict["routeType"] != nil {
            self.routeType = dict["routeType"] as! Int64
        }
        if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
            self.ruleName = dict["ruleName"] as! [UInt8]
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! [UInt8]
        }
    }
}

public class ListRouteRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var assignObjectId: Int64?

        public var assignObjectType: String?

        public var createTime: String?

        public var effection: String?

        public var enableStatus: String?

        public var incidentLevel: String?

        public var isValid: Int32?

        public var matchCount: Int64?

        public var monitorSourceNames: String?

        public var relServiceDeleteType: Int32?

        public var relatedServiceId: Int64?

        public var relatedServiceName: String?

        public var routeRuleId: Int64?

        public var routeType: String?

        public var ruleName: String?

        public var tenantRamId: Int64?

        public var timeWindow: Int64?

        public var timeWindowUnit: Int64?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignObjectId != nil {
                map["assignObjectId"] = self.assignObjectId!
            }
            if self.assignObjectType != nil {
                map["assignObjectType"] = self.assignObjectType!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.effection != nil {
                map["effection"] = self.effection!
            }
            if self.enableStatus != nil {
                map["enableStatus"] = self.enableStatus!
            }
            if self.incidentLevel != nil {
                map["incidentLevel"] = self.incidentLevel!
            }
            if self.isValid != nil {
                map["isValid"] = self.isValid!
            }
            if self.matchCount != nil {
                map["matchCount"] = self.matchCount!
            }
            if self.monitorSourceNames != nil {
                map["monitorSourceNames"] = self.monitorSourceNames!
            }
            if self.relServiceDeleteType != nil {
                map["relServiceDeleteType"] = self.relServiceDeleteType!
            }
            if self.relatedServiceId != nil {
                map["relatedServiceId"] = self.relatedServiceId!
            }
            if self.relatedServiceName != nil {
                map["relatedServiceName"] = self.relatedServiceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.routeType != nil {
                map["routeType"] = self.routeType!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.tenantRamId != nil {
                map["tenantRamId"] = self.tenantRamId!
            }
            if self.timeWindow != nil {
                map["timeWindow"] = self.timeWindow!
            }
            if self.timeWindowUnit != nil {
                map["timeWindowUnit"] = self.timeWindowUnit!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignObjectId") && dict["assignObjectId"] != nil {
                self.assignObjectId = dict["assignObjectId"] as! Int64
            }
            if dict.keys.contains("assignObjectType") && dict["assignObjectType"] != nil {
                self.assignObjectType = dict["assignObjectType"] as! String
            }
            if dict.keys.contains("createTime") && dict["createTime"] != nil {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("effection") && dict["effection"] != nil {
                self.effection = dict["effection"] as! String
            }
            if dict.keys.contains("enableStatus") && dict["enableStatus"] != nil {
                self.enableStatus = dict["enableStatus"] as! String
            }
            if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
                self.incidentLevel = dict["incidentLevel"] as! String
            }
            if dict.keys.contains("isValid") && dict["isValid"] != nil {
                self.isValid = dict["isValid"] as! Int32
            }
            if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
                self.matchCount = dict["matchCount"] as! Int64
            }
            if dict.keys.contains("monitorSourceNames") && dict["monitorSourceNames"] != nil {
                self.monitorSourceNames = dict["monitorSourceNames"] as! String
            }
            if dict.keys.contains("relServiceDeleteType") && dict["relServiceDeleteType"] != nil {
                self.relServiceDeleteType = dict["relServiceDeleteType"] as! Int32
            }
            if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
                self.relatedServiceId = dict["relatedServiceId"] as! Int64
            }
            if dict.keys.contains("relatedServiceName") && dict["relatedServiceName"] != nil {
                self.relatedServiceName = dict["relatedServiceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("routeType") && dict["routeType"] != nil {
                self.routeType = dict["routeType"] as! String
            }
            if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("tenantRamId") && dict["tenantRamId"] != nil {
                self.tenantRamId = dict["tenantRamId"] as! Int64
            }
            if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
                self.timeWindow = dict["timeWindow"] as! Int64
            }
            if dict.keys.contains("timeWindowUnit") && dict["timeWindowUnit"] != nil {
                self.timeWindowUnit = dict["timeWindowUnit"] as! Int64
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var data: [ListRouteRulesResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListRouteRulesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListRouteRulesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListRouteRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRouteRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRouteRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRouteRulesByAssignWhoIdRequest : Tea.TeaModel {
    public var assignWhoId: Int64?

    public var assignWhoType: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignWhoId != nil {
            map["assignWhoId"] = self.assignWhoId!
        }
        if self.assignWhoType != nil {
            map["assignWhoType"] = self.assignWhoType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignWhoId") && dict["assignWhoId"] != nil {
            self.assignWhoId = dict["assignWhoId"] as! Int64
        }
        if dict.keys.contains("assignWhoType") && dict["assignWhoType"] != nil {
            self.assignWhoType = dict["assignWhoType"] as! Int64
        }
    }
}

public class ListRouteRulesByAssignWhoIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public var ruleName: String?

        public var tenantRamId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            if self.tenantRamId != nil {
                map["tenantRamId"] = self.tenantRamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
                self.ruleName = dict["ruleName"] as! String
            }
            if dict.keys.contains("tenantRamId") && dict["tenantRamId"] != nil {
                self.tenantRamId = dict["tenantRamId"] as! Int64
            }
        }
    }
    public var data: [ListRouteRulesByAssignWhoIdResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListRouteRulesByAssignWhoIdResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListRouteRulesByAssignWhoIdResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListRouteRulesByAssignWhoIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRouteRulesByAssignWhoIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRouteRulesByAssignWhoIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRouteRulesByServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int32?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleName != nil {
                map["ruleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int32
            }
            if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
                self.ruleName = dict["ruleName"] as! String
            }
        }
    }
    public var data: [ListRouteRulesByServiceResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListRouteRulesByServiceResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListRouteRulesByServiceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListRouteRulesByServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRouteRulesByServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRouteRulesByServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceGroupMonitorSourceTemplatesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var requestId: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class ListServiceGroupMonitorSourceTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fields: [String]?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var templateContent: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fields != nil {
                map["fields"] = self.fields!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.templateContent != nil {
                map["templateContent"] = self.templateContent!
            }
            if self.templateId != nil {
                map["templateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fields") && dict["fields"] != nil {
                self.fields = dict["fields"] as! [String]
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("templateContent") && dict["templateContent"] != nil {
                self.templateContent = dict["templateContent"] as! String
            }
            if dict.keys.contains("templateId") && dict["templateId"] != nil {
                self.templateId = dict["templateId"] as! Int64
            }
        }
    }
    public var data: [ListServiceGroupMonitorSourceTemplatesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListServiceGroupMonitorSourceTemplatesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListServiceGroupMonitorSourceTemplatesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListServiceGroupMonitorSourceTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceGroupMonitorSourceTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServiceGroupMonitorSourceTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceGroupsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var isScheduled: Bool?

    public var orderByScheduleStatus: Bool?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var queryName: String?

    public var queryType: String?

    public var serviceId: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.isScheduled != nil {
            map["isScheduled"] = self.isScheduled!
        }
        if self.orderByScheduleStatus != nil {
            map["orderByScheduleStatus"] = self.orderByScheduleStatus!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.queryName != nil {
            map["queryName"] = self.queryName!
        }
        if self.queryType != nil {
            map["queryType"] = self.queryType!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("isScheduled") && dict["isScheduled"] != nil {
            self.isScheduled = dict["isScheduled"] as! Bool
        }
        if dict.keys.contains("orderByScheduleStatus") && dict["orderByScheduleStatus"] != nil {
            self.orderByScheduleStatus = dict["orderByScheduleStatus"] as! Bool
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("queryName") && dict["queryName"] != nil {
            self.queryName = dict["queryName"] as! String
        }
        if dict.keys.contains("queryType") && dict["queryType"] != nil {
            self.queryType = dict["queryType"] as! String
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class ListServiceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Users : Tea.TeaModel {
            public var email: String?

            public var isRelated: Int32?

            public var phone: String?

            public var serviceGroupId: Int64?

            public var userId: Int64?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.isRelated != nil {
                    map["isRelated"] = self.isRelated!
                }
                if self.phone != nil {
                    map["phone"] = self.phone!
                }
                if self.serviceGroupId != nil {
                    map["serviceGroupId"] = self.serviceGroupId!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("email") && dict["email"] != nil {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("isRelated") && dict["isRelated"] != nil {
                    self.isRelated = dict["isRelated"] as! Int32
                }
                if dict.keys.contains("phone") && dict["phone"] != nil {
                    self.phone = dict["phone"] as! String
                }
                if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                    self.serviceGroupId = dict["serviceGroupId"] as! Int64
                }
                if dict.keys.contains("userId") && dict["userId"] != nil {
                    self.userId = dict["userId"] as! Int64
                }
                if dict.keys.contains("userName") && dict["userName"] != nil {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var enableWebhook: String?

        public var isScheduled: Bool?

        public var serviceGroupDescription: String?

        public var serviceGroupId: Int64?

        public var serviceGroupName: String?

        public var updateTime: String?

        public var users: [ListServiceGroupsResponseBody.Data.Users]?

        public var webhookLink: String?

        public var webhookType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableWebhook != nil {
                map["enableWebhook"] = self.enableWebhook!
            }
            if self.isScheduled != nil {
                map["isScheduled"] = self.isScheduled!
            }
            if self.serviceGroupDescription != nil {
                map["serviceGroupDescription"] = self.serviceGroupDescription!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.serviceGroupName != nil {
                map["serviceGroupName"] = self.serviceGroupName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.users != nil {
                var tmp : [Any] = []
                for k in self.users! {
                    tmp.append(k.toMap())
                }
                map["users"] = tmp
            }
            if self.webhookLink != nil {
                map["webhookLink"] = self.webhookLink!
            }
            if self.webhookType != nil {
                map["webhookType"] = self.webhookType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
                self.enableWebhook = dict["enableWebhook"] as! String
            }
            if dict.keys.contains("isScheduled") && dict["isScheduled"] != nil {
                self.isScheduled = dict["isScheduled"] as! Bool
            }
            if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
                self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                self.serviceGroupName = dict["serviceGroupName"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("users") && dict["users"] != nil {
                var tmp : [ListServiceGroupsResponseBody.Data.Users] = []
                for v in dict["users"] as! [Any] {
                    var model = ListServiceGroupsResponseBody.Data.Users()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.users = tmp
            }
            if dict.keys.contains("webhookLink") && dict["webhookLink"] != nil {
                self.webhookLink = dict["webhookLink"] as! String
            }
            if dict.keys.contains("webhookType") && dict["webhookType"] != nil {
                self.webhookType = dict["webhookType"] as! String
            }
        }
    }
    public var data: [ListServiceGroupsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListServiceGroupsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListServiceGroupsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceGroupsByUserIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isScheduled: Bool?

        public var serviceGroupId: Int64?

        public var serviceGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isScheduled != nil {
                map["isScheduled"] = self.isScheduled!
            }
            if self.serviceGroupId != nil {
                map["serviceGroupId"] = self.serviceGroupId!
            }
            if self.serviceGroupName != nil {
                map["serviceGroupName"] = self.serviceGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("isScheduled") && dict["isScheduled"] != nil {
                self.isScheduled = dict["isScheduled"] as! Bool
            }
            if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                self.serviceGroupId = dict["serviceGroupId"] as! Int64
            }
            if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                self.serviceGroupName = dict["serviceGroupName"] as! String
            }
        }
    }
    public var data: ListServiceGroupsByUserIdResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = ListServiceGroupsByUserIdResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListServiceGroupsByUserIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceGroupsByUserIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServiceGroupsByUserIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServicesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
    }
}

public class ListServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var escalationPlanId: Int64?

        public var escalationPlanName: String?

        public var isValid: Int32?

        public var serviceDescription: String?

        public var serviceGroupIdList: [Int64]?

        public var serviceId: Int64?

        public var serviceName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanId != nil {
                map["escalationPlanId"] = self.escalationPlanId!
            }
            if self.escalationPlanName != nil {
                map["escalationPlanName"] = self.escalationPlanName!
            }
            if self.isValid != nil {
                map["isValid"] = self.isValid!
            }
            if self.serviceDescription != nil {
                map["serviceDescription"] = self.serviceDescription!
            }
            if self.serviceGroupIdList != nil {
                map["serviceGroupIdList"] = self.serviceGroupIdList!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                self.escalationPlanId = dict["escalationPlanId"] as! Int64
            }
            if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                self.escalationPlanName = dict["escalationPlanName"] as! String
            }
            if dict.keys.contains("isValid") && dict["isValid"] != nil {
                self.isValid = dict["isValid"] as! Int32
            }
            if dict.keys.contains("serviceDescription") && dict["serviceDescription"] != nil {
                self.serviceDescription = dict["serviceDescription"] as! String
            }
            if dict.keys.contains("serviceGroupIdList") && dict["serviceGroupIdList"] != nil {
                self.serviceGroupIdList = dict["serviceGroupIdList"] as! [Int64]
            }
            if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                self.serviceId = dict["serviceId"] as! Int64
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
            if dict.keys.contains("updateTime") && dict["updateTime"] != nil {
                self.updateTime = dict["updateTime"] as! String
            }
        }
    }
    public var data: [ListServicesResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListServicesResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSourceEventsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endTime: String?

    public var instanceId: Int64?

    public var instanceType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startRowKey: String?

    public var startTime: String?

    public var stopRowKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.startRowKey != nil {
            map["startRowKey"] = self.startRowKey!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.stopRowKey != nil {
            map["stopRowKey"] = self.stopRowKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("startRowKey") && dict["startRowKey"] != nil {
            self.startRowKey = dict["startRowKey"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
        if dict.keys.contains("stopRowKey") && dict["stopRowKey"] != nil {
            self.stopRowKey = dict["stopRowKey"] as! String
        }
    }
}

public class ListSourceEventsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventJson: String?

        public var eventTime: String?

        public var instanceId: Int64?

        public var instanceType: String?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var routeRuleId: Int64?

        public var tenantRamId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventJson != nil {
                map["eventJson"] = self.eventJson!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["instanceType"] = self.instanceType!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.routeRuleId != nil {
                map["routeRuleId"] = self.routeRuleId!
            }
            if self.tenantRamId != nil {
                map["tenantRamId"] = self.tenantRamId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventJson") && dict["eventJson"] != nil {
                self.eventJson = dict["eventJson"] as! String
            }
            if dict.keys.contains("eventTime") && dict["eventTime"] != nil {
                self.eventTime = dict["eventTime"] as! String
            }
            if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
                self.instanceId = dict["instanceId"] as! Int64
            }
            if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                self.instanceType = dict["instanceType"] as! String
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
                self.routeRuleId = dict["routeRuleId"] as! Int64
            }
            if dict.keys.contains("tenantRamId") && dict["tenantRamId"] != nil {
                self.tenantRamId = dict["tenantRamId"] as! Int64
            }
        }
    }
    public var data: [ListSourceEventsResponseBody.Data]?

    public var firstRowKey: String?

    public var lastRowKey: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.firstRowKey != nil {
            map["firstRowKey"] = self.firstRowKey!
        }
        if self.lastRowKey != nil {
            map["lastRowKey"] = self.lastRowKey!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListSourceEventsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListSourceEventsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("firstRowKey") && dict["firstRowKey"] != nil {
            self.firstRowKey = dict["firstRowKey"] as! String
        }
        if dict.keys.contains("lastRowKey") && dict["lastRowKey"] != nil {
            self.lastRowKey = dict["lastRowKey"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListSourceEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSourceEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSourceEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSourceEventsForMonitorSourceRequest : Tea.TeaModel {
    public var monitorSourceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorSourceId != nil {
            map["monitorSourceId"] = self.monitorSourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
            self.monitorSourceId = dict["monitorSourceId"] as! Int64
        }
    }
}

public class ListSourceEventsForMonitorSourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventJson: String?

        public var eventTime: String?

        public var monitorSourceId: Bool?

        public var monitorSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventJson != nil {
                map["eventJson"] = self.eventJson!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventJson") && dict["eventJson"] != nil {
                self.eventJson = dict["eventJson"] as! String
            }
            if dict.keys.contains("eventTime") && dict["eventTime"] != nil {
                self.eventTime = dict["eventTime"] as! String
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Bool
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
        }
    }
    public var data: [ListSourceEventsForMonitorSourceResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListSourceEventsForMonitorSourceResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListSourceEventsForMonitorSourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListSourceEventsForMonitorSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSourceEventsForMonitorSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSourceEventsForMonitorSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSubscriptionServiceGroupsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.serviceIds != nil {
            map["serviceIds"] = self.serviceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("serviceIds") && dict["serviceIds"] != nil {
            self.serviceIds = dict["serviceIds"] as! [Int64]
        }
    }
}

public class ListSubscriptionServiceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var serviceGroupDescription: String?

        public var serviceId: Int64?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceGroupDescription != nil {
                map["serviceGroupDescription"] = self.serviceGroupDescription!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
                self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
            }
            if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
                self.serviceId = dict["serviceId"] as! Int64
            }
            if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
                self.serviceName = dict["serviceName"] as! String
            }
        }
    }
    public var data: [ListSubscriptionServiceGroupsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListSubscriptionServiceGroupsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListSubscriptionServiceGroupsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListSubscriptionServiceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSubscriptionServiceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSubscriptionServiceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSubscriptionsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var notFilterScopeObjectDeleted: Bool?

    public var notifyObject: String?

    public var notifyObjectType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scope: String?

    public var scopeObject: String?

    public var subscriptionTitle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.notFilterScopeObjectDeleted != nil {
            map["notFilterScopeObjectDeleted"] = self.notFilterScopeObjectDeleted!
        }
        if self.notifyObject != nil {
            map["notifyObject"] = self.notifyObject!
        }
        if self.notifyObjectType != nil {
            map["notifyObjectType"] = self.notifyObjectType!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.scopeObject != nil {
            map["scopeObject"] = self.scopeObject!
        }
        if self.subscriptionTitle != nil {
            map["subscriptionTitle"] = self.subscriptionTitle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("notFilterScopeObjectDeleted") && dict["notFilterScopeObjectDeleted"] != nil {
            self.notFilterScopeObjectDeleted = dict["notFilterScopeObjectDeleted"] as! Bool
        }
        if dict.keys.contains("notifyObject") && dict["notifyObject"] != nil {
            self.notifyObject = dict["notifyObject"] as! String
        }
        if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
            self.notifyObjectType = dict["notifyObjectType"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("scope") && dict["scope"] != nil {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("scopeObject") && dict["scopeObject"] != nil {
            self.scopeObject = dict["scopeObject"] as! String
        }
        if dict.keys.contains("subscriptionTitle") && dict["subscriptionTitle"] != nil {
            self.subscriptionTitle = dict["subscriptionTitle"] as! String
        }
    }
}

public class ListSubscriptionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NotifyObjectList : Tea.TeaModel {
            public var id: Int64?

            public var isValid: Int64?

            public var name: String?

            public var notifyObjectId: Int64?

            public var notifyObjectType: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.isValid != nil {
                    map["isValid"] = self.isValid!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.notifyObjectId != nil {
                    map["notifyObjectId"] = self.notifyObjectId!
                }
                if self.notifyObjectType != nil {
                    map["notifyObjectType"] = self.notifyObjectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("isValid") && dict["isValid"] != nil {
                    self.isValid = dict["isValid"] as! Int64
                }
                if dict.keys.contains("name") && dict["name"] != nil {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("notifyObjectId") && dict["notifyObjectId"] != nil {
                    self.notifyObjectId = dict["notifyObjectId"] as! Int64
                }
                if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
                    self.notifyObjectType = dict["notifyObjectType"] as! Int64
                }
            }
        }
        public class ScopeObjectList : Tea.TeaModel {
            public var id: Int64?

            public var isValid: Int64?

            public var scope: Int64?

            public var scopeObject: String?

            public var scopeObjectId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.isValid != nil {
                    map["isValid"] = self.isValid!
                }
                if self.scope != nil {
                    map["scope"] = self.scope!
                }
                if self.scopeObject != nil {
                    map["scopeObject"] = self.scopeObject!
                }
                if self.scopeObjectId != nil {
                    map["scopeObjectId"] = self.scopeObjectId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("isValid") && dict["isValid"] != nil {
                    self.isValid = dict["isValid"] as! Int64
                }
                if dict.keys.contains("scope") && dict["scope"] != nil {
                    self.scope = dict["scope"] as! Int64
                }
                if dict.keys.contains("scopeObject") && dict["scopeObject"] != nil {
                    self.scopeObject = dict["scopeObject"] as! String
                }
                if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                    self.scopeObjectId = dict["scopeObjectId"] as! Int64
                }
            }
        }
        public var endTime: String?

        public var expiredType: String?

        public var notifyObjectList: [ListSubscriptionsResponseBody.Data.NotifyObjectList]?

        public var notifyObjectType: Int64?

        public var scope: Int64?

        public var scopeObjectList: [ListSubscriptionsResponseBody.Data.ScopeObjectList]?

        public var startTime: String?

        public var status: String?

        public var subscriptionId: Int64?

        public var subscriptionTitle: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.expiredType != nil {
                map["expiredType"] = self.expiredType!
            }
            if self.notifyObjectList != nil {
                var tmp : [Any] = []
                for k in self.notifyObjectList! {
                    tmp.append(k.toMap())
                }
                map["notifyObjectList"] = tmp
            }
            if self.notifyObjectType != nil {
                map["notifyObjectType"] = self.notifyObjectType!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.scopeObjectList != nil {
                var tmp : [Any] = []
                for k in self.scopeObjectList! {
                    tmp.append(k.toMap())
                }
                map["scopeObjectList"] = tmp
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscriptionId != nil {
                map["subscriptionId"] = self.subscriptionId!
            }
            if self.subscriptionTitle != nil {
                map["subscriptionTitle"] = self.subscriptionTitle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("endTime") && dict["endTime"] != nil {
                self.endTime = dict["endTime"] as! String
            }
            if dict.keys.contains("expiredType") && dict["expiredType"] != nil {
                self.expiredType = dict["expiredType"] as! String
            }
            if dict.keys.contains("notifyObjectList") && dict["notifyObjectList"] != nil {
                var tmp : [ListSubscriptionsResponseBody.Data.NotifyObjectList] = []
                for v in dict["notifyObjectList"] as! [Any] {
                    var model = ListSubscriptionsResponseBody.Data.NotifyObjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifyObjectList = tmp
            }
            if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
                self.notifyObjectType = dict["notifyObjectType"] as! Int64
            }
            if dict.keys.contains("scope") && dict["scope"] != nil {
                self.scope = dict["scope"] as! Int64
            }
            if dict.keys.contains("scopeObjectList") && dict["scopeObjectList"] != nil {
                var tmp : [ListSubscriptionsResponseBody.Data.ScopeObjectList] = []
                for v in dict["scopeObjectList"] as! [Any] {
                    var model = ListSubscriptionsResponseBody.Data.ScopeObjectList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scopeObjectList = tmp
            }
            if dict.keys.contains("startTime") && dict["startTime"] != nil {
                self.startTime = dict["startTime"] as! String
            }
            if dict.keys.contains("status") && dict["status"] != nil {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
                self.subscriptionId = dict["subscriptionId"] as! Int64
            }
            if dict.keys.contains("subscriptionTitle") && dict["subscriptionTitle"] != nil {
                self.subscriptionTitle = dict["subscriptionTitle"] as! String
            }
        }
    }
    public var data: [ListSubscriptionsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListSubscriptionsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListSubscriptionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListSubscriptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSubscriptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSubscriptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTrendForSourceEventRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: Int64?

    public var instanceType: String?

    public var requestId: String?

    public var startTime: String?

    public var timeUnit: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timeUnit != nil {
            map["timeUnit"] = self.timeUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
        if dict.keys.contains("timeUnit") && dict["timeUnit"] != nil {
            self.timeUnit = dict["timeUnit"] as! Int64
        }
    }
}

public class ListTrendForSourceEventResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var convergenceRate: String?

        public var maxSustainTime: Int64?

        public var skipDay: Bool?

        public var sourceEventsStatMap: [String: Any]?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.convergenceRate != nil {
                map["convergenceRate"] = self.convergenceRate!
            }
            if self.maxSustainTime != nil {
                map["maxSustainTime"] = self.maxSustainTime!
            }
            if self.skipDay != nil {
                map["skipDay"] = self.skipDay!
            }
            if self.sourceEventsStatMap != nil {
                map["sourceEventsStatMap"] = self.sourceEventsStatMap!
            }
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("convergenceRate") && dict["convergenceRate"] != nil {
                self.convergenceRate = dict["convergenceRate"] as! String
            }
            if dict.keys.contains("maxSustainTime") && dict["maxSustainTime"] != nil {
                self.maxSustainTime = dict["maxSustainTime"] as! Int64
            }
            if dict.keys.contains("skipDay") && dict["skipDay"] != nil {
                self.skipDay = dict["skipDay"] as! Bool
            }
            if dict.keys.contains("sourceEventsStatMap") && dict["sourceEventsStatMap"] != nil {
                self.sourceEventsStatMap = dict["sourceEventsStatMap"] as! [String: Any]
            }
            if dict.keys.contains("unit") && dict["unit"] != nil {
                self.unit = dict["unit"] as! String
            }
        }
    }
    public var data: [ListTrendForSourceEventResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListTrendForSourceEventResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListTrendForSourceEventResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListTrendForSourceEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTrendForSourceEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTrendForSourceEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserSerivceGroupsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
    }
}

public class ListUserSerivceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ServiceGroups : Tea.TeaModel {
            public var serviceGroupDescription: String?

            public var serviceGroupId: Int64?

            public var serviceGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.serviceGroupDescription != nil {
                    map["serviceGroupDescription"] = self.serviceGroupDescription!
                }
                if self.serviceGroupId != nil {
                    map["serviceGroupId"] = self.serviceGroupId!
                }
                if self.serviceGroupName != nil {
                    map["serviceGroupName"] = self.serviceGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
                    self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
                }
                if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
                    self.serviceGroupId = dict["serviceGroupId"] as! Int64
                }
                if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
                    self.serviceGroupName = dict["serviceGroupName"] as! String
                }
            }
        }
        public var email: String?

        public var phone: String?

        public var ramId: Int64?

        public var serviceGroups: [ListUserSerivceGroupsResponseBody.Data.ServiceGroups]?

        public var userId: Int64?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.phone != nil {
                map["phone"] = self.phone!
            }
            if self.ramId != nil {
                map["ramId"] = self.ramId!
            }
            if self.serviceGroups != nil {
                var tmp : [Any] = []
                for k in self.serviceGroups! {
                    tmp.append(k.toMap())
                }
                map["serviceGroups"] = tmp
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("email") && dict["email"] != nil {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("phone") && dict["phone"] != nil {
                self.phone = dict["phone"] as! String
            }
            if dict.keys.contains("ramId") && dict["ramId"] != nil {
                self.ramId = dict["ramId"] as! Int64
            }
            if dict.keys.contains("serviceGroups") && dict["serviceGroups"] != nil {
                var tmp : [ListUserSerivceGroupsResponseBody.Data.ServiceGroups] = []
                for v in dict["serviceGroups"] as! [Any] {
                    var model = ListUserSerivceGroupsResponseBody.Data.ServiceGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceGroups = tmp
            }
            if dict.keys.contains("userId") && dict["userId"] != nil {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("username") && dict["username"] != nil {
                self.username = dict["username"] as! String
            }
        }
    }
    public var data: ListUserSerivceGroupsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = ListUserSerivceGroupsResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListUserSerivceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserSerivceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserSerivceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var phone: String?

    public var ramId: String?

    public var scene: Int64?

    public var synergyChannel: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.phone != nil {
            map["phone"] = self.phone!
        }
        if self.ramId != nil {
            map["ramId"] = self.ramId!
        }
        if self.scene != nil {
            map["scene"] = self.scene!
        }
        if self.synergyChannel != nil {
            map["synergyChannel"] = self.synergyChannel!
        }
        if self.username != nil {
            map["username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("phone") && dict["phone"] != nil {
            self.phone = dict["phone"] as! String
        }
        if dict.keys.contains("ramId") && dict["ramId"] != nil {
            self.ramId = dict["ramId"] as! String
        }
        if dict.keys.contains("scene") && dict["scene"] != nil {
            self.scene = dict["scene"] as! Int64
        }
        if dict.keys.contains("synergyChannel") && dict["synergyChannel"] != nil {
            self.synergyChannel = dict["synergyChannel"] as! String
        }
        if dict.keys.contains("username") && dict["username"] != nil {
            self.username = dict["username"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountType: Int64?

        public var appAccount: String?

        public var email: String?

        public var isEditableUser: Int64?

        public var isOperation: Int32?

        public var isRam: Int32?

        public var isRelated: String?

        public var phone: String?

        public var ramId: Int64?

        public var roleIdList: [Int64]?

        public var roleNameList: [String]?

        public var synergyChannel: String?

        public var userId: Int64?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountType != nil {
                map["accountType"] = self.accountType!
            }
            if self.appAccount != nil {
                map["appAccount"] = self.appAccount!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.isEditableUser != nil {
                map["isEditableUser"] = self.isEditableUser!
            }
            if self.isOperation != nil {
                map["isOperation"] = self.isOperation!
            }
            if self.isRam != nil {
                map["isRam"] = self.isRam!
            }
            if self.isRelated != nil {
                map["isRelated"] = self.isRelated!
            }
            if self.phone != nil {
                map["phone"] = self.phone!
            }
            if self.ramId != nil {
                map["ramId"] = self.ramId!
            }
            if self.roleIdList != nil {
                map["roleIdList"] = self.roleIdList!
            }
            if self.roleNameList != nil {
                map["roleNameList"] = self.roleNameList!
            }
            if self.synergyChannel != nil {
                map["synergyChannel"] = self.synergyChannel!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountType") && dict["accountType"] != nil {
                self.accountType = dict["accountType"] as! Int64
            }
            if dict.keys.contains("appAccount") && dict["appAccount"] != nil {
                self.appAccount = dict["appAccount"] as! String
            }
            if dict.keys.contains("email") && dict["email"] != nil {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("isEditableUser") && dict["isEditableUser"] != nil {
                self.isEditableUser = dict["isEditableUser"] as! Int64
            }
            if dict.keys.contains("isOperation") && dict["isOperation"] != nil {
                self.isOperation = dict["isOperation"] as! Int32
            }
            if dict.keys.contains("isRam") && dict["isRam"] != nil {
                self.isRam = dict["isRam"] as! Int32
            }
            if dict.keys.contains("isRelated") && dict["isRelated"] != nil {
                self.isRelated = dict["isRelated"] as! String
            }
            if dict.keys.contains("phone") && dict["phone"] != nil {
                self.phone = dict["phone"] as! String
            }
            if dict.keys.contains("ramId") && dict["ramId"] != nil {
                self.ramId = dict["ramId"] as! Int64
            }
            if dict.keys.contains("roleIdList") && dict["roleIdList"] != nil {
                self.roleIdList = dict["roleIdList"] as! [Int64]
            }
            if dict.keys.contains("roleNameList") && dict["roleNameList"] != nil {
                self.roleNameList = dict["roleNameList"] as! [String]
            }
            if dict.keys.contains("synergyChannel") && dict["synergyChannel"] != nil {
                self.synergyChannel = dict["synergyChannel"] as! String
            }
            if dict.keys.contains("userId") && dict["userId"] != nil {
                self.userId = dict["userId"] as! Int64
            }
            if dict.keys.contains("username") && dict["username"] != nil {
                self.username = dict["username"] as! String
            }
        }
    }
    public var data: [ListUsersResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var tmp : [ListUsersResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListUsersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("pageNumber") && dict["pageNumber"] != nil {
            self.pageNumber = dict["pageNumber"] as! Int64
        }
        if dict.keys.contains("pageSize") && dict["pageSize"] != nil {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("totalCount") && dict["totalCount"] != nil {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushMonitorRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") && dict["body"] != nil {
            self.body = dict["body"] as! String
        }
    }
}

public class PushMonitorResponseBody : Tea.TeaModel {
    public var data: Any?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! Any
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class PushMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverProblemRequest : Tea.TeaModel {
    public var problemId: Int64?

    public var problemNotifyType: String?

    public var recoveryTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        if self.recoveryTime != nil {
            map["recoveryTime"] = self.recoveryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! String
        }
        if dict.keys.contains("recoveryTime") && dict["recoveryTime"] != nil {
            self.recoveryTime = dict["recoveryTime"] as! String
        }
    }
}

public class RecoverProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RecoverProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecoverProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshIntegrationConfigKeyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class RefreshIntegrationConfigKeyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var key: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") && dict["key"] != nil {
                self.key = dict["key"] as! String
            }
        }
    }
    public var data: RefreshIntegrationConfigKeyResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = RefreshIntegrationConfigKeyResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RefreshIntegrationConfigKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshIntegrationConfigKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshIntegrationConfigKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIntegrationConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class RemoveIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RemoveIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveProblemServiceGroupRequest : Tea.TeaModel {
    public var problemId: Int64?

    public var serviceGroupIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.serviceGroupIds != nil {
            map["serviceGroupIds"] = self.serviceGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
            self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
        }
    }
}

public class RemoveProblemServiceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RemoveProblemServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveProblemServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveProblemServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplayProblemRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public var replayDutyUserId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.replayDutyUserId != nil {
            map["replayDutyUserId"] = self.replayDutyUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("replayDutyUserId") && dict["replayDutyUserId"] != nil {
            self.replayDutyUserId = dict["replayDutyUserId"] as! Int64
        }
    }
}

public class ReplayProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ReplayProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplayProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReplayProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RespondIncidentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var incidentIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.incidentIds != nil {
            map["incidentIds"] = self.incidentIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("incidentIds") && dict["incidentIds"] != nil {
            self.incidentIds = dict["incidentIds"] as! [Int64]
        }
    }
}

public class RespondIncidentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RespondIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RespondIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RespondIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeProblemRecoveryRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public var problemNotifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! String
        }
    }
}

public class RevokeProblemRecoveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class RevokeProblemRecoveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeProblemRecoveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokeProblemRecoveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UnbindUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnbindUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEscalationPlanRequest : Tea.TeaModel {
    public class EscalationPlanRules : Tea.TeaModel {
        public class EscalationPlanConditions : Tea.TeaModel {
            public var effection: String?

            public var level: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.effection != nil {
                    map["effection"] = self.effection!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("effection") && dict["effection"] != nil {
                    self.effection = dict["effection"] as! String
                }
                if dict.keys.contains("level") && dict["level"] != nil {
                    self.level = dict["level"] as! String
                }
            }
        }
        public class EscalationPlanStrategies : Tea.TeaModel {
            public var enableWebhook: Bool?

            public var escalationPlanType: String?

            public var noticeChannels: [String]?

            public var noticeObjects: [Int64]?

            public var noticeRoleList: [Int64]?

            public var noticeTime: Int64?

            public var serviceGroupIds: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableWebhook != nil {
                    map["enableWebhook"] = self.enableWebhook!
                }
                if self.escalationPlanType != nil {
                    map["escalationPlanType"] = self.escalationPlanType!
                }
                if self.noticeChannels != nil {
                    map["noticeChannels"] = self.noticeChannels!
                }
                if self.noticeObjects != nil {
                    map["noticeObjects"] = self.noticeObjects!
                }
                if self.noticeRoleList != nil {
                    map["noticeRoleList"] = self.noticeRoleList!
                }
                if self.noticeTime != nil {
                    map["noticeTime"] = self.noticeTime!
                }
                if self.serviceGroupIds != nil {
                    map["serviceGroupIds"] = self.serviceGroupIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
                    self.enableWebhook = dict["enableWebhook"] as! Bool
                }
                if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                    self.escalationPlanType = dict["escalationPlanType"] as! String
                }
                if dict.keys.contains("noticeChannels") && dict["noticeChannels"] != nil {
                    self.noticeChannels = dict["noticeChannels"] as! [String]
                }
                if dict.keys.contains("noticeObjects") && dict["noticeObjects"] != nil {
                    self.noticeObjects = dict["noticeObjects"] as! [Int64]
                }
                if dict.keys.contains("noticeRoleList") && dict["noticeRoleList"] != nil {
                    self.noticeRoleList = dict["noticeRoleList"] as! [Int64]
                }
                if dict.keys.contains("noticeTime") && dict["noticeTime"] != nil {
                    self.noticeTime = dict["noticeTime"] as! Int64
                }
                if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
                    self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
                }
            }
        }
        public var escalationPlanConditions: [UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions]?

        public var escalationPlanStrategies: [UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies]?

        public var escalationPlanType: String?

        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlanConditions != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanConditions! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanConditions"] = tmp
            }
            if self.escalationPlanStrategies != nil {
                var tmp : [Any] = []
                for k in self.escalationPlanStrategies! {
                    tmp.append(k.toMap())
                }
                map["escalationPlanStrategies"] = tmp
            }
            if self.escalationPlanType != nil {
                map["escalationPlanType"] = self.escalationPlanType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlanConditions") && dict["escalationPlanConditions"] != nil {
                var tmp : [UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions] = []
                for v in dict["escalationPlanConditions"] as! [Any] {
                    var model = UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanConditions = tmp
            }
            if dict.keys.contains("escalationPlanStrategies") && dict["escalationPlanStrategies"] != nil {
                var tmp : [UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies] = []
                for v in dict["escalationPlanStrategies"] as! [Any] {
                    var model = UpdateEscalationPlanRequest.EscalationPlanRules.EscalationPlanStrategies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlanStrategies = tmp
            }
            if dict.keys.contains("escalationPlanType") && dict["escalationPlanType"] != nil {
                self.escalationPlanType = dict["escalationPlanType"] as! String
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
        }
    }
    public class EscalationPlanScopeObjects : Tea.TeaModel {
        public var id: Int64?

        public var scope: String?

        public var scopeObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.scopeObjectId != nil {
                map["scopeObjectId"] = self.scopeObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("scope") && dict["scope"] != nil {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                self.scopeObjectId = dict["scopeObjectId"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var escalationPlanDescription: String?

    public var escalationPlanId: Int64?

    public var escalationPlanName: String?

    public var escalationPlanRules: [UpdateEscalationPlanRequest.EscalationPlanRules]?

    public var escalationPlanScopeObjects: [UpdateEscalationPlanRequest.EscalationPlanScopeObjects]?

    public var isGlobal: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanDescription != nil {
            map["escalationPlanDescription"] = self.escalationPlanDescription!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        if self.escalationPlanName != nil {
            map["escalationPlanName"] = self.escalationPlanName!
        }
        if self.escalationPlanRules != nil {
            var tmp : [Any] = []
            for k in self.escalationPlanRules! {
                tmp.append(k.toMap())
            }
            map["escalationPlanRules"] = tmp
        }
        if self.escalationPlanScopeObjects != nil {
            var tmp : [Any] = []
            for k in self.escalationPlanScopeObjects! {
                tmp.append(k.toMap())
            }
            map["escalationPlanScopeObjects"] = tmp
        }
        if self.isGlobal != nil {
            map["isGlobal"] = self.isGlobal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanDescription") && dict["escalationPlanDescription"] != nil {
            self.escalationPlanDescription = dict["escalationPlanDescription"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
        if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
            self.escalationPlanName = dict["escalationPlanName"] as! String
        }
        if dict.keys.contains("escalationPlanRules") && dict["escalationPlanRules"] != nil {
            var tmp : [UpdateEscalationPlanRequest.EscalationPlanRules] = []
            for v in dict["escalationPlanRules"] as! [Any] {
                var model = UpdateEscalationPlanRequest.EscalationPlanRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.escalationPlanRules = tmp
        }
        if dict.keys.contains("escalationPlanScopeObjects") && dict["escalationPlanScopeObjects"] != nil {
            var tmp : [UpdateEscalationPlanRequest.EscalationPlanScopeObjects] = []
            for v in dict["escalationPlanScopeObjects"] as! [Any] {
                var model = UpdateEscalationPlanRequest.EscalationPlanScopeObjects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.escalationPlanScopeObjects = tmp
        }
        if dict.keys.contains("isGlobal") && dict["isGlobal"] != nil {
            self.isGlobal = dict["isGlobal"] as! Bool
        }
    }
}

public class UpdateEscalationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateEscalationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEscalationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEscalationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIncidentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var effect: String?

    public var incidentId: Int64?

    public var incidentLevel: String?

    public var incidentTitle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.effect != nil {
            map["effect"] = self.effect!
        }
        if self.incidentId != nil {
            map["incidentId"] = self.incidentId!
        }
        if self.incidentLevel != nil {
            map["incidentLevel"] = self.incidentLevel!
        }
        if self.incidentTitle != nil {
            map["incidentTitle"] = self.incidentTitle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("effect") && dict["effect"] != nil {
            self.effect = dict["effect"] as! String
        }
        if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
            self.incidentId = dict["incidentId"] as! Int64
        }
        if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
            self.incidentLevel = dict["incidentLevel"] as! String
        }
        if dict.keys.contains("incidentTitle") && dict["incidentTitle"] != nil {
            self.incidentTitle = dict["incidentTitle"] as! String
        }
    }
}

public class UpdateIncidentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var incidentId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.incidentId != nil {
                map["incidentId"] = self.incidentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("incidentId") && dict["incidentId"] != nil {
                self.incidentId = dict["incidentId"] as! Int64
            }
        }
    }
    public var data: UpdateIncidentResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = UpdateIncidentResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateIncidentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIncidentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateIncidentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIntegrationConfigRequest : Tea.TeaModel {
    public var accessKey: String?

    public var clientToken: String?

    public var integrationConfigId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.integrationConfigId != nil {
            map["integrationConfigId"] = self.integrationConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessKey") && dict["accessKey"] != nil {
            self.accessKey = dict["accessKey"] as! String
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("integrationConfigId") && dict["integrationConfigId"] != nil {
            self.integrationConfigId = dict["integrationConfigId"] as! Int64
        }
    }
}

public class UpdateIntegrationConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateIntegrationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIntegrationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateIntegrationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemRequest : Tea.TeaModel {
    public var feedback: String?

    public var level: String?

    public var mainHandlerId: Int64?

    public var preliminaryReason: String?

    public var problemId: Int64?

    public var problemName: String?

    public var progressSummary: String?

    public var progressSummaryRichTextId: Int64?

    public var relatedServiceId: Int64?

    public var serviceGroupIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feedback != nil {
            map["feedback"] = self.feedback!
        }
        if self.level != nil {
            map["level"] = self.level!
        }
        if self.mainHandlerId != nil {
            map["mainHandlerId"] = self.mainHandlerId!
        }
        if self.preliminaryReason != nil {
            map["preliminaryReason"] = self.preliminaryReason!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemName != nil {
            map["problemName"] = self.problemName!
        }
        if self.progressSummary != nil {
            map["progressSummary"] = self.progressSummary!
        }
        if self.progressSummaryRichTextId != nil {
            map["progressSummaryRichTextId"] = self.progressSummaryRichTextId!
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.serviceGroupIds != nil {
            map["serviceGroupIds"] = self.serviceGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("feedback") && dict["feedback"] != nil {
            self.feedback = dict["feedback"] as! String
        }
        if dict.keys.contains("level") && dict["level"] != nil {
            self.level = dict["level"] as! String
        }
        if dict.keys.contains("mainHandlerId") && dict["mainHandlerId"] != nil {
            self.mainHandlerId = dict["mainHandlerId"] as! Int64
        }
        if dict.keys.contains("preliminaryReason") && dict["preliminaryReason"] != nil {
            self.preliminaryReason = dict["preliminaryReason"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemName") && dict["problemName"] != nil {
            self.problemName = dict["problemName"] as! String
        }
        if dict.keys.contains("progressSummary") && dict["progressSummary"] != nil {
            self.progressSummary = dict["progressSummary"] as! String
        }
        if dict.keys.contains("progressSummaryRichTextId") && dict["progressSummaryRichTextId"] != nil {
            self.progressSummaryRichTextId = dict["progressSummaryRichTextId"] as! Int64
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("serviceGroupIds") && dict["serviceGroupIds"] != nil {
            self.serviceGroupIds = dict["serviceGroupIds"] as! [Int64]
        }
    }
}

public class UpdateProblemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemEffectionServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var effectionServiceId: Int64?

    public var level: String?

    public var picUrl: [String]?

    public var problemId: Int64?

    public var serviceId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.effectionServiceId != nil {
            map["effectionServiceId"] = self.effectionServiceId!
        }
        if self.level != nil {
            map["level"] = self.level!
        }
        if self.picUrl != nil {
            map["picUrl"] = self.picUrl!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("description") && dict["description"] != nil {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("effectionServiceId") && dict["effectionServiceId"] != nil {
            self.effectionServiceId = dict["effectionServiceId"] as! Int64
        }
        if dict.keys.contains("level") && dict["level"] != nil {
            self.level = dict["level"] as! String
        }
        if dict.keys.contains("picUrl") && dict["picUrl"] != nil {
            self.picUrl = dict["picUrl"] as! [String]
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
    }
}

public class UpdateProblemEffectionServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemEffectionServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemEffectionServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemEffectionServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemImprovementRequest : Tea.TeaModel {
    public var clientToken: String?

    public var customProblemReason: String?

    public var discoverSource: Int64?

    public var dutyDepartmentId: Int64?

    public var dutyDepartmentName: String?

    public var dutyUserId: Int64?

    public var injectionMode: String?

    public var monitorSourceName: String?

    public var problemId: Int64?

    public var problemReason: String?

    public var recentActivity: String?

    public var recoveryMode: String?

    public var relationChanges: String?

    public var remark: String?

    public var replayDutyUserId: Int64?

    public var userReport: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.customProblemReason != nil {
            map["customProblemReason"] = self.customProblemReason!
        }
        if self.discoverSource != nil {
            map["discoverSource"] = self.discoverSource!
        }
        if self.dutyDepartmentId != nil {
            map["dutyDepartmentId"] = self.dutyDepartmentId!
        }
        if self.dutyDepartmentName != nil {
            map["dutyDepartmentName"] = self.dutyDepartmentName!
        }
        if self.dutyUserId != nil {
            map["dutyUserId"] = self.dutyUserId!
        }
        if self.injectionMode != nil {
            map["injectionMode"] = self.injectionMode!
        }
        if self.monitorSourceName != nil {
            map["monitorSourceName"] = self.monitorSourceName!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemReason != nil {
            map["problemReason"] = self.problemReason!
        }
        if self.recentActivity != nil {
            map["recentActivity"] = self.recentActivity!
        }
        if self.recoveryMode != nil {
            map["recoveryMode"] = self.recoveryMode!
        }
        if self.relationChanges != nil {
            map["relationChanges"] = self.relationChanges!
        }
        if self.remark != nil {
            map["remark"] = self.remark!
        }
        if self.replayDutyUserId != nil {
            map["replayDutyUserId"] = self.replayDutyUserId!
        }
        if self.userReport != nil {
            map["userReport"] = self.userReport!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("customProblemReason") && dict["customProblemReason"] != nil {
            self.customProblemReason = dict["customProblemReason"] as! String
        }
        if dict.keys.contains("discoverSource") && dict["discoverSource"] != nil {
            self.discoverSource = dict["discoverSource"] as! Int64
        }
        if dict.keys.contains("dutyDepartmentId") && dict["dutyDepartmentId"] != nil {
            self.dutyDepartmentId = dict["dutyDepartmentId"] as! Int64
        }
        if dict.keys.contains("dutyDepartmentName") && dict["dutyDepartmentName"] != nil {
            self.dutyDepartmentName = dict["dutyDepartmentName"] as! String
        }
        if dict.keys.contains("dutyUserId") && dict["dutyUserId"] != nil {
            self.dutyUserId = dict["dutyUserId"] as! Int64
        }
        if dict.keys.contains("injectionMode") && dict["injectionMode"] != nil {
            self.injectionMode = dict["injectionMode"] as! String
        }
        if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
            self.monitorSourceName = dict["monitorSourceName"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemReason") && dict["problemReason"] != nil {
            self.problemReason = dict["problemReason"] as! String
        }
        if dict.keys.contains("recentActivity") && dict["recentActivity"] != nil {
            self.recentActivity = dict["recentActivity"] as! String
        }
        if dict.keys.contains("recoveryMode") && dict["recoveryMode"] != nil {
            self.recoveryMode = dict["recoveryMode"] as! String
        }
        if dict.keys.contains("relationChanges") && dict["relationChanges"] != nil {
            self.relationChanges = dict["relationChanges"] as! String
        }
        if dict.keys.contains("remark") && dict["remark"] != nil {
            self.remark = dict["remark"] as! String
        }
        if dict.keys.contains("replayDutyUserId") && dict["replayDutyUserId"] != nil {
            self.replayDutyUserId = dict["replayDutyUserId"] as! Int64
        }
        if dict.keys.contains("userReport") && dict["userReport"] != nil {
            self.userReport = dict["userReport"] as! Int64
        }
    }
}

public class UpdateProblemImprovementResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemImprovementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemImprovementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemImprovementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemMeasureRequest : Tea.TeaModel {
    public var checkStandard: String?

    public var checkUserId: Int64?

    public var clientToken: String?

    public var content: String?

    public var directorId: Int64?

    public var measureId: Int64?

    public var planFinishTime: String?

    public var problemId: Int64?

    public var stalkerId: Int64?

    public var status: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkStandard != nil {
            map["checkStandard"] = self.checkStandard!
        }
        if self.checkUserId != nil {
            map["checkUserId"] = self.checkUserId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.directorId != nil {
            map["directorId"] = self.directorId!
        }
        if self.measureId != nil {
            map["measureId"] = self.measureId!
        }
        if self.planFinishTime != nil {
            map["planFinishTime"] = self.planFinishTime!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.stalkerId != nil {
            map["stalkerId"] = self.stalkerId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("checkStandard") && dict["checkStandard"] != nil {
            self.checkStandard = dict["checkStandard"] as! String
        }
        if dict.keys.contains("checkUserId") && dict["checkUserId"] != nil {
            self.checkUserId = dict["checkUserId"] as! Int64
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("content") && dict["content"] != nil {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("directorId") && dict["directorId"] != nil {
            self.directorId = dict["directorId"] as! Int64
        }
        if dict.keys.contains("measureId") && dict["measureId"] != nil {
            self.measureId = dict["measureId"] as! Int64
        }
        if dict.keys.contains("planFinishTime") && dict["planFinishTime"] != nil {
            self.planFinishTime = dict["planFinishTime"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("stalkerId") && dict["stalkerId"] != nil {
            self.stalkerId = dict["stalkerId"] as! Int64
        }
        if dict.keys.contains("status") && dict["status"] != nil {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("type") && dict["type"] != nil {
            self.type = dict["type"] as! Int32
        }
    }
}

public class UpdateProblemMeasureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemMeasureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemMeasureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemMeasureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemNoticeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var problemId: Int64?

    public var problemNotifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemNotifyType != nil {
            map["problemNotifyType"] = self.problemNotifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
            self.problemNotifyType = dict["problemNotifyType"] as! String
        }
    }
}

public class UpdateProblemNoticeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemNoticeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemNoticeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemNoticeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProblemTimelineRequest : Tea.TeaModel {
    public var clientToken: String?

    public var content: String?

    public var keyNode: String?

    public var problemId: Int64?

    public var problemTimelineId: Int64?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.keyNode != nil {
            map["keyNode"] = self.keyNode!
        }
        if self.problemId != nil {
            map["problemId"] = self.problemId!
        }
        if self.problemTimelineId != nil {
            map["problemTimelineId"] = self.problemTimelineId!
        }
        if self.time != nil {
            map["time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("content") && dict["content"] != nil {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("keyNode") && dict["keyNode"] != nil {
            self.keyNode = dict["keyNode"] as! String
        }
        if dict.keys.contains("problemId") && dict["problemId"] != nil {
            self.problemId = dict["problemId"] as! Int64
        }
        if dict.keys.contains("problemTimelineId") && dict["problemTimelineId"] != nil {
            self.problemTimelineId = dict["problemTimelineId"] as! Int64
        }
        if dict.keys.contains("time") && dict["time"] != nil {
            self.time = dict["time"] as! String
        }
    }
}

public class UpdateProblemTimelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateProblemTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProblemTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateProblemTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRichTextRequest : Tea.TeaModel {
    public var instanceId: Int64?

    public var instanceType: String?

    public var richText: String?

    public var richTextId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.richText != nil {
            map["richText"] = self.richText!
        }
        if self.richTextId != nil {
            map["richTextId"] = self.richTextId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceId") && dict["instanceId"] != nil {
            self.instanceId = dict["instanceId"] as! Int64
        }
        if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("richText") && dict["richText"] != nil {
            self.richText = dict["richText"] as! String
        }
        if dict.keys.contains("richTextId") && dict["richTextId"] != nil {
            self.richTextId = dict["richTextId"] as! Int64
        }
    }
}

public class UpdateRichTextResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
        }
    }
    public var data: UpdateRichTextResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = UpdateRichTextResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateRichTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRichTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateRichTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRouteRuleRequest : Tea.TeaModel {
    public class RouteChildRules : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var key: String?

            public var operationSymbol: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.operationSymbol != nil {
                    map["operationSymbol"] = self.operationSymbol!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") && dict["key"] != nil {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("operationSymbol") && dict["operationSymbol"] != nil {
                    self.operationSymbol = dict["operationSymbol"] as! String
                }
                if dict.keys.contains("value") && dict["value"] != nil {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var childConditionRelation: Int64?

        public var childRouteRuleId: Int64?

        public var conditions: [UpdateRouteRuleRequest.RouteChildRules.Conditions]?

        public var isValidChildRule: Bool?

        public var monitorSourceId: Int64?

        public var problemLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.childConditionRelation != nil {
                map["childConditionRelation"] = self.childConditionRelation!
            }
            if self.childRouteRuleId != nil {
                map["childRouteRuleId"] = self.childRouteRuleId!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["conditions"] = tmp
            }
            if self.isValidChildRule != nil {
                map["isValidChildRule"] = self.isValidChildRule!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.problemLevel != nil {
                map["problemLevel"] = self.problemLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("childConditionRelation") && dict["childConditionRelation"] != nil {
                self.childConditionRelation = dict["childConditionRelation"] as! Int64
            }
            if dict.keys.contains("childRouteRuleId") && dict["childRouteRuleId"] != nil {
                self.childRouteRuleId = dict["childRouteRuleId"] as! Int64
            }
            if dict.keys.contains("conditions") && dict["conditions"] != nil {
                var tmp : [UpdateRouteRuleRequest.RouteChildRules.Conditions] = []
                for v in dict["conditions"] as! [Any] {
                    var model = UpdateRouteRuleRequest.RouteChildRules.Conditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditions = tmp
            }
            if dict.keys.contains("isValidChildRule") && dict["isValidChildRule"] != nil {
                self.isValidChildRule = dict["isValidChildRule"] as! Bool
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("problemLevel") && dict["problemLevel"] != nil {
                self.problemLevel = dict["problemLevel"] as! String
            }
        }
    }
    public var assignObjectId: Int64?

    public var assignObjectType: String?

    public var childRuleRelation: String?

    public var clientToken: String?

    public var convergenceFields: [String]?

    public var convergenceType: Int32?

    public var coverageProblemLevels: [String]?

    public var effection: String?

    public var incidentLevel: String?

    public var matchCount: Int64?

    public var notifyChannels: [String]?

    public var problemEffectionServices: [Int64]?

    public var problemLevelGroup: [String: ProblemLevelGroupValue]?

    public var relatedServiceId: Int64?

    public var routeChildRules: [UpdateRouteRuleRequest.RouteChildRules]?

    public var routeRuleId: Int64?

    public var routeType: String?

    public var ruleName: String?

    public var timeWindow: Int32?

    public var timeWindowUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignObjectId != nil {
            map["assignObjectId"] = self.assignObjectId!
        }
        if self.assignObjectType != nil {
            map["assignObjectType"] = self.assignObjectType!
        }
        if self.childRuleRelation != nil {
            map["childRuleRelation"] = self.childRuleRelation!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.convergenceFields != nil {
            map["convergenceFields"] = self.convergenceFields!
        }
        if self.convergenceType != nil {
            map["convergenceType"] = self.convergenceType!
        }
        if self.coverageProblemLevels != nil {
            map["coverageProblemLevels"] = self.coverageProblemLevels!
        }
        if self.effection != nil {
            map["effection"] = self.effection!
        }
        if self.incidentLevel != nil {
            map["incidentLevel"] = self.incidentLevel!
        }
        if self.matchCount != nil {
            map["matchCount"] = self.matchCount!
        }
        if self.notifyChannels != nil {
            map["notifyChannels"] = self.notifyChannels!
        }
        if self.problemEffectionServices != nil {
            map["problemEffectionServices"] = self.problemEffectionServices!
        }
        if self.problemLevelGroup != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.problemLevelGroup! {
                tmp[k] = v.toMap()
            }
            map["problemLevelGroup"] = tmp
        }
        if self.relatedServiceId != nil {
            map["relatedServiceId"] = self.relatedServiceId!
        }
        if self.routeChildRules != nil {
            var tmp : [Any] = []
            for k in self.routeChildRules! {
                tmp.append(k.toMap())
            }
            map["routeChildRules"] = tmp
        }
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        if self.routeType != nil {
            map["routeType"] = self.routeType!
        }
        if self.ruleName != nil {
            map["ruleName"] = self.ruleName!
        }
        if self.timeWindow != nil {
            map["timeWindow"] = self.timeWindow!
        }
        if self.timeWindowUnit != nil {
            map["timeWindowUnit"] = self.timeWindowUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignObjectId") && dict["assignObjectId"] != nil {
            self.assignObjectId = dict["assignObjectId"] as! Int64
        }
        if dict.keys.contains("assignObjectType") && dict["assignObjectType"] != nil {
            self.assignObjectType = dict["assignObjectType"] as! String
        }
        if dict.keys.contains("childRuleRelation") && dict["childRuleRelation"] != nil {
            self.childRuleRelation = dict["childRuleRelation"] as! String
        }
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("convergenceFields") && dict["convergenceFields"] != nil {
            self.convergenceFields = dict["convergenceFields"] as! [String]
        }
        if dict.keys.contains("convergenceType") && dict["convergenceType"] != nil {
            self.convergenceType = dict["convergenceType"] as! Int32
        }
        if dict.keys.contains("coverageProblemLevels") && dict["coverageProblemLevels"] != nil {
            self.coverageProblemLevels = dict["coverageProblemLevels"] as! [String]
        }
        if dict.keys.contains("effection") && dict["effection"] != nil {
            self.effection = dict["effection"] as! String
        }
        if dict.keys.contains("incidentLevel") && dict["incidentLevel"] != nil {
            self.incidentLevel = dict["incidentLevel"] as! String
        }
        if dict.keys.contains("matchCount") && dict["matchCount"] != nil {
            self.matchCount = dict["matchCount"] as! Int64
        }
        if dict.keys.contains("notifyChannels") && dict["notifyChannels"] != nil {
            self.notifyChannels = dict["notifyChannels"] as! [String]
        }
        if dict.keys.contains("problemEffectionServices") && dict["problemEffectionServices"] != nil {
            self.problemEffectionServices = dict["problemEffectionServices"] as! [Int64]
        }
        if dict.keys.contains("problemLevelGroup") && dict["problemLevelGroup"] != nil {
            var tmp : [String: ProblemLevelGroupValue] = [:]
            for (k, v) in dict["problemLevelGroup"] as! [String: Any] {
                if v != nil {
                    var model = ProblemLevelGroupValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.problemLevelGroup = tmp
        }
        if dict.keys.contains("relatedServiceId") && dict["relatedServiceId"] != nil {
            self.relatedServiceId = dict["relatedServiceId"] as! Int64
        }
        if dict.keys.contains("routeChildRules") && dict["routeChildRules"] != nil {
            var tmp : [UpdateRouteRuleRequest.RouteChildRules] = []
            for v in dict["routeChildRules"] as! [Any] {
                var model = UpdateRouteRuleRequest.RouteChildRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeChildRules = tmp
        }
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
        if dict.keys.contains("routeType") && dict["routeType"] != nil {
            self.routeType = dict["routeType"] as! String
        }
        if dict.keys.contains("ruleName") && dict["ruleName"] != nil {
            self.ruleName = dict["ruleName"] as! String
        }
        if dict.keys.contains("timeWindow") && dict["timeWindow"] != nil {
            self.timeWindow = dict["timeWindow"] as! Int32
        }
        if dict.keys.contains("timeWindowUnit") && dict["timeWindowUnit"] != nil {
            self.timeWindowUnit = dict["timeWindowUnit"] as! String
        }
    }
}

public class UpdateRouteRuleResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var escalationPlanId: Int64?

    public var serviceDescription: String?

    public var serviceGroupIdList: [Int64]?

    public var serviceId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.escalationPlanId != nil {
            map["escalationPlanId"] = self.escalationPlanId!
        }
        if self.serviceDescription != nil {
            map["serviceDescription"] = self.serviceDescription!
        }
        if self.serviceGroupIdList != nil {
            map["serviceGroupIdList"] = self.serviceGroupIdList!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
            self.escalationPlanId = dict["escalationPlanId"] as! Int64
        }
        if dict.keys.contains("serviceDescription") && dict["serviceDescription"] != nil {
            self.serviceDescription = dict["serviceDescription"] as! String
        }
        if dict.keys.contains("serviceGroupIdList") && dict["serviceGroupIdList"] != nil {
            self.serviceGroupIdList = dict["serviceGroupIdList"] as! [Int64]
        }
        if dict.keys.contains("serviceId") && dict["serviceId"] != nil {
            self.serviceId = dict["serviceId"] as! Int64
        }
        if dict.keys.contains("serviceName") && dict["serviceName"] != nil {
            self.serviceName = dict["serviceName"] as! String
        }
    }
}

public class UpdateServiceResponseBody : Tea.TeaModel {
    public var data: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! Int64
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceGroupRequest : Tea.TeaModel {
    public class MonitorSourceTemplates : Tea.TeaModel {
        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public var templateContent: String?

        public var templateId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            if self.templateContent != nil {
                map["templateContent"] = self.templateContent!
            }
            if self.templateId != nil {
                map["templateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
            if dict.keys.contains("templateContent") && dict["templateContent"] != nil {
                self.templateContent = dict["templateContent"] as! String
            }
            if dict.keys.contains("templateId") && dict["templateId"] != nil {
                self.templateId = dict["templateId"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var enableWebhook: String?

    public var monitorSourceTemplates: [UpdateServiceGroupRequest.MonitorSourceTemplates]?

    public var serviceGroupDescription: String?

    public var serviceGroupId: Int64?

    public var serviceGroupName: String?

    public var userIds: [Int64]?

    public var webhookLink: String?

    public var webhookType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.enableWebhook != nil {
            map["enableWebhook"] = self.enableWebhook!
        }
        if self.monitorSourceTemplates != nil {
            var tmp : [Any] = []
            for k in self.monitorSourceTemplates! {
                tmp.append(k.toMap())
            }
            map["monitorSourceTemplates"] = tmp
        }
        if self.serviceGroupDescription != nil {
            map["serviceGroupDescription"] = self.serviceGroupDescription!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        if self.serviceGroupName != nil {
            map["serviceGroupName"] = self.serviceGroupName!
        }
        if self.userIds != nil {
            map["userIds"] = self.userIds!
        }
        if self.webhookLink != nil {
            map["webhookLink"] = self.webhookLink!
        }
        if self.webhookType != nil {
            map["webhookType"] = self.webhookType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("enableWebhook") && dict["enableWebhook"] != nil {
            self.enableWebhook = dict["enableWebhook"] as! String
        }
        if dict.keys.contains("monitorSourceTemplates") && dict["monitorSourceTemplates"] != nil {
            var tmp : [UpdateServiceGroupRequest.MonitorSourceTemplates] = []
            for v in dict["monitorSourceTemplates"] as! [Any] {
                var model = UpdateServiceGroupRequest.MonitorSourceTemplates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitorSourceTemplates = tmp
        }
        if dict.keys.contains("serviceGroupDescription") && dict["serviceGroupDescription"] != nil {
            self.serviceGroupDescription = dict["serviceGroupDescription"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
        if dict.keys.contains("serviceGroupName") && dict["serviceGroupName"] != nil {
            self.serviceGroupName = dict["serviceGroupName"] as! String
        }
        if dict.keys.contains("userIds") && dict["userIds"] != nil {
            self.userIds = dict["userIds"] as! [Int64]
        }
        if dict.keys.contains("webhookLink") && dict["webhookLink"] != nil {
            self.webhookLink = dict["webhookLink"] as! String
        }
        if dict.keys.contains("webhookType") && dict["webhookType"] != nil {
            self.webhookType = dict["webhookType"] as! String
        }
    }
}

public class UpdateServiceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateServiceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceGroupSchedulingRequest : Tea.TeaModel {
    public class FastScheduling : Tea.TeaModel {
        public class SchedulingUsers : Tea.TeaModel {
            public var schedulingObjectType: String?

            public var schedulingOrder: Int32?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int32
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
            }
        }
        public var dutyPlan: String?

        public var id: Int64?

        public var schedulingUsers: [UpdateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers]?

        public var singleDuration: Int32?

        public var singleDurationUnit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dutyPlan != nil {
                map["dutyPlan"] = self.dutyPlan!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.schedulingUsers != nil {
                var tmp : [Any] = []
                for k in self.schedulingUsers! {
                    tmp.append(k.toMap())
                }
                map["schedulingUsers"] = tmp
            }
            if self.singleDuration != nil {
                map["singleDuration"] = self.singleDuration!
            }
            if self.singleDurationUnit != nil {
                map["singleDurationUnit"] = self.singleDurationUnit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dutyPlan") && dict["dutyPlan"] != nil {
                self.dutyPlan = dict["dutyPlan"] as! String
            }
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("schedulingUsers") && dict["schedulingUsers"] != nil {
                var tmp : [UpdateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers] = []
                for v in dict["schedulingUsers"] as! [Any] {
                    var model = UpdateServiceGroupSchedulingRequest.FastScheduling.SchedulingUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingUsers = tmp
            }
            if dict.keys.contains("singleDuration") && dict["singleDuration"] != nil {
                self.singleDuration = dict["singleDuration"] as! Int32
            }
            if dict.keys.contains("singleDurationUnit") && dict["singleDurationUnit"] != nil {
                self.singleDurationUnit = dict["singleDurationUnit"] as! String
            }
        }
    }
    public class FineScheduling : Tea.TeaModel {
        public class SchedulingFineShifts : Tea.TeaModel {
            public var cycleOrder: Int32?

            public var schedulingEndTime: String?

            public var schedulingObjectType: String?

            public var schedulingOrder: Int64?

            public var schedulingStartTime: String?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public var shiftName: String?

            public var skipOneDay: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleOrder != nil {
                    map["cycleOrder"] = self.cycleOrder!
                }
                if self.schedulingEndTime != nil {
                    map["schedulingEndTime"] = self.schedulingEndTime!
                }
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingStartTime != nil {
                    map["schedulingStartTime"] = self.schedulingStartTime!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                if self.shiftName != nil {
                    map["shiftName"] = self.shiftName!
                }
                if self.skipOneDay != nil {
                    map["skipOneDay"] = self.skipOneDay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cycleOrder") && dict["cycleOrder"] != nil {
                    self.cycleOrder = dict["cycleOrder"] as! Int32
                }
                if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                    self.schedulingEndTime = dict["schedulingEndTime"] as! String
                }
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int64
                }
                if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                    self.schedulingStartTime = dict["schedulingStartTime"] as! String
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
                if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                    self.shiftName = dict["shiftName"] as! String
                }
                if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                    self.skipOneDay = dict["skipOneDay"] as! Bool
                }
            }
        }
        public class SchedulingTemplateFineShifts : Tea.TeaModel {
            public var schedulingEndTime: String?

            public var schedulingObjectType: String?

            public var schedulingOrder: Int32?

            public var schedulingStartTime: String?

            public var schedulingUserId: Int64?

            public var schedulingUserIdList: [Int64]?

            public var shiftName: String?

            public var skipOneDay: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulingEndTime != nil {
                    map["schedulingEndTime"] = self.schedulingEndTime!
                }
                if self.schedulingObjectType != nil {
                    map["schedulingObjectType"] = self.schedulingObjectType!
                }
                if self.schedulingOrder != nil {
                    map["schedulingOrder"] = self.schedulingOrder!
                }
                if self.schedulingStartTime != nil {
                    map["schedulingStartTime"] = self.schedulingStartTime!
                }
                if self.schedulingUserId != nil {
                    map["schedulingUserId"] = self.schedulingUserId!
                }
                if self.schedulingUserIdList != nil {
                    map["schedulingUserIdList"] = self.schedulingUserIdList!
                }
                if self.shiftName != nil {
                    map["shiftName"] = self.shiftName!
                }
                if self.skipOneDay != nil {
                    map["skipOneDay"] = self.skipOneDay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                    self.schedulingEndTime = dict["schedulingEndTime"] as! String
                }
                if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                    self.schedulingObjectType = dict["schedulingObjectType"] as! String
                }
                if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                    self.schedulingOrder = dict["schedulingOrder"] as! Int32
                }
                if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                    self.schedulingStartTime = dict["schedulingStartTime"] as! String
                }
                if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                    self.schedulingUserId = dict["schedulingUserId"] as! Int64
                }
                if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                    self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
                }
                if dict.keys.contains("shiftName") && dict["shiftName"] != nil {
                    self.shiftName = dict["shiftName"] as! String
                }
                if dict.keys.contains("skipOneDay") && dict["skipOneDay"] != nil {
                    self.skipOneDay = dict["skipOneDay"] as! Bool
                }
            }
        }
        public var id: Int64?

        public var period: Int32?

        public var periodUnit: String?

        public var schedulingFineShifts: [UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts]?

        public var schedulingTemplateFineShifts: [UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts]?

        public var shiftType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.period != nil {
                map["period"] = self.period!
            }
            if self.periodUnit != nil {
                map["periodUnit"] = self.periodUnit!
            }
            if self.schedulingFineShifts != nil {
                var tmp : [Any] = []
                for k in self.schedulingFineShifts! {
                    tmp.append(k.toMap())
                }
                map["schedulingFineShifts"] = tmp
            }
            if self.schedulingTemplateFineShifts != nil {
                var tmp : [Any] = []
                for k in self.schedulingTemplateFineShifts! {
                    tmp.append(k.toMap())
                }
                map["schedulingTemplateFineShifts"] = tmp
            }
            if self.shiftType != nil {
                map["shiftType"] = self.shiftType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("period") && dict["period"] != nil {
                self.period = dict["period"] as! Int32
            }
            if dict.keys.contains("periodUnit") && dict["periodUnit"] != nil {
                self.periodUnit = dict["periodUnit"] as! String
            }
            if dict.keys.contains("schedulingFineShifts") && dict["schedulingFineShifts"] != nil {
                var tmp : [UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts] = []
                for v in dict["schedulingFineShifts"] as! [Any] {
                    var model = UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingFineShifts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingFineShifts = tmp
            }
            if dict.keys.contains("schedulingTemplateFineShifts") && dict["schedulingTemplateFineShifts"] != nil {
                var tmp : [UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts] = []
                for v in dict["schedulingTemplateFineShifts"] as! [Any] {
                    var model = UpdateServiceGroupSchedulingRequest.FineScheduling.SchedulingTemplateFineShifts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schedulingTemplateFineShifts = tmp
            }
            if dict.keys.contains("shiftType") && dict["shiftType"] != nil {
                self.shiftType = dict["shiftType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var fastScheduling: UpdateServiceGroupSchedulingRequest.FastScheduling?

    public var fineScheduling: UpdateServiceGroupSchedulingRequest.FineScheduling?

    public var schedulingWay: String?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fastScheduling?.validate()
        try self.fineScheduling?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.fastScheduling != nil {
            map["fastScheduling"] = self.fastScheduling?.toMap()
        }
        if self.fineScheduling != nil {
            map["fineScheduling"] = self.fineScheduling?.toMap()
        }
        if self.schedulingWay != nil {
            map["schedulingWay"] = self.schedulingWay!
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("fastScheduling") && dict["fastScheduling"] != nil {
            var model = UpdateServiceGroupSchedulingRequest.FastScheduling()
            model.fromMap(dict["fastScheduling"] as! [String: Any])
            self.fastScheduling = model
        }
        if dict.keys.contains("fineScheduling") && dict["fineScheduling"] != nil {
            var model = UpdateServiceGroupSchedulingRequest.FineScheduling()
            model.fromMap(dict["fineScheduling"] as! [String: Any])
            self.fineScheduling = model
        }
        if dict.keys.contains("schedulingWay") && dict["schedulingWay"] != nil {
            self.schedulingWay = dict["schedulingWay"] as! String
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class UpdateServiceGroupSchedulingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateServiceGroupSchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceGroupSchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceGroupSchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceGroupSpecialDaySchedulingRequest : Tea.TeaModel {
    public class SchedulingSpecialDays : Tea.TeaModel {
        public var schedulingEndTime: String?

        public var schedulingObjectType: String?

        public var schedulingOrder: Int32?

        public var schedulingStartTime: String?

        public var schedulingUserId: Int64?

        public var schedulingUserIdList: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedulingEndTime != nil {
                map["schedulingEndTime"] = self.schedulingEndTime!
            }
            if self.schedulingObjectType != nil {
                map["schedulingObjectType"] = self.schedulingObjectType!
            }
            if self.schedulingOrder != nil {
                map["schedulingOrder"] = self.schedulingOrder!
            }
            if self.schedulingStartTime != nil {
                map["schedulingStartTime"] = self.schedulingStartTime!
            }
            if self.schedulingUserId != nil {
                map["schedulingUserId"] = self.schedulingUserId!
            }
            if self.schedulingUserIdList != nil {
                map["schedulingUserIdList"] = self.schedulingUserIdList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("schedulingEndTime") && dict["schedulingEndTime"] != nil {
                self.schedulingEndTime = dict["schedulingEndTime"] as! String
            }
            if dict.keys.contains("schedulingObjectType") && dict["schedulingObjectType"] != nil {
                self.schedulingObjectType = dict["schedulingObjectType"] as! String
            }
            if dict.keys.contains("schedulingOrder") && dict["schedulingOrder"] != nil {
                self.schedulingOrder = dict["schedulingOrder"] as! Int32
            }
            if dict.keys.contains("schedulingStartTime") && dict["schedulingStartTime"] != nil {
                self.schedulingStartTime = dict["schedulingStartTime"] as! String
            }
            if dict.keys.contains("schedulingUserId") && dict["schedulingUserId"] != nil {
                self.schedulingUserId = dict["schedulingUserId"] as! Int64
            }
            if dict.keys.contains("schedulingUserIdList") && dict["schedulingUserIdList"] != nil {
                self.schedulingUserIdList = dict["schedulingUserIdList"] as! [Int64]
            }
        }
    }
    public var clientToken: String?

    public var schedulingDate: String?

    public var schedulingSpecialDays: [UpdateServiceGroupSpecialDaySchedulingRequest.SchedulingSpecialDays]?

    public var serviceGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.schedulingDate != nil {
            map["schedulingDate"] = self.schedulingDate!
        }
        if self.schedulingSpecialDays != nil {
            var tmp : [Any] = []
            for k in self.schedulingSpecialDays! {
                tmp.append(k.toMap())
            }
            map["schedulingSpecialDays"] = tmp
        }
        if self.serviceGroupId != nil {
            map["serviceGroupId"] = self.serviceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("schedulingDate") && dict["schedulingDate"] != nil {
            self.schedulingDate = dict["schedulingDate"] as! String
        }
        if dict.keys.contains("schedulingSpecialDays") && dict["schedulingSpecialDays"] != nil {
            var tmp : [UpdateServiceGroupSpecialDaySchedulingRequest.SchedulingSpecialDays] = []
            for v in dict["schedulingSpecialDays"] as! [Any] {
                var model = UpdateServiceGroupSpecialDaySchedulingRequest.SchedulingSpecialDays()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.schedulingSpecialDays = tmp
        }
        if dict.keys.contains("serviceGroupId") && dict["serviceGroupId"] != nil {
            self.serviceGroupId = dict["serviceGroupId"] as! Int64
        }
    }
}

public class UpdateServiceGroupSpecialDaySchedulingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateServiceGroupSpecialDaySchedulingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceGroupSpecialDaySchedulingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceGroupSpecialDaySchedulingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSubscriptionRequest : Tea.TeaModel {
    public class NotifyObjectList : Tea.TeaModel {
        public var id: Int64?

        public var notifyObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.notifyObjectId != nil {
                map["notifyObjectId"] = self.notifyObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("notifyObjectId") && dict["notifyObjectId"] != nil {
                self.notifyObjectId = dict["notifyObjectId"] as! Int64
            }
        }
    }
    public class NotifyStrategyList : Tea.TeaModel {
        public class Strategies : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var action: String?

                public var effection: String?

                public var level: String?

                public var problemNotifyType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["action"] = self.action!
                    }
                    if self.effection != nil {
                        map["effection"] = self.effection!
                    }
                    if self.level != nil {
                        map["level"] = self.level!
                    }
                    if self.problemNotifyType != nil {
                        map["problemNotifyType"] = self.problemNotifyType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("action") && dict["action"] != nil {
                        self.action = dict["action"] as! String
                    }
                    if dict.keys.contains("effection") && dict["effection"] != nil {
                        self.effection = dict["effection"] as! String
                    }
                    if dict.keys.contains("level") && dict["level"] != nil {
                        self.level = dict["level"] as! String
                    }
                    if dict.keys.contains("problemNotifyType") && dict["problemNotifyType"] != nil {
                        self.problemNotifyType = dict["problemNotifyType"] as! String
                    }
                }
            }
            public class PeriodChannel : Tea.TeaModel {
                public var nonWorkday: String?

                public var workday: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nonWorkday != nil {
                        map["nonWorkday"] = self.nonWorkday!
                    }
                    if self.workday != nil {
                        map["workday"] = self.workday!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("nonWorkday") && dict["nonWorkday"] != nil {
                        self.nonWorkday = dict["nonWorkday"] as! String
                    }
                    if dict.keys.contains("workday") && dict["workday"] != nil {
                        self.workday = dict["workday"] as! String
                    }
                }
            }
            public var channels: String?

            public var conditions: [UpdateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions]?

            public var id: String?

            public var periodChannel: UpdateSubscriptionRequest.NotifyStrategyList.Strategies.PeriodChannel?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.periodChannel?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["channels"] = self.channels!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["conditions"] = tmp
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.periodChannel != nil {
                    map["periodChannel"] = self.periodChannel?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("channels") && dict["channels"] != nil {
                    self.channels = dict["channels"] as! String
                }
                if dict.keys.contains("conditions") && dict["conditions"] != nil {
                    var tmp : [UpdateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions] = []
                    for v in dict["conditions"] as! [Any] {
                        var model = UpdateSubscriptionRequest.NotifyStrategyList.Strategies.Conditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.conditions = tmp
                }
                if dict.keys.contains("id") && dict["id"] != nil {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("periodChannel") && dict["periodChannel"] != nil {
                    var model = UpdateSubscriptionRequest.NotifyStrategyList.Strategies.PeriodChannel()
                    model.fromMap(dict["periodChannel"] as! [String: Any])
                    self.periodChannel = model
                }
            }
        }
        public var instanceType: Int64?

        public var strategies: [UpdateSubscriptionRequest.NotifyStrategyList.Strategies]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["instanceType"] = self.instanceType!
            }
            if self.strategies != nil {
                var tmp : [Any] = []
                for k in self.strategies! {
                    tmp.append(k.toMap())
                }
                map["strategies"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceType") && dict["instanceType"] != nil {
                self.instanceType = dict["instanceType"] as! Int64
            }
            if dict.keys.contains("strategies") && dict["strategies"] != nil {
                var tmp : [UpdateSubscriptionRequest.NotifyStrategyList.Strategies] = []
                for v in dict["strategies"] as! [Any] {
                    var model = UpdateSubscriptionRequest.NotifyStrategyList.Strategies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.strategies = tmp
            }
        }
    }
    public class ScopeObjectList : Tea.TeaModel {
        public var id: Int64?

        public var scopeObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.scopeObjectId != nil {
                map["scopeObjectId"] = self.scopeObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") && dict["id"] != nil {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("scopeObjectId") && dict["scopeObjectId"] != nil {
                self.scopeObjectId = dict["scopeObjectId"] as! Int64
            }
        }
    }
    public var endTime: String?

    public var expiredType: String?

    public var notifyObjectList: [UpdateSubscriptionRequest.NotifyObjectList]?

    public var notifyObjectType: String?

    public var notifyStrategyList: [UpdateSubscriptionRequest.NotifyStrategyList]?

    public var period: String?

    public var scope: String?

    public var scopeObjectList: [UpdateSubscriptionRequest.ScopeObjectList]?

    public var startTime: String?

    public var subscriptionId: Int64?

    public var subscriptionTitle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.expiredType != nil {
            map["expiredType"] = self.expiredType!
        }
        if self.notifyObjectList != nil {
            var tmp : [Any] = []
            for k in self.notifyObjectList! {
                tmp.append(k.toMap())
            }
            map["notifyObjectList"] = tmp
        }
        if self.notifyObjectType != nil {
            map["notifyObjectType"] = self.notifyObjectType!
        }
        if self.notifyStrategyList != nil {
            var tmp : [Any] = []
            for k in self.notifyStrategyList! {
                tmp.append(k.toMap())
            }
            map["notifyStrategyList"] = tmp
        }
        if self.period != nil {
            map["period"] = self.period!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.scopeObjectList != nil {
            var tmp : [Any] = []
            for k in self.scopeObjectList! {
                tmp.append(k.toMap())
            }
            map["scopeObjectList"] = tmp
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.subscriptionId != nil {
            map["subscriptionId"] = self.subscriptionId!
        }
        if self.subscriptionTitle != nil {
            map["subscriptionTitle"] = self.subscriptionTitle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") && dict["endTime"] != nil {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("expiredType") && dict["expiredType"] != nil {
            self.expiredType = dict["expiredType"] as! String
        }
        if dict.keys.contains("notifyObjectList") && dict["notifyObjectList"] != nil {
            var tmp : [UpdateSubscriptionRequest.NotifyObjectList] = []
            for v in dict["notifyObjectList"] as! [Any] {
                var model = UpdateSubscriptionRequest.NotifyObjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notifyObjectList = tmp
        }
        if dict.keys.contains("notifyObjectType") && dict["notifyObjectType"] != nil {
            self.notifyObjectType = dict["notifyObjectType"] as! String
        }
        if dict.keys.contains("notifyStrategyList") && dict["notifyStrategyList"] != nil {
            var tmp : [UpdateSubscriptionRequest.NotifyStrategyList] = []
            for v in dict["notifyStrategyList"] as! [Any] {
                var model = UpdateSubscriptionRequest.NotifyStrategyList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notifyStrategyList = tmp
        }
        if dict.keys.contains("period") && dict["period"] != nil {
            self.period = dict["period"] as! String
        }
        if dict.keys.contains("scope") && dict["scope"] != nil {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("scopeObjectList") && dict["scopeObjectList"] != nil {
            var tmp : [UpdateSubscriptionRequest.ScopeObjectList] = []
            for v in dict["scopeObjectList"] as! [Any] {
                var model = UpdateSubscriptionRequest.ScopeObjectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scopeObjectList = tmp
        }
        if dict.keys.contains("startTime") && dict["startTime"] != nil {
            self.startTime = dict["startTime"] as! String
        }
        if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
            self.subscriptionId = dict["subscriptionId"] as! Int64
        }
        if dict.keys.contains("subscriptionTitle") && dict["subscriptionTitle"] != nil {
            self.subscriptionTitle = dict["subscriptionTitle"] as! String
        }
    }
}

public class UpdateSubscriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserRequest : Tea.TeaModel {
    public var clientToken: String?

    public var email: String?

    public var phone: String?

    public var ramId: Int64?

    public var roleIdList: [Int64]?

    public var userId: Int64?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.email != nil {
            map["email"] = self.email!
        }
        if self.phone != nil {
            map["phone"] = self.phone!
        }
        if self.ramId != nil {
            map["ramId"] = self.ramId!
        }
        if self.roleIdList != nil {
            map["roleIdList"] = self.roleIdList!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        if self.username != nil {
            map["username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("email") && dict["email"] != nil {
            self.email = dict["email"] as! String
        }
        if dict.keys.contains("phone") && dict["phone"] != nil {
            self.phone = dict["phone"] as! String
        }
        if dict.keys.contains("ramId") && dict["ramId"] != nil {
            self.ramId = dict["ramId"] as! Int64
        }
        if dict.keys.contains("roleIdList") && dict["roleIdList"] != nil {
            self.roleIdList = dict["roleIdList"] as! [Int64]
        }
        if dict.keys.contains("userId") && dict["userId"] != nil {
            self.userId = dict["userId"] as! Int64
        }
        if dict.keys.contains("username") && dict["username"] != nil {
            self.username = dict["username"] as! String
        }
    }
}

public class UpdateUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateUserGuideStatusRequest : Tea.TeaModel {
    public var clientToken: String?

    public var guideAction: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.guideAction != nil {
            map["guideAction"] = self.guideAction!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") && dict["clientToken"] != nil {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("guideAction") && dict["guideAction"] != nil {
            self.guideAction = dict["guideAction"] as! String
        }
    }
}

public class UpdateUserGuideStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateUserGuideStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserGuideStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateUserGuideStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyRouteRuleRequest : Tea.TeaModel {
    public class TestSourceEvents : Tea.TeaModel {
        public var eventJson: String?

        public var eventTime: String?

        public var monitorSourceId: Int64?

        public var monitorSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventJson != nil {
                map["eventJson"] = self.eventJson!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.monitorSourceId != nil {
                map["monitorSourceId"] = self.monitorSourceId!
            }
            if self.monitorSourceName != nil {
                map["monitorSourceName"] = self.monitorSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("eventJson") && dict["eventJson"] != nil {
                self.eventJson = dict["eventJson"] as! String
            }
            if dict.keys.contains("eventTime") && dict["eventTime"] != nil {
                self.eventTime = dict["eventTime"] as! String
            }
            if dict.keys.contains("monitorSourceId") && dict["monitorSourceId"] != nil {
                self.monitorSourceId = dict["monitorSourceId"] as! Int64
            }
            if dict.keys.contains("monitorSourceName") && dict["monitorSourceName"] != nil {
                self.monitorSourceName = dict["monitorSourceName"] as! String
            }
        }
    }
    public var routeRuleId: Int64?

    public var testSourceEvents: [VerifyRouteRuleRequest.TestSourceEvents]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeRuleId != nil {
            map["routeRuleId"] = self.routeRuleId!
        }
        if self.testSourceEvents != nil {
            var tmp : [Any] = []
            for k in self.testSourceEvents! {
                tmp.append(k.toMap())
            }
            map["testSourceEvents"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("routeRuleId") && dict["routeRuleId"] != nil {
            self.routeRuleId = dict["routeRuleId"] as! Int64
        }
        if dict.keys.contains("testSourceEvents") && dict["testSourceEvents"] != nil {
            var tmp : [VerifyRouteRuleRequest.TestSourceEvents] = []
            for v in dict["testSourceEvents"] as! [Any] {
                var model = VerifyRouteRuleRequest.TestSourceEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.testSourceEvents = tmp
        }
    }
}

public class VerifyRouteRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EscalationPlans : Tea.TeaModel {
            public var escalationPlanId: Int64?

            public var escalationPlanName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.escalationPlanId != nil {
                    map["escalationPlanId"] = self.escalationPlanId!
                }
                if self.escalationPlanName != nil {
                    map["escalationPlanName"] = self.escalationPlanName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("escalationPlanId") && dict["escalationPlanId"] != nil {
                    self.escalationPlanId = dict["escalationPlanId"] as! Int64
                }
                if dict.keys.contains("escalationPlanName") && dict["escalationPlanName"] != nil {
                    self.escalationPlanName = dict["escalationPlanName"] as! String
                }
            }
        }
        public class NotifySubscriptionNames : Tea.TeaModel {
            public var subscriptionId: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.subscriptionId != nil {
                    map["subscriptionId"] = self.subscriptionId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("subscriptionId") && dict["subscriptionId"] != nil {
                    self.subscriptionId = dict["subscriptionId"] as! Int64
                }
                if dict.keys.contains("title") && dict["title"] != nil {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var escalationPlans: [VerifyRouteRuleResponseBody.Data.EscalationPlans]?

        public var isValidRule: Bool?

        public var monitorSourceIds: [Int64]?

        public var notifySubscriptionNames: [VerifyRouteRuleResponseBody.Data.NotifySubscriptionNames]?

        public var routeRuleFailReason: [String]?

        public var routeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.escalationPlans != nil {
                var tmp : [Any] = []
                for k in self.escalationPlans! {
                    tmp.append(k.toMap())
                }
                map["escalationPlans"] = tmp
            }
            if self.isValidRule != nil {
                map["isValidRule"] = self.isValidRule!
            }
            if self.monitorSourceIds != nil {
                map["monitorSourceIds"] = self.monitorSourceIds!
            }
            if self.notifySubscriptionNames != nil {
                var tmp : [Any] = []
                for k in self.notifySubscriptionNames! {
                    tmp.append(k.toMap())
                }
                map["notifySubscriptionNames"] = tmp
            }
            if self.routeRuleFailReason != nil {
                map["routeRuleFailReason"] = self.routeRuleFailReason!
            }
            if self.routeType != nil {
                map["routeType"] = self.routeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("escalationPlans") && dict["escalationPlans"] != nil {
                var tmp : [VerifyRouteRuleResponseBody.Data.EscalationPlans] = []
                for v in dict["escalationPlans"] as! [Any] {
                    var model = VerifyRouteRuleResponseBody.Data.EscalationPlans()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.escalationPlans = tmp
            }
            if dict.keys.contains("isValidRule") && dict["isValidRule"] != nil {
                self.isValidRule = dict["isValidRule"] as! Bool
            }
            if dict.keys.contains("monitorSourceIds") && dict["monitorSourceIds"] != nil {
                self.monitorSourceIds = dict["monitorSourceIds"] as! [Int64]
            }
            if dict.keys.contains("notifySubscriptionNames") && dict["notifySubscriptionNames"] != nil {
                var tmp : [VerifyRouteRuleResponseBody.Data.NotifySubscriptionNames] = []
                for v in dict["notifySubscriptionNames"] as! [Any] {
                    var model = VerifyRouteRuleResponseBody.Data.NotifySubscriptionNames()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifySubscriptionNames = tmp
            }
            if dict.keys.contains("routeRuleFailReason") && dict["routeRuleFailReason"] != nil {
                self.routeRuleFailReason = dict["routeRuleFailReason"] as! [String]
            }
            if dict.keys.contains("routeType") && dict["routeType"] != nil {
                self.routeType = dict["routeType"] as! String
            }
        }
    }
    public var data: VerifyRouteRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") && dict["data"] != nil {
            var model = VerifyRouteRuleResponseBody.Data()
            model.fromMap(dict["data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("requestId") && dict["requestId"] != nil {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class VerifyRouteRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyRouteRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyRouteRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
