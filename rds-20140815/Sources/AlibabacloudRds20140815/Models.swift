import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AcceptRCInquiredSystemEventRequest : Tea.TeaModel {
    public var eventId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventId"] as? String {
            self.eventId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AcceptRCInquiredSystemEventResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AcceptRCInquiredSystemEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptRCInquiredSystemEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AcceptRCInquiredSystemEventResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ActivateMigrationTargetInstanceRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var forceSwitch: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var switchTimeMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.forceSwitch != nil {
            map["ForceSwitch"] = self.forceSwitch!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.switchTimeMode != nil {
            map["SwitchTimeMode"] = self.switchTimeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["ForceSwitch"] as? String {
            self.forceSwitch = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["SwitchTimeMode"] as? String {
            self.switchTimeMode = value
        }
    }
}

public class ActivateMigrationTargetInstanceResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var sourceIpAddress: String?

    public var sourcePort: Int64?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class ActivateMigrationTargetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateMigrationTargetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActivateMigrationTargetInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddTagsToResourceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var tag: [AddTagsToResourceRequest.Tag]?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AddTagsToResourceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AddTagsToResourceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class AddTagsToResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddTagsToResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagsToResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddTagsToResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateInstancePublicConnectionRequest : Tea.TeaModel {
    public var babelfishPort: String?

    public var connectionStringPrefix: String?

    public var DBInstanceId: String?

    public var generalGroupName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PGBouncerPort: String?

    public var port: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.babelfishPort != nil {
            map["BabelfishPort"] = self.babelfishPort!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.generalGroupName != nil {
            map["GeneralGroupName"] = self.generalGroupName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PGBouncerPort != nil {
            map["PGBouncerPort"] = self.PGBouncerPort!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BabelfishPort"] as? String {
            self.babelfishPort = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["GeneralGroupName"] as? String {
            self.generalGroupName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PGBouncerPort"] as? String {
            self.PGBouncerPort = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class AllocateInstancePublicConnectionResponseBody : Tea.TeaModel {
    public var connectionString: String?

    public var dbInstanceName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.dbInstanceName != nil {
            map["DbInstanceName"] = self.dbInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DbInstanceName"] as? String {
            self.dbInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateInstancePublicConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateInstancePublicConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateInstancePublicConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AllocateReadWriteSplittingConnectionRequest : Tea.TeaModel {
    public var connectionStringPrefix: String?

    public var DBInstanceId: String?

    public var distributionType: String?

    public var maxDelayTime: String?

    public var netType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.distributionType != nil {
            map["DistributionType"] = self.distributionType!
        }
        if self.maxDelayTime != nil {
            map["MaxDelayTime"] = self.maxDelayTime!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DistributionType"] as? String {
            self.distributionType = value
        }
        if let value = dict["MaxDelayTime"] as? String {
            self.maxDelayTime = value
        }
        if let value = dict["NetType"] as? String {
            self.netType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Weight"] as? String {
            self.weight = value
        }
    }
}

public class AllocateReadWriteSplittingConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateReadWriteSplittingConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateReadWriteSplittingConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateReadWriteSplittingConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateEipAddressWithRCInstanceRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AssociateEipAddressWithRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AssociateEipAddressWithRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressWithRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateEipAddressWithRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachRCDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: Bool?

    public var diskId: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AttachRCDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachRCDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachRCDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachRCDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachRCInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var keyPair: String?

    public var password: String?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyPair != nil {
            map["KeyPair"] = self.keyPair!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["KeyPair"] as? String {
            self.keyPair = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AttachRCInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var keyPair: String?

    public var password: String?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.keyPair != nil {
            map["KeyPair"] = self.keyPair!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["KeyPair"] as? String {
            self.keyPair = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class AttachRCInstancesResponseBody : Tea.TeaModel {
    public class Responses : Tea.TeaModel {
        public var code: String?

        public var instanceId: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
        }
    }
    public var requestId: String?

    public var responses: [AttachRCInstancesResponseBody.Responses]?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.responses != nil {
            var tmp : [Any] = []
            for k in self.responses! {
                tmp.append(k.toMap())
            }
            map["Responses"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Responses"] as? [Any?] {
            var tmp : [AttachRCInstancesResponseBody.Responses] = []
            for v in value {
                if v != nil {
                    var model = AttachRCInstancesResponseBody.Responses()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.responses = tmp
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class AttachRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachWhitelistTemplateToInstanceRequest : Tea.TeaModel {
    public var insName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insName != nil {
            map["InsName"] = self.insName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InsName"] as? String {
            self.insName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
    }
}

public class AttachWhitelistTemplateToInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: AttachWhitelistTemplateToInstanceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AttachWhitelistTemplateToInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AttachWhitelistTemplateToInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachWhitelistTemplateToInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachWhitelistTemplateToInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeRCSecurityGroupPermissionRequest : Tea.TeaModel {
    public class SecurityGroupPermissions : Tea.TeaModel {
        public var destCidrIp: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: Int32?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public var direction: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupPermissions: [AuthorizeRCSecurityGroupPermissionRequest.SecurityGroupPermissions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupPermissions != nil {
            var tmp : [Any] = []
            for k in self.securityGroupPermissions! {
                tmp.append(k.toMap())
            }
            map["SecurityGroupPermissions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupPermissions"] as? [Any?] {
            var tmp : [AuthorizeRCSecurityGroupPermissionRequest.SecurityGroupPermissions] = []
            for v in value {
                if v != nil {
                    var model = AuthorizeRCSecurityGroupPermissionRequest.SecurityGroupPermissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.securityGroupPermissions = tmp
        }
    }
}

public class AuthorizeRCSecurityGroupPermissionShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupPermissionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupPermissionsShrink != nil {
            map["SecurityGroupPermissions"] = self.securityGroupPermissionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupPermissions"] as? String {
            self.securityGroupPermissionsShrink = value
        }
    }
}

public class AuthorizeRCSecurityGroupPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeRCSecurityGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeRCSecurityGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeRCSecurityGroupPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CalculateDBInstanceWeightRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CalculateDBInstanceWeightResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceWeight : Tea.TeaModel {
            public var DBInstanceId: String?

            public var DBInstanceType: String?

            public var readonlyInstanceSQLDelayedTime: String?

            public var weight: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceType != nil {
                    map["DBInstanceType"] = self.DBInstanceType!
                }
                if self.readonlyInstanceSQLDelayedTime != nil {
                    map["ReadonlyInstanceSQLDelayedTime"] = self.readonlyInstanceSQLDelayedTime!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceType"] as? String {
                    self.DBInstanceType = value
                }
                if let value = dict["ReadonlyInstanceSQLDelayedTime"] as? String {
                    self.readonlyInstanceSQLDelayedTime = value
                }
                if let value = dict["Weight"] as? String {
                    self.weight = value
                }
            }
        }
        public var DBInstanceWeight: [CalculateDBInstanceWeightResponseBody.Items.DBInstanceWeight]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceWeight != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceWeight! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceWeight"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceWeight"] as? [Any?] {
                var tmp : [CalculateDBInstanceWeightResponseBody.Items.DBInstanceWeight] = []
                for v in value {
                    if v != nil {
                        var model = CalculateDBInstanceWeightResponseBody.Items.DBInstanceWeight()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceWeight = tmp
            }
        }
    }
    public var items: CalculateDBInstanceWeightResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = CalculateDBInstanceWeightResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CalculateDBInstanceWeightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CalculateDBInstanceWeightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CalculateDBInstanceWeightResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelActiveOperationTasksRequest : Tea.TeaModel {
    public var ids: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.ids = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class CancelActiveOperationTasksResponseBody : Tea.TeaModel {
    public var ids: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.ids = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelActiveOperationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelActiveOperationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelActiveOperationTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckAccountNameAvailableRequest : Tea.TeaModel {
    public var accountName: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class CheckAccountNameAvailableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CheckAccountNameAvailableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckAccountNameAvailableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckAccountNameAvailableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckCloudResourceAuthorizedRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var targetRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.targetRegionId != nil {
            map["TargetRegionId"] = self.targetRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["TargetRegionId"] as? String {
            self.targetRegionId = value
        }
    }
}

public class CheckCloudResourceAuthorizedResponseBody : Tea.TeaModel {
    public var authorizationState: Int32?

    public var requestId: String?

    public var roleArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizationState != nil {
            map["AuthorizationState"] = self.authorizationState!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthorizationState"] as? Int32 {
            self.authorizationState = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RoleArn"] as? String {
            self.roleArn = value
        }
    }
}

public class CheckCloudResourceAuthorizedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCloudResourceAuthorizedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckCloudResourceAuthorizedResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckCreateDdrDBInstanceRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var DBInstanceClass: String?

    public var DBInstanceStorage: Int32?

    public var engine: String?

    public var engineVersion: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var restoreType: String?

    public var sourceDBInstanceName: String?

    public var sourceRegion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.restoreType != nil {
            map["RestoreType"] = self.restoreType!
        }
        if self.sourceDBInstanceName != nil {
            map["SourceDBInstanceName"] = self.sourceDBInstanceName!
        }
        if self.sourceRegion != nil {
            map["SourceRegion"] = self.sourceRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetId"] as? String {
            self.backupSetId = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["RestoreType"] as? String {
            self.restoreType = value
        }
        if let value = dict["SourceDBInstanceName"] as? String {
            self.sourceDBInstanceName = value
        }
        if let value = dict["SourceRegion"] as? String {
            self.sourceRegion = value
        }
    }
}

public class CheckCreateDdrDBInstanceResponseBody : Tea.TeaModel {
    public var isValid: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isValid != nil {
            map["IsValid"] = self.isValid!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsValid"] as? String {
            self.isValid = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckCreateDdrDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckCreateDdrDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckCreateDdrDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckDBNameAvailableRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CheckDBNameAvailableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckDBNameAvailableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckDBNameAvailableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckDBNameAvailableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckInstanceExistRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CheckInstanceExistResponseBody : Tea.TeaModel {
    public var isExistInstance: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isExistInstance != nil {
            map["IsExistInstance"] = self.isExistInstance!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsExistInstance"] as? Bool {
            self.isExistInstance = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CheckInstanceExistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckInstanceExistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckInstanceExistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckServiceLinkedRoleRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceLinkedRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceLinkedRole != nil {
            map["ServiceLinkedRole"] = self.serviceLinkedRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceLinkedRole"] as? String {
            self.serviceLinkedRole = value
        }
    }
}

public class CheckServiceLinkedRoleResponseBody : Tea.TeaModel {
    public var hasServiceLinkedRole: String?

    public var requestId: String?

    public var requireServiceLinkedRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasServiceLinkedRole != nil {
            map["HasServiceLinkedRole"] = self.hasServiceLinkedRole!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requireServiceLinkedRole != nil {
            map["RequireServiceLinkedRole"] = self.requireServiceLinkedRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HasServiceLinkedRole"] as? String {
            self.hasServiceLinkedRole = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RequireServiceLinkedRole"] as? String {
            self.requireServiceLinkedRole = value
        }
    }
}

public class CheckServiceLinkedRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckServiceLinkedRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckServiceLinkedRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloneDBInstanceRequest : Tea.TeaModel {
    public class ServerlessConfig : Tea.TeaModel {
        public var autoPause: Bool?

        public var maxCapacity: Double?

        public var minCapacity: Double?

        public var switchForce: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPause != nil {
                map["AutoPause"] = self.autoPause!
            }
            if self.maxCapacity != nil {
                map["MaxCapacity"] = self.maxCapacity!
            }
            if self.minCapacity != nil {
                map["MinCapacity"] = self.minCapacity!
            }
            if self.switchForce != nil {
                map["SwitchForce"] = self.switchForce!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoPause"] as? Bool {
                self.autoPause = value
            }
            if let value = dict["MaxCapacity"] as? Double {
                self.maxCapacity = value
            }
            if let value = dict["MinCapacity"] as? Double {
                self.minCapacity = value
            }
            if let value = dict["SwitchForce"] as? Bool {
                self.switchForce = value
            }
        }
    }
    public var autoPay: Bool?

    public var backupId: String?

    public var backupType: String?

    public var bpeEnabled: String?

    public var burstingEnabled: Bool?

    public var category: String?

    public var clientToken: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dbNames: String?

    public var dedicatedHostGroupId: String?

    public var deletionProtection: Bool?

    public var instanceNetworkType: String?

    public var ioAccelerationEnabled: String?

    public var payType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var restoreTable: String?

    public var restoreTime: String?

    public var serverlessConfig: CloneDBInstanceRequest.ServerlessConfig?

    public var tableMeta: String?

    public var usedTime: Int32?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serverlessConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupType != nil {
            map["BackupType"] = self.backupType!
        }
        if self.bpeEnabled != nil {
            map["BpeEnabled"] = self.bpeEnabled!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTable != nil {
            map["RestoreTable"] = self.restoreTable!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.serverlessConfig != nil {
            map["ServerlessConfig"] = self.serverlessConfig?.toMap()
        }
        if self.tableMeta != nil {
            map["TableMeta"] = self.tableMeta!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupType"] as? String {
            self.backupType = value
        }
        if let value = dict["BpeEnabled"] as? String {
            self.bpeEnabled = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTable"] as? String {
            self.restoreTable = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["ServerlessConfig"] as? [String: Any?] {
            var model = CloneDBInstanceRequest.ServerlessConfig()
            model.fromMap(value)
            self.serverlessConfig = model
        }
        if let value = dict["TableMeta"] as? String {
            self.tableMeta = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class CloneDBInstanceShrinkRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var backupId: String?

    public var backupType: String?

    public var bpeEnabled: String?

    public var burstingEnabled: Bool?

    public var category: String?

    public var clientToken: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dbNames: String?

    public var dedicatedHostGroupId: String?

    public var deletionProtection: Bool?

    public var instanceNetworkType: String?

    public var ioAccelerationEnabled: String?

    public var payType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var restoreTable: String?

    public var restoreTime: String?

    public var serverlessConfigShrink: String?

    public var tableMeta: String?

    public var usedTime: Int32?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupType != nil {
            map["BackupType"] = self.backupType!
        }
        if self.bpeEnabled != nil {
            map["BpeEnabled"] = self.bpeEnabled!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTable != nil {
            map["RestoreTable"] = self.restoreTable!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.serverlessConfigShrink != nil {
            map["ServerlessConfig"] = self.serverlessConfigShrink!
        }
        if self.tableMeta != nil {
            map["TableMeta"] = self.tableMeta!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupType"] as? String {
            self.backupType = value
        }
        if let value = dict["BpeEnabled"] as? String {
            self.bpeEnabled = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTable"] as? String {
            self.restoreTable = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["ServerlessConfig"] as? String {
            self.serverlessConfigShrink = value
        }
        if let value = dict["TableMeta"] as? String {
            self.tableMeta = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class CloneDBInstanceResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CloneDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloneDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloneParameterGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var parameterGroupDesc: String?

    public var parameterGroupId: String?

    public var parameterGroupName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupDesc != nil {
            map["ParameterGroupDesc"] = self.parameterGroupDesc!
        }
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.parameterGroupName != nil {
            map["ParameterGroupName"] = self.parameterGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetRegionId != nil {
            map["TargetRegionId"] = self.targetRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupDesc"] as? String {
            self.parameterGroupDesc = value
        }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["ParameterGroupName"] as? String {
            self.parameterGroupName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetRegionId"] as? String {
            self.targetRegionId = value
        }
    }
}

public class CloneParameterGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CloneParameterGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneParameterGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloneParameterGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConfirmNotifyRequest : Tea.TeaModel {
    public var confirmor: Int64?

    public var notifyIdList: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirmor != nil {
            map["Confirmor"] = self.confirmor!
        }
        if self.notifyIdList != nil {
            map["NotifyIdList"] = self.notifyIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Confirmor"] as? Int64 {
            self.confirmor = value
        }
        if let value = dict["NotifyIdList"] as? [Int64] {
            self.notifyIdList = value
        }
    }
}

public class ConfirmNotifyShrinkRequest : Tea.TeaModel {
    public var confirmor: Int64?

    public var notifyIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirmor != nil {
            map["Confirmor"] = self.confirmor!
        }
        if self.notifyIdListShrink != nil {
            map["NotifyIdList"] = self.notifyIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Confirmor"] as? Int64 {
            self.confirmor = value
        }
        if let value = dict["NotifyIdList"] as? String {
            self.notifyIdListShrink = value
        }
    }
}

public class ConfirmNotifyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ConfirmNotifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmNotifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConfirmNotifyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyDatabaseRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var dstDBName: String?

    public var ownerId: Int64?

    public var reserveAccount: Int32?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var srcDBName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.dstDBName != nil {
            map["DstDBName"] = self.dstDBName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.reserveAccount != nil {
            map["ReserveAccount"] = self.reserveAccount!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.srcDBName != nil {
            map["SrcDBName"] = self.srcDBName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DstDBName"] as? String {
            self.dstDBName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReserveAccount"] as? Int32 {
            self.reserveAccount = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SrcDBName"] as? String {
            self.srcDBName = value
        }
    }
}

public class CopyDatabaseResponseBody : Tea.TeaModel {
    public var DBName: String?

    public var DBStatus: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.DBStatus != nil {
            map["DBStatus"] = self.DBStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DBStatus"] as? String {
            self.DBStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CopyDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyDatabaseBetweenInstancesRequest : Tea.TeaModel {
    public var backupId: String?

    public var DBInstanceId: String?

    public var dbNames: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var syncUserPrivilege: String?

    public var targetDBInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.syncUserPrivilege != nil {
            map["SyncUserPrivilege"] = self.syncUserPrivilege!
        }
        if self.targetDBInstanceId != nil {
            map["TargetDBInstanceId"] = self.targetDBInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["SyncUserPrivilege"] as? String {
            self.syncUserPrivilege = value
        }
        if let value = dict["TargetDBInstanceId"] as? String {
            self.targetDBInstanceId = value
        }
    }
}

public class CopyDatabaseBetweenInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyDatabaseBetweenInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyDatabaseBetweenInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyDatabaseBetweenInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAccountRequest : Tea.TeaModel {
    public var accountDescription: String?

    public var accountName: String?

    public var accountPassword: String?

    public var accountType: String?

    public var checkPolicy: Bool?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountDescription != nil {
            map["AccountDescription"] = self.accountDescription!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.checkPolicy != nil {
            map["CheckPolicy"] = self.checkPolicy!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountDescription"] as? String {
            self.accountDescription = value
        }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["AccountType"] as? String {
            self.accountType = value
        }
        if let value = dict["CheckPolicy"] as? Bool {
            self.checkPolicy = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateBackupRequest : Tea.TeaModel {
    public var backupMethod: String?

    public var backupStrategy: String?

    public var backupType: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupMethod != nil {
            map["BackupMethod"] = self.backupMethod!
        }
        if self.backupStrategy != nil {
            map["BackupStrategy"] = self.backupStrategy!
        }
        if self.backupType != nil {
            map["BackupType"] = self.backupType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupMethod"] as? String {
            self.backupMethod = value
        }
        if let value = dict["BackupStrategy"] as? String {
            self.backupStrategy = value
        }
        if let value = dict["BackupType"] as? String {
            self.backupType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateBackupResponseBody : Tea.TeaModel {
    public var backupJobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupJobId != nil {
            map["BackupJobId"] = self.backupJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupJobId"] as? String {
            self.backupJobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateBackupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBackupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudMigrationPrecheckTaskRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var resourceOwnerId: Int64?

    public var sourceAccount: String?

    public var sourceCategory: String?

    public var sourceIpAddress: String?

    public var sourcePassword: String?

    public var sourcePort: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceAccount != nil {
            map["SourceAccount"] = self.sourceAccount!
        }
        if self.sourceCategory != nil {
            map["SourceCategory"] = self.sourceCategory!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        if self.sourcePassword != nil {
            map["SourcePassword"] = self.sourcePassword!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceAccount"] as? String {
            self.sourceAccount = value
        }
        if let value = dict["SourceCategory"] as? String {
            self.sourceCategory = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
        if let value = dict["SourcePassword"] as? String {
            self.sourcePassword = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateCloudMigrationPrecheckTaskResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateCloudMigrationPrecheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudMigrationPrecheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudMigrationPrecheckTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCloudMigrationTaskRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var resourceOwnerId: Int64?

    public var sourceAccount: String?

    public var sourceCategory: String?

    public var sourceIpAddress: String?

    public var sourcePassword: String?

    public var sourcePort: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceAccount != nil {
            map["SourceAccount"] = self.sourceAccount!
        }
        if self.sourceCategory != nil {
            map["SourceCategory"] = self.sourceCategory!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        if self.sourcePassword != nil {
            map["SourcePassword"] = self.sourcePassword!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceAccount"] as? String {
            self.sourceAccount = value
        }
        if let value = dict["SourceCategory"] as? String {
            self.sourceCategory = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
        if let value = dict["SourcePassword"] as? String {
            self.sourcePassword = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateCloudMigrationTaskResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateCloudMigrationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudMigrationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCloudMigrationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBInstanceRequest : Tea.TeaModel {
    public class ServerlessConfig : Tea.TeaModel {
        public var autoPause: Bool?

        public var maxCapacity: Double?

        public var minCapacity: Double?

        public var switchForce: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPause != nil {
                map["AutoPause"] = self.autoPause!
            }
            if self.maxCapacity != nil {
                map["MaxCapacity"] = self.maxCapacity!
            }
            if self.minCapacity != nil {
                map["MinCapacity"] = self.minCapacity!
            }
            if self.switchForce != nil {
                map["SwitchForce"] = self.switchForce!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoPause"] as? Bool {
                self.autoPause = value
            }
            if let value = dict["MaxCapacity"] as? Double {
                self.maxCapacity = value
            }
            if let value = dict["MinCapacity"] as? Double {
                self.minCapacity = value
            }
            if let value = dict["SwitchForce"] as? Bool {
                self.switchForce = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoCreateProxy: Bool?

    public var autoPay: Bool?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var babelfishConfig: String?

    public var bpeEnabled: String?

    public var burstingEnabled: Bool?

    public var businessInfo: String?

    public var category: String?

    public var clientToken: String?

    public var coldDataEnabled: Bool?

    public var connectionMode: String?

    public var connectionString: String?

    public var createStrategy: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceNetType: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var DBIsIgnoreCase: String?

    public var DBParamGroupId: String?

    public var DBTimeZone: String?

    public var dedicatedHostGroupId: String?

    public var deletionProtection: Bool?

    public var dryRun: Bool?

    public var encryptionKey: String?

    public var engine: String?

    public var engineVersion: String?

    public var instanceNetworkType: String?

    public var ioAccelerationEnabled: String?

    public var optimizedWrites: String?

    public var payType: String?

    public var period: String?

    public var port: String?

    public var privateIpAddress: String?

    public var promotionCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var roleARN: String?

    public var securityIPList: String?

    public var serverlessConfig: CreateDBInstanceRequest.ServerlessConfig?

    public var storageAutoScale: String?

    public var storageThreshold: Int32?

    public var storageUpperBound: Int32?

    public var systemDBCharset: String?

    public var tag: [CreateDBInstanceRequest.Tag]?

    public var targetDedicatedHostIdForLog: String?

    public var targetDedicatedHostIdForMaster: String?

    public var targetDedicatedHostIdForSlave: String?

    public var targetMinorVersion: String?

    public var usedTime: String?

    public var userBackupId: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var whitelistTemplateList: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serverlessConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoCreateProxy != nil {
            map["AutoCreateProxy"] = self.autoCreateProxy!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.babelfishConfig != nil {
            map["BabelfishConfig"] = self.babelfishConfig!
        }
        if self.bpeEnabled != nil {
            map["BpeEnabled"] = self.bpeEnabled!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coldDataEnabled != nil {
            map["ColdDataEnabled"] = self.coldDataEnabled!
        }
        if self.connectionMode != nil {
            map["ConnectionMode"] = self.connectionMode!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.createStrategy != nil {
            map["CreateStrategy"] = self.createStrategy!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceNetType != nil {
            map["DBInstanceNetType"] = self.DBInstanceNetType!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBIsIgnoreCase != nil {
            map["DBIsIgnoreCase"] = self.DBIsIgnoreCase!
        }
        if self.DBParamGroupId != nil {
            map["DBParamGroupId"] = self.DBParamGroupId!
        }
        if self.DBTimeZone != nil {
            map["DBTimeZone"] = self.DBTimeZone!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.optimizedWrites != nil {
            map["OptimizedWrites"] = self.optimizedWrites!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleARN != nil {
            map["RoleARN"] = self.roleARN!
        }
        if self.securityIPList != nil {
            map["SecurityIPList"] = self.securityIPList!
        }
        if self.serverlessConfig != nil {
            map["ServerlessConfig"] = self.serverlessConfig?.toMap()
        }
        if self.storageAutoScale != nil {
            map["StorageAutoScale"] = self.storageAutoScale!
        }
        if self.storageThreshold != nil {
            map["StorageThreshold"] = self.storageThreshold!
        }
        if self.storageUpperBound != nil {
            map["StorageUpperBound"] = self.storageUpperBound!
        }
        if self.systemDBCharset != nil {
            map["SystemDBCharset"] = self.systemDBCharset!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetDedicatedHostIdForLog != nil {
            map["TargetDedicatedHostIdForLog"] = self.targetDedicatedHostIdForLog!
        }
        if self.targetDedicatedHostIdForMaster != nil {
            map["TargetDedicatedHostIdForMaster"] = self.targetDedicatedHostIdForMaster!
        }
        if self.targetDedicatedHostIdForSlave != nil {
            map["TargetDedicatedHostIdForSlave"] = self.targetDedicatedHostIdForSlave!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.userBackupId != nil {
            map["UserBackupId"] = self.userBackupId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.whitelistTemplateList != nil {
            map["WhitelistTemplateList"] = self.whitelistTemplateList!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoCreateProxy"] as? Bool {
            self.autoCreateProxy = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BabelfishConfig"] as? String {
            self.babelfishConfig = value
        }
        if let value = dict["BpeEnabled"] as? String {
            self.bpeEnabled = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ColdDataEnabled"] as? Bool {
            self.coldDataEnabled = value
        }
        if let value = dict["ConnectionMode"] as? String {
            self.connectionMode = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["CreateStrategy"] as? String {
            self.createStrategy = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceNetType"] as? String {
            self.DBInstanceNetType = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBIsIgnoreCase"] as? String {
            self.DBIsIgnoreCase = value
        }
        if let value = dict["DBParamGroupId"] as? String {
            self.DBParamGroupId = value
        }
        if let value = dict["DBTimeZone"] as? String {
            self.DBTimeZone = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["OptimizedWrites"] as? String {
            self.optimizedWrites = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleARN"] as? String {
            self.roleARN = value
        }
        if let value = dict["SecurityIPList"] as? String {
            self.securityIPList = value
        }
        if let value = dict["ServerlessConfig"] as? [String: Any?] {
            var model = CreateDBInstanceRequest.ServerlessConfig()
            model.fromMap(value)
            self.serverlessConfig = model
        }
        if let value = dict["StorageAutoScale"] as? String {
            self.storageAutoScale = value
        }
        if let value = dict["StorageThreshold"] as? Int32 {
            self.storageThreshold = value
        }
        if let value = dict["StorageUpperBound"] as? Int32 {
            self.storageUpperBound = value
        }
        if let value = dict["SystemDBCharset"] as? String {
            self.systemDBCharset = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDBInstanceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDBInstanceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TargetDedicatedHostIdForLog"] as? String {
            self.targetDedicatedHostIdForLog = value
        }
        if let value = dict["TargetDedicatedHostIdForMaster"] as? String {
            self.targetDedicatedHostIdForMaster = value
        }
        if let value = dict["TargetDedicatedHostIdForSlave"] as? String {
            self.targetDedicatedHostIdForSlave = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["UserBackupId"] as? String {
            self.userBackupId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["WhitelistTemplateList"] as? String {
            self.whitelistTemplateList = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class CreateDBInstanceShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoCreateProxy: Bool?

    public var autoPay: Bool?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var babelfishConfig: String?

    public var bpeEnabled: String?

    public var burstingEnabled: Bool?

    public var businessInfo: String?

    public var category: String?

    public var clientToken: String?

    public var coldDataEnabled: Bool?

    public var connectionMode: String?

    public var connectionString: String?

    public var createStrategy: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceNetType: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var DBIsIgnoreCase: String?

    public var DBParamGroupId: String?

    public var DBTimeZone: String?

    public var dedicatedHostGroupId: String?

    public var deletionProtection: Bool?

    public var dryRun: Bool?

    public var encryptionKey: String?

    public var engine: String?

    public var engineVersion: String?

    public var instanceNetworkType: String?

    public var ioAccelerationEnabled: String?

    public var optimizedWrites: String?

    public var payType: String?

    public var period: String?

    public var port: String?

    public var privateIpAddress: String?

    public var promotionCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var roleARN: String?

    public var securityIPList: String?

    public var serverlessConfigShrink: String?

    public var storageAutoScale: String?

    public var storageThreshold: Int32?

    public var storageUpperBound: Int32?

    public var systemDBCharset: String?

    public var tag: [CreateDBInstanceShrinkRequest.Tag]?

    public var targetDedicatedHostIdForLog: String?

    public var targetDedicatedHostIdForMaster: String?

    public var targetDedicatedHostIdForSlave: String?

    public var targetMinorVersion: String?

    public var usedTime: String?

    public var userBackupId: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var whitelistTemplateList: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoCreateProxy != nil {
            map["AutoCreateProxy"] = self.autoCreateProxy!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.babelfishConfig != nil {
            map["BabelfishConfig"] = self.babelfishConfig!
        }
        if self.bpeEnabled != nil {
            map["BpeEnabled"] = self.bpeEnabled!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.coldDataEnabled != nil {
            map["ColdDataEnabled"] = self.coldDataEnabled!
        }
        if self.connectionMode != nil {
            map["ConnectionMode"] = self.connectionMode!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.createStrategy != nil {
            map["CreateStrategy"] = self.createStrategy!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceNetType != nil {
            map["DBInstanceNetType"] = self.DBInstanceNetType!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBIsIgnoreCase != nil {
            map["DBIsIgnoreCase"] = self.DBIsIgnoreCase!
        }
        if self.DBParamGroupId != nil {
            map["DBParamGroupId"] = self.DBParamGroupId!
        }
        if self.DBTimeZone != nil {
            map["DBTimeZone"] = self.DBTimeZone!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.optimizedWrites != nil {
            map["OptimizedWrites"] = self.optimizedWrites!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleARN != nil {
            map["RoleARN"] = self.roleARN!
        }
        if self.securityIPList != nil {
            map["SecurityIPList"] = self.securityIPList!
        }
        if self.serverlessConfigShrink != nil {
            map["ServerlessConfig"] = self.serverlessConfigShrink!
        }
        if self.storageAutoScale != nil {
            map["StorageAutoScale"] = self.storageAutoScale!
        }
        if self.storageThreshold != nil {
            map["StorageThreshold"] = self.storageThreshold!
        }
        if self.storageUpperBound != nil {
            map["StorageUpperBound"] = self.storageUpperBound!
        }
        if self.systemDBCharset != nil {
            map["SystemDBCharset"] = self.systemDBCharset!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetDedicatedHostIdForLog != nil {
            map["TargetDedicatedHostIdForLog"] = self.targetDedicatedHostIdForLog!
        }
        if self.targetDedicatedHostIdForMaster != nil {
            map["TargetDedicatedHostIdForMaster"] = self.targetDedicatedHostIdForMaster!
        }
        if self.targetDedicatedHostIdForSlave != nil {
            map["TargetDedicatedHostIdForSlave"] = self.targetDedicatedHostIdForSlave!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.userBackupId != nil {
            map["UserBackupId"] = self.userBackupId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.whitelistTemplateList != nil {
            map["WhitelistTemplateList"] = self.whitelistTemplateList!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoCreateProxy"] as? Bool {
            self.autoCreateProxy = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BabelfishConfig"] as? String {
            self.babelfishConfig = value
        }
        if let value = dict["BpeEnabled"] as? String {
            self.bpeEnabled = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ColdDataEnabled"] as? Bool {
            self.coldDataEnabled = value
        }
        if let value = dict["ConnectionMode"] as? String {
            self.connectionMode = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["CreateStrategy"] as? String {
            self.createStrategy = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceNetType"] as? String {
            self.DBInstanceNetType = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBIsIgnoreCase"] as? String {
            self.DBIsIgnoreCase = value
        }
        if let value = dict["DBParamGroupId"] as? String {
            self.DBParamGroupId = value
        }
        if let value = dict["DBTimeZone"] as? String {
            self.DBTimeZone = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["OptimizedWrites"] as? String {
            self.optimizedWrites = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleARN"] as? String {
            self.roleARN = value
        }
        if let value = dict["SecurityIPList"] as? String {
            self.securityIPList = value
        }
        if let value = dict["ServerlessConfig"] as? String {
            self.serverlessConfigShrink = value
        }
        if let value = dict["StorageAutoScale"] as? String {
            self.storageAutoScale = value
        }
        if let value = dict["StorageThreshold"] as? Int32 {
            self.storageThreshold = value
        }
        if let value = dict["StorageUpperBound"] as? Int32 {
            self.storageUpperBound = value
        }
        if let value = dict["SystemDBCharset"] as? String {
            self.systemDBCharset = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDBInstanceShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDBInstanceShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TargetDedicatedHostIdForLog"] as? String {
            self.targetDedicatedHostIdForLog = value
        }
        if let value = dict["TargetDedicatedHostIdForMaster"] as? String {
            self.targetDedicatedHostIdForMaster = value
        }
        if let value = dict["TargetDedicatedHostIdForSlave"] as? String {
            self.targetDedicatedHostIdForSlave = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["UserBackupId"] as? String {
            self.userBackupId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["WhitelistTemplateList"] as? String {
            self.whitelistTemplateList = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class CreateDBInstanceResponseBody : Tea.TeaModel {
    public var connectionString: String?

    public var DBInstanceId: String?

    public var dryRun: Bool?

    public var dryRunResult: Bool?

    public var message: String?

    public var orderId: String?

    public var port: String?

    public var requestId: String?

    public var tagResult: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.dryRunResult != nil {
            map["DryRunResult"] = self.dryRunResult!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResult != nil {
            map["TagResult"] = self.tagResult!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["DryRunResult"] as? Bool {
            self.dryRunResult = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResult"] as? Bool {
            self.tagResult = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CreateDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBInstanceEndpointRequest : Tea.TeaModel {
    public class NodeItems : Tea.TeaModel {
        public var DBInstanceId: String?

        public var nodeId: String?

        public var weight: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceId != nil {
                map["DBInstanceId"] = self.DBInstanceId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceId"] as? String {
                self.DBInstanceId = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["Weight"] as? Int64 {
                self.weight = value
            }
        }
    }
    public var clientToken: String?

    public var connectionStringPrefix: String?

    public var DBInstanceEndpointDescription: String?

    public var DBInstanceEndpointType: String?

    public var DBInstanceId: String?

    public var nodeItems: [CreateDBInstanceEndpointRequest.NodeItems]?

    public var port: String?

    public var privateIpAddress: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceEndpointDescription != nil {
            map["DBInstanceEndpointDescription"] = self.DBInstanceEndpointDescription!
        }
        if self.DBInstanceEndpointType != nil {
            map["DBInstanceEndpointType"] = self.DBInstanceEndpointType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeItems != nil {
            var tmp : [Any] = []
            for k in self.nodeItems! {
                tmp.append(k.toMap())
            }
            map["NodeItems"] = tmp
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceEndpointDescription"] as? String {
            self.DBInstanceEndpointDescription = value
        }
        if let value = dict["DBInstanceEndpointType"] as? String {
            self.DBInstanceEndpointType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeItems"] as? [Any?] {
            var tmp : [CreateDBInstanceEndpointRequest.NodeItems] = []
            for v in value {
                if v != nil {
                    var model = CreateDBInstanceEndpointRequest.NodeItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nodeItems = tmp
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateDBInstanceEndpointShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionStringPrefix: String?

    public var DBInstanceEndpointDescription: String?

    public var DBInstanceEndpointType: String?

    public var DBInstanceId: String?

    public var nodeItemsShrink: String?

    public var port: String?

    public var privateIpAddress: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceEndpointDescription != nil {
            map["DBInstanceEndpointDescription"] = self.DBInstanceEndpointDescription!
        }
        if self.DBInstanceEndpointType != nil {
            map["DBInstanceEndpointType"] = self.DBInstanceEndpointType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeItemsShrink != nil {
            map["NodeItems"] = self.nodeItemsShrink!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceEndpointDescription"] as? String {
            self.DBInstanceEndpointDescription = value
        }
        if let value = dict["DBInstanceEndpointType"] as? String {
            self.DBInstanceEndpointType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeItems"] as? String {
            self.nodeItemsShrink = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class CreateDBInstanceEndpointResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var connectionString: String?

        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionString != nil {
                map["ConnectionString"] = self.connectionString!
            }
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectionString"] as? String {
                self.connectionString = value
            }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: CreateDBInstanceEndpointResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateDBInstanceEndpointResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBInstanceEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBInstanceEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBInstanceEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBInstanceEndpointAddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionStringPrefix: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var ipType: String?

    public var port: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["IpType"] as? String {
            self.ipType = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateDBInstanceEndpointAddressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var connectionString: String?

        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionString != nil {
                map["ConnectionString"] = self.connectionString!
            }
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectionString"] as? String {
                self.connectionString = value
            }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: CreateDBInstanceEndpointAddressResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateDBInstanceEndpointAddressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBInstanceEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBInstanceEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBInstanceEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBInstanceForRebuildRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var DBInstanceNetType: String?

    public var instanceNetworkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var period: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityIPList: String?

    public var securityToken: String?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceNetType != nil {
            map["DBInstanceNetType"] = self.DBInstanceNetType!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityIPList != nil {
            map["SecurityIPList"] = self.securityIPList!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceNetType"] as? String {
            self.DBInstanceNetType = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityIPList"] as? String {
            self.securityIPList = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class CreateDBInstanceForRebuildResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var message: String?

    public var orderId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CreateDBInstanceForRebuildResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBInstanceForRebuildResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBInstanceForRebuildResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBInstanceSecurityGroupRuleRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var description_: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var portRange: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sourceCidrIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
    }
}

public class CreateDBInstanceSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBInstanceSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBInstanceSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBInstanceSecurityGroupRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBNodesRequest : Tea.TeaModel {
    public class DBNode : Tea.TeaModel {
        public var classCode: String?

        public var vswitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classCode != nil {
                map["classCode"] = self.classCode!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["classCode"] as? String {
                self.classCode = value
            }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNode: [CreateDBNodesRequest.DBNode]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNode != nil {
            var tmp : [Any] = []
            for k in self.DBNode! {
                tmp.append(k.toMap())
            }
            map["DBNode"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNode"] as? [Any?] {
            var tmp : [CreateDBNodesRequest.DBNode] = []
            for v in value {
                if v != nil {
                    var model = CreateDBNodesRequest.DBNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBNode = tmp
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateDBNodesShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNodeShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeShrink != nil {
            map["DBNode"] = self.DBNodeShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNode"] as? String {
            self.DBNodeShrink = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateDBNodesResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var nodeIds: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeIds != nil {
            map["NodeIds"] = self.nodeIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeIds"] as? String {
            self.nodeIds = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBProxyEndpointAddressRequest : Tea.TeaModel {
    public var connectionStringPrefix: String?

    public var DBInstanceId: String?

    public var DBProxyConnectStringNetType: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEngineType: String?

    public var DBProxyNewConnectStringPort: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyConnectStringNetType != nil {
            map["DBProxyConnectStringNetType"] = self.DBProxyConnectStringNetType!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyNewConnectStringPort != nil {
            map["DBProxyNewConnectStringPort"] = self.DBProxyNewConnectStringPort!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyConnectStringNetType"] as? String {
            self.DBProxyConnectStringNetType = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyNewConnectStringPort"] as? String {
            self.DBProxyNewConnectStringPort = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class CreateDBProxyEndpointAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBProxyEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBProxyEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBProxyEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDatabaseRequest : Tea.TeaModel {
    public var characterSetName: String?

    public var DBDescription: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.characterSetName != nil {
            map["CharacterSetName"] = self.characterSetName!
        }
        if self.DBDescription != nil {
            map["DBDescription"] = self.DBDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CharacterSetName"] as? String {
            self.characterSetName = value
        }
        if let value = dict["DBDescription"] as? String {
            self.DBDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateDatabaseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDdrInstanceRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var backupSetRegion: String?

    public var clientToken: String?

    public var connectionMode: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceNetType: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var encryptionKey: String?

    public var engine: String?

    public var engineVersion: String?

    public var instanceNetworkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var restoreType: String?

    public var roleARN: String?

    public var securityIPList: String?

    public var sourceDBInstanceName: String?

    public var sourceRegion: String?

    public var systemDBCharset: String?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.backupSetRegion != nil {
            map["BackupSetRegion"] = self.backupSetRegion!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionMode != nil {
            map["ConnectionMode"] = self.connectionMode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceNetType != nil {
            map["DBInstanceNetType"] = self.DBInstanceNetType!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.restoreType != nil {
            map["RestoreType"] = self.restoreType!
        }
        if self.roleARN != nil {
            map["RoleARN"] = self.roleARN!
        }
        if self.securityIPList != nil {
            map["SecurityIPList"] = self.securityIPList!
        }
        if self.sourceDBInstanceName != nil {
            map["SourceDBInstanceName"] = self.sourceDBInstanceName!
        }
        if self.sourceRegion != nil {
            map["SourceRegion"] = self.sourceRegion!
        }
        if self.systemDBCharset != nil {
            map["SystemDBCharset"] = self.systemDBCharset!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetId"] as? String {
            self.backupSetId = value
        }
        if let value = dict["BackupSetRegion"] as? String {
            self.backupSetRegion = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionMode"] as? String {
            self.connectionMode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceNetType"] as? String {
            self.DBInstanceNetType = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["RestoreType"] as? String {
            self.restoreType = value
        }
        if let value = dict["RoleARN"] as? String {
            self.roleARN = value
        }
        if let value = dict["SecurityIPList"] as? String {
            self.securityIPList = value
        }
        if let value = dict["SourceDBInstanceName"] as? String {
            self.sourceDBInstanceName = value
        }
        if let value = dict["SourceRegion"] as? String {
            self.sourceRegion = value
        }
        if let value = dict["SystemDBCharset"] as? String {
            self.systemDBCharset = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateDdrInstanceResponseBody : Tea.TeaModel {
    public var connectionString: String?

    public var DBInstanceId: String?

    public var orderId: String?

    public var port: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDdrInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDdrInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDdrInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateGADInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class UnitNode : Tea.TeaModel {
        public var DBInstanceDescription: String?

        public var DBInstanceStorage: Int64?

        public var DBInstanceStorageType: String?

        public var dbInstanceClass: String?

        public var dtsConflict: String?

        public var dtsInstanceClass: String?

        public var engine: String?

        public var engineVersion: String?

        public var payType: String?

        public var regionID: String?

        public var securityIPList: String?

        public var vSwitchID: String?

        public var vpcID: String?

        public var zoneID: String?

        public var zoneIDSlave1: String?

        public var zoneIDSlave2: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceDescription != nil {
                map["DBInstanceDescription"] = self.DBInstanceDescription!
            }
            if self.DBInstanceStorage != nil {
                map["DBInstanceStorage"] = self.DBInstanceStorage!
            }
            if self.DBInstanceStorageType != nil {
                map["DBInstanceStorageType"] = self.DBInstanceStorageType!
            }
            if self.dbInstanceClass != nil {
                map["DbInstanceClass"] = self.dbInstanceClass!
            }
            if self.dtsConflict != nil {
                map["DtsConflict"] = self.dtsConflict!
            }
            if self.dtsInstanceClass != nil {
                map["DtsInstanceClass"] = self.dtsInstanceClass!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineVersion != nil {
                map["EngineVersion"] = self.engineVersion!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.securityIPList != nil {
                map["SecurityIPList"] = self.securityIPList!
            }
            if self.vSwitchID != nil {
                map["VSwitchID"] = self.vSwitchID!
            }
            if self.vpcID != nil {
                map["VpcID"] = self.vpcID!
            }
            if self.zoneID != nil {
                map["ZoneID"] = self.zoneID!
            }
            if self.zoneIDSlave1 != nil {
                map["ZoneIDSlave1"] = self.zoneIDSlave1!
            }
            if self.zoneIDSlave2 != nil {
                map["ZoneIDSlave2"] = self.zoneIDSlave2!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceDescription"] as? String {
                self.DBInstanceDescription = value
            }
            if let value = dict["DBInstanceStorage"] as? Int64 {
                self.DBInstanceStorage = value
            }
            if let value = dict["DBInstanceStorageType"] as? String {
                self.DBInstanceStorageType = value
            }
            if let value = dict["DbInstanceClass"] as? String {
                self.dbInstanceClass = value
            }
            if let value = dict["DtsConflict"] as? String {
                self.dtsConflict = value
            }
            if let value = dict["DtsInstanceClass"] as? String {
                self.dtsInstanceClass = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineVersion"] as? String {
                self.engineVersion = value
            }
            if let value = dict["PayType"] as? String {
                self.payType = value
            }
            if let value = dict["RegionID"] as? String {
                self.regionID = value
            }
            if let value = dict["SecurityIPList"] as? String {
                self.securityIPList = value
            }
            if let value = dict["VSwitchID"] as? String {
                self.vSwitchID = value
            }
            if let value = dict["VpcID"] as? String {
                self.vpcID = value
            }
            if let value = dict["ZoneID"] as? String {
                self.zoneID = value
            }
            if let value = dict["ZoneIDSlave1"] as? String {
                self.zoneIDSlave1 = value
            }
            if let value = dict["ZoneIDSlave2"] as? String {
                self.zoneIDSlave2 = value
            }
        }
    }
    public var centralDBInstanceId: String?

    public var centralRdsDtsAdminAccount: String?

    public var centralRdsDtsAdminPassword: String?

    public var centralRegionId: String?

    public var DBList: String?

    public var description_: String?

    public var resourceGroupId: String?

    public var tag: [CreateGADInstanceRequest.Tag]?

    public var unitNode: [CreateGADInstanceRequest.UnitNode]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.centralDBInstanceId != nil {
            map["CentralDBInstanceId"] = self.centralDBInstanceId!
        }
        if self.centralRdsDtsAdminAccount != nil {
            map["CentralRdsDtsAdminAccount"] = self.centralRdsDtsAdminAccount!
        }
        if self.centralRdsDtsAdminPassword != nil {
            map["CentralRdsDtsAdminPassword"] = self.centralRdsDtsAdminPassword!
        }
        if self.centralRegionId != nil {
            map["CentralRegionId"] = self.centralRegionId!
        }
        if self.DBList != nil {
            map["DBList"] = self.DBList!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.unitNode != nil {
            var tmp : [Any] = []
            for k in self.unitNode! {
                tmp.append(k.toMap())
            }
            map["UnitNode"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CentralDBInstanceId"] as? String {
            self.centralDBInstanceId = value
        }
        if let value = dict["CentralRdsDtsAdminAccount"] as? String {
            self.centralRdsDtsAdminAccount = value
        }
        if let value = dict["CentralRdsDtsAdminPassword"] as? String {
            self.centralRdsDtsAdminPassword = value
        }
        if let value = dict["CentralRegionId"] as? String {
            self.centralRegionId = value
        }
        if let value = dict["DBList"] as? String {
            self.DBList = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateGADInstanceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateGADInstanceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UnitNode"] as? [Any?] {
            var tmp : [CreateGADInstanceRequest.UnitNode] = []
            for v in value {
                if v != nil {
                    var model = CreateGADInstanceRequest.UnitNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.unitNode = tmp
        }
    }
}

public class CreateGADInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createMemberCount: String?

        public var gadInstanceName: String?

        public var taskID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createMemberCount != nil {
                map["CreateMemberCount"] = self.createMemberCount!
            }
            if self.gadInstanceName != nil {
                map["GadInstanceName"] = self.gadInstanceName!
            }
            if self.taskID != nil {
                map["TaskID"] = self.taskID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateMemberCount"] as? String {
                self.createMemberCount = value
            }
            if let value = dict["GadInstanceName"] as? String {
                self.gadInstanceName = value
            }
            if let value = dict["TaskID"] as? String {
                self.taskID = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateGADInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateGADInstanceResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateGADInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGADInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateGADInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateGadInstanceMemberRequest : Tea.TeaModel {
    public class UnitNode : Tea.TeaModel {
        public var DBInstanceDescription: String?

        public var DBInstanceStorage: Int64?

        public var DBInstanceStorageType: String?

        public var dbInstanceClass: String?

        public var dtsConflict: String?

        public var dtsInstanceClass: String?

        public var engine: String?

        public var engineVersion: String?

        public var regionID: String?

        public var securityIPList: String?

        public var vSwitchID: String?

        public var vpcID: String?

        public var zoneID: String?

        public var zoneIDSlave1: String?

        public var zoneIDSlave2: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceDescription != nil {
                map["DBInstanceDescription"] = self.DBInstanceDescription!
            }
            if self.DBInstanceStorage != nil {
                map["DBInstanceStorage"] = self.DBInstanceStorage!
            }
            if self.DBInstanceStorageType != nil {
                map["DBInstanceStorageType"] = self.DBInstanceStorageType!
            }
            if self.dbInstanceClass != nil {
                map["DbInstanceClass"] = self.dbInstanceClass!
            }
            if self.dtsConflict != nil {
                map["DtsConflict"] = self.dtsConflict!
            }
            if self.dtsInstanceClass != nil {
                map["DtsInstanceClass"] = self.dtsInstanceClass!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineVersion != nil {
                map["EngineVersion"] = self.engineVersion!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.securityIPList != nil {
                map["SecurityIPList"] = self.securityIPList!
            }
            if self.vSwitchID != nil {
                map["VSwitchID"] = self.vSwitchID!
            }
            if self.vpcID != nil {
                map["VpcID"] = self.vpcID!
            }
            if self.zoneID != nil {
                map["ZoneID"] = self.zoneID!
            }
            if self.zoneIDSlave1 != nil {
                map["ZoneIDSlave1"] = self.zoneIDSlave1!
            }
            if self.zoneIDSlave2 != nil {
                map["ZoneIDSlave2"] = self.zoneIDSlave2!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceDescription"] as? String {
                self.DBInstanceDescription = value
            }
            if let value = dict["DBInstanceStorage"] as? Int64 {
                self.DBInstanceStorage = value
            }
            if let value = dict["DBInstanceStorageType"] as? String {
                self.DBInstanceStorageType = value
            }
            if let value = dict["DbInstanceClass"] as? String {
                self.dbInstanceClass = value
            }
            if let value = dict["DtsConflict"] as? String {
                self.dtsConflict = value
            }
            if let value = dict["DtsInstanceClass"] as? String {
                self.dtsInstanceClass = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineVersion"] as? String {
                self.engineVersion = value
            }
            if let value = dict["RegionID"] as? String {
                self.regionID = value
            }
            if let value = dict["SecurityIPList"] as? String {
                self.securityIPList = value
            }
            if let value = dict["VSwitchID"] as? String {
                self.vSwitchID = value
            }
            if let value = dict["VpcID"] as? String {
                self.vpcID = value
            }
            if let value = dict["ZoneID"] as? String {
                self.zoneID = value
            }
            if let value = dict["ZoneIDSlave1"] as? String {
                self.zoneIDSlave1 = value
            }
            if let value = dict["ZoneIDSlave2"] as? String {
                self.zoneIDSlave2 = value
            }
        }
    }
    public var centralDBInstanceId: String?

    public var centralRdsDtsAdminAccount: String?

    public var centralRdsDtsAdminPassword: String?

    public var centralRegionId: String?

    public var DBList: String?

    public var gadInstanceId: String?

    public var unitNode: [CreateGadInstanceMemberRequest.UnitNode]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.centralDBInstanceId != nil {
            map["CentralDBInstanceId"] = self.centralDBInstanceId!
        }
        if self.centralRdsDtsAdminAccount != nil {
            map["CentralRdsDtsAdminAccount"] = self.centralRdsDtsAdminAccount!
        }
        if self.centralRdsDtsAdminPassword != nil {
            map["CentralRdsDtsAdminPassword"] = self.centralRdsDtsAdminPassword!
        }
        if self.centralRegionId != nil {
            map["CentralRegionId"] = self.centralRegionId!
        }
        if self.DBList != nil {
            map["DBList"] = self.DBList!
        }
        if self.gadInstanceId != nil {
            map["GadInstanceId"] = self.gadInstanceId!
        }
        if self.unitNode != nil {
            var tmp : [Any] = []
            for k in self.unitNode! {
                tmp.append(k.toMap())
            }
            map["UnitNode"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CentralDBInstanceId"] as? String {
            self.centralDBInstanceId = value
        }
        if let value = dict["CentralRdsDtsAdminAccount"] as? String {
            self.centralRdsDtsAdminAccount = value
        }
        if let value = dict["CentralRdsDtsAdminPassword"] as? String {
            self.centralRdsDtsAdminPassword = value
        }
        if let value = dict["CentralRegionId"] as? String {
            self.centralRegionId = value
        }
        if let value = dict["DBList"] as? String {
            self.DBList = value
        }
        if let value = dict["GadInstanceId"] as? String {
            self.gadInstanceId = value
        }
        if let value = dict["UnitNode"] as? [Any?] {
            var tmp : [CreateGadInstanceMemberRequest.UnitNode] = []
            for v in value {
                if v != nil {
                    var model = CreateGadInstanceMemberRequest.UnitNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.unitNode = tmp
        }
    }
}

public class CreateGadInstanceMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createCount: String?

        public var gadInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createCount != nil {
                map["CreateCount"] = self.createCount!
            }
            if self.gadInstanceName != nil {
                map["GadInstanceName"] = self.gadInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateCount"] as? String {
                self.createCount = value
            }
            if let value = dict["GadInstanceName"] as? String {
                self.gadInstanceName = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateGadInstanceMemberResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateGadInstanceMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateGadInstanceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGadInstanceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateGadInstanceMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMaskingRulesRequest : Tea.TeaModel {
    public class RuleConfig : Tea.TeaModel {
        public var columns: [String]?

        public var databases: [String]?

        public var tables: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.databases != nil {
                map["Databases"] = self.databases!
            }
            if self.tables != nil {
                map["Tables"] = self.tables!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["Databases"] as? [String] {
                self.databases = value
            }
            if let value = dict["Tables"] as? [String] {
                self.tables = value
            }
        }
    }
    public var DBInstanceName: String?

    public var DBName: String?

    public var defaultAlgo: String?

    public var maskingAlgo: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleConfig: CreateMaskingRulesRequest.RuleConfig?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.defaultAlgo != nil {
            map["DefaultAlgo"] = self.defaultAlgo!
        }
        if self.maskingAlgo != nil {
            map["MaskingAlgo"] = self.maskingAlgo!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleConfig != nil {
            map["RuleConfig"] = self.ruleConfig?.toMap()
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DefaultAlgo"] as? String {
            self.defaultAlgo = value
        }
        if let value = dict["MaskingAlgo"] as? String {
            self.maskingAlgo = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleConfig"] as? [String: Any?] {
            var model = CreateMaskingRulesRequest.RuleConfig()
            model.fromMap(value)
            self.ruleConfig = model
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class CreateMaskingRulesShrinkRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var defaultAlgo: String?

    public var maskingAlgo: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleConfigShrink: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.defaultAlgo != nil {
            map["DefaultAlgo"] = self.defaultAlgo!
        }
        if self.maskingAlgo != nil {
            map["MaskingAlgo"] = self.maskingAlgo!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleConfigShrink != nil {
            map["RuleConfig"] = self.ruleConfigShrink!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DefaultAlgo"] as? String {
            self.defaultAlgo = value
        }
        if let value = dict["MaskingAlgo"] as? String {
            self.maskingAlgo = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleConfig"] as? String {
            self.ruleConfigShrink = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class CreateMaskingRulesResponseBody : Tea.TeaModel {
    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: String] {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class CreateMaskingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMaskingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMaskingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMigrateTaskRequest : Tea.TeaModel {
    public var backupMode: String?

    public var checkDBMode: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var isOnlineDB: String?

    public var migrateTaskId: String?

    public var OSSUrls: String?

    public var ossObjectPositions: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.checkDBMode != nil {
            map["CheckDBMode"] = self.checkDBMode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.isOnlineDB != nil {
            map["IsOnlineDB"] = self.isOnlineDB!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.OSSUrls != nil {
            map["OSSUrls"] = self.OSSUrls!
        }
        if self.ossObjectPositions != nil {
            map["OssObjectPositions"] = self.ossObjectPositions!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["CheckDBMode"] as? String {
            self.checkDBMode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["IsOnlineDB"] as? String {
            self.isOnlineDB = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["OSSUrls"] as? String {
            self.OSSUrls = value
        }
        if let value = dict["OssObjectPositions"] as? String {
            self.ossObjectPositions = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateMigrateTaskResponseBody : Tea.TeaModel {
    public var backupMode: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var migrateTaskId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CreateMigrateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMigrateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMigrateTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOnlineDatabaseTaskRequest : Tea.TeaModel {
    public var checkDBMode: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var migrateTaskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkDBMode != nil {
            map["CheckDBMode"] = self.checkDBMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckDBMode"] as? String {
            self.checkDBMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateOnlineDatabaseTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateOnlineDatabaseTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOnlineDatabaseTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOnlineDatabaseTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOrderForDeleteDBNodesRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var DBNodeId: [String]?

    public var engineVersion: String?

    public var nodeType: String?

    public var ownerId: Int64?

    public var promotionCode: String?

    public var regionId: String?

    public var resource: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeId != nil {
            map["DBNodeId"] = self.DBNodeId!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? [String] {
            self.DBNodeId = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? String {
            self.resource = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateOrderForDeleteDBNodesShrinkRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var DBNodeIdShrink: String?

    public var engineVersion: String?

    public var nodeType: String?

    public var ownerId: Int64?

    public var promotionCode: String?

    public var regionId: String?

    public var resource: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeIdShrink != nil {
            map["DBNodeId"] = self.DBNodeIdShrink!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? String {
            self.DBNodeIdShrink = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? String {
            self.resource = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateOrderForDeleteDBNodesResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateOrderForDeleteDBNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderForDeleteDBNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOrderForDeleteDBNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateParameterGroupRequest : Tea.TeaModel {
    public var engine: String?

    public var engineVersion: String?

    public var ownerId: Int64?

    public var parameterGroupDesc: String?

    public var parameterGroupName: String?

    public var parameters: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupDesc != nil {
            map["ParameterGroupDesc"] = self.parameterGroupDesc!
        }
        if self.parameterGroupName != nil {
            map["ParameterGroupName"] = self.parameterGroupName!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupDesc"] as? String {
            self.parameterGroupDesc = value
        }
        if let value = dict["ParameterGroupName"] as? String {
            self.parameterGroupName = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateParameterGroupResponseBody : Tea.TeaModel {
    public var parameterGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateParameterGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateParameterGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateParameterGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePostgresExtensionsRequest : Tea.TeaModel {
    public var accountName: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNames: String?

    public var extensions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var riskConfirmed: Bool?

    public var sourceDatabase: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNames != nil {
            map["DBNames"] = self.DBNames!
        }
        if self.extensions != nil {
            map["Extensions"] = self.extensions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.riskConfirmed != nil {
            map["RiskConfirmed"] = self.riskConfirmed!
        }
        if self.sourceDatabase != nil {
            map["SourceDatabase"] = self.sourceDatabase!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNames"] as? String {
            self.DBNames = value
        }
        if let value = dict["Extensions"] as? String {
            self.extensions = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RiskConfirmed"] as? Bool {
            self.riskConfirmed = value
        }
        if let value = dict["SourceDatabase"] as? String {
            self.sourceDatabase = value
        }
    }
}

public class CreatePostgresExtensionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePostgresExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePostgresExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePostgresExtensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRCDeploymentSetRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var clientToken: String?

    public var deploymentSetName: String?

    public var description_: String?

    public var groupCount: Int64?

    public var onUnableToRedeployFailedInstance: String?

    public var regionId: String?

    public var strategy: String?

    public var tag: [CreateRCDeploymentSetRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupCount != nil {
            map["GroupCount"] = self.groupCount!
        }
        if self.onUnableToRedeployFailedInstance != nil {
            map["OnUnableToRedeployFailedInstance"] = self.onUnableToRedeployFailedInstance!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DeploymentSetName"] as? String {
            self.deploymentSetName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["GroupCount"] as? Int64 {
            self.groupCount = value
        }
        if let value = dict["OnUnableToRedeployFailedInstance"] as? String {
            self.onUnableToRedeployFailedInstance = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Strategy"] as? String {
            self.strategy = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRCDeploymentSetRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRCDeploymentSetRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateRCDeploymentSetResponseBody : Tea.TeaModel {
    public var deploymentSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateRCDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRCDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRCDeploymentSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRCDiskRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var description_: String?

    public var diskCategory: String?

    public var diskName: String?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var performanceLevel: String?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var size: Int32?

    public var snapshotId: String?

    public var tag: [CreateRCDiskRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskCategory"] as? String {
            self.diskCategory = value
        }
        if let value = dict["DiskName"] as? String {
            self.diskName = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PerformanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Size"] as? Int32 {
            self.size = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRCDiskRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRCDiskRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateRCDiskResponseBody : Tea.TeaModel {
    public var diskId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateRCDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRCDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRCDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRCNodePoolRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var deleteWithInstance: Bool?

        public var encrypted: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var clientToken: String?

    public var clusterId: String?

    public var createMode: String?

    public var dataDisk: [CreateRCNodePoolRequest.DataDisk]?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var nodePoolName: String?

    public var password: String?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotStrategy: String?

    public var supportCase: String?

    public var systemDisk: CreateRCNodePoolRequest.SystemDisk?

    public var tag: [CreateRCNodePoolRequest.Tag]?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createMode != nil {
            map["CreateMode"] = self.createMode!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nodePoolName != nil {
            map["NodePoolName"] = self.nodePoolName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.supportCase != nil {
            map["SupportCase"] = self.supportCase!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CreateMode"] as? String {
            self.createMode = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [CreateRCNodePoolRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = CreateRCNodePoolRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["NodePoolName"] as? String {
            self.nodePoolName = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SupportCase"] as? String {
            self.supportCase = value
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = CreateRCNodePoolRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRCNodePoolRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRCNodePoolRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateRCNodePoolShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var clientToken: String?

    public var clusterId: String?

    public var createMode: String?

    public var dataDiskShrink: String?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var nodePoolName: String?

    public var password: String?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotStrategy: String?

    public var supportCase: String?

    public var systemDiskShrink: String?

    public var tag: [CreateRCNodePoolShrinkRequest.Tag]?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createMode != nil {
            map["CreateMode"] = self.createMode!
        }
        if self.dataDiskShrink != nil {
            map["DataDisk"] = self.dataDiskShrink!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nodePoolName != nil {
            map["NodePoolName"] = self.nodePoolName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.supportCase != nil {
            map["SupportCase"] = self.supportCase!
        }
        if self.systemDiskShrink != nil {
            map["SystemDisk"] = self.systemDiskShrink!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["CreateMode"] as? String {
            self.createMode = value
        }
        if let value = dict["DataDisk"] as? String {
            self.dataDiskShrink = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["NodePoolName"] as? String {
            self.nodePoolName = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SupportCase"] as? String {
            self.supportCase = value
        }
        if let value = dict["SystemDisk"] as? String {
            self.systemDiskShrink = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateRCNodePoolShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateRCNodePoolShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateRCNodePoolResponseBody : Tea.TeaModel {
    public var instanceIdSets: [String]?

    public var nodePoolId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdSets != nil {
            map["InstanceIdSets"] = self.instanceIdSets!
        }
        if self.nodePoolId != nil {
            map["NodePoolId"] = self.nodePoolId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIdSets"] as? [String] {
            self.instanceIdSets = value
        }
        if let value = dict["NodePoolId"] as? String {
            self.nodePoolId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateRCNodePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRCNodePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRCNodePoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRCSnapshotRequest : Tea.TeaModel {
    public var description_: String?

    public var diskId: String?

    public var instantAccess: Bool?

    public var instantAccessRetentionDays: Int32?

    public var regionId: String?

    public var retentionDays: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instantAccess != nil {
            map["InstantAccess"] = self.instantAccess!
        }
        if self.instantAccessRetentionDays != nil {
            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["InstantAccess"] as? Bool {
            self.instantAccess = value
        }
        if let value = dict["InstantAccessRetentionDays"] as? Int32 {
            self.instantAccessRetentionDays = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RetentionDays"] as? Int32 {
            self.retentionDays = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateRCSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class CreateRCSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRCSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRCSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateReadOnlyDBInstanceRequest : Tea.TeaModel {
    public var autoCreateProxy: Bool?

    public var autoPay: Bool?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var bpeEnabled: String?

    public var burstingEnabled: Bool?

    public var category: String?

    public var clientToken: String?

    public var DBInstanceClass: String?

    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dedicatedHostGroupId: String?

    public var deletionProtection: Bool?

    public var engineVersion: String?

    public var gdnInstanceName: String?

    public var instanceNetworkType: String?

    public var instructionSetArch: String?

    public var ioAccelerationEnabled: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var period: String?

    public var port: String?

    public var privateIpAddress: String?

    public var promotionCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetDedicatedHostIdForMaster: String?

    public var tddlBizType: String?

    public var tddlRegionConfig: String?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoCreateProxy != nil {
            map["AutoCreateProxy"] = self.autoCreateProxy!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.bpeEnabled != nil {
            map["BpeEnabled"] = self.bpeEnabled!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.gdnInstanceName != nil {
            map["GdnInstanceName"] = self.gdnInstanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instructionSetArch != nil {
            map["InstructionSetArch"] = self.instructionSetArch!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetDedicatedHostIdForMaster != nil {
            map["TargetDedicatedHostIdForMaster"] = self.targetDedicatedHostIdForMaster!
        }
        if self.tddlBizType != nil {
            map["TddlBizType"] = self.tddlBizType!
        }
        if self.tddlRegionConfig != nil {
            map["TddlRegionConfig"] = self.tddlRegionConfig!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoCreateProxy"] as? Bool {
            self.autoCreateProxy = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BpeEnabled"] as? String {
            self.bpeEnabled = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["GdnInstanceName"] as? String {
            self.gdnInstanceName = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["InstructionSetArch"] as? String {
            self.instructionSetArch = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetDedicatedHostIdForMaster"] as? String {
            self.targetDedicatedHostIdForMaster = value
        }
        if let value = dict["TddlBizType"] as? String {
            self.tddlBizType = value
        }
        if let value = dict["TddlRegionConfig"] as? String {
            self.tddlRegionConfig = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateReadOnlyDBInstanceResponseBody : Tea.TeaModel {
    public var connectionString: String?

    public var DBInstanceId: String?

    public var orderId: String?

    public var port: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateReadOnlyDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReadOnlyDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateReadOnlyDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateReplicationLinkRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var dryRun: Bool?

    public var replicatorAccount: String?

    public var replicatorPassword: String?

    public var sourceAddress: String?

    public var sourceCategory: String?

    public var sourceInstanceName: String?

    public var sourceInstanceRegionId: String?

    public var sourcePort: Int64?

    public var targetAddress: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.replicatorAccount != nil {
            map["ReplicatorAccount"] = self.replicatorAccount!
        }
        if self.replicatorPassword != nil {
            map["ReplicatorPassword"] = self.replicatorPassword!
        }
        if self.sourceAddress != nil {
            map["SourceAddress"] = self.sourceAddress!
        }
        if self.sourceCategory != nil {
            map["SourceCategory"] = self.sourceCategory!
        }
        if self.sourceInstanceName != nil {
            map["SourceInstanceName"] = self.sourceInstanceName!
        }
        if self.sourceInstanceRegionId != nil {
            map["SourceInstanceRegionId"] = self.sourceInstanceRegionId!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.targetAddress != nil {
            map["TargetAddress"] = self.targetAddress!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ReplicatorAccount"] as? String {
            self.replicatorAccount = value
        }
        if let value = dict["ReplicatorPassword"] as? String {
            self.replicatorPassword = value
        }
        if let value = dict["SourceAddress"] as? String {
            self.sourceAddress = value
        }
        if let value = dict["SourceCategory"] as? String {
            self.sourceCategory = value
        }
        if let value = dict["SourceInstanceName"] as? String {
            self.sourceInstanceName = value
        }
        if let value = dict["SourceInstanceRegionId"] as? String {
            self.sourceInstanceRegionId = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TargetAddress"] as? String {
            self.targetAddress = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateReplicationLinkResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateReplicationLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReplicationLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateReplicationLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSecretRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dbInstanceId: String?

    public var dbNames: String?

    public var description_: String?

    public var engine: String?

    public var ownerId: Int64?

    public var password: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secretName: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
    }
}

public class CreateSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var secretArn: String?

    public var secretName: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secretArn != nil {
            map["SecretArn"] = self.secretArn!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecretArn"] as? String {
            self.secretArn = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateServiceLinkedRoleRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serviceLinkedRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceLinkedRole != nil {
            map["ServiceLinkedRole"] = self.serviceLinkedRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServiceLinkedRole"] as? String {
            self.serviceLinkedRole = value
        }
    }
}

public class CreateServiceLinkedRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateServiceLinkedRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceLinkedRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateServiceLinkedRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTempDBInstanceRequest : Tea.TeaModel {
    public var backupId: Int64?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? Int64 {
            self.backupId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
    }
}

public class CreateTempDBInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tempDBInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tempDBInstanceId != nil {
            map["TempDBInstanceId"] = self.tempDBInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TempDBInstanceId"] as? String {
            self.tempDBInstanceId = value
        }
    }
}

public class CreateTempDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTempDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTempDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateYouhuiForOrderRequest : Tea.TeaModel {
    public var activityId: Int64?

    public var ownerId: String?

    public var promotionId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.promotionId != nil {
            map["PromotionId"] = self.promotionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivityId"] as? Int64 {
            self.activityId = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PromotionId"] as? Int64 {
            self.promotionId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class CreateYouhuiForOrderResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var youhuiId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.youhuiId != nil {
            map["YouhuiId"] = self.youhuiId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["YouhuiId"] as? String {
            self.youhuiId = value
        }
    }
}

public class CreateYouhuiForOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateYouhuiForOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateYouhuiForOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteADSettingRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteADSettingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteADSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteADSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteADSettingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBackupRequest : Tea.TeaModel {
    public var backupId: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBackupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBackupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBackupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBackupFileRequest : Tea.TeaModel {
    public var backupId: String?

    public var backupTime: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupTime != nil {
            map["BackupTime"] = self.backupTime!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupTime"] as? String {
            self.backupTime = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBackupFileResponseBody : Tea.TeaModel {
    public class DeletedBaksetIds : Tea.TeaModel {
        public var deletedBaksetIds: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletedBaksetIds != nil {
                map["DeletedBaksetIds"] = self.deletedBaksetIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeletedBaksetIds"] as? [Int32] {
                self.deletedBaksetIds = value
            }
        }
    }
    public var deletedBaksetIds: DeleteBackupFileResponseBody.DeletedBaksetIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deletedBaksetIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deletedBaksetIds != nil {
            map["DeletedBaksetIds"] = self.deletedBaksetIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeletedBaksetIds"] as? [String: Any?] {
            var model = DeleteBackupFileResponseBody.DeletedBaksetIds()
            model.fromMap(value)
            self.deletedBaksetIds = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBackupFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackupFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBackupFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var releasedKeepPolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.releasedKeepPolicy != nil {
            map["ReleasedKeepPolicy"] = self.releasedKeepPolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReleasedKeepPolicy"] as? String {
            self.releasedKeepPolicy = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDBInstanceResponseBody : Tea.TeaModel {
    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBInstanceEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDBInstanceEndpointResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: DeleteDBInstanceEndpointResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteDBInstanceEndpointResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBInstanceEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBInstanceEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBInstanceEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBInstanceEndpointAddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionString: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDBInstanceEndpointAddressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: DeleteDBInstanceEndpointAddressResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteDBInstanceEndpointAddressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBInstanceEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBInstanceEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBInstanceEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBInstanceSecurityGroupRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupRuleIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupRuleIds != nil {
            map["SecurityGroupRuleIds"] = self.securityGroupRuleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupRuleIds"] as? String {
            self.securityGroupRuleIds = value
        }
    }
}

public class DeleteDBInstanceSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBInstanceSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBInstanceSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBInstanceSecurityGroupRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBNodesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNodeId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeId != nil {
            map["DBNodeId"] = self.DBNodeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? [String] {
            self.DBNodeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDBNodesShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNodeIdShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeIdShrink != nil {
            map["DBNodeId"] = self.DBNodeIdShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? String {
            self.DBNodeIdShrink = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDBNodesResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBProxyEndpointAddressRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyConnectStringNetType: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEngineType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyConnectStringNetType != nil {
            map["DBProxyConnectStringNetType"] = self.DBProxyConnectStringNetType!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyConnectStringNetType"] as? String {
            self.DBProxyConnectStringNetType = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteDBProxyEndpointAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBProxyEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBProxyEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBProxyEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDatabaseRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBName: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteDatabaseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGadInstanceRequest : Tea.TeaModel {
    public var gadInstanceName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gadInstanceName != nil {
            map["GadInstanceName"] = self.gadInstanceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GadInstanceName"] as? String {
            self.gadInstanceName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DeleteGadInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGadInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGadInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGadInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMaskingRulesRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class DeleteMaskingRulesResponseBody : Tea.TeaModel {
    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: String] {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeleteMaskingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMaskingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMaskingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteParameterGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var parameterGroupId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteParameterGroupResponseBody : Tea.TeaModel {
    public var parameterGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteParameterGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteParameterGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteParameterGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePostgresExtensionsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNames: String?

    public var extensions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNames != nil {
            map["DBNames"] = self.DBNames!
        }
        if self.extensions != nil {
            map["Extensions"] = self.extensions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNames"] as? String {
            self.DBNames = value
        }
        if let value = dict["Extensions"] as? String {
            self.extensions = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeletePostgresExtensionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePostgresExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePostgresExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePostgresExtensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCClusterNodesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var nodes: [String]?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.nodes != nil {
            map["Nodes"] = self.nodes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["Nodes"] as? [String] {
            self.nodes = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DeleteRCClusterNodesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var nodesShrink: String?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.nodesShrink != nil {
            map["Nodes"] = self.nodesShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["Nodes"] as? String {
            self.nodesShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DeleteRCClusterNodesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DeleteRCClusterNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCClusterNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCClusterNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCDeploymentSetRequest : Tea.TeaModel {
    public var deploymentSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteRCDeploymentSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCDeploymentSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteRCDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCInstanceRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCInstancesRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var force: Bool?

    public var instanceId: [String]?

    public var regionId: String?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? [String] {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TerminateSubscription"] as? Bool {
            self.terminateSubscription = value
        }
    }
}

public class DeleteRCInstancesShrinkRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var force: Bool?

    public var instanceIdShrink: String?

    public var regionId: String?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceIdShrink != nil {
            map["InstanceId"] = self.instanceIdShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceIdShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TerminateSubscription"] as? Bool {
            self.terminateSubscription = value
        }
    }
}

public class DeleteRCInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCNodePoolRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodePoolId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodePoolId != nil {
            map["NodePoolId"] = self.nodePoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["NodePoolId"] as? String {
            self.nodePoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteRCNodePoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCNodePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCNodePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCNodePoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRCSnapshotRequest : Tea.TeaModel {
    public var force: Bool?

    public var regionId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Force"] as? Bool {
            self.force = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SnapshotId"] as? String {
            self.snapshotId = value
        }
    }
}

public class DeleteRCSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRCSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRCSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRCSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteReplicationLinkRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var promoteToMaster: Bool?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.promoteToMaster != nil {
            map["PromoteToMaster"] = self.promoteToMaster!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["PromoteToMaster"] as? Bool {
            self.promoteToMaster = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteReplicationLinkResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class DeleteReplicationLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteReplicationLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteReplicationLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSecretRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dbInstanceId: String?

    public var engine: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secretArn: String?

    public var secretName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secretArn != nil {
            map["SecretArn"] = self.secretArn!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecretArn"] as? String {
            self.secretArn = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
    }
}

public class DeleteSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var secretArn: String?

    public var secretName: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secretArn != nil {
            map["SecretArn"] = self.secretArn!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecretArn"] as? String {
            self.secretArn = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSlotRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var slotName: String?

    public var slotStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.slotName != nil {
            map["SlotName"] = self.slotName!
        }
        if self.slotStatus != nil {
            map["SlotStatus"] = self.slotStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SlotName"] as? String {
            self.slotName = value
        }
        if let value = dict["SlotStatus"] as? String {
            self.slotStatus = value
        }
    }
}

public class DeleteSlotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var slotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slotName != nil {
            map["SlotName"] = self.slotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SlotName"] as? String {
            self.slotName = value
        }
    }
}

public class DeleteSlotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSlotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSlotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteUserBackupFileRequest : Tea.TeaModel {
    public var backupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteUserBackupFileResponseBody : Tea.TeaModel {
    public var backupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteUserBackupFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserBackupFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteUserBackupFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescibeImportsFromDatabaseRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var engine: String?

    public var importId: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.importId != nil {
            map["ImportId"] = self.importId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["ImportId"] as? Int32 {
            self.importId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescibeImportsFromDatabaseResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class ImportResultFromDB : Tea.TeaModel {
            public var importDataStatus: String?

            public var importDataStatusDescription: String?

            public var importDataType: String?

            public var importId: Int32?

            public var incrementalImportingTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.importDataStatus != nil {
                    map["ImportDataStatus"] = self.importDataStatus!
                }
                if self.importDataStatusDescription != nil {
                    map["ImportDataStatusDescription"] = self.importDataStatusDescription!
                }
                if self.importDataType != nil {
                    map["ImportDataType"] = self.importDataType!
                }
                if self.importId != nil {
                    map["ImportId"] = self.importId!
                }
                if self.incrementalImportingTime != nil {
                    map["IncrementalImportingTime"] = self.incrementalImportingTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ImportDataStatus"] as? String {
                    self.importDataStatus = value
                }
                if let value = dict["ImportDataStatusDescription"] as? String {
                    self.importDataStatusDescription = value
                }
                if let value = dict["ImportDataType"] as? String {
                    self.importDataType = value
                }
                if let value = dict["ImportId"] as? Int32 {
                    self.importId = value
                }
                if let value = dict["IncrementalImportingTime"] as? String {
                    self.incrementalImportingTime = value
                }
            }
        }
        public var importResultFromDB: [DescibeImportsFromDatabaseResponseBody.Items.ImportResultFromDB]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.importResultFromDB != nil {
                var tmp : [Any] = []
                for k in self.importResultFromDB! {
                    tmp.append(k.toMap())
                }
                map["ImportResultFromDB"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ImportResultFromDB"] as? [Any?] {
                var tmp : [DescibeImportsFromDatabaseResponseBody.Items.ImportResultFromDB] = []
                for v in value {
                    if v != nil {
                        var model = DescibeImportsFromDatabaseResponseBody.Items.ImportResultFromDB()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.importResultFromDB = tmp
            }
        }
    }
    public var items: DescibeImportsFromDatabaseResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescibeImportsFromDatabaseResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescibeImportsFromDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescibeImportsFromDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescibeImportsFromDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeADInfoRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeADInfoResponseBody : Tea.TeaModel {
    public var ADDNS: String?

    public var ADServerIpAddress: String?

    public var ADStatus: String?

    public var abnormalReason: String?

    public var requestId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ADDNS != nil {
            map["ADDNS"] = self.ADDNS!
        }
        if self.ADServerIpAddress != nil {
            map["ADServerIpAddress"] = self.ADServerIpAddress!
        }
        if self.ADStatus != nil {
            map["ADStatus"] = self.ADStatus!
        }
        if self.abnormalReason != nil {
            map["AbnormalReason"] = self.abnormalReason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ADDNS"] as? String {
            self.ADDNS = value
        }
        if let value = dict["ADServerIpAddress"] as? String {
            self.ADServerIpAddress = value
        }
        if let value = dict["ADStatus"] as? String {
            self.ADStatus = value
        }
        if let value = dict["AbnormalReason"] as? String {
            self.abnormalReason = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class DescribeADInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeADInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeADInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountMaskingPrivilegeRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class DescribeAccountMaskingPrivilegeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class UserPrivilege : Tea.TeaModel {
            public var expireTime: String?

            public var privilege: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.privilege != nil {
                    map["Privilege"] = self.privilege!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["Privilege"] as? String {
                    self.privilege = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
            }
        }
        public var userPrivilege: [DescribeAccountMaskingPrivilegeResponseBody.Data.UserPrivilege]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userPrivilege != nil {
                var tmp : [Any] = []
                for k in self.userPrivilege! {
                    tmp.append(k.toMap())
                }
                map["UserPrivilege"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UserPrivilege"] as? [Any?] {
                var tmp : [DescribeAccountMaskingPrivilegeResponseBody.Data.UserPrivilege] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccountMaskingPrivilegeResponseBody.Data.UserPrivilege()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userPrivilege = tmp
            }
        }
    }
    public var data: DescribeAccountMaskingPrivilegeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAccountMaskingPrivilegeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAccountMaskingPrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountMaskingPrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountMaskingPrivilegeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountsRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBInstanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAccountsResponseBody : Tea.TeaModel {
    public class Accounts : Tea.TeaModel {
        public class DBInstanceAccount : Tea.TeaModel {
            public class DatabasePrivileges : Tea.TeaModel {
                public class DatabasePrivilege : Tea.TeaModel {
                    public var accountPrivilege: String?

                    public var accountPrivilegeDetail: String?

                    public var DBName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.accountPrivilege != nil {
                            map["AccountPrivilege"] = self.accountPrivilege!
                        }
                        if self.accountPrivilegeDetail != nil {
                            map["AccountPrivilegeDetail"] = self.accountPrivilegeDetail!
                        }
                        if self.DBName != nil {
                            map["DBName"] = self.DBName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AccountPrivilege"] as? String {
                            self.accountPrivilege = value
                        }
                        if let value = dict["AccountPrivilegeDetail"] as? String {
                            self.accountPrivilegeDetail = value
                        }
                        if let value = dict["DBName"] as? String {
                            self.DBName = value
                        }
                    }
                }
                public var databasePrivilege: [DescribeAccountsResponseBody.Accounts.DBInstanceAccount.DatabasePrivileges.DatabasePrivilege]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databasePrivilege != nil {
                        var tmp : [Any] = []
                        for k in self.databasePrivilege! {
                            tmp.append(k.toMap())
                        }
                        map["DatabasePrivilege"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DatabasePrivilege"] as? [Any?] {
                        var tmp : [DescribeAccountsResponseBody.Accounts.DBInstanceAccount.DatabasePrivileges.DatabasePrivilege] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAccountsResponseBody.Accounts.DBInstanceAccount.DatabasePrivileges.DatabasePrivilege()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.databasePrivilege = tmp
                    }
                }
            }
            public var accountDescription: String?

            public var accountName: String?

            public var accountStatus: String?

            public var accountType: String?

            public var bypassRLS: String?

            public var checkPolicy: Bool?

            public var createDB: String?

            public var createRole: String?

            public var DBInstanceId: String?

            public var databasePrivileges: DescribeAccountsResponseBody.Accounts.DBInstanceAccount.DatabasePrivileges?

            public var passwordExpireTime: String?

            public var privExceeded: String?

            public var replication: String?

            public var validUntil: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.databasePrivileges?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountDescription != nil {
                    map["AccountDescription"] = self.accountDescription!
                }
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.accountStatus != nil {
                    map["AccountStatus"] = self.accountStatus!
                }
                if self.accountType != nil {
                    map["AccountType"] = self.accountType!
                }
                if self.bypassRLS != nil {
                    map["BypassRLS"] = self.bypassRLS!
                }
                if self.checkPolicy != nil {
                    map["CheckPolicy"] = self.checkPolicy!
                }
                if self.createDB != nil {
                    map["CreateDB"] = self.createDB!
                }
                if self.createRole != nil {
                    map["CreateRole"] = self.createRole!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.databasePrivileges != nil {
                    map["DatabasePrivileges"] = self.databasePrivileges?.toMap()
                }
                if self.passwordExpireTime != nil {
                    map["PasswordExpireTime"] = self.passwordExpireTime!
                }
                if self.privExceeded != nil {
                    map["PrivExceeded"] = self.privExceeded!
                }
                if self.replication != nil {
                    map["Replication"] = self.replication!
                }
                if self.validUntil != nil {
                    map["ValidUntil"] = self.validUntil!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountDescription"] as? String {
                    self.accountDescription = value
                }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["AccountStatus"] as? String {
                    self.accountStatus = value
                }
                if let value = dict["AccountType"] as? String {
                    self.accountType = value
                }
                if let value = dict["BypassRLS"] as? String {
                    self.bypassRLS = value
                }
                if let value = dict["CheckPolicy"] as? Bool {
                    self.checkPolicy = value
                }
                if let value = dict["CreateDB"] as? String {
                    self.createDB = value
                }
                if let value = dict["CreateRole"] as? String {
                    self.createRole = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DatabasePrivileges"] as? [String: Any?] {
                    var model = DescribeAccountsResponseBody.Accounts.DBInstanceAccount.DatabasePrivileges()
                    model.fromMap(value)
                    self.databasePrivileges = model
                }
                if let value = dict["PasswordExpireTime"] as? String {
                    self.passwordExpireTime = value
                }
                if let value = dict["PrivExceeded"] as? String {
                    self.privExceeded = value
                }
                if let value = dict["Replication"] as? String {
                    self.replication = value
                }
                if let value = dict["ValidUntil"] as? String {
                    self.validUntil = value
                }
            }
        }
        public var DBInstanceAccount: [DescribeAccountsResponseBody.Accounts.DBInstanceAccount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceAccount != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceAccount! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceAccount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceAccount"] as? [Any?] {
                var tmp : [DescribeAccountsResponseBody.Accounts.DBInstanceAccount] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccountsResponseBody.Accounts.DBInstanceAccount()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceAccount = tmp
            }
        }
    }
    public var accounts: DescribeAccountsResponseBody.Accounts?

    public var pageNumber: Int32?

    public var requestId: String?

    public var resourceGroupId: String?

    public var systemAdminAccountFirstActivationTime: String?

    public var systemAdminAccountStatus: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accounts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accounts != nil {
            map["Accounts"] = self.accounts?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.systemAdminAccountFirstActivationTime != nil {
            map["SystemAdminAccountFirstActivationTime"] = self.systemAdminAccountFirstActivationTime!
        }
        if self.systemAdminAccountStatus != nil {
            map["SystemAdminAccountStatus"] = self.systemAdminAccountStatus!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Accounts"] as? [String: Any?] {
            var model = DescribeAccountsResponseBody.Accounts()
            model.fromMap(value)
            self.accounts = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SystemAdminAccountFirstActivationTime"] as? String {
            self.systemAdminAccountFirstActivationTime = value
        }
        if let value = dict["SystemAdminAccountStatus"] as? String {
            self.systemAdminAccountStatus = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeAccountsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeActionEventPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeActionEventPolicyResponseBody : Tea.TeaModel {
    public var enableEventLog: String?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableEventLog != nil {
            map["EnableEventLog"] = self.enableEventLog!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableEventLog"] as? String {
            self.enableEventLog = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeActionEventPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeActionEventPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeActionEventPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeActiveOperationTasksRequest : Tea.TeaModel {
    public var allowCancel: Int32?

    public var allowChange: Int32?

    public var changeLevel: String?

    public var dbType: String?

    public var insName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var productId: String?

    public var region: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var status: Int32?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowCancel != nil {
            map["AllowCancel"] = self.allowCancel!
        }
        if self.allowChange != nil {
            map["AllowChange"] = self.allowChange!
        }
        if self.changeLevel != nil {
            map["ChangeLevel"] = self.changeLevel!
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.insName != nil {
            map["InsName"] = self.insName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productId != nil {
            map["ProductId"] = self.productId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllowCancel"] as? Int32 {
            self.allowCancel = value
        }
        if let value = dict["AllowChange"] as? Int32 {
            self.allowChange = value
        }
        if let value = dict["ChangeLevel"] as? String {
            self.changeLevel = value
        }
        if let value = dict["DbType"] as? String {
            self.dbType = value
        }
        if let value = dict["InsName"] as? String {
            self.insName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProductId"] as? String {
            self.productId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class DescribeActiveOperationTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var allowCancel: String?

        public var allowChange: String?

        public var changeLevel: String?

        public var changeLevelEn: String?

        public var changeLevelZh: String?

        public var createdTime: String?

        public var currentAVZ: String?

        public var dbType: String?

        public var dbVersion: String?

        public var deadline: String?

        public var id: Int32?

        public var impact: String?

        public var impactEn: String?

        public var impactZh: String?

        public var insComment: String?

        public var insName: String?

        public var modifiedTime: String?

        public var prepareInterval: String?

        public var region: String?

        public var resultInfo: String?

        public var startTime: String?

        public var status: Int32?

        public var subInsNames: [String]?

        public var switchTime: String?

        public var taskParams: String?

        public var taskType: String?

        public var taskTypeEn: String?

        public var taskTypeZh: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowCancel != nil {
                map["AllowCancel"] = self.allowCancel!
            }
            if self.allowChange != nil {
                map["AllowChange"] = self.allowChange!
            }
            if self.changeLevel != nil {
                map["ChangeLevel"] = self.changeLevel!
            }
            if self.changeLevelEn != nil {
                map["ChangeLevelEn"] = self.changeLevelEn!
            }
            if self.changeLevelZh != nil {
                map["ChangeLevelZh"] = self.changeLevelZh!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.currentAVZ != nil {
                map["CurrentAVZ"] = self.currentAVZ!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.dbVersion != nil {
                map["DbVersion"] = self.dbVersion!
            }
            if self.deadline != nil {
                map["Deadline"] = self.deadline!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.impact != nil {
                map["Impact"] = self.impact!
            }
            if self.impactEn != nil {
                map["ImpactEn"] = self.impactEn!
            }
            if self.impactZh != nil {
                map["ImpactZh"] = self.impactZh!
            }
            if self.insComment != nil {
                map["InsComment"] = self.insComment!
            }
            if self.insName != nil {
                map["InsName"] = self.insName!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.prepareInterval != nil {
                map["PrepareInterval"] = self.prepareInterval!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resultInfo != nil {
                map["ResultInfo"] = self.resultInfo!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subInsNames != nil {
                map["SubInsNames"] = self.subInsNames!
            }
            if self.switchTime != nil {
                map["SwitchTime"] = self.switchTime!
            }
            if self.taskParams != nil {
                map["TaskParams"] = self.taskParams!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.taskTypeEn != nil {
                map["TaskTypeEn"] = self.taskTypeEn!
            }
            if self.taskTypeZh != nil {
                map["TaskTypeZh"] = self.taskTypeZh!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllowCancel"] as? String {
                self.allowCancel = value
            }
            if let value = dict["AllowChange"] as? String {
                self.allowChange = value
            }
            if let value = dict["ChangeLevel"] as? String {
                self.changeLevel = value
            }
            if let value = dict["ChangeLevelEn"] as? String {
                self.changeLevelEn = value
            }
            if let value = dict["ChangeLevelZh"] as? String {
                self.changeLevelZh = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["CurrentAVZ"] as? String {
                self.currentAVZ = value
            }
            if let value = dict["DbType"] as? String {
                self.dbType = value
            }
            if let value = dict["DbVersion"] as? String {
                self.dbVersion = value
            }
            if let value = dict["Deadline"] as? String {
                self.deadline = value
            }
            if let value = dict["Id"] as? Int32 {
                self.id = value
            }
            if let value = dict["Impact"] as? String {
                self.impact = value
            }
            if let value = dict["ImpactEn"] as? String {
                self.impactEn = value
            }
            if let value = dict["ImpactZh"] as? String {
                self.impactZh = value
            }
            if let value = dict["InsComment"] as? String {
                self.insComment = value
            }
            if let value = dict["InsName"] as? String {
                self.insName = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["PrepareInterval"] as? String {
                self.prepareInterval = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResultInfo"] as? String {
                self.resultInfo = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["SubInsNames"] as? [String] {
                self.subInsNames = value
            }
            if let value = dict["SwitchTime"] as? String {
                self.switchTime = value
            }
            if let value = dict["TaskParams"] as? String {
                self.taskParams = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
            if let value = dict["TaskTypeEn"] as? String {
                self.taskTypeEn = value
            }
            if let value = dict["TaskTypeZh"] as? String {
                self.taskTypeZh = value
            }
        }
    }
    public var items: [DescribeActiveOperationTasksResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeActiveOperationTasksResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeActiveOperationTasksResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeActiveOperationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeActiveOperationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeActiveOperationTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAllWhitelistTemplateRequest : Tea.TeaModel {
    public var fuzzySearch: Bool?

    public var maxRecordsPerPage: Int32?

    public var pageNumbers: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fuzzySearch != nil {
            map["FuzzySearch"] = self.fuzzySearch!
        }
        if self.maxRecordsPerPage != nil {
            map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
        }
        if self.pageNumbers != nil {
            map["PageNumbers"] = self.pageNumbers!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FuzzySearch"] as? Bool {
            self.fuzzySearch = value
        }
        if let value = dict["MaxRecordsPerPage"] as? Int32 {
            self.maxRecordsPerPage = value
        }
        if let value = dict["PageNumbers"] as? Int32 {
            self.pageNumbers = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateName"] as? String {
            self.templateName = value
        }
    }
}

public class DescribeAllWhitelistTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Templates : Tea.TeaModel {
            public var id: Int32?

            public var ips: String?

            public var templateId: Int32?

            public var templateName: String?

            public var userId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Ips"] as? String {
                    self.ips = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["UserId"] as? Int32 {
                    self.userId = value
                }
            }
        }
        public var currPageNumbers: Int32?

        public var hasNext: Bool?

        public var hasPrev: Bool?

        public var maxRecordsPerPage: Int32?

        public var templates: [DescribeAllWhitelistTemplateResponseBody.Data.Templates]?

        public var totalPageNumbers: Int32?

        public var totalRecords: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currPageNumbers != nil {
                map["CurrPageNumbers"] = self.currPageNumbers!
            }
            if self.hasNext != nil {
                map["HasNext"] = self.hasNext!
            }
            if self.hasPrev != nil {
                map["HasPrev"] = self.hasPrev!
            }
            if self.maxRecordsPerPage != nil {
                map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
            }
            if self.templates != nil {
                var tmp : [Any] = []
                for k in self.templates! {
                    tmp.append(k.toMap())
                }
                map["Templates"] = tmp
            }
            if self.totalPageNumbers != nil {
                map["TotalPageNumbers"] = self.totalPageNumbers!
            }
            if self.totalRecords != nil {
                map["TotalRecords"] = self.totalRecords!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrPageNumbers"] as? Int32 {
                self.currPageNumbers = value
            }
            if let value = dict["HasNext"] as? Bool {
                self.hasNext = value
            }
            if let value = dict["HasPrev"] as? Bool {
                self.hasPrev = value
            }
            if let value = dict["MaxRecordsPerPage"] as? Int32 {
                self.maxRecordsPerPage = value
            }
            if let value = dict["Templates"] as? [Any?] {
                var tmp : [DescribeAllWhitelistTemplateResponseBody.Data.Templates] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAllWhitelistTemplateResponseBody.Data.Templates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.templates = tmp
            }
            if let value = dict["TotalPageNumbers"] as? Int32 {
                self.totalPageNumbers = value
            }
            if let value = dict["TotalRecords"] as? Int32 {
                self.totalRecords = value
            }
        }
    }
    public var code: String?

    public var data: DescribeAllWhitelistTemplateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAllWhitelistTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeAllWhitelistTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllWhitelistTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAllWhitelistTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAnalyticdbByPrimaryDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAnalyticdbByPrimaryDBInstanceResponseBody : Tea.TeaModel {
    public var analyticDBCount: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyticDBCount != nil {
            map["AnalyticDBCount"] = self.analyticDBCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AnalyticDBCount"] as? Int32 {
            self.analyticDBCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAnalyticdbByPrimaryDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAnalyticdbByPrimaryDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAnalyticdbByPrimaryDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableClassesRequest : Tea.TeaModel {
    public var category: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var DBInstanceStorageType: String?

    public var engine: String?

    public var engineVersion: String?

    public var instanceChargeType: String?

    public var orderType: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeAvailableClassesResponseBody : Tea.TeaModel {
    public class DBInstanceClasses : Tea.TeaModel {
        public class DBInstanceStorageRange : Tea.TeaModel {
            public var maxValue: Int32?

            public var minValue: Int32?

            public var step: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.step != nil {
                    map["Step"] = self.step!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxValue"] as? Int32 {
                    self.maxValue = value
                }
                if let value = dict["MinValue"] as? Int32 {
                    self.minValue = value
                }
                if let value = dict["Step"] as? Int32 {
                    self.step = value
                }
            }
        }
        public var DBInstanceClass: String?

        public var DBInstanceStorageRange: DescribeAvailableClassesResponseBody.DBInstanceClasses.DBInstanceStorageRange?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.DBInstanceStorageRange?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceClass != nil {
                map["DBInstanceClass"] = self.DBInstanceClass!
            }
            if self.DBInstanceStorageRange != nil {
                map["DBInstanceStorageRange"] = self.DBInstanceStorageRange?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceClass"] as? String {
                self.DBInstanceClass = value
            }
            if let value = dict["DBInstanceStorageRange"] as? [String: Any?] {
                var model = DescribeAvailableClassesResponseBody.DBInstanceClasses.DBInstanceStorageRange()
                model.fromMap(value)
                self.DBInstanceStorageRange = model
            }
        }
    }
    public var DBInstanceClasses: [DescribeAvailableClassesResponseBody.DBInstanceClasses]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceClasses != nil {
            var tmp : [Any] = []
            for k in self.DBInstanceClasses! {
                tmp.append(k.toMap())
            }
            map["DBInstanceClasses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceClasses"] as? [Any?] {
            var tmp : [DescribeAvailableClassesResponseBody.DBInstanceClasses] = []
            for v in value {
                if v != nil {
                    var model = DescribeAvailableClassesResponseBody.DBInstanceClasses()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBInstanceClasses = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAvailableClassesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableClassesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableClassesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableCrossRegionRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAvailableCrossRegionResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var region: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                map["Region"] = self.region!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? [String] {
                self.region = value
            }
        }
    }
    public var regions: DescribeAvailableCrossRegionResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeAvailableCrossRegionResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAvailableCrossRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableCrossRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableCrossRegionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableMetricsRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAvailableMetricsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var description_: String?

        public var dimension: String?

        public var groupKey: String?

        public var groupKeyType: String?

        public var method: String?

        public var metricsKey: String?

        public var metricsKeyAlias: String?

        public var sortRule: Int32?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dimension != nil {
                map["Dimension"] = self.dimension!
            }
            if self.groupKey != nil {
                map["GroupKey"] = self.groupKey!
            }
            if self.groupKeyType != nil {
                map["GroupKeyType"] = self.groupKeyType!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.metricsKey != nil {
                map["MetricsKey"] = self.metricsKey!
            }
            if self.metricsKeyAlias != nil {
                map["MetricsKeyAlias"] = self.metricsKeyAlias!
            }
            if self.sortRule != nil {
                map["SortRule"] = self.sortRule!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Dimension"] as? String {
                self.dimension = value
            }
            if let value = dict["GroupKey"] as? String {
                self.groupKey = value
            }
            if let value = dict["GroupKeyType"] as? String {
                self.groupKeyType = value
            }
            if let value = dict["Method"] as? String {
                self.method = value
            }
            if let value = dict["MetricsKey"] as? String {
                self.metricsKey = value
            }
            if let value = dict["MetricsKeyAlias"] as? String {
                self.metricsKeyAlias = value
            }
            if let value = dict["SortRule"] as? Int32 {
                self.sortRule = value
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public var DBInstanceName: String?

    public var items: [DescribeAvailableMetricsResponseBody.Items]?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeAvailableMetricsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeAvailableMetricsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeAvailableMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableRecoveryTimeRequest : Tea.TeaModel {
    public var crossBackupId: Int32?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crossBackupId != nil {
            map["CrossBackupId"] = self.crossBackupId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CrossBackupId"] as? Int32 {
            self.crossBackupId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeAvailableRecoveryTimeResponseBody : Tea.TeaModel {
    public var crossBackupId: Int32?

    public var recoveryBeginTime: String?

    public var recoveryEndTime: String?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crossBackupId != nil {
            map["CrossBackupId"] = self.crossBackupId!
        }
        if self.recoveryBeginTime != nil {
            map["RecoveryBeginTime"] = self.recoveryBeginTime!
        }
        if self.recoveryEndTime != nil {
            map["RecoveryEndTime"] = self.recoveryEndTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CrossBackupId"] as? Int32 {
            self.crossBackupId = value
        }
        if let value = dict["RecoveryBeginTime"] as? String {
            self.recoveryBeginTime = value
        }
        if let value = dict["RecoveryEndTime"] as? String {
            self.recoveryEndTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAvailableRecoveryTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableRecoveryTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableRecoveryTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableZonesRequest : Tea.TeaModel {
    public var category: String?

    public var commodityCode: String?

    public var DBInstanceName: String?

    public var dispenseMode: String?

    public var engine: String?

    public var engineVersion: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.dispenseMode != nil {
            map["DispenseMode"] = self.dispenseMode!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DispenseMode"] as? String {
            self.dispenseMode = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeAvailableZonesResponseBody : Tea.TeaModel {
    public class AvailableZones : Tea.TeaModel {
        public class SupportedEngines : Tea.TeaModel {
            public class SupportedEngineVersions : Tea.TeaModel {
                public class SupportedCategorys : Tea.TeaModel {
                    public class SupportedStorageTypes : Tea.TeaModel {
                        public var storageType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.storageType != nil {
                                map["StorageType"] = self.storageType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["StorageType"] as? String {
                                self.storageType = value
                            }
                        }
                    }
                    public var category: String?

                    public var supportedStorageTypes: [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys.SupportedStorageTypes]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.supportedStorageTypes != nil {
                            var tmp : [Any] = []
                            for k in self.supportedStorageTypes! {
                                tmp.append(k.toMap())
                            }
                            map["SupportedStorageTypes"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Category"] as? String {
                            self.category = value
                        }
                        if let value = dict["SupportedStorageTypes"] as? [Any?] {
                            var tmp : [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys.SupportedStorageTypes] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys.SupportedStorageTypes()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.supportedStorageTypes = tmp
                        }
                    }
                }
                public var supportedCategorys: [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys]?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedCategorys != nil {
                        var tmp : [Any] = []
                        for k in self.supportedCategorys! {
                            tmp.append(k.toMap())
                        }
                        map["SupportedCategorys"] = tmp
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SupportedCategorys"] as? [Any?] {
                        var tmp : [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions.SupportedCategorys()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.supportedCategorys = tmp
                    }
                    if let value = dict["Version"] as? String {
                        self.version = value
                    }
                }
            }
            public var engine: String?

            public var supportedEngineVersions: [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.supportedEngineVersions != nil {
                    var tmp : [Any] = []
                    for k in self.supportedEngineVersions! {
                        tmp.append(k.toMap())
                    }
                    map["SupportedEngineVersions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["SupportedEngineVersions"] as? [Any?] {
                    var tmp : [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines.SupportedEngineVersions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.supportedEngineVersions = tmp
                }
            }
        }
        public var regionId: String?

        public var supportedEngines: [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines]?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.supportedEngines != nil {
                var tmp : [Any] = []
                for k in self.supportedEngines! {
                    tmp.append(k.toMap())
                }
                map["SupportedEngines"] = tmp
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SupportedEngines"] as? [Any?] {
                var tmp : [DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAvailableZonesResponseBody.AvailableZones.SupportedEngines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.supportedEngines = tmp
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var availableZones: [DescribeAvailableZonesResponseBody.AvailableZones]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZones != nil {
            var tmp : [Any] = []
            for k in self.availableZones! {
                tmp.append(k.toMap())
            }
            map["AvailableZones"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableZones"] as? [Any?] {
            var tmp : [DescribeAvailableZonesResponseBody.AvailableZones] = []
            for v in value {
                if v != nil {
                    var model = DescribeAvailableZonesResponseBody.AvailableZones()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.availableZones = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupDatabaseRequest : Tea.TeaModel {
    public var backupId: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeBackupDatabaseResponseBody : Tea.TeaModel {
    public var databaseNames: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseNames != nil {
            map["DatabaseNames"] = self.databaseNames!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DatabaseNames"] as? String {
            self.databaseNames = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeBackupDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupPolicyRequest : Tea.TeaModel {
    public var backupPolicyMode: String?

    public var compressType: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var releasedKeepPolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupPolicyMode != nil {
            map["BackupPolicyMode"] = self.backupPolicyMode!
        }
        if self.compressType != nil {
            map["CompressType"] = self.compressType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.releasedKeepPolicy != nil {
            map["ReleasedKeepPolicy"] = self.releasedKeepPolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupPolicyMode"] as? String {
            self.backupPolicyMode = value
        }
        if let value = dict["CompressType"] as? String {
            self.compressType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReleasedKeepPolicy"] as? String {
            self.releasedKeepPolicy = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeBackupPolicyResponseBody : Tea.TeaModel {
    public var archiveBackupKeepCount: String?

    public var archiveBackupKeepPolicy: String?

    public var archiveBackupRetentionPeriod: String?

    public var backupInterval: String?

    public var backupLog: String?

    public var backupMethod: String?

    public var backupPriority: Int32?

    public var backupRetentionPeriod: Int32?

    public var category: String?

    public var compressType: String?

    public var enableBackupLog: String?

    public var enableIncrementDataBackup: Bool?

    public var enablePitrProtection: Bool?

    public var highSpaceUsageProtection: String?

    public var localLogRetentionHours: Int32?

    public var localLogRetentionSpace: String?

    public var logBackupFrequency: String?

    public var logBackupLocalRetentionNumber: Int32?

    public var logBackupRetentionPeriod: Int32?

    public var pitrRetentionPeriod: Int32?

    public var preferredBackupPeriod: String?

    public var preferredBackupTime: String?

    public var preferredNextBackupTime: String?

    public var releasedKeepPolicy: String?

    public var requestId: String?

    public var supportModifyBackupPriority: Bool?

    public var supportReleasedKeep: Int32?

    public var supportVolumeShadowCopy: Int32?

    public var supportsHighFrequencyBackup: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveBackupKeepCount != nil {
            map["ArchiveBackupKeepCount"] = self.archiveBackupKeepCount!
        }
        if self.archiveBackupKeepPolicy != nil {
            map["ArchiveBackupKeepPolicy"] = self.archiveBackupKeepPolicy!
        }
        if self.archiveBackupRetentionPeriod != nil {
            map["ArchiveBackupRetentionPeriod"] = self.archiveBackupRetentionPeriod!
        }
        if self.backupInterval != nil {
            map["BackupInterval"] = self.backupInterval!
        }
        if self.backupLog != nil {
            map["BackupLog"] = self.backupLog!
        }
        if self.backupMethod != nil {
            map["BackupMethod"] = self.backupMethod!
        }
        if self.backupPriority != nil {
            map["BackupPriority"] = self.backupPriority!
        }
        if self.backupRetentionPeriod != nil {
            map["BackupRetentionPeriod"] = self.backupRetentionPeriod!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.compressType != nil {
            map["CompressType"] = self.compressType!
        }
        if self.enableBackupLog != nil {
            map["EnableBackupLog"] = self.enableBackupLog!
        }
        if self.enableIncrementDataBackup != nil {
            map["EnableIncrementDataBackup"] = self.enableIncrementDataBackup!
        }
        if self.enablePitrProtection != nil {
            map["EnablePitrProtection"] = self.enablePitrProtection!
        }
        if self.highSpaceUsageProtection != nil {
            map["HighSpaceUsageProtection"] = self.highSpaceUsageProtection!
        }
        if self.localLogRetentionHours != nil {
            map["LocalLogRetentionHours"] = self.localLogRetentionHours!
        }
        if self.localLogRetentionSpace != nil {
            map["LocalLogRetentionSpace"] = self.localLogRetentionSpace!
        }
        if self.logBackupFrequency != nil {
            map["LogBackupFrequency"] = self.logBackupFrequency!
        }
        if self.logBackupLocalRetentionNumber != nil {
            map["LogBackupLocalRetentionNumber"] = self.logBackupLocalRetentionNumber!
        }
        if self.logBackupRetentionPeriod != nil {
            map["LogBackupRetentionPeriod"] = self.logBackupRetentionPeriod!
        }
        if self.pitrRetentionPeriod != nil {
            map["PitrRetentionPeriod"] = self.pitrRetentionPeriod!
        }
        if self.preferredBackupPeriod != nil {
            map["PreferredBackupPeriod"] = self.preferredBackupPeriod!
        }
        if self.preferredBackupTime != nil {
            map["PreferredBackupTime"] = self.preferredBackupTime!
        }
        if self.preferredNextBackupTime != nil {
            map["PreferredNextBackupTime"] = self.preferredNextBackupTime!
        }
        if self.releasedKeepPolicy != nil {
            map["ReleasedKeepPolicy"] = self.releasedKeepPolicy!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportModifyBackupPriority != nil {
            map["SupportModifyBackupPriority"] = self.supportModifyBackupPriority!
        }
        if self.supportReleasedKeep != nil {
            map["SupportReleasedKeep"] = self.supportReleasedKeep!
        }
        if self.supportVolumeShadowCopy != nil {
            map["SupportVolumeShadowCopy"] = self.supportVolumeShadowCopy!
        }
        if self.supportsHighFrequencyBackup != nil {
            map["SupportsHighFrequencyBackup"] = self.supportsHighFrequencyBackup!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveBackupKeepCount"] as? String {
            self.archiveBackupKeepCount = value
        }
        if let value = dict["ArchiveBackupKeepPolicy"] as? String {
            self.archiveBackupKeepPolicy = value
        }
        if let value = dict["ArchiveBackupRetentionPeriod"] as? String {
            self.archiveBackupRetentionPeriod = value
        }
        if let value = dict["BackupInterval"] as? String {
            self.backupInterval = value
        }
        if let value = dict["BackupLog"] as? String {
            self.backupLog = value
        }
        if let value = dict["BackupMethod"] as? String {
            self.backupMethod = value
        }
        if let value = dict["BackupPriority"] as? Int32 {
            self.backupPriority = value
        }
        if let value = dict["BackupRetentionPeriod"] as? Int32 {
            self.backupRetentionPeriod = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["CompressType"] as? String {
            self.compressType = value
        }
        if let value = dict["EnableBackupLog"] as? String {
            self.enableBackupLog = value
        }
        if let value = dict["EnableIncrementDataBackup"] as? Bool {
            self.enableIncrementDataBackup = value
        }
        if let value = dict["EnablePitrProtection"] as? Bool {
            self.enablePitrProtection = value
        }
        if let value = dict["HighSpaceUsageProtection"] as? String {
            self.highSpaceUsageProtection = value
        }
        if let value = dict["LocalLogRetentionHours"] as? Int32 {
            self.localLogRetentionHours = value
        }
        if let value = dict["LocalLogRetentionSpace"] as? String {
            self.localLogRetentionSpace = value
        }
        if let value = dict["LogBackupFrequency"] as? String {
            self.logBackupFrequency = value
        }
        if let value = dict["LogBackupLocalRetentionNumber"] as? Int32 {
            self.logBackupLocalRetentionNumber = value
        }
        if let value = dict["LogBackupRetentionPeriod"] as? Int32 {
            self.logBackupRetentionPeriod = value
        }
        if let value = dict["PitrRetentionPeriod"] as? Int32 {
            self.pitrRetentionPeriod = value
        }
        if let value = dict["PreferredBackupPeriod"] as? String {
            self.preferredBackupPeriod = value
        }
        if let value = dict["PreferredBackupTime"] as? String {
            self.preferredBackupTime = value
        }
        if let value = dict["PreferredNextBackupTime"] as? String {
            self.preferredNextBackupTime = value
        }
        if let value = dict["ReleasedKeepPolicy"] as? String {
            self.releasedKeepPolicy = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SupportModifyBackupPriority"] as? Bool {
            self.supportModifyBackupPriority = value
        }
        if let value = dict["SupportReleasedKeep"] as? Int32 {
            self.supportReleasedKeep = value
        }
        if let value = dict["SupportVolumeShadowCopy"] as? Int32 {
            self.supportVolumeShadowCopy = value
        }
        if let value = dict["SupportsHighFrequencyBackup"] as? Int64 {
            self.supportsHighFrequencyBackup = value
        }
    }
}

public class DescribeBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupTasksRequest : Tea.TeaModel {
    public var backupJobId: Int32?

    public var backupJobStatus: String?

    public var backupMode: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var flag: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupJobId != nil {
            map["BackupJobId"] = self.backupJobId!
        }
        if self.backupJobStatus != nil {
            map["BackupJobStatus"] = self.backupJobStatus!
        }
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.flag != nil {
            map["Flag"] = self.flag!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupJobId"] as? Int32 {
            self.backupJobId = value
        }
        if let value = dict["BackupJobStatus"] as? String {
            self.backupJobStatus = value
        }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Flag"] as? String {
            self.flag = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeBackupTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class BackupJob : Tea.TeaModel {
            public var backupId: String?

            public var backupJobId: String?

            public var backupProgressStatus: String?

            public var backupStatus: String?

            public var jobMode: String?

            public var process: String?

            public var taskAction: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupId != nil {
                    map["BackupId"] = self.backupId!
                }
                if self.backupJobId != nil {
                    map["BackupJobId"] = self.backupJobId!
                }
                if self.backupProgressStatus != nil {
                    map["BackupProgressStatus"] = self.backupProgressStatus!
                }
                if self.backupStatus != nil {
                    map["BackupStatus"] = self.backupStatus!
                }
                if self.jobMode != nil {
                    map["JobMode"] = self.jobMode!
                }
                if self.process != nil {
                    map["Process"] = self.process!
                }
                if self.taskAction != nil {
                    map["TaskAction"] = self.taskAction!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupId"] as? String {
                    self.backupId = value
                }
                if let value = dict["BackupJobId"] as? String {
                    self.backupJobId = value
                }
                if let value = dict["BackupProgressStatus"] as? String {
                    self.backupProgressStatus = value
                }
                if let value = dict["BackupStatus"] as? String {
                    self.backupStatus = value
                }
                if let value = dict["JobMode"] as? String {
                    self.jobMode = value
                }
                if let value = dict["Process"] as? String {
                    self.process = value
                }
                if let value = dict["TaskAction"] as? String {
                    self.taskAction = value
                }
            }
        }
        public var backupJob: [DescribeBackupTasksResponseBody.Items.BackupJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backupJob != nil {
                var tmp : [Any] = []
                for k in self.backupJob! {
                    tmp.append(k.toMap())
                }
                map["BackupJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BackupJob"] as? [Any?] {
                var tmp : [DescribeBackupTasksResponseBody.Items.BackupJob] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBackupTasksResponseBody.Items.BackupJob()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.backupJob = tmp
            }
        }
    }
    public var items: DescribeBackupTasksResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeBackupTasksResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeBackupTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupsRequest : Tea.TeaModel {
    public var backupId: String?

    public var backupMode: String?

    public var backupStatus: String?

    public var backupType: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.backupStatus != nil {
            map["BackupStatus"] = self.backupStatus!
        }
        if self.backupType != nil {
            map["BackupType"] = self.backupType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["BackupStatus"] as? String {
            self.backupStatus = value
        }
        if let value = dict["BackupType"] as? String {
            self.backupType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeBackupsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Backup : Tea.TeaModel {
            public class BackupDownloadLinkByDB : Tea.TeaModel {
                public class BackupDownloadLinkByDB : Tea.TeaModel {
                    public var dataBase: String?

                    public var downloadLink: String?

                    public var intranetDownloadLink: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dataBase != nil {
                            map["DataBase"] = self.dataBase!
                        }
                        if self.downloadLink != nil {
                            map["DownloadLink"] = self.downloadLink!
                        }
                        if self.intranetDownloadLink != nil {
                            map["IntranetDownloadLink"] = self.intranetDownloadLink!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DataBase"] as? String {
                            self.dataBase = value
                        }
                        if let value = dict["DownloadLink"] as? String {
                            self.downloadLink = value
                        }
                        if let value = dict["IntranetDownloadLink"] as? String {
                            self.intranetDownloadLink = value
                        }
                    }
                }
                public var backupDownloadLinkByDB: [DescribeBackupsResponseBody.Items.Backup.BackupDownloadLinkByDB.BackupDownloadLinkByDB]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.backupDownloadLinkByDB != nil {
                        var tmp : [Any] = []
                        for k in self.backupDownloadLinkByDB! {
                            tmp.append(k.toMap())
                        }
                        map["BackupDownloadLinkByDB"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BackupDownloadLinkByDB"] as? [Any?] {
                        var tmp : [DescribeBackupsResponseBody.Items.Backup.BackupDownloadLinkByDB.BackupDownloadLinkByDB] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeBackupsResponseBody.Items.Backup.BackupDownloadLinkByDB.BackupDownloadLinkByDB()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.backupDownloadLinkByDB = tmp
                    }
                }
            }
            public var backupDownloadLinkByDB: DescribeBackupsResponseBody.Items.Backup.BackupDownloadLinkByDB?

            public var backupDownloadURL: String?

            public var backupEndTime: String?

            public var backupId: String?

            public var backupInitiator: String?

            public var backupIntranetDownloadURL: String?

            public var backupMethod: String?

            public var backupMode: String?

            public var backupSize: Int64?

            public var backupStartTime: String?

            public var backupStatus: String?

            public var backupType: String?

            public var checksum: String?

            public var consistentTime: Int64?

            public var copyOnlyBackup: String?

            public var DBInstanceId: String?

            public var encryption: String?

            public var engine: String?

            public var engineVersion: String?

            public var hostInstanceID: String?

            public var isAvail: Int32?

            public var metaStatus: String?

            public var storageClass: String?

            public var storeStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.backupDownloadLinkByDB?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupDownloadLinkByDB != nil {
                    map["BackupDownloadLinkByDB"] = self.backupDownloadLinkByDB?.toMap()
                }
                if self.backupDownloadURL != nil {
                    map["BackupDownloadURL"] = self.backupDownloadURL!
                }
                if self.backupEndTime != nil {
                    map["BackupEndTime"] = self.backupEndTime!
                }
                if self.backupId != nil {
                    map["BackupId"] = self.backupId!
                }
                if self.backupInitiator != nil {
                    map["BackupInitiator"] = self.backupInitiator!
                }
                if self.backupIntranetDownloadURL != nil {
                    map["BackupIntranetDownloadURL"] = self.backupIntranetDownloadURL!
                }
                if self.backupMethod != nil {
                    map["BackupMethod"] = self.backupMethod!
                }
                if self.backupMode != nil {
                    map["BackupMode"] = self.backupMode!
                }
                if self.backupSize != nil {
                    map["BackupSize"] = self.backupSize!
                }
                if self.backupStartTime != nil {
                    map["BackupStartTime"] = self.backupStartTime!
                }
                if self.backupStatus != nil {
                    map["BackupStatus"] = self.backupStatus!
                }
                if self.backupType != nil {
                    map["BackupType"] = self.backupType!
                }
                if self.checksum != nil {
                    map["Checksum"] = self.checksum!
                }
                if self.consistentTime != nil {
                    map["ConsistentTime"] = self.consistentTime!
                }
                if self.copyOnlyBackup != nil {
                    map["CopyOnlyBackup"] = self.copyOnlyBackup!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.encryption != nil {
                    map["Encryption"] = self.encryption!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.hostInstanceID != nil {
                    map["HostInstanceID"] = self.hostInstanceID!
                }
                if self.isAvail != nil {
                    map["IsAvail"] = self.isAvail!
                }
                if self.metaStatus != nil {
                    map["MetaStatus"] = self.metaStatus!
                }
                if self.storageClass != nil {
                    map["StorageClass"] = self.storageClass!
                }
                if self.storeStatus != nil {
                    map["StoreStatus"] = self.storeStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupDownloadLinkByDB"] as? [String: Any?] {
                    var model = DescribeBackupsResponseBody.Items.Backup.BackupDownloadLinkByDB()
                    model.fromMap(value)
                    self.backupDownloadLinkByDB = model
                }
                if let value = dict["BackupDownloadURL"] as? String {
                    self.backupDownloadURL = value
                }
                if let value = dict["BackupEndTime"] as? String {
                    self.backupEndTime = value
                }
                if let value = dict["BackupId"] as? String {
                    self.backupId = value
                }
                if let value = dict["BackupInitiator"] as? String {
                    self.backupInitiator = value
                }
                if let value = dict["BackupIntranetDownloadURL"] as? String {
                    self.backupIntranetDownloadURL = value
                }
                if let value = dict["BackupMethod"] as? String {
                    self.backupMethod = value
                }
                if let value = dict["BackupMode"] as? String {
                    self.backupMode = value
                }
                if let value = dict["BackupSize"] as? Int64 {
                    self.backupSize = value
                }
                if let value = dict["BackupStartTime"] as? String {
                    self.backupStartTime = value
                }
                if let value = dict["BackupStatus"] as? String {
                    self.backupStatus = value
                }
                if let value = dict["BackupType"] as? String {
                    self.backupType = value
                }
                if let value = dict["Checksum"] as? String {
                    self.checksum = value
                }
                if let value = dict["ConsistentTime"] as? Int64 {
                    self.consistentTime = value
                }
                if let value = dict["CopyOnlyBackup"] as? String {
                    self.copyOnlyBackup = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["Encryption"] as? String {
                    self.encryption = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["HostInstanceID"] as? String {
                    self.hostInstanceID = value
                }
                if let value = dict["IsAvail"] as? Int32 {
                    self.isAvail = value
                }
                if let value = dict["MetaStatus"] as? String {
                    self.metaStatus = value
                }
                if let value = dict["StorageClass"] as? String {
                    self.storageClass = value
                }
                if let value = dict["StoreStatus"] as? String {
                    self.storeStatus = value
                }
            }
        }
        public var backup: [DescribeBackupsResponseBody.Items.Backup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backup != nil {
                var tmp : [Any] = []
                for k in self.backup! {
                    tmp.append(k.toMap())
                }
                map["Backup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Backup"] as? [Any?] {
                var tmp : [DescribeBackupsResponseBody.Items.Backup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBackupsResponseBody.Items.Backup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.backup = tmp
            }
        }
    }
    public var items: DescribeBackupsResponseBody.Items?

    public var pageNumber: String?

    public var pageRecordCount: String?

    public var requestId: String?

    public var totalEcsSnapshotSize: Int64?

    public var totalRecordCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalEcsSnapshotSize != nil {
            map["TotalEcsSnapshotSize"] = self.totalEcsSnapshotSize!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeBackupsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? String {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalEcsSnapshotSize"] as? Int64 {
            self.totalEcsSnapshotSize = value
        }
        if let value = dict["TotalRecordCount"] as? String {
            self.totalRecordCount = value
        }
    }
}

public class DescribeBackupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBinlogFilesRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeBinlogFilesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class BinLogFile : Tea.TeaModel {
            public var checksum: String?

            public var downloadLink: String?

            public var fileSize: Int64?

            public var hostInstanceID: String?

            public var intranetDownloadLink: String?

            public var linkExpiredTime: String?

            public var logBeginTime: String?

            public var logEndTime: String?

            public var logFileName: String?

            public var remoteStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checksum != nil {
                    map["Checksum"] = self.checksum!
                }
                if self.downloadLink != nil {
                    map["DownloadLink"] = self.downloadLink!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.hostInstanceID != nil {
                    map["HostInstanceID"] = self.hostInstanceID!
                }
                if self.intranetDownloadLink != nil {
                    map["IntranetDownloadLink"] = self.intranetDownloadLink!
                }
                if self.linkExpiredTime != nil {
                    map["LinkExpiredTime"] = self.linkExpiredTime!
                }
                if self.logBeginTime != nil {
                    map["LogBeginTime"] = self.logBeginTime!
                }
                if self.logEndTime != nil {
                    map["LogEndTime"] = self.logEndTime!
                }
                if self.logFileName != nil {
                    map["LogFileName"] = self.logFileName!
                }
                if self.remoteStatus != nil {
                    map["RemoteStatus"] = self.remoteStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Checksum"] as? String {
                    self.checksum = value
                }
                if let value = dict["DownloadLink"] as? String {
                    self.downloadLink = value
                }
                if let value = dict["FileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["HostInstanceID"] as? String {
                    self.hostInstanceID = value
                }
                if let value = dict["IntranetDownloadLink"] as? String {
                    self.intranetDownloadLink = value
                }
                if let value = dict["LinkExpiredTime"] as? String {
                    self.linkExpiredTime = value
                }
                if let value = dict["LogBeginTime"] as? String {
                    self.logBeginTime = value
                }
                if let value = dict["LogEndTime"] as? String {
                    self.logEndTime = value
                }
                if let value = dict["LogFileName"] as? String {
                    self.logFileName = value
                }
                if let value = dict["RemoteStatus"] as? String {
                    self.remoteStatus = value
                }
            }
        }
        public var binLogFile: [DescribeBinlogFilesResponseBody.Items.BinLogFile]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.binLogFile != nil {
                var tmp : [Any] = []
                for k in self.binLogFile! {
                    tmp.append(k.toMap())
                }
                map["BinLogFile"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BinLogFile"] as? [Any?] {
                var tmp : [DescribeBinlogFilesResponseBody.Items.BinLogFile] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBinlogFilesResponseBody.Items.BinLogFile()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.binLogFile = tmp
            }
        }
    }
    public var items: DescribeBinlogFilesResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalFileSize: Int64?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalFileSize != nil {
            map["TotalFileSize"] = self.totalFileSize!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeBinlogFilesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalFileSize"] as? Int64 {
            self.totalFileSize = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeBinlogFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBinlogFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBinlogFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCharacterSetNameRequest : Tea.TeaModel {
    public var engine: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCharacterSetNameResponseBody : Tea.TeaModel {
    public class CharacterSetNameItems : Tea.TeaModel {
        public var characterSetName: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.characterSetName != nil {
                map["CharacterSetName"] = self.characterSetName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CharacterSetName"] as? [String] {
                self.characterSetName = value
            }
        }
    }
    public var characterSetNameItems: DescribeCharacterSetNameResponseBody.CharacterSetNameItems?

    public var engine: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.characterSetNameItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.characterSetNameItems != nil {
            map["CharacterSetNameItems"] = self.characterSetNameItems?.toMap()
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CharacterSetNameItems"] as? [String: Any?] {
            var model = DescribeCharacterSetNameResponseBody.CharacterSetNameItems()
            model.fromMap(value)
            self.characterSetNameItems = model
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCharacterSetNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCharacterSetNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCharacterSetNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClassDetailsRequest : Tea.TeaModel {
    public var classCode: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var engine: String?

    public var engineVersion: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classCode != nil {
            map["ClassCode"] = self.classCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClassCode"] as? String {
            self.classCode = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeClassDetailsResponseBody : Tea.TeaModel {
    public var category: String?

    public var classCode: String?

    public var classGroup: String?

    public var cpu: String?

    public var DBInstanceStorageType: String?

    public var instructionSetArch: String?

    public var maxConnections: String?

    public var maxIOMBPS: String?

    public var maxIOPS: String?

    public var memoryClass: String?

    public var referencePrice: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.classCode != nil {
            map["ClassCode"] = self.classCode!
        }
        if self.classGroup != nil {
            map["ClassGroup"] = self.classGroup!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.instructionSetArch != nil {
            map["InstructionSetArch"] = self.instructionSetArch!
        }
        if self.maxConnections != nil {
            map["MaxConnections"] = self.maxConnections!
        }
        if self.maxIOMBPS != nil {
            map["MaxIOMBPS"] = self.maxIOMBPS!
        }
        if self.maxIOPS != nil {
            map["MaxIOPS"] = self.maxIOPS!
        }
        if self.memoryClass != nil {
            map["MemoryClass"] = self.memoryClass!
        }
        if self.referencePrice != nil {
            map["ReferencePrice"] = self.referencePrice!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClassCode"] as? String {
            self.classCode = value
        }
        if let value = dict["ClassGroup"] as? String {
            self.classGroup = value
        }
        if let value = dict["Cpu"] as? String {
            self.cpu = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["InstructionSetArch"] as? String {
            self.instructionSetArch = value
        }
        if let value = dict["MaxConnections"] as? String {
            self.maxConnections = value
        }
        if let value = dict["MaxIOMBPS"] as? String {
            self.maxIOMBPS = value
        }
        if let value = dict["MaxIOPS"] as? String {
            self.maxIOPS = value
        }
        if let value = dict["MemoryClass"] as? String {
            self.memoryClass = value
        }
        if let value = dict["ReferencePrice"] as? String {
            self.referencePrice = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClassDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClassDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClassDetailsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudMigrationPrecheckResultRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerId: Int64?

    public var sourceIpAddress: String?

    public var sourcePort: Int64?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class DescribeCloudMigrationPrecheckResultResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var detail: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var sourceAccount: String?

        public var sourceCategory: String?

        public var sourceIpAddress: String?

        public var sourcePassword: String?

        public var sourcePort: Int64?

        public var targetEip: String?

        public var targetInstanceName: String?

        public var taskId: Int64?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.sourceAccount != nil {
                map["SourceAccount"] = self.sourceAccount!
            }
            if self.sourceCategory != nil {
                map["SourceCategory"] = self.sourceCategory!
            }
            if self.sourceIpAddress != nil {
                map["SourceIpAddress"] = self.sourceIpAddress!
            }
            if self.sourcePassword != nil {
                map["SourcePassword"] = self.sourcePassword!
            }
            if self.sourcePort != nil {
                map["SourcePort"] = self.sourcePort!
            }
            if self.targetEip != nil {
                map["TargetEip"] = self.targetEip!
            }
            if self.targetInstanceName != nil {
                map["TargetInstanceName"] = self.targetInstanceName!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["GmtCreated"] as? String {
                self.gmtCreated = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["SourceAccount"] as? String {
                self.sourceAccount = value
            }
            if let value = dict["SourceCategory"] as? String {
                self.sourceCategory = value
            }
            if let value = dict["SourceIpAddress"] as? String {
                self.sourceIpAddress = value
            }
            if let value = dict["SourcePassword"] as? String {
                self.sourcePassword = value
            }
            if let value = dict["SourcePort"] as? Int64 {
                self.sourcePort = value
            }
            if let value = dict["TargetEip"] as? String {
                self.targetEip = value
            }
            if let value = dict["TargetInstanceName"] as? String {
                self.targetInstanceName = value
            }
            if let value = dict["TaskId"] as? Int64 {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
        }
    }
    public var items: [DescribeCloudMigrationPrecheckResultResponseBody.Items]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeCloudMigrationPrecheckResultResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeCloudMigrationPrecheckResultResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class DescribeCloudMigrationPrecheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudMigrationPrecheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudMigrationPrecheckResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCloudMigrationResultRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerId: Int64?

    public var sourceIpAddress: String?

    public var sourcePort: Int64?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        if self.sourcePort != nil {
            map["SourcePort"] = self.sourcePort!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
        if let value = dict["SourcePort"] as? Int64 {
            self.sourcePort = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class DescribeCloudMigrationResultResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var detail: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var migrateStage: String?

        public var replicationInfo: String?

        public var replicationState: String?

        public var sourceAccount: String?

        public var sourceCategory: String?

        public var sourceIpAddress: String?

        public var sourcePassword: String?

        public var sourcePort: Int64?

        public var switchTime: String?

        public var targetEip: String?

        public var targetInstanceName: String?

        public var taskId: Int64?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.migrateStage != nil {
                map["MigrateStage"] = self.migrateStage!
            }
            if self.replicationInfo != nil {
                map["ReplicationInfo"] = self.replicationInfo!
            }
            if self.replicationState != nil {
                map["ReplicationState"] = self.replicationState!
            }
            if self.sourceAccount != nil {
                map["SourceAccount"] = self.sourceAccount!
            }
            if self.sourceCategory != nil {
                map["SourceCategory"] = self.sourceCategory!
            }
            if self.sourceIpAddress != nil {
                map["SourceIpAddress"] = self.sourceIpAddress!
            }
            if self.sourcePassword != nil {
                map["SourcePassword"] = self.sourcePassword!
            }
            if self.sourcePort != nil {
                map["SourcePort"] = self.sourcePort!
            }
            if self.switchTime != nil {
                map["SwitchTime"] = self.switchTime!
            }
            if self.targetEip != nil {
                map["TargetEip"] = self.targetEip!
            }
            if self.targetInstanceName != nil {
                map["TargetInstanceName"] = self.targetInstanceName!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["GmtCreated"] as? String {
                self.gmtCreated = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["MigrateStage"] as? String {
                self.migrateStage = value
            }
            if let value = dict["ReplicationInfo"] as? String {
                self.replicationInfo = value
            }
            if let value = dict["ReplicationState"] as? String {
                self.replicationState = value
            }
            if let value = dict["SourceAccount"] as? String {
                self.sourceAccount = value
            }
            if let value = dict["SourceCategory"] as? String {
                self.sourceCategory = value
            }
            if let value = dict["SourceIpAddress"] as? String {
                self.sourceIpAddress = value
            }
            if let value = dict["SourcePassword"] as? String {
                self.sourcePassword = value
            }
            if let value = dict["SourcePort"] as? Int64 {
                self.sourcePort = value
            }
            if let value = dict["SwitchTime"] as? String {
                self.switchTime = value
            }
            if let value = dict["TargetEip"] as? String {
                self.targetEip = value
            }
            if let value = dict["TargetInstanceName"] as? String {
                self.targetInstanceName = value
            }
            if let value = dict["TaskId"] as? Int64 {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
        }
    }
    public var items: [DescribeCloudMigrationResultResponseBody.Items]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeCloudMigrationResultResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeCloudMigrationResultResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class DescribeCloudMigrationResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudMigrationResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCloudMigrationResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCollationTimeZonesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCollationTimeZonesResponseBody : Tea.TeaModel {
    public class CollationTimeZones : Tea.TeaModel {
        public class CollationTimeZone : Tea.TeaModel {
            public var description_: String?

            public var standardTimeOffset: String?

            public var timeZone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.standardTimeOffset != nil {
                    map["StandardTimeOffset"] = self.standardTimeOffset!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["StandardTimeOffset"] as? String {
                    self.standardTimeOffset = value
                }
                if let value = dict["TimeZone"] as? String {
                    self.timeZone = value
                }
            }
        }
        public var collationTimeZone: [DescribeCollationTimeZonesResponseBody.CollationTimeZones.CollationTimeZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collationTimeZone != nil {
                var tmp : [Any] = []
                for k in self.collationTimeZone! {
                    tmp.append(k.toMap())
                }
                map["CollationTimeZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CollationTimeZone"] as? [Any?] {
                var tmp : [DescribeCollationTimeZonesResponseBody.CollationTimeZones.CollationTimeZone] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCollationTimeZonesResponseBody.CollationTimeZones.CollationTimeZone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.collationTimeZone = tmp
            }
        }
    }
    public var collationTimeZones: DescribeCollationTimeZonesResponseBody.CollationTimeZones?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.collationTimeZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collationTimeZones != nil {
            map["CollationTimeZones"] = self.collationTimeZones?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollationTimeZones"] as? [String: Any?] {
            var model = DescribeCollationTimeZonesResponseBody.CollationTimeZones()
            model.fromMap(value)
            self.collationTimeZones = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCollationTimeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCollationTimeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCollationTimeZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCrossBackupMetaListRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var getDbName: String?

    public var ownerId: Int64?

    public var pageIndex: String?

    public var pageSize: String?

    public var pattern: String?

    public var region: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.getDbName != nil {
            map["GetDbName"] = self.getDbName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetId"] as? String {
            self.backupSetId = value
        }
        if let value = dict["GetDbName"] as? String {
            self.getDbName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageIndex"] as? String {
            self.pageIndex = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["Pattern"] as? String {
            self.pattern = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCrossBackupMetaListResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Meta : Tea.TeaModel {
            public var database: String?

            public var size: String?

            public var tables: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Size"] as? String {
                    self.size = value
                }
                if let value = dict["Tables"] as? String {
                    self.tables = value
                }
            }
        }
        public var meta: [DescribeCrossBackupMetaListResponseBody.Items.Meta]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.meta != nil {
                var tmp : [Any] = []
                for k in self.meta! {
                    tmp.append(k.toMap())
                }
                map["Meta"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Meta"] as? [Any?] {
                var tmp : [DescribeCrossBackupMetaListResponseBody.Items.Meta] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCrossBackupMetaListResponseBody.Items.Meta()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.meta = tmp
            }
        }
    }
    public var DBInstanceName: String?

    public var items: DescribeCrossBackupMetaListResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalPageCount: Int32?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalPageCount != nil {
            map["TotalPageCount"] = self.totalPageCount!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeCrossBackupMetaListResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalPageCount"] as? Int32 {
            self.totalPageCount = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeCrossBackupMetaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCrossBackupMetaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCrossBackupMetaListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCrossRegionBackupDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCrossRegionBackupDBInstanceResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var backupEnabled: String?

            public var backupEnabledTime: String?

            public var crossBackupRegion: String?

            public var crossBackupType: String?

            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var DBInstanceStatus: String?

            public var engine: String?

            public var engineVersion: String?

            public var lockMode: String?

            public var logBackupEnabled: String?

            public var logBackupEnabledTime: String?

            public var retentType: Int32?

            public var retention: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupEnabled != nil {
                    map["BackupEnabled"] = self.backupEnabled!
                }
                if self.backupEnabledTime != nil {
                    map["BackupEnabledTime"] = self.backupEnabledTime!
                }
                if self.crossBackupRegion != nil {
                    map["CrossBackupRegion"] = self.crossBackupRegion!
                }
                if self.crossBackupType != nil {
                    map["CrossBackupType"] = self.crossBackupType!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.logBackupEnabled != nil {
                    map["LogBackupEnabled"] = self.logBackupEnabled!
                }
                if self.logBackupEnabledTime != nil {
                    map["LogBackupEnabledTime"] = self.logBackupEnabledTime!
                }
                if self.retentType != nil {
                    map["RetentType"] = self.retentType!
                }
                if self.retention != nil {
                    map["Retention"] = self.retention!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupEnabled"] as? String {
                    self.backupEnabled = value
                }
                if let value = dict["BackupEnabledTime"] as? String {
                    self.backupEnabledTime = value
                }
                if let value = dict["CrossBackupRegion"] as? String {
                    self.crossBackupRegion = value
                }
                if let value = dict["CrossBackupType"] as? String {
                    self.crossBackupType = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LogBackupEnabled"] as? String {
                    self.logBackupEnabled = value
                }
                if let value = dict["LogBackupEnabledTime"] as? String {
                    self.logBackupEnabledTime = value
                }
                if let value = dict["RetentType"] as? Int32 {
                    self.retentType = value
                }
                if let value = dict["Retention"] as? Int32 {
                    self.retention = value
                }
            }
        }
        public var item: [DescribeCrossRegionBackupDBInstanceResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Item"] as? [Any?] {
                var tmp : [DescribeCrossRegionBackupDBInstanceResponseBody.Items.Item] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCrossRegionBackupDBInstanceResponseBody.Items.Item()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.item = tmp
            }
        }
    }
    public var items: DescribeCrossRegionBackupDBInstanceResponseBody.Items?

    public var itemsNumbers: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalRecords: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.itemsNumbers != nil {
            map["ItemsNumbers"] = self.itemsNumbers!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecords != nil {
            map["TotalRecords"] = self.totalRecords!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeCrossRegionBackupDBInstanceResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["ItemsNumbers"] as? Int32 {
            self.itemsNumbers = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecords"] as? Int32 {
            self.totalRecords = value
        }
    }
}

public class DescribeCrossRegionBackupDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCrossRegionBackupDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCrossRegionBackupDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCrossRegionBackupsRequest : Tea.TeaModel {
    public var backupId: Int32?

    public var crossBackupId: Int32?

    public var crossBackupRegion: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.crossBackupId != nil {
            map["CrossBackupId"] = self.crossBackupId!
        }
        if self.crossBackupRegion != nil {
            map["CrossBackupRegion"] = self.crossBackupRegion!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? Int32 {
            self.backupId = value
        }
        if let value = dict["CrossBackupId"] as? Int32 {
            self.crossBackupId = value
        }
        if let value = dict["CrossBackupRegion"] as? String {
            self.crossBackupRegion = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeCrossRegionBackupsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class RestoreRegions : Tea.TeaModel {
                public var restoreRegion: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.restoreRegion != nil {
                        map["RestoreRegion"] = self.restoreRegion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RestoreRegion"] as? [String] {
                        self.restoreRegion = value
                    }
                }
            }
            public var backupEndTime: String?

            public var backupMethod: String?

            public var backupSetScale: Int32?

            public var backupSetStatus: Int32?

            public var backupStartTime: String?

            public var backupType: String?

            public var category: String?

            public var consistentTime: String?

            public var crossBackupDownloadLink: String?

            public var crossBackupId: Int32?

            public var crossBackupRegion: String?

            public var crossBackupSetFile: String?

            public var crossBackupSetLocation: String?

            public var crossBackupSetSize: Int64?

            public var DBInstanceStorageType: String?

            public var engine: String?

            public var engineVersion: String?

            public var instanceId: Int32?

            public var restoreRegions: DescribeCrossRegionBackupsResponseBody.Items.Item.RestoreRegions?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.restoreRegions?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupEndTime != nil {
                    map["BackupEndTime"] = self.backupEndTime!
                }
                if self.backupMethod != nil {
                    map["BackupMethod"] = self.backupMethod!
                }
                if self.backupSetScale != nil {
                    map["BackupSetScale"] = self.backupSetScale!
                }
                if self.backupSetStatus != nil {
                    map["BackupSetStatus"] = self.backupSetStatus!
                }
                if self.backupStartTime != nil {
                    map["BackupStartTime"] = self.backupStartTime!
                }
                if self.backupType != nil {
                    map["BackupType"] = self.backupType!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.consistentTime != nil {
                    map["ConsistentTime"] = self.consistentTime!
                }
                if self.crossBackupDownloadLink != nil {
                    map["CrossBackupDownloadLink"] = self.crossBackupDownloadLink!
                }
                if self.crossBackupId != nil {
                    map["CrossBackupId"] = self.crossBackupId!
                }
                if self.crossBackupRegion != nil {
                    map["CrossBackupRegion"] = self.crossBackupRegion!
                }
                if self.crossBackupSetFile != nil {
                    map["CrossBackupSetFile"] = self.crossBackupSetFile!
                }
                if self.crossBackupSetLocation != nil {
                    map["CrossBackupSetLocation"] = self.crossBackupSetLocation!
                }
                if self.crossBackupSetSize != nil {
                    map["CrossBackupSetSize"] = self.crossBackupSetSize!
                }
                if self.DBInstanceStorageType != nil {
                    map["DBInstanceStorageType"] = self.DBInstanceStorageType!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.restoreRegions != nil {
                    map["RestoreRegions"] = self.restoreRegions?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupEndTime"] as? String {
                    self.backupEndTime = value
                }
                if let value = dict["BackupMethod"] as? String {
                    self.backupMethod = value
                }
                if let value = dict["BackupSetScale"] as? Int32 {
                    self.backupSetScale = value
                }
                if let value = dict["BackupSetStatus"] as? Int32 {
                    self.backupSetStatus = value
                }
                if let value = dict["BackupStartTime"] as? String {
                    self.backupStartTime = value
                }
                if let value = dict["BackupType"] as? String {
                    self.backupType = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["ConsistentTime"] as? String {
                    self.consistentTime = value
                }
                if let value = dict["CrossBackupDownloadLink"] as? String {
                    self.crossBackupDownloadLink = value
                }
                if let value = dict["CrossBackupId"] as? Int32 {
                    self.crossBackupId = value
                }
                if let value = dict["CrossBackupRegion"] as? String {
                    self.crossBackupRegion = value
                }
                if let value = dict["CrossBackupSetFile"] as? String {
                    self.crossBackupSetFile = value
                }
                if let value = dict["CrossBackupSetLocation"] as? String {
                    self.crossBackupSetLocation = value
                }
                if let value = dict["CrossBackupSetSize"] as? Int64 {
                    self.crossBackupSetSize = value
                }
                if let value = dict["DBInstanceStorageType"] as? String {
                    self.DBInstanceStorageType = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["InstanceId"] as? Int32 {
                    self.instanceId = value
                }
                if let value = dict["RestoreRegions"] as? [String: Any?] {
                    var model = DescribeCrossRegionBackupsResponseBody.Items.Item.RestoreRegions()
                    model.fromMap(value)
                    self.restoreRegions = model
                }
            }
        }
        public var item: [DescribeCrossRegionBackupsResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Item"] as? [Any?] {
                var tmp : [DescribeCrossRegionBackupsResponseBody.Items.Item] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCrossRegionBackupsResponseBody.Items.Item()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.item = tmp
            }
        }
    }
    public var endTime: String?

    public var items: DescribeCrossRegionBackupsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var regionId: String?

    public var requestId: String?

    public var startTime: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeCrossRegionBackupsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeCrossRegionBackupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCrossRegionBackupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCrossRegionBackupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCrossRegionLogBackupFilesRequest : Tea.TeaModel {
    public var crossBackupRegion: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crossBackupRegion != nil {
            map["CrossBackupRegion"] = self.crossBackupRegion!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CrossBackupRegion"] as? String {
            self.crossBackupRegion = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeCrossRegionLogBackupFilesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var crossBackupRegion: String?

            public var crossDownloadLink: String?

            public var crossIntranetDownloadLink: String?

            public var crossLogBackupId: Int32?

            public var crossLogBackupSize: Int64?

            public var instanceId: Int32?

            public var linkExpiredTime: String?

            public var logBeginTime: String?

            public var logEndTime: String?

            public var logFileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.crossBackupRegion != nil {
                    map["CrossBackupRegion"] = self.crossBackupRegion!
                }
                if self.crossDownloadLink != nil {
                    map["CrossDownloadLink"] = self.crossDownloadLink!
                }
                if self.crossIntranetDownloadLink != nil {
                    map["CrossIntranetDownloadLink"] = self.crossIntranetDownloadLink!
                }
                if self.crossLogBackupId != nil {
                    map["CrossLogBackupId"] = self.crossLogBackupId!
                }
                if self.crossLogBackupSize != nil {
                    map["CrossLogBackupSize"] = self.crossLogBackupSize!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.linkExpiredTime != nil {
                    map["LinkExpiredTime"] = self.linkExpiredTime!
                }
                if self.logBeginTime != nil {
                    map["LogBeginTime"] = self.logBeginTime!
                }
                if self.logEndTime != nil {
                    map["LogEndTime"] = self.logEndTime!
                }
                if self.logFileName != nil {
                    map["LogFileName"] = self.logFileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CrossBackupRegion"] as? String {
                    self.crossBackupRegion = value
                }
                if let value = dict["CrossDownloadLink"] as? String {
                    self.crossDownloadLink = value
                }
                if let value = dict["CrossIntranetDownloadLink"] as? String {
                    self.crossIntranetDownloadLink = value
                }
                if let value = dict["CrossLogBackupId"] as? Int32 {
                    self.crossLogBackupId = value
                }
                if let value = dict["CrossLogBackupSize"] as? Int64 {
                    self.crossLogBackupSize = value
                }
                if let value = dict["InstanceId"] as? Int32 {
                    self.instanceId = value
                }
                if let value = dict["LinkExpiredTime"] as? String {
                    self.linkExpiredTime = value
                }
                if let value = dict["LogBeginTime"] as? String {
                    self.logBeginTime = value
                }
                if let value = dict["LogEndTime"] as? String {
                    self.logEndTime = value
                }
                if let value = dict["LogFileName"] as? String {
                    self.logFileName = value
                }
            }
        }
        public var item: [DescribeCrossRegionLogBackupFilesResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Item"] as? [Any?] {
                var tmp : [DescribeCrossRegionLogBackupFilesResponseBody.Items.Item] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCrossRegionLogBackupFilesResponseBody.Items.Item()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.item = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var endTime: String?

    public var items: DescribeCrossRegionLogBackupFilesResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var regionId: String?

    public var requestId: String?

    public var startTime: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeCrossRegionLogBackupFilesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeCrossRegionLogBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCrossRegionLogBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCrossRegionLogBackupFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCurrentModifyOrderRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dbInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCurrentModifyOrderResponseBody : Tea.TeaModel {
    public class ModifyOrder : Tea.TeaModel {
        public var classGroup: String?

        public var cpu: String?

        public var dbInstanceId: String?

        public var effectiveTime: String?

        public var mark: String?

        public var memoryClass: String?

        public var status: String?

        public var storage: String?

        public var targetDBInstanceClass: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classGroup != nil {
                map["ClassGroup"] = self.classGroup!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.dbInstanceId != nil {
                map["DbInstanceId"] = self.dbInstanceId!
            }
            if self.effectiveTime != nil {
                map["EffectiveTime"] = self.effectiveTime!
            }
            if self.mark != nil {
                map["Mark"] = self.mark!
            }
            if self.memoryClass != nil {
                map["MemoryClass"] = self.memoryClass!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storage != nil {
                map["Storage"] = self.storage!
            }
            if self.targetDBInstanceClass != nil {
                map["TargetDBInstanceClass"] = self.targetDBInstanceClass!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClassGroup"] as? String {
                self.classGroup = value
            }
            if let value = dict["Cpu"] as? String {
                self.cpu = value
            }
            if let value = dict["DbInstanceId"] as? String {
                self.dbInstanceId = value
            }
            if let value = dict["EffectiveTime"] as? String {
                self.effectiveTime = value
            }
            if let value = dict["Mark"] as? String {
                self.mark = value
            }
            if let value = dict["MemoryClass"] as? String {
                self.memoryClass = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Storage"] as? String {
                self.storage = value
            }
            if let value = dict["TargetDBInstanceClass"] as? String {
                self.targetDBInstanceClass = value
            }
        }
    }
    public var modifyOrder: [DescribeCurrentModifyOrderResponseBody.ModifyOrder]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyOrder != nil {
            var tmp : [Any] = []
            for k in self.modifyOrder! {
                tmp.append(k.toMap())
            }
            map["ModifyOrder"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ModifyOrder"] as? [Any?] {
            var tmp : [DescribeCurrentModifyOrderResponseBody.ModifyOrder] = []
            for v in value {
                if v != nil {
                    var model = DescribeCurrentModifyOrderResponseBody.ModifyOrder()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.modifyOrder = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCurrentModifyOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCurrentModifyOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCurrentModifyOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCustinsResourceInfoRequest : Tea.TeaModel {
    public var DBInstanceIds: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceIds != nil {
            map["DBInstanceIds"] = self.DBInstanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceIds"] as? String {
            self.DBInstanceIds = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeCustinsResourceInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cpuAdjustDeadline: String?

        public var cpuAdjustableMaxRatio: String?

        public var cpuAdjustableMaxValue: String?

        public var cpuIncreaseRatio: String?

        public var cpuIncreaseRatioValue: String?

        public var DBInstanceId: String?

        public var iopsAdjustableMaxValue: String?

        public var maxConnAdjustDeadline: String?

        public var maxConnAdjustableMaxValue: String?

        public var maxConnIncreaseRatio: String?

        public var maxConnIncreaseRatioValue: String?

        public var maxIopsAdjustDeadline: String?

        public var maxIopsIncreaseRatio: String?

        public var maxIopsIncreaseRatioValue: String?

        public var memAdjustableMaxRatio: String?

        public var memAdjustableMaxValue: String?

        public var memoryAdjustDeadline: String?

        public var memoryIncreaseRatio: String?

        public var memoryIncreaseRatioValue: String?

        public var originCpu: String?

        public var originMaxConn: String?

        public var originMaxIops: String?

        public var originMemory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuAdjustDeadline != nil {
                map["CpuAdjustDeadline"] = self.cpuAdjustDeadline!
            }
            if self.cpuAdjustableMaxRatio != nil {
                map["CpuAdjustableMaxRatio"] = self.cpuAdjustableMaxRatio!
            }
            if self.cpuAdjustableMaxValue != nil {
                map["CpuAdjustableMaxValue"] = self.cpuAdjustableMaxValue!
            }
            if self.cpuIncreaseRatio != nil {
                map["CpuIncreaseRatio"] = self.cpuIncreaseRatio!
            }
            if self.cpuIncreaseRatioValue != nil {
                map["CpuIncreaseRatioValue"] = self.cpuIncreaseRatioValue!
            }
            if self.DBInstanceId != nil {
                map["DBInstanceId"] = self.DBInstanceId!
            }
            if self.iopsAdjustableMaxValue != nil {
                map["IopsAdjustableMaxValue"] = self.iopsAdjustableMaxValue!
            }
            if self.maxConnAdjustDeadline != nil {
                map["MaxConnAdjustDeadline"] = self.maxConnAdjustDeadline!
            }
            if self.maxConnAdjustableMaxValue != nil {
                map["MaxConnAdjustableMaxValue"] = self.maxConnAdjustableMaxValue!
            }
            if self.maxConnIncreaseRatio != nil {
                map["MaxConnIncreaseRatio"] = self.maxConnIncreaseRatio!
            }
            if self.maxConnIncreaseRatioValue != nil {
                map["MaxConnIncreaseRatioValue"] = self.maxConnIncreaseRatioValue!
            }
            if self.maxIopsAdjustDeadline != nil {
                map["MaxIopsAdjustDeadline"] = self.maxIopsAdjustDeadline!
            }
            if self.maxIopsIncreaseRatio != nil {
                map["MaxIopsIncreaseRatio"] = self.maxIopsIncreaseRatio!
            }
            if self.maxIopsIncreaseRatioValue != nil {
                map["MaxIopsIncreaseRatioValue"] = self.maxIopsIncreaseRatioValue!
            }
            if self.memAdjustableMaxRatio != nil {
                map["MemAdjustableMaxRatio"] = self.memAdjustableMaxRatio!
            }
            if self.memAdjustableMaxValue != nil {
                map["MemAdjustableMaxValue"] = self.memAdjustableMaxValue!
            }
            if self.memoryAdjustDeadline != nil {
                map["MemoryAdjustDeadline"] = self.memoryAdjustDeadline!
            }
            if self.memoryIncreaseRatio != nil {
                map["MemoryIncreaseRatio"] = self.memoryIncreaseRatio!
            }
            if self.memoryIncreaseRatioValue != nil {
                map["MemoryIncreaseRatioValue"] = self.memoryIncreaseRatioValue!
            }
            if self.originCpu != nil {
                map["OriginCpu"] = self.originCpu!
            }
            if self.originMaxConn != nil {
                map["OriginMaxConn"] = self.originMaxConn!
            }
            if self.originMaxIops != nil {
                map["OriginMaxIops"] = self.originMaxIops!
            }
            if self.originMemory != nil {
                map["OriginMemory"] = self.originMemory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CpuAdjustDeadline"] as? String {
                self.cpuAdjustDeadline = value
            }
            if let value = dict["CpuAdjustableMaxRatio"] as? String {
                self.cpuAdjustableMaxRatio = value
            }
            if let value = dict["CpuAdjustableMaxValue"] as? String {
                self.cpuAdjustableMaxValue = value
            }
            if let value = dict["CpuIncreaseRatio"] as? String {
                self.cpuIncreaseRatio = value
            }
            if let value = dict["CpuIncreaseRatioValue"] as? String {
                self.cpuIncreaseRatioValue = value
            }
            if let value = dict["DBInstanceId"] as? String {
                self.DBInstanceId = value
            }
            if let value = dict["IopsAdjustableMaxValue"] as? String {
                self.iopsAdjustableMaxValue = value
            }
            if let value = dict["MaxConnAdjustDeadline"] as? String {
                self.maxConnAdjustDeadline = value
            }
            if let value = dict["MaxConnAdjustableMaxValue"] as? String {
                self.maxConnAdjustableMaxValue = value
            }
            if let value = dict["MaxConnIncreaseRatio"] as? String {
                self.maxConnIncreaseRatio = value
            }
            if let value = dict["MaxConnIncreaseRatioValue"] as? String {
                self.maxConnIncreaseRatioValue = value
            }
            if let value = dict["MaxIopsAdjustDeadline"] as? String {
                self.maxIopsAdjustDeadline = value
            }
            if let value = dict["MaxIopsIncreaseRatio"] as? String {
                self.maxIopsIncreaseRatio = value
            }
            if let value = dict["MaxIopsIncreaseRatioValue"] as? String {
                self.maxIopsIncreaseRatioValue = value
            }
            if let value = dict["MemAdjustableMaxRatio"] as? String {
                self.memAdjustableMaxRatio = value
            }
            if let value = dict["MemAdjustableMaxValue"] as? String {
                self.memAdjustableMaxValue = value
            }
            if let value = dict["MemoryAdjustDeadline"] as? String {
                self.memoryAdjustDeadline = value
            }
            if let value = dict["MemoryIncreaseRatio"] as? String {
                self.memoryIncreaseRatio = value
            }
            if let value = dict["MemoryIncreaseRatioValue"] as? String {
                self.memoryIncreaseRatioValue = value
            }
            if let value = dict["OriginCpu"] as? String {
                self.originCpu = value
            }
            if let value = dict["OriginMaxConn"] as? String {
                self.originMaxConn = value
            }
            if let value = dict["OriginMaxIops"] as? String {
                self.originMaxIops = value
            }
            if let value = dict["OriginMemory"] as? String {
                self.originMemory = value
            }
        }
    }
    public var data: [DescribeCustinsResourceInfoResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeCustinsResourceInfoResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeCustinsResourceInfoResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCustinsResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustinsResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCustinsResourceInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceAttributeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var expired: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.expired != nil {
            map["Expired"] = self.expired!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Expired"] as? String {
            self.expired = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceAttributeResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceAttribute : Tea.TeaModel {
            public class BabelfishConfig : Tea.TeaModel {
                public var babelfishEnabled: String?

                public var migrationMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.babelfishEnabled != nil {
                        map["BabelfishEnabled"] = self.babelfishEnabled!
                    }
                    if self.migrationMode != nil {
                        map["MigrationMode"] = self.migrationMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BabelfishEnabled"] as? String {
                        self.babelfishEnabled = value
                    }
                    if let value = dict["MigrationMode"] as? String {
                        self.migrationMode = value
                    }
                }
            }
            public class DBClusterNodes : Tea.TeaModel {
                public class DBClusterNode : Tea.TeaModel {
                    public var classCode: String?

                    public var classType: String?

                    public var cpu: String?

                    public var memory: String?

                    public var nodeId: String?

                    public var nodeRegionId: String?

                    public var nodeRole: String?

                    public var nodeZoneId: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.classCode != nil {
                            map["ClassCode"] = self.classCode!
                        }
                        if self.classType != nil {
                            map["ClassType"] = self.classType!
                        }
                        if self.cpu != nil {
                            map["Cpu"] = self.cpu!
                        }
                        if self.memory != nil {
                            map["Memory"] = self.memory!
                        }
                        if self.nodeId != nil {
                            map["NodeId"] = self.nodeId!
                        }
                        if self.nodeRegionId != nil {
                            map["NodeRegionId"] = self.nodeRegionId!
                        }
                        if self.nodeRole != nil {
                            map["NodeRole"] = self.nodeRole!
                        }
                        if self.nodeZoneId != nil {
                            map["NodeZoneId"] = self.nodeZoneId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ClassCode"] as? String {
                            self.classCode = value
                        }
                        if let value = dict["ClassType"] as? String {
                            self.classType = value
                        }
                        if let value = dict["Cpu"] as? String {
                            self.cpu = value
                        }
                        if let value = dict["Memory"] as? String {
                            self.memory = value
                        }
                        if let value = dict["NodeId"] as? String {
                            self.nodeId = value
                        }
                        if let value = dict["NodeRegionId"] as? String {
                            self.nodeRegionId = value
                        }
                        if let value = dict["NodeRole"] as? String {
                            self.nodeRole = value
                        }
                        if let value = dict["NodeZoneId"] as? String {
                            self.nodeZoneId = value
                        }
                        if let value = dict["Status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var DBClusterNode: [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.DBClusterNodes.DBClusterNode]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBClusterNode != nil {
                        var tmp : [Any] = []
                        for k in self.DBClusterNode! {
                            tmp.append(k.toMap())
                        }
                        map["DBClusterNode"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DBClusterNode"] as? [Any?] {
                        var tmp : [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.DBClusterNodes.DBClusterNode] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.DBClusterNodes.DBClusterNode()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.DBClusterNode = tmp
                    }
                }
            }
            public class Extra : Tea.TeaModel {
                public class DBInstanceIds : Tea.TeaModel {
                    public var DBInstanceId: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DBInstanceId"] as? [String] {
                            self.DBInstanceId = value
                        }
                    }
                }
                public var accountSecurityPolicy: String?

                public var DBInstanceIds: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.Extra.DBInstanceIds?

                public var recoveryModel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.DBInstanceIds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountSecurityPolicy != nil {
                        map["AccountSecurityPolicy"] = self.accountSecurityPolicy!
                    }
                    if self.DBInstanceIds != nil {
                        map["DBInstanceIds"] = self.DBInstanceIds?.toMap()
                    }
                    if self.recoveryModel != nil {
                        map["RecoveryModel"] = self.recoveryModel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccountSecurityPolicy"] as? String {
                        self.accountSecurityPolicy = value
                    }
                    if let value = dict["DBInstanceIds"] as? [String: Any?] {
                        var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.Extra.DBInstanceIds()
                        model.fromMap(value)
                        self.DBInstanceIds = model
                    }
                    if let value = dict["RecoveryModel"] as? String {
                        self.recoveryModel = value
                    }
                }
            }
            public class ReadOnlyDBInstanceIds : Tea.TeaModel {
                public class ReadOnlyDBInstanceId : Tea.TeaModel {
                    public var DBInstanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DBInstanceId"] as? String {
                            self.DBInstanceId = value
                        }
                    }
                }
                public var readOnlyDBInstanceId: [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readOnlyDBInstanceId != nil {
                        var tmp : [Any] = []
                        for k in self.readOnlyDBInstanceId! {
                            tmp.append(k.toMap())
                        }
                        map["ReadOnlyDBInstanceId"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadOnlyDBInstanceId"] as? [Any?] {
                        var tmp : [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.readOnlyDBInstanceId = tmp
                    }
                }
            }
            public class ServerlessConfig : Tea.TeaModel {
                public var autoPause: Bool?

                public var scaleMax: Double?

                public var scaleMin: Double?

                public var switchForce: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoPause != nil {
                        map["AutoPause"] = self.autoPause!
                    }
                    if self.scaleMax != nil {
                        map["ScaleMax"] = self.scaleMax!
                    }
                    if self.scaleMin != nil {
                        map["ScaleMin"] = self.scaleMin!
                    }
                    if self.switchForce != nil {
                        map["SwitchForce"] = self.switchForce!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoPause"] as? Bool {
                        self.autoPause = value
                    }
                    if let value = dict["ScaleMax"] as? Double {
                        self.scaleMax = value
                    }
                    if let value = dict["ScaleMin"] as? Double {
                        self.scaleMin = value
                    }
                    if let value = dict["SwitchForce"] as? Bool {
                        self.switchForce = value
                    }
                }
            }
            public class SlaveZones : Tea.TeaModel {
                public class SlaveZone : Tea.TeaModel {
                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var slaveZone: [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.SlaveZones.SlaveZone]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slaveZone != nil {
                        var tmp : [Any] = []
                        for k in self.slaveZone! {
                            tmp.append(k.toMap())
                        }
                        map["SlaveZone"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SlaveZone"] as? [Any?] {
                        var tmp : [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.SlaveZones.SlaveZone] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.SlaveZones.SlaveZone()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.slaveZone = tmp
                    }
                }
            }
            public var accountMaxQuantity: Int32?

            public var advancedFeatures: String?

            public var autoUpgradeMinorVersion: String?

            public var availabilityValue: String?

            public var babelfishConfig: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.BabelfishConfig?

            public var blueGreenDeploymentName: String?

            public var blueInstanceName: String?

            public var bpeEnabled: String?

            public var burstingEnabled: Bool?

            public var canTempUpgrade: Bool?

            public var category: String?

            public var coldDataEnabled: Bool?

            public var collation: String?

            public var compressionMode: String?

            public var compressionRatio: String?

            public var computeBurstEnabled: Bool?

            public var connectionMode: String?

            public var connectionString: String?

            public var consoleVersion: String?

            public var creationTime: String?

            public var currentKernelVersion: String?

            public var DBClusterNodes: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.DBClusterNodes?

            public var DBInstanceCPU: String?

            public var DBInstanceClass: String?

            public var DBInstanceClassType: String?

            public var DBInstanceDescription: String?

            public var DBInstanceDiskUsed: String?

            public var DBInstanceId: String?

            public var DBInstanceMemory: Int64?

            public var DBInstanceNetType: String?

            public var DBInstanceStatus: String?

            public var DBInstanceStorage: Int32?

            public var DBInstanceStorageType: String?

            public var DBInstanceType: String?

            public var DBMaxQuantity: Int32?

            public var dedicatedHostGroupId: String?

            public var deletionProtection: Bool?

            public var disasterRecoveryInfo: String?

            public var disasterRecoveryInstances: String?

            public var engine: String?

            public var engineVersion: String?

            public var expireTime: String?

            public var extra: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.Extra?

            public var generalGroupName: String?

            public var greenInstanceName: String?

            public var guardDBInstanceId: String?

            public var IPType: String?

            public var incrementSourceDBInstanceId: String?

            public var instanceNetworkType: String?

            public var instructionSetArch: String?

            public var ioAccelerationEnabled: String?

            public var latestKernelVersion: String?

            public var lockMode: String?

            public var lockReason: String?

            public var maintainTime: String?

            public var masterInstanceId: String?

            public var masterZone: String?

            public var maxConnections: Int32?

            public var maxIOMBPS: Int32?

            public var maxIOPS: Int32?

            public var multipleTempUpgrade: Bool?

            public var optimizedWritesInfo: String?

            public var PGBouncerEnabled: String?

            public var payType: String?

            public var port: String?

            public var proxyType: Int32?

            public var readOnlyDBInstanceIds: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ReadOnlyDBInstanceIds?

            public var readOnlyStatus: String?

            public var readonlyInstanceSQLDelayedTime: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var securityIPList: String?

            public var securityIPMode: String?

            public var serverlessConfig: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ServerlessConfig?

            public var slaveZones: DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.SlaveZones?

            public var superPermissionMode: String?

            public var supportCompression: Bool?

            public var tempDBInstanceId: String?

            public var tempUpgradeTimeEnd: String?

            public var tempUpgradeTimeStart: String?

            public var timeZone: String?

            public var tips: String?

            public var tipsLevel: Int32?

            public var vSwitchId: String?

            public var vpcCloudInstanceId: String?

            public var vpcId: String?

            public var zoneId: String?

            public var kindCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.babelfishConfig?.validate()
                try self.DBClusterNodes?.validate()
                try self.extra?.validate()
                try self.readOnlyDBInstanceIds?.validate()
                try self.serverlessConfig?.validate()
                try self.slaveZones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountMaxQuantity != nil {
                    map["AccountMaxQuantity"] = self.accountMaxQuantity!
                }
                if self.advancedFeatures != nil {
                    map["AdvancedFeatures"] = self.advancedFeatures!
                }
                if self.autoUpgradeMinorVersion != nil {
                    map["AutoUpgradeMinorVersion"] = self.autoUpgradeMinorVersion!
                }
                if self.availabilityValue != nil {
                    map["AvailabilityValue"] = self.availabilityValue!
                }
                if self.babelfishConfig != nil {
                    map["BabelfishConfig"] = self.babelfishConfig?.toMap()
                }
                if self.blueGreenDeploymentName != nil {
                    map["BlueGreenDeploymentName"] = self.blueGreenDeploymentName!
                }
                if self.blueInstanceName != nil {
                    map["BlueInstanceName"] = self.blueInstanceName!
                }
                if self.bpeEnabled != nil {
                    map["BpeEnabled"] = self.bpeEnabled!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.canTempUpgrade != nil {
                    map["CanTempUpgrade"] = self.canTempUpgrade!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coldDataEnabled != nil {
                    map["ColdDataEnabled"] = self.coldDataEnabled!
                }
                if self.collation != nil {
                    map["Collation"] = self.collation!
                }
                if self.compressionMode != nil {
                    map["CompressionMode"] = self.compressionMode!
                }
                if self.compressionRatio != nil {
                    map["CompressionRatio"] = self.compressionRatio!
                }
                if self.computeBurstEnabled != nil {
                    map["ComputeBurstEnabled"] = self.computeBurstEnabled!
                }
                if self.connectionMode != nil {
                    map["ConnectionMode"] = self.connectionMode!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.consoleVersion != nil {
                    map["ConsoleVersion"] = self.consoleVersion!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.currentKernelVersion != nil {
                    map["CurrentKernelVersion"] = self.currentKernelVersion!
                }
                if self.DBClusterNodes != nil {
                    map["DBClusterNodes"] = self.DBClusterNodes?.toMap()
                }
                if self.DBInstanceCPU != nil {
                    map["DBInstanceCPU"] = self.DBInstanceCPU!
                }
                if self.DBInstanceClass != nil {
                    map["DBInstanceClass"] = self.DBInstanceClass!
                }
                if self.DBInstanceClassType != nil {
                    map["DBInstanceClassType"] = self.DBInstanceClassType!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceDiskUsed != nil {
                    map["DBInstanceDiskUsed"] = self.DBInstanceDiskUsed!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceMemory != nil {
                    map["DBInstanceMemory"] = self.DBInstanceMemory!
                }
                if self.DBInstanceNetType != nil {
                    map["DBInstanceNetType"] = self.DBInstanceNetType!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.DBInstanceStorage != nil {
                    map["DBInstanceStorage"] = self.DBInstanceStorage!
                }
                if self.DBInstanceStorageType != nil {
                    map["DBInstanceStorageType"] = self.DBInstanceStorageType!
                }
                if self.DBInstanceType != nil {
                    map["DBInstanceType"] = self.DBInstanceType!
                }
                if self.DBMaxQuantity != nil {
                    map["DBMaxQuantity"] = self.DBMaxQuantity!
                }
                if self.dedicatedHostGroupId != nil {
                    map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.disasterRecoveryInfo != nil {
                    map["DisasterRecoveryInfo"] = self.disasterRecoveryInfo!
                }
                if self.disasterRecoveryInstances != nil {
                    map["DisasterRecoveryInstances"] = self.disasterRecoveryInstances!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.extra != nil {
                    map["Extra"] = self.extra?.toMap()
                }
                if self.generalGroupName != nil {
                    map["GeneralGroupName"] = self.generalGroupName!
                }
                if self.greenInstanceName != nil {
                    map["GreenInstanceName"] = self.greenInstanceName!
                }
                if self.guardDBInstanceId != nil {
                    map["GuardDBInstanceId"] = self.guardDBInstanceId!
                }
                if self.IPType != nil {
                    map["IPType"] = self.IPType!
                }
                if self.incrementSourceDBInstanceId != nil {
                    map["IncrementSourceDBInstanceId"] = self.incrementSourceDBInstanceId!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.instructionSetArch != nil {
                    map["InstructionSetArch"] = self.instructionSetArch!
                }
                if self.ioAccelerationEnabled != nil {
                    map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
                }
                if self.latestKernelVersion != nil {
                    map["LatestKernelVersion"] = self.latestKernelVersion!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.maintainTime != nil {
                    map["MaintainTime"] = self.maintainTime!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.masterZone != nil {
                    map["MasterZone"] = self.masterZone!
                }
                if self.maxConnections != nil {
                    map["MaxConnections"] = self.maxConnections!
                }
                if self.maxIOMBPS != nil {
                    map["MaxIOMBPS"] = self.maxIOMBPS!
                }
                if self.maxIOPS != nil {
                    map["MaxIOPS"] = self.maxIOPS!
                }
                if self.multipleTempUpgrade != nil {
                    map["MultipleTempUpgrade"] = self.multipleTempUpgrade!
                }
                if self.optimizedWritesInfo != nil {
                    map["OptimizedWritesInfo"] = self.optimizedWritesInfo!
                }
                if self.PGBouncerEnabled != nil {
                    map["PGBouncerEnabled"] = self.PGBouncerEnabled!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.proxyType != nil {
                    map["ProxyType"] = self.proxyType!
                }
                if self.readOnlyDBInstanceIds != nil {
                    map["ReadOnlyDBInstanceIds"] = self.readOnlyDBInstanceIds?.toMap()
                }
                if self.readOnlyStatus != nil {
                    map["ReadOnlyStatus"] = self.readOnlyStatus!
                }
                if self.readonlyInstanceSQLDelayedTime != nil {
                    map["ReadonlyInstanceSQLDelayedTime"] = self.readonlyInstanceSQLDelayedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityIPList != nil {
                    map["SecurityIPList"] = self.securityIPList!
                }
                if self.securityIPMode != nil {
                    map["SecurityIPMode"] = self.securityIPMode!
                }
                if self.serverlessConfig != nil {
                    map["ServerlessConfig"] = self.serverlessConfig?.toMap()
                }
                if self.slaveZones != nil {
                    map["SlaveZones"] = self.slaveZones?.toMap()
                }
                if self.superPermissionMode != nil {
                    map["SuperPermissionMode"] = self.superPermissionMode!
                }
                if self.supportCompression != nil {
                    map["SupportCompression"] = self.supportCompression!
                }
                if self.tempDBInstanceId != nil {
                    map["TempDBInstanceId"] = self.tempDBInstanceId!
                }
                if self.tempUpgradeTimeEnd != nil {
                    map["TempUpgradeTimeEnd"] = self.tempUpgradeTimeEnd!
                }
                if self.tempUpgradeTimeStart != nil {
                    map["TempUpgradeTimeStart"] = self.tempUpgradeTimeStart!
                }
                if self.timeZone != nil {
                    map["TimeZone"] = self.timeZone!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                if self.tipsLevel != nil {
                    map["TipsLevel"] = self.tipsLevel!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcCloudInstanceId != nil {
                    map["VpcCloudInstanceId"] = self.vpcCloudInstanceId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.kindCode != nil {
                    map["kindCode"] = self.kindCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountMaxQuantity"] as? Int32 {
                    self.accountMaxQuantity = value
                }
                if let value = dict["AdvancedFeatures"] as? String {
                    self.advancedFeatures = value
                }
                if let value = dict["AutoUpgradeMinorVersion"] as? String {
                    self.autoUpgradeMinorVersion = value
                }
                if let value = dict["AvailabilityValue"] as? String {
                    self.availabilityValue = value
                }
                if let value = dict["BabelfishConfig"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.BabelfishConfig()
                    model.fromMap(value)
                    self.babelfishConfig = model
                }
                if let value = dict["BlueGreenDeploymentName"] as? String {
                    self.blueGreenDeploymentName = value
                }
                if let value = dict["BlueInstanceName"] as? String {
                    self.blueInstanceName = value
                }
                if let value = dict["BpeEnabled"] as? String {
                    self.bpeEnabled = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["CanTempUpgrade"] as? Bool {
                    self.canTempUpgrade = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["ColdDataEnabled"] as? Bool {
                    self.coldDataEnabled = value
                }
                if let value = dict["Collation"] as? String {
                    self.collation = value
                }
                if let value = dict["CompressionMode"] as? String {
                    self.compressionMode = value
                }
                if let value = dict["CompressionRatio"] as? String {
                    self.compressionRatio = value
                }
                if let value = dict["ComputeBurstEnabled"] as? Bool {
                    self.computeBurstEnabled = value
                }
                if let value = dict["ConnectionMode"] as? String {
                    self.connectionMode = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["ConsoleVersion"] as? String {
                    self.consoleVersion = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["CurrentKernelVersion"] as? String {
                    self.currentKernelVersion = value
                }
                if let value = dict["DBClusterNodes"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.DBClusterNodes()
                    model.fromMap(value)
                    self.DBClusterNodes = model
                }
                if let value = dict["DBInstanceCPU"] as? String {
                    self.DBInstanceCPU = value
                }
                if let value = dict["DBInstanceClass"] as? String {
                    self.DBInstanceClass = value
                }
                if let value = dict["DBInstanceClassType"] as? String {
                    self.DBInstanceClassType = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceDiskUsed"] as? String {
                    self.DBInstanceDiskUsed = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceMemory"] as? Int64 {
                    self.DBInstanceMemory = value
                }
                if let value = dict["DBInstanceNetType"] as? String {
                    self.DBInstanceNetType = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["DBInstanceStorage"] as? Int32 {
                    self.DBInstanceStorage = value
                }
                if let value = dict["DBInstanceStorageType"] as? String {
                    self.DBInstanceStorageType = value
                }
                if let value = dict["DBInstanceType"] as? String {
                    self.DBInstanceType = value
                }
                if let value = dict["DBMaxQuantity"] as? Int32 {
                    self.DBMaxQuantity = value
                }
                if let value = dict["DedicatedHostGroupId"] as? String {
                    self.dedicatedHostGroupId = value
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["DisasterRecoveryInfo"] as? String {
                    self.disasterRecoveryInfo = value
                }
                if let value = dict["DisasterRecoveryInstances"] as? String {
                    self.disasterRecoveryInstances = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["Extra"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.Extra()
                    model.fromMap(value)
                    self.extra = model
                }
                if let value = dict["GeneralGroupName"] as? String {
                    self.generalGroupName = value
                }
                if let value = dict["GreenInstanceName"] as? String {
                    self.greenInstanceName = value
                }
                if let value = dict["GuardDBInstanceId"] as? String {
                    self.guardDBInstanceId = value
                }
                if let value = dict["IPType"] as? String {
                    self.IPType = value
                }
                if let value = dict["IncrementSourceDBInstanceId"] as? String {
                    self.incrementSourceDBInstanceId = value
                }
                if let value = dict["InstanceNetworkType"] as? String {
                    self.instanceNetworkType = value
                }
                if let value = dict["InstructionSetArch"] as? String {
                    self.instructionSetArch = value
                }
                if let value = dict["IoAccelerationEnabled"] as? String {
                    self.ioAccelerationEnabled = value
                }
                if let value = dict["LatestKernelVersion"] as? String {
                    self.latestKernelVersion = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["MaintainTime"] as? String {
                    self.maintainTime = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["MasterZone"] as? String {
                    self.masterZone = value
                }
                if let value = dict["MaxConnections"] as? Int32 {
                    self.maxConnections = value
                }
                if let value = dict["MaxIOMBPS"] as? Int32 {
                    self.maxIOMBPS = value
                }
                if let value = dict["MaxIOPS"] as? Int32 {
                    self.maxIOPS = value
                }
                if let value = dict["MultipleTempUpgrade"] as? Bool {
                    self.multipleTempUpgrade = value
                }
                if let value = dict["OptimizedWritesInfo"] as? String {
                    self.optimizedWritesInfo = value
                }
                if let value = dict["PGBouncerEnabled"] as? String {
                    self.PGBouncerEnabled = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["ProxyType"] as? Int32 {
                    self.proxyType = value
                }
                if let value = dict["ReadOnlyDBInstanceIds"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ReadOnlyDBInstanceIds()
                    model.fromMap(value)
                    self.readOnlyDBInstanceIds = model
                }
                if let value = dict["ReadOnlyStatus"] as? String {
                    self.readOnlyStatus = value
                }
                if let value = dict["ReadonlyInstanceSQLDelayedTime"] as? String {
                    self.readonlyInstanceSQLDelayedTime = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecurityIPList"] as? String {
                    self.securityIPList = value
                }
                if let value = dict["SecurityIPMode"] as? String {
                    self.securityIPMode = value
                }
                if let value = dict["ServerlessConfig"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.ServerlessConfig()
                    model.fromMap(value)
                    self.serverlessConfig = model
                }
                if let value = dict["SlaveZones"] as? [String: Any?] {
                    var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute.SlaveZones()
                    model.fromMap(value)
                    self.slaveZones = model
                }
                if let value = dict["SuperPermissionMode"] as? String {
                    self.superPermissionMode = value
                }
                if let value = dict["SupportCompression"] as? Bool {
                    self.supportCompression = value
                }
                if let value = dict["TempDBInstanceId"] as? String {
                    self.tempDBInstanceId = value
                }
                if let value = dict["TempUpgradeTimeEnd"] as? String {
                    self.tempUpgradeTimeEnd = value
                }
                if let value = dict["TempUpgradeTimeStart"] as? String {
                    self.tempUpgradeTimeStart = value
                }
                if let value = dict["TimeZone"] as? String {
                    self.timeZone = value
                }
                if let value = dict["Tips"] as? String {
                    self.tips = value
                }
                if let value = dict["TipsLevel"] as? Int32 {
                    self.tipsLevel = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcCloudInstanceId"] as? String {
                    self.vpcCloudInstanceId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["kindCode"] as? String {
                    self.kindCode = value
                }
            }
        }
        public var DBInstanceAttribute: [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceAttribute"] as? [Any?] {
                var tmp : [DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceAttributeResponseBody.Items.DBInstanceAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceAttribute = tmp
            }
        }
    }
    public var items: DescribeDBInstanceAttributeResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstanceAttributeResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceByTagsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeDBInstanceByTagsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceTag : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var DBInstanceId: String?

            public var tags: DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var DBInstanceTag: [DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceTag != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceTag! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceTag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceTag"] as? [Any?] {
                var tmp : [DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceByTagsResponseBody.Items.DBInstanceTag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceTag = tmp
            }
        }
    }
    public var items: DescribeDBInstanceByTagsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstanceByTagsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstanceByTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceByTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceByTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceConnectivityRequest : Tea.TeaModel {
    public var dbInstanceName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var sourceIpAddress: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbInstanceName != nil {
            map["DbInstanceName"] = self.dbInstanceName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sourceIpAddress != nil {
            map["SourceIpAddress"] = self.sourceIpAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbInstanceName"] as? String {
            self.dbInstanceName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["SourceIpAddress"] as? String {
            self.sourceIpAddress = value
        }
    }
}

public class DescribeDBInstanceConnectivityResponseBody : Tea.TeaModel {
    public var connCheckErrorCode: String?

    public var connCheckErrorMessage: String?

    public var connCheckResult: String?

    public var dbInstanceName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connCheckErrorCode != nil {
            map["ConnCheckErrorCode"] = self.connCheckErrorCode!
        }
        if self.connCheckErrorMessage != nil {
            map["ConnCheckErrorMessage"] = self.connCheckErrorMessage!
        }
        if self.connCheckResult != nil {
            map["ConnCheckResult"] = self.connCheckResult!
        }
        if self.dbInstanceName != nil {
            map["DbInstanceName"] = self.dbInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnCheckErrorCode"] as? String {
            self.connCheckErrorCode = value
        }
        if let value = dict["ConnCheckErrorMessage"] as? String {
            self.connCheckErrorMessage = value
        }
        if let value = dict["ConnCheckResult"] as? String {
            self.connCheckResult = value
        }
        if let value = dict["DbInstanceName"] as? String {
            self.dbInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceConnectivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceConnectivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceConnectivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceDetailRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceDetailResponseBody : Tea.TeaModel {
    public var activationState: String?

    public var DBInstanceId: String?

    public var licenseType: String?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationState != nil {
            map["ActivationState"] = self.activationState!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActivationState"] as? String {
            self.activationState = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["LicenseType"] as? String {
            self.licenseType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceEncryptionKeyRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var encryptionKey: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var targetRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.targetRegionId != nil {
            map["TargetRegionId"] = self.targetRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["TargetRegionId"] as? String {
            self.targetRegionId = value
        }
    }
}

public class DescribeDBInstanceEncryptionKeyResponseBody : Tea.TeaModel {
    public class EncryptionKeyList : Tea.TeaModel {
        public var aliasName: String?

        public var creator: String?

        public var deleteDate: String?

        public var description_: String?

        public var encryptionKey: String?

        public var encryptionKeyStatus: String?

        public var keyType: String?

        public var keyUsage: String?

        public var materialExpireTime: String?

        public var origin: String?

        public var usedBy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deleteDate != nil {
                map["DeleteDate"] = self.deleteDate!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.encryptionKey != nil {
                map["EncryptionKey"] = self.encryptionKey!
            }
            if self.encryptionKeyStatus != nil {
                map["EncryptionKeyStatus"] = self.encryptionKeyStatus!
            }
            if self.keyType != nil {
                map["KeyType"] = self.keyType!
            }
            if self.keyUsage != nil {
                map["KeyUsage"] = self.keyUsage!
            }
            if self.materialExpireTime != nil {
                map["MaterialExpireTime"] = self.materialExpireTime!
            }
            if self.origin != nil {
                map["Origin"] = self.origin!
            }
            if self.usedBy != nil {
                map["UsedBy"] = self.usedBy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliasName"] as? String {
                self.aliasName = value
            }
            if let value = dict["Creator"] as? String {
                self.creator = value
            }
            if let value = dict["DeleteDate"] as? String {
                self.deleteDate = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EncryptionKey"] as? String {
                self.encryptionKey = value
            }
            if let value = dict["EncryptionKeyStatus"] as? String {
                self.encryptionKeyStatus = value
            }
            if let value = dict["KeyType"] as? String {
                self.keyType = value
            }
            if let value = dict["KeyUsage"] as? String {
                self.keyUsage = value
            }
            if let value = dict["MaterialExpireTime"] as? String {
                self.materialExpireTime = value
            }
            if let value = dict["Origin"] as? String {
                self.origin = value
            }
            if let value = dict["UsedBy"] as? String {
                self.usedBy = value
            }
        }
    }
    public var creator: String?

    public var deleteDate: String?

    public var description_: String?

    public var encryptionKey: String?

    public var encryptionKeyList: [DescribeDBInstanceEncryptionKeyResponseBody.EncryptionKeyList]?

    public var encryptionKeyStatus: String?

    public var keyUsage: String?

    public var materialExpireTime: String?

    public var origin: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.deleteDate != nil {
            map["DeleteDate"] = self.deleteDate!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.encryptionKeyList != nil {
            var tmp : [Any] = []
            for k in self.encryptionKeyList! {
                tmp.append(k.toMap())
            }
            map["EncryptionKeyList"] = tmp
        }
        if self.encryptionKeyStatus != nil {
            map["EncryptionKeyStatus"] = self.encryptionKeyStatus!
        }
        if self.keyUsage != nil {
            map["KeyUsage"] = self.keyUsage!
        }
        if self.materialExpireTime != nil {
            map["MaterialExpireTime"] = self.materialExpireTime!
        }
        if self.origin != nil {
            map["Origin"] = self.origin!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Creator"] as? String {
            self.creator = value
        }
        if let value = dict["DeleteDate"] as? String {
            self.deleteDate = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["EncryptionKeyList"] as? [Any?] {
            var tmp : [DescribeDBInstanceEncryptionKeyResponseBody.EncryptionKeyList] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBInstanceEncryptionKeyResponseBody.EncryptionKeyList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.encryptionKeyList = tmp
        }
        if let value = dict["EncryptionKeyStatus"] as? String {
            self.encryptionKeyStatus = value
        }
        if let value = dict["KeyUsage"] as? String {
            self.keyUsage = value
        }
        if let value = dict["MaterialExpireTime"] as? String {
            self.materialExpireTime = value
        }
        if let value = dict["Origin"] as? String {
            self.origin = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceEncryptionKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceEncryptionKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceEncryptionKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceEndpointsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceEndpointsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DBInstanceEndpoints : Tea.TeaModel {
            public class DBInstanceEndpoint : Tea.TeaModel {
                public class AddressItems : Tea.TeaModel {
                    public class AddressItem : Tea.TeaModel {
                        public var connectionString: String?

                        public var ipAddress: String?

                        public var ipType: String?

                        public var port: String?

                        public var vSwitchId: String?

                        public var vpcId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.connectionString != nil {
                                map["ConnectionString"] = self.connectionString!
                            }
                            if self.ipAddress != nil {
                                map["IpAddress"] = self.ipAddress!
                            }
                            if self.ipType != nil {
                                map["IpType"] = self.ipType!
                            }
                            if self.port != nil {
                                map["Port"] = self.port!
                            }
                            if self.vSwitchId != nil {
                                map["VSwitchId"] = self.vSwitchId!
                            }
                            if self.vpcId != nil {
                                map["VpcId"] = self.vpcId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ConnectionString"] as? String {
                                self.connectionString = value
                            }
                            if let value = dict["IpAddress"] as? String {
                                self.ipAddress = value
                            }
                            if let value = dict["IpType"] as? String {
                                self.ipType = value
                            }
                            if let value = dict["Port"] as? String {
                                self.port = value
                            }
                            if let value = dict["VSwitchId"] as? String {
                                self.vSwitchId = value
                            }
                            if let value = dict["VpcId"] as? String {
                                self.vpcId = value
                            }
                        }
                    }
                    public var addressItem: [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.AddressItems.AddressItem]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.addressItem != nil {
                            var tmp : [Any] = []
                            for k in self.addressItem! {
                                tmp.append(k.toMap())
                            }
                            map["AddressItem"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AddressItem"] as? [Any?] {
                            var tmp : [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.AddressItems.AddressItem] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.AddressItems.AddressItem()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.addressItem = tmp
                        }
                    }
                }
                public class NodeItems : Tea.TeaModel {
                    public class NodeItem : Tea.TeaModel {
                        public var DBInstanceId: String?

                        public var nodeId: String?

                        public var weight: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.DBInstanceId != nil {
                                map["DBInstanceId"] = self.DBInstanceId!
                            }
                            if self.nodeId != nil {
                                map["NodeId"] = self.nodeId!
                            }
                            if self.weight != nil {
                                map["Weight"] = self.weight!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["DBInstanceId"] as? String {
                                self.DBInstanceId = value
                            }
                            if let value = dict["NodeId"] as? String {
                                self.nodeId = value
                            }
                            if let value = dict["Weight"] as? Int32 {
                                self.weight = value
                            }
                        }
                    }
                    public var nodeItem: [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.NodeItems.NodeItem]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.nodeItem != nil {
                            var tmp : [Any] = []
                            for k in self.nodeItem! {
                                tmp.append(k.toMap())
                            }
                            map["NodeItem"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NodeItem"] as? [Any?] {
                            var tmp : [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.NodeItems.NodeItem] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.NodeItems.NodeItem()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.nodeItem = tmp
                        }
                    }
                }
                public var addressItems: DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.AddressItems?

                public var endpointDescription: String?

                public var endpointId: String?

                public var endpointType: String?

                public var nodeItems: DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.NodeItems?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.addressItems?.validate()
                    try self.nodeItems?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addressItems != nil {
                        map["AddressItems"] = self.addressItems?.toMap()
                    }
                    if self.endpointDescription != nil {
                        map["EndpointDescription"] = self.endpointDescription!
                    }
                    if self.endpointId != nil {
                        map["EndpointId"] = self.endpointId!
                    }
                    if self.endpointType != nil {
                        map["EndpointType"] = self.endpointType!
                    }
                    if self.nodeItems != nil {
                        map["NodeItems"] = self.nodeItems?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AddressItems"] as? [String: Any?] {
                        var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.AddressItems()
                        model.fromMap(value)
                        self.addressItems = model
                    }
                    if let value = dict["EndpointDescription"] as? String {
                        self.endpointDescription = value
                    }
                    if let value = dict["EndpointId"] as? String {
                        self.endpointId = value
                    }
                    if let value = dict["EndpointType"] as? String {
                        self.endpointType = value
                    }
                    if let value = dict["NodeItems"] as? [String: Any?] {
                        var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint.NodeItems()
                        model.fromMap(value)
                        self.nodeItems = model
                    }
                }
            }
            public var DBInstanceEndpoint: [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceEndpoint != nil {
                    var tmp : [Any] = []
                    for k in self.DBInstanceEndpoint! {
                        tmp.append(k.toMap())
                    }
                    map["DBInstanceEndpoint"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceEndpoint"] as? [Any?] {
                    var tmp : [DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints.DBInstanceEndpoint()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.DBInstanceEndpoint = tmp
                }
            }
        }
        public var DBInstanceEndpoints: DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints?

        public var DBInstanceName: String?

        public var ipVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.DBInstanceEndpoints?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceEndpoints != nil {
                map["DBInstanceEndpoints"] = self.DBInstanceEndpoints?.toMap()
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceEndpoints"] as? [String: Any?] {
                var model = DescribeDBInstanceEndpointsResponseBody.Data.DBInstanceEndpoints()
                model.fromMap(value)
                self.DBInstanceEndpoints = model
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
            if let value = dict["IpVersion"] as? String {
                self.ipVersion = value
            }
        }
    }
    public var data: DescribeDBInstanceEndpointsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeDBInstanceEndpointsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceEndpointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceHAConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceHAConfigResponseBody : Tea.TeaModel {
    public class HostInstanceInfos : Tea.TeaModel {
        public class NodeInfo : Tea.TeaModel {
            public var dataSyncTime: String?

            public var logSyncTime: String?

            public var nodeId: String?

            public var nodeType: String?

            public var regionId: String?

            public var syncStatus: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSyncTime != nil {
                    map["DataSyncTime"] = self.dataSyncTime!
                }
                if self.logSyncTime != nil {
                    map["LogSyncTime"] = self.logSyncTime!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.syncStatus != nil {
                    map["SyncStatus"] = self.syncStatus!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSyncTime"] as? String {
                    self.dataSyncTime = value
                }
                if let value = dict["LogSyncTime"] as? String {
                    self.logSyncTime = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["NodeType"] as? String {
                    self.nodeType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SyncStatus"] as? String {
                    self.syncStatus = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var nodeInfo: [DescribeDBInstanceHAConfigResponseBody.HostInstanceInfos.NodeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeInfo != nil {
                var tmp : [Any] = []
                for k in self.nodeInfo! {
                    tmp.append(k.toMap())
                }
                map["NodeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NodeInfo"] as? [Any?] {
                var tmp : [DescribeDBInstanceHAConfigResponseBody.HostInstanceInfos.NodeInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceHAConfigResponseBody.HostInstanceInfos.NodeInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeInfo = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var HAMode: String?

    public var hostInstanceInfos: DescribeDBInstanceHAConfigResponseBody.HostInstanceInfos?

    public var requestId: String?

    public var syncMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostInstanceInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.HAMode != nil {
            map["HAMode"] = self.HAMode!
        }
        if self.hostInstanceInfos != nil {
            map["HostInstanceInfos"] = self.hostInstanceInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.syncMode != nil {
            map["SyncMode"] = self.syncMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["HAMode"] as? String {
            self.HAMode = value
        }
        if let value = dict["HostInstanceInfos"] as? [String: Any?] {
            var model = DescribeDBInstanceHAConfigResponseBody.HostInstanceInfos()
            model.fromMap(value)
            self.hostInstanceInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SyncMode"] as? String {
            self.syncMode = value
        }
    }
}

public class DescribeDBInstanceHAConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceHAConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceHAConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceIPArrayListRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var resourceOwnerId: Int64?

    public var whitelistNetworkType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.whitelistNetworkType != nil {
            map["WhitelistNetworkType"] = self.whitelistNetworkType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["WhitelistNetworkType"] as? String {
            self.whitelistNetworkType = value
        }
    }
}

public class DescribeDBInstanceIPArrayListResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceIPArray : Tea.TeaModel {
            public var DBInstanceIPArrayAttribute: String?

            public var DBInstanceIPArrayName: String?

            public var securityIPList: String?

            public var securityIPType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceIPArrayAttribute != nil {
                    map["DBInstanceIPArrayAttribute"] = self.DBInstanceIPArrayAttribute!
                }
                if self.DBInstanceIPArrayName != nil {
                    map["DBInstanceIPArrayName"] = self.DBInstanceIPArrayName!
                }
                if self.securityIPList != nil {
                    map["SecurityIPList"] = self.securityIPList!
                }
                if self.securityIPType != nil {
                    map["SecurityIPType"] = self.securityIPType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceIPArrayAttribute"] as? String {
                    self.DBInstanceIPArrayAttribute = value
                }
                if let value = dict["DBInstanceIPArrayName"] as? String {
                    self.DBInstanceIPArrayName = value
                }
                if let value = dict["SecurityIPList"] as? String {
                    self.securityIPList = value
                }
                if let value = dict["SecurityIPType"] as? String {
                    self.securityIPType = value
                }
            }
        }
        public var DBInstanceIPArray: [DescribeDBInstanceIPArrayListResponseBody.Items.DBInstanceIPArray]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceIPArray != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceIPArray! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceIPArray"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceIPArray"] as? [Any?] {
                var tmp : [DescribeDBInstanceIPArrayListResponseBody.Items.DBInstanceIPArray] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceIPArrayListResponseBody.Items.DBInstanceIPArray()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceIPArray = tmp
            }
        }
    }
    public var items: DescribeDBInstanceIPArrayListResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstanceIPArrayListResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceIPArrayListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceIPArrayListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceIPArrayListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceIpHostnameRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeDBInstanceIpHostnameResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ipHostnameInfos: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ipHostnameInfos != nil {
            map["IpHostnameInfos"] = self.ipHostnameInfos!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["IpHostnameInfos"] as? String {
            self.ipHostnameInfos = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceIpHostnameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceIpHostnameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceIpHostnameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceMetricsRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceMetricsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var description_: String?

        public var dimension: String?

        public var groupKey: String?

        public var groupKeyType: String?

        public var method: String?

        public var metricsKey: String?

        public var metricsKeyAlias: String?

        public var sortRule: Int32?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dimension != nil {
                map["Dimension"] = self.dimension!
            }
            if self.groupKey != nil {
                map["GroupKey"] = self.groupKey!
            }
            if self.groupKeyType != nil {
                map["GroupKeyType"] = self.groupKeyType!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.metricsKey != nil {
                map["MetricsKey"] = self.metricsKey!
            }
            if self.metricsKeyAlias != nil {
                map["MetricsKeyAlias"] = self.metricsKeyAlias!
            }
            if self.sortRule != nil {
                map["SortRule"] = self.sortRule!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Dimension"] as? String {
                self.dimension = value
            }
            if let value = dict["GroupKey"] as? String {
                self.groupKey = value
            }
            if let value = dict["GroupKeyType"] as? String {
                self.groupKeyType = value
            }
            if let value = dict["Method"] as? String {
                self.method = value
            }
            if let value = dict["MetricsKey"] as? String {
                self.metricsKey = value
            }
            if let value = dict["MetricsKeyAlias"] as? String {
                self.metricsKeyAlias = value
            }
            if let value = dict["SortRule"] as? Int32 {
                self.sortRule = value
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public var DBInstanceName: String?

    public var items: [DescribeDBInstanceMetricsResponseBody.Items]?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeDBInstanceMetricsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBInstanceMetricsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstanceMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceMonitorResponseBody : Tea.TeaModel {
    public var period: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceNetInfoRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBInstanceNetRWSplitType: String?

    public var flag: Int32?

    public var generalGroupName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceNetRWSplitType != nil {
            map["DBInstanceNetRWSplitType"] = self.DBInstanceNetRWSplitType!
        }
        if self.flag != nil {
            map["Flag"] = self.flag!
        }
        if self.generalGroupName != nil {
            map["GeneralGroupName"] = self.generalGroupName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceNetRWSplitType"] as? String {
            self.DBInstanceNetRWSplitType = value
        }
        if let value = dict["Flag"] as? Int32 {
            self.flag = value
        }
        if let value = dict["GeneralGroupName"] as? String {
            self.generalGroupName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceNetInfoResponseBody : Tea.TeaModel {
    public class DBInstanceNetInfos : Tea.TeaModel {
        public class DBInstanceNetInfo : Tea.TeaModel {
            public class DBInstanceWeights : Tea.TeaModel {
                public class DBInstanceWeight : Tea.TeaModel {
                    public var availability: String?

                    public var DBInstanceId: String?

                    public var DBInstanceType: String?

                    public var role: String?

                    public var weight: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availability != nil {
                            map["Availability"] = self.availability!
                        }
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        if self.DBInstanceType != nil {
                            map["DBInstanceType"] = self.DBInstanceType!
                        }
                        if self.role != nil {
                            map["Role"] = self.role!
                        }
                        if self.weight != nil {
                            map["Weight"] = self.weight!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Availability"] as? String {
                            self.availability = value
                        }
                        if let value = dict["DBInstanceId"] as? String {
                            self.DBInstanceId = value
                        }
                        if let value = dict["DBInstanceType"] as? String {
                            self.DBInstanceType = value
                        }
                        if let value = dict["Role"] as? String {
                            self.role = value
                        }
                        if let value = dict["Weight"] as? String {
                            self.weight = value
                        }
                    }
                }
                public var DBInstanceWeight: [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBInstanceWeight != nil {
                        var tmp : [Any] = []
                        for k in self.DBInstanceWeight! {
                            tmp.append(k.toMap())
                        }
                        map["DBInstanceWeight"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DBInstanceWeight"] as? [Any?] {
                        var tmp : [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.DBInstanceWeight = tmp
                    }
                }
            }
            public class SecurityIPGroups : Tea.TeaModel {
                public class SecurityIPGroup : Tea.TeaModel {
                    public var securityIPGroupName: String?

                    public var securityIPs: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.securityIPGroupName != nil {
                            map["SecurityIPGroupName"] = self.securityIPGroupName!
                        }
                        if self.securityIPs != nil {
                            map["SecurityIPs"] = self.securityIPs!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SecurityIPGroupName"] as? String {
                            self.securityIPGroupName = value
                        }
                        if let value = dict["SecurityIPs"] as? String {
                            self.securityIPs = value
                        }
                    }
                }
                public var securityIPGroup: [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityIPGroup != nil {
                        var tmp : [Any] = []
                        for k in self.securityIPGroup! {
                            tmp.append(k.toMap())
                        }
                        map["securityIPGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["securityIPGroup"] as? [Any?] {
                        var tmp : [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.securityIPGroup = tmp
                    }
                }
            }
            public var babelfishPort: String?

            public var connectionString: String?

            public var connectionStringType: String?

            public var DBInstanceWeights: DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights?

            public var distributionType: String?

            public var expiredTime: String?

            public var IPAddress: String?

            public var IPType: String?

            public var maxDelayTime: String?

            public var PGBouncerPort: String?

            public var port: String?

            public var securityIPGroups: DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups?

            public var upgradeable: String?

            public var VPCId: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.DBInstanceWeights?.validate()
                try self.securityIPGroups?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.babelfishPort != nil {
                    map["BabelfishPort"] = self.babelfishPort!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.connectionStringType != nil {
                    map["ConnectionStringType"] = self.connectionStringType!
                }
                if self.DBInstanceWeights != nil {
                    map["DBInstanceWeights"] = self.DBInstanceWeights?.toMap()
                }
                if self.distributionType != nil {
                    map["DistributionType"] = self.distributionType!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.IPAddress != nil {
                    map["IPAddress"] = self.IPAddress!
                }
                if self.IPType != nil {
                    map["IPType"] = self.IPType!
                }
                if self.maxDelayTime != nil {
                    map["MaxDelayTime"] = self.maxDelayTime!
                }
                if self.PGBouncerPort != nil {
                    map["PGBouncerPort"] = self.PGBouncerPort!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.securityIPGroups != nil {
                    map["SecurityIPGroups"] = self.securityIPGroups?.toMap()
                }
                if self.upgradeable != nil {
                    map["Upgradeable"] = self.upgradeable!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BabelfishPort"] as? String {
                    self.babelfishPort = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["ConnectionStringType"] as? String {
                    self.connectionStringType = value
                }
                if let value = dict["DBInstanceWeights"] as? [String: Any?] {
                    var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights()
                    model.fromMap(value)
                    self.DBInstanceWeights = model
                }
                if let value = dict["DistributionType"] as? String {
                    self.distributionType = value
                }
                if let value = dict["ExpiredTime"] as? String {
                    self.expiredTime = value
                }
                if let value = dict["IPAddress"] as? String {
                    self.IPAddress = value
                }
                if let value = dict["IPType"] as? String {
                    self.IPType = value
                }
                if let value = dict["MaxDelayTime"] as? String {
                    self.maxDelayTime = value
                }
                if let value = dict["PGBouncerPort"] as? String {
                    self.PGBouncerPort = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["SecurityIPGroups"] as? [String: Any?] {
                    var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups()
                    model.fromMap(value)
                    self.securityIPGroups = model
                }
                if let value = dict["Upgradeable"] as? String {
                    self.upgradeable = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
            }
        }
        public var DBInstanceNetInfo: [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceNetInfo != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceNetInfo! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceNetInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceNetInfo"] as? [Any?] {
                var tmp : [DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos.DBInstanceNetInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceNetInfo = tmp
            }
        }
    }
    public var DBInstanceNetInfos: DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos?

    public var instanceNetworkType: String?

    public var requestId: String?

    public var securityIPMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBInstanceNetInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceNetInfos != nil {
            map["DBInstanceNetInfos"] = self.DBInstanceNetInfos?.toMap()
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIPMode != nil {
            map["SecurityIPMode"] = self.securityIPMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceNetInfos"] as? [String: Any?] {
            var model = DescribeDBInstanceNetInfoResponseBody.DBInstanceNetInfos()
            model.fromMap(value)
            self.DBInstanceNetInfos = model
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityIPMode"] as? String {
            self.securityIPMode = value
        }
    }
}

public class DescribeDBInstanceNetInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceNetInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceNetInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceNetInfoForChannelRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBInstanceNetRWSplitType: String?

    public var flag: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceNetRWSplitType != nil {
            map["DBInstanceNetRWSplitType"] = self.DBInstanceNetRWSplitType!
        }
        if self.flag != nil {
            map["Flag"] = self.flag!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceNetRWSplitType"] as? String {
            self.DBInstanceNetRWSplitType = value
        }
        if let value = dict["Flag"] as? String {
            self.flag = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceNetInfoForChannelResponseBody : Tea.TeaModel {
    public class DBInstanceNetInfos : Tea.TeaModel {
        public class DBInstanceNetInfo : Tea.TeaModel {
            public class DBInstanceWeights : Tea.TeaModel {
                public class DBInstanceWeight : Tea.TeaModel {
                    public var availability: String?

                    public var DBInstanceId: String?

                    public var DBInstanceType: String?

                    public var weight: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availability != nil {
                            map["Availability"] = self.availability!
                        }
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        if self.DBInstanceType != nil {
                            map["DBInstanceType"] = self.DBInstanceType!
                        }
                        if self.weight != nil {
                            map["Weight"] = self.weight!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Availability"] as? String {
                            self.availability = value
                        }
                        if let value = dict["DBInstanceId"] as? String {
                            self.DBInstanceId = value
                        }
                        if let value = dict["DBInstanceType"] as? String {
                            self.DBInstanceType = value
                        }
                        if let value = dict["Weight"] as? String {
                            self.weight = value
                        }
                    }
                }
                public var DBInstanceWeight: [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBInstanceWeight != nil {
                        var tmp : [Any] = []
                        for k in self.DBInstanceWeight! {
                            tmp.append(k.toMap())
                        }
                        map["DBInstanceWeight"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DBInstanceWeight"] as? [Any?] {
                        var tmp : [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights.DBInstanceWeight()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.DBInstanceWeight = tmp
                    }
                }
            }
            public class SecurityIPGroups : Tea.TeaModel {
                public class SecurityIPGroup : Tea.TeaModel {
                    public var securityIPGroupName: String?

                    public var securityIPs: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.securityIPGroupName != nil {
                            map["SecurityIPGroupName"] = self.securityIPGroupName!
                        }
                        if self.securityIPs != nil {
                            map["SecurityIPs"] = self.securityIPs!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SecurityIPGroupName"] as? String {
                            self.securityIPGroupName = value
                        }
                        if let value = dict["SecurityIPs"] as? String {
                            self.securityIPs = value
                        }
                    }
                }
                public var securityIPGroup: [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityIPGroup != nil {
                        var tmp : [Any] = []
                        for k in self.securityIPGroup! {
                            tmp.append(k.toMap())
                        }
                        map["securityIPGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["securityIPGroup"] as? [Any?] {
                        var tmp : [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups.SecurityIPGroup()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.securityIPGroup = tmp
                    }
                }
            }
            public var availability: String?

            public var connectionString: String?

            public var connectionStringType: String?

            public var DBInstanceWeights: DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights?

            public var distributionType: String?

            public var IPAddress: String?

            public var IPType: String?

            public var maxDelayTime: String?

            public var port: String?

            public var securityIPGroups: DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups?

            public var upgradeable: String?

            public var VPCId: String?

            public var vSwitchId: String?

            public var expiredTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.DBInstanceWeights?.validate()
                try self.securityIPGroups?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availability != nil {
                    map["Availability"] = self.availability!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.connectionStringType != nil {
                    map["ConnectionStringType"] = self.connectionStringType!
                }
                if self.DBInstanceWeights != nil {
                    map["DBInstanceWeights"] = self.DBInstanceWeights?.toMap()
                }
                if self.distributionType != nil {
                    map["DistributionType"] = self.distributionType!
                }
                if self.IPAddress != nil {
                    map["IPAddress"] = self.IPAddress!
                }
                if self.IPType != nil {
                    map["IPType"] = self.IPType!
                }
                if self.maxDelayTime != nil {
                    map["MaxDelayTime"] = self.maxDelayTime!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.securityIPGroups != nil {
                    map["SecurityIPGroups"] = self.securityIPGroups?.toMap()
                }
                if self.upgradeable != nil {
                    map["Upgradeable"] = self.upgradeable!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.expiredTime != nil {
                    map["expiredTime"] = self.expiredTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Availability"] as? String {
                    self.availability = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["ConnectionStringType"] as? String {
                    self.connectionStringType = value
                }
                if let value = dict["DBInstanceWeights"] as? [String: Any?] {
                    var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.DBInstanceWeights()
                    model.fromMap(value)
                    self.DBInstanceWeights = model
                }
                if let value = dict["DistributionType"] as? String {
                    self.distributionType = value
                }
                if let value = dict["IPAddress"] as? String {
                    self.IPAddress = value
                }
                if let value = dict["IPType"] as? String {
                    self.IPType = value
                }
                if let value = dict["MaxDelayTime"] as? String {
                    self.maxDelayTime = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["SecurityIPGroups"] as? [String: Any?] {
                    var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo.SecurityIPGroups()
                    model.fromMap(value)
                    self.securityIPGroups = model
                }
                if let value = dict["Upgradeable"] as? String {
                    self.upgradeable = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["expiredTime"] as? String {
                    self.expiredTime = value
                }
            }
        }
        public var DBInstanceNetInfo: [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceNetInfo != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceNetInfo! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceNetInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceNetInfo"] as? [Any?] {
                var tmp : [DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos.DBInstanceNetInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceNetInfo = tmp
            }
        }
    }
    public var DBInstanceNetInfos: DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos?

    public var instanceNetworkType: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBInstanceNetInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceNetInfos != nil {
            map["DBInstanceNetInfos"] = self.DBInstanceNetInfos?.toMap()
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceNetInfos"] as? [String: Any?] {
            var model = DescribeDBInstanceNetInfoForChannelResponseBody.DBInstanceNetInfos()
            model.fromMap(value)
            self.DBInstanceNetInfos = model
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceNetInfoForChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceNetInfoForChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceNetInfoForChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancePerformanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var key: String?

    public var nodeId: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBInstancePerformanceResponseBody : Tea.TeaModel {
    public class PerformanceKeys : Tea.TeaModel {
        public class PerformanceKey : Tea.TeaModel {
            public class Values : Tea.TeaModel {
                public class PerformanceValue : Tea.TeaModel {
                    public var date: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.date != nil {
                            map["Date"] = self.date!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Date"] as? String {
                            self.date = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var performanceValue: [DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.performanceValue != nil {
                        var tmp : [Any] = []
                        for k in self.performanceValue! {
                            tmp.append(k.toMap())
                        }
                        map["PerformanceValue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PerformanceValue"] as? [Any?] {
                        var tmp : [DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.performanceValue = tmp
                    }
                }
            }
            public var key: String?

            public var unit: String?

            public var valueFormat: String?

            public var values: DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey.Values?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.values?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                if self.valueFormat != nil {
                    map["ValueFormat"] = self.valueFormat!
                }
                if self.values != nil {
                    map["Values"] = self.values?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Unit"] as? String {
                    self.unit = value
                }
                if let value = dict["ValueFormat"] as? String {
                    self.valueFormat = value
                }
                if let value = dict["Values"] as? [String: Any?] {
                    var model = DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey.Values()
                    model.fromMap(value)
                    self.values = model
                }
            }
        }
        public var performanceKey: [DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.performanceKey != nil {
                var tmp : [Any] = []
                for k in self.performanceKey! {
                    tmp.append(k.toMap())
                }
                map["PerformanceKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PerformanceKey"] as? [Any?] {
                var tmp : [DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancePerformanceResponseBody.PerformanceKeys.PerformanceKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.performanceKey = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var endTime: String?

    public var engine: String?

    public var performanceKeys: DescribeDBInstancePerformanceResponseBody.PerformanceKeys?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.performanceKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.performanceKeys != nil {
            map["PerformanceKeys"] = self.performanceKeys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["PerformanceKeys"] as? [String: Any?] {
            var model = DescribeDBInstancePerformanceResponseBody.PerformanceKeys()
            model.fromMap(value)
            self.performanceKeys = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBInstancePerformanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancePerformanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancePerformanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancePromoteActivityRequest : Tea.TeaModel {
    public var aliUid: String?

    public var dbInstanceName: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUid != nil {
            map["AliUid"] = self.aliUid!
        }
        if self.dbInstanceName != nil {
            map["DbInstanceName"] = self.dbInstanceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliUid"] as? String {
            self.aliUid = value
        }
        if let value = dict["DbInstanceName"] as? String {
            self.dbInstanceName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstancePromoteActivityResponseBody : Tea.TeaModel {
    public var aliUid: String?

    public var bid: String?

    public var DBInstanceId: String?

    public var DBInstanceName: String?

    public var DBType: String?

    public var isActivity: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUid != nil {
            map["AliUid"] = self.aliUid!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBType != nil {
            map["DBType"] = self.DBType!
        }
        if self.isActivity != nil {
            map["IsActivity"] = self.isActivity!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliUid"] as? String {
            self.aliUid = value
        }
        if let value = dict["Bid"] as? String {
            self.bid = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBType"] as? String {
            self.DBType = value
        }
        if let value = dict["IsActivity"] as? String {
            self.isActivity = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstancePromoteActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancePromoteActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancePromoteActivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceProxyConfigurationRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceProxyConfigurationResponseBody : Tea.TeaModel {
    public var attacksProtectionConfiguration: String?

    public var persistentConnectionsConfiguration: String?

    public var requestId: String?

    public var transparentSwitchConfiguration: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attacksProtectionConfiguration != nil {
            map["AttacksProtectionConfiguration"] = self.attacksProtectionConfiguration!
        }
        if self.persistentConnectionsConfiguration != nil {
            map["PersistentConnectionsConfiguration"] = self.persistentConnectionsConfiguration!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transparentSwitchConfiguration != nil {
            map["TransparentSwitchConfiguration"] = self.transparentSwitchConfiguration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttacksProtectionConfiguration"] as? String {
            self.attacksProtectionConfiguration = value
        }
        if let value = dict["PersistentConnectionsConfiguration"] as? String {
            self.persistentConnectionsConfiguration = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TransparentSwitchConfiguration"] as? String {
            self.transparentSwitchConfiguration = value
        }
    }
}

public class DescribeDBInstanceProxyConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceProxyConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceProxyConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceReplicationRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DescribeDBInstanceReplicationResponseBody : Tea.TeaModel {
    public var externalReplication: String?

    public var replicationDelay: String?

    public var replicationErrorMessage: String?

    public var replicationSource: String?

    public var replicationState: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalReplication != nil {
            map["ExternalReplication"] = self.externalReplication!
        }
        if self.replicationDelay != nil {
            map["ReplicationDelay"] = self.replicationDelay!
        }
        if self.replicationErrorMessage != nil {
            map["ReplicationErrorMessage"] = self.replicationErrorMessage!
        }
        if self.replicationSource != nil {
            map["ReplicationSource"] = self.replicationSource!
        }
        if self.replicationState != nil {
            map["ReplicationState"] = self.replicationState!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExternalReplication"] as? String {
            self.externalReplication = value
        }
        if let value = dict["ReplicationDelay"] as? String {
            self.replicationDelay = value
        }
        if let value = dict["ReplicationErrorMessage"] as? String {
            self.replicationErrorMessage = value
        }
        if let value = dict["ReplicationSource"] as? String {
            self.replicationSource = value
        }
        if let value = dict["ReplicationState"] as? String {
            self.replicationState = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceReplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceReplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceReplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceSSLRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceSSLResponseBody : Tea.TeaModel {
    public var ACL: String?

    public var CAType: String?

    public var clientCACert: String?

    public var clientCACertExpireTime: String?

    public var clientCertRevocationList: String?

    public var connectionString: String?

    public var forceEncryption: String?

    public var lastModifyStatus: String?

    public var modifyStatusReason: String?

    public var replicationACL: String?

    public var requestId: String?

    public var requireUpdate: String?

    public var requireUpdateItem: String?

    public var requireUpdateReason: String?

    public var SSLCreateTime: String?

    public var SSLEnabled: String?

    public var SSLExpireTime: String?

    public var serverCAUrl: String?

    public var serverCert: String?

    public var serverKey: String?

    public var tlsVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ACL != nil {
            map["ACL"] = self.ACL!
        }
        if self.CAType != nil {
            map["CAType"] = self.CAType!
        }
        if self.clientCACert != nil {
            map["ClientCACert"] = self.clientCACert!
        }
        if self.clientCACertExpireTime != nil {
            map["ClientCACertExpireTime"] = self.clientCACertExpireTime!
        }
        if self.clientCertRevocationList != nil {
            map["ClientCertRevocationList"] = self.clientCertRevocationList!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.forceEncryption != nil {
            map["ForceEncryption"] = self.forceEncryption!
        }
        if self.lastModifyStatus != nil {
            map["LastModifyStatus"] = self.lastModifyStatus!
        }
        if self.modifyStatusReason != nil {
            map["ModifyStatusReason"] = self.modifyStatusReason!
        }
        if self.replicationACL != nil {
            map["ReplicationACL"] = self.replicationACL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requireUpdate != nil {
            map["RequireUpdate"] = self.requireUpdate!
        }
        if self.requireUpdateItem != nil {
            map["RequireUpdateItem"] = self.requireUpdateItem!
        }
        if self.requireUpdateReason != nil {
            map["RequireUpdateReason"] = self.requireUpdateReason!
        }
        if self.SSLCreateTime != nil {
            map["SSLCreateTime"] = self.SSLCreateTime!
        }
        if self.SSLEnabled != nil {
            map["SSLEnabled"] = self.SSLEnabled!
        }
        if self.SSLExpireTime != nil {
            map["SSLExpireTime"] = self.SSLExpireTime!
        }
        if self.serverCAUrl != nil {
            map["ServerCAUrl"] = self.serverCAUrl!
        }
        if self.serverCert != nil {
            map["ServerCert"] = self.serverCert!
        }
        if self.serverKey != nil {
            map["ServerKey"] = self.serverKey!
        }
        if self.tlsVersion != nil {
            map["TlsVersion"] = self.tlsVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ACL"] as? String {
            self.ACL = value
        }
        if let value = dict["CAType"] as? String {
            self.CAType = value
        }
        if let value = dict["ClientCACert"] as? String {
            self.clientCACert = value
        }
        if let value = dict["ClientCACertExpireTime"] as? String {
            self.clientCACertExpireTime = value
        }
        if let value = dict["ClientCertRevocationList"] as? String {
            self.clientCertRevocationList = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["ForceEncryption"] as? String {
            self.forceEncryption = value
        }
        if let value = dict["LastModifyStatus"] as? String {
            self.lastModifyStatus = value
        }
        if let value = dict["ModifyStatusReason"] as? String {
            self.modifyStatusReason = value
        }
        if let value = dict["ReplicationACL"] as? String {
            self.replicationACL = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RequireUpdate"] as? String {
            self.requireUpdate = value
        }
        if let value = dict["RequireUpdateItem"] as? String {
            self.requireUpdateItem = value
        }
        if let value = dict["RequireUpdateReason"] as? String {
            self.requireUpdateReason = value
        }
        if let value = dict["SSLCreateTime"] as? String {
            self.SSLCreateTime = value
        }
        if let value = dict["SSLEnabled"] as? String {
            self.SSLEnabled = value
        }
        if let value = dict["SSLExpireTime"] as? String {
            self.SSLExpireTime = value
        }
        if let value = dict["ServerCAUrl"] as? String {
            self.serverCAUrl = value
        }
        if let value = dict["ServerCert"] as? String {
            self.serverCert = value
        }
        if let value = dict["ServerKey"] as? String {
            self.serverKey = value
        }
        if let value = dict["TlsVersion"] as? String {
            self.tlsVersion = value
        }
    }
}

public class DescribeDBInstanceSSLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceSSLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceSSLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceSecurityGroupRuleRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstanceSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceSecurityGroupRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstanceTDERequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstanceTDEResponseBody : Tea.TeaModel {
    public class Databases : Tea.TeaModel {
        public class Database : Tea.TeaModel {
            public var DBName: String?

            public var TDEStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.TDEStatus != nil {
                    map["TDEStatus"] = self.TDEStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["TDEStatus"] as? String {
                    self.TDEStatus = value
                }
            }
        }
        public var database: [DescribeDBInstanceTDEResponseBody.Databases.Database]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                var tmp : [Any] = []
                for k in self.database! {
                    tmp.append(k.toMap())
                }
                map["Database"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Database"] as? [Any?] {
                var tmp : [DescribeDBInstanceTDEResponseBody.Databases.Database] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstanceTDEResponseBody.Databases.Database()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.database = tmp
            }
        }
    }
    public var databases: DescribeDBInstanceTDEResponseBody.Databases?

    public var encryptionKey: String?

    public var requestId: String?

    public var TDEMode: String?

    public var TDEStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databases?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databases != nil {
            map["Databases"] = self.databases?.toMap()
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.TDEMode != nil {
            map["TDEMode"] = self.TDEMode!
        }
        if self.TDEStatus != nil {
            map["TDEStatus"] = self.TDEStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Databases"] as? [String: Any?] {
            var model = DescribeDBInstanceTDEResponseBody.Databases()
            model.fromMap(value)
            self.databases = model
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TDEMode"] as? String {
            self.TDEMode = value
        }
        if let value = dict["TDEStatus"] as? String {
            self.TDEStatus = value
        }
    }
}

public class DescribeDBInstanceTDEResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstanceTDEResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstanceTDEResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancesRequest : Tea.TeaModel {
    public var category: String?

    public var clientToken: String?

    public var connectionMode: String?

    public var connectionString: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStatus: String?

    public var DBInstanceType: String?

    public var dedicatedHostGroupId: String?

    public var dedicatedHostId: String?

    public var engine: String?

    public var engineVersion: String?

    public var expired: String?

    public var filter: String?

    public var instanceLevel: Int32?

    public var instanceNetworkType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var searchKey: String?

    public var tags: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionMode != nil {
            map["ConnectionMode"] = self.connectionMode!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStatus != nil {
            map["DBInstanceStatus"] = self.DBInstanceStatus!
        }
        if self.DBInstanceType != nil {
            map["DBInstanceType"] = self.DBInstanceType!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.expired != nil {
            map["Expired"] = self.expired!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.instanceLevel != nil {
            map["InstanceLevel"] = self.instanceLevel!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionMode"] as? String {
            self.connectionMode = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStatus"] as? String {
            self.DBInstanceStatus = value
        }
        if let value = dict["DBInstanceType"] as? String {
            self.DBInstanceType = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["Expired"] as? String {
            self.expired = value
        }
        if let value = dict["Filter"] as? String {
            self.filter = value
        }
        if let value = dict["InstanceLevel"] as? Int32 {
            self.instanceLevel = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["MaxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SearchKey"] as? String {
            self.searchKey = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeDBInstancesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstance : Tea.TeaModel {
            public class ReadOnlyDBInstanceIds : Tea.TeaModel {
                public class ReadOnlyDBInstanceId : Tea.TeaModel {
                    public var DBInstanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DBInstanceId"] as? String {
                            self.DBInstanceId = value
                        }
                    }
                }
                public var readOnlyDBInstanceId: [DescribeDBInstancesResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readOnlyDBInstanceId != nil {
                        var tmp : [Any] = []
                        for k in self.readOnlyDBInstanceId! {
                            tmp.append(k.toMap())
                        }
                        map["ReadOnlyDBInstanceId"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadOnlyDBInstanceId"] as? [Any?] {
                        var tmp : [DescribeDBInstancesResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstancesResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.readOnlyDBInstanceId = tmp
                    }
                }
            }
            public var blueGreenDeploymentName: String?

            public var blueInstanceName: String?

            public var bpeEnabled: String?

            public var burstingEnabled: Bool?

            public var category: String?

            public var coldDataEnabled: Bool?

            public var connectionMode: String?

            public var connectionString: String?

            public var createTime: String?

            public var DBInstanceCPU: String?

            public var DBInstanceClass: String?

            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var DBInstanceMemory: Int32?

            public var DBInstanceNetType: String?

            public var DBInstanceStatus: String?

            public var DBInstanceStorageType: String?

            public var DBInstanceType: String?

            public var dedicatedHostGroupId: String?

            public var dedicatedHostGroupName: String?

            public var dedicatedHostIdForLog: String?

            public var dedicatedHostIdForMaster: String?

            public var dedicatedHostIdForSlave: String?

            public var dedicatedHostNameForLog: String?

            public var dedicatedHostNameForMaster: String?

            public var dedicatedHostNameForSlave: String?

            public var dedicatedHostZoneIdForLog: String?

            public var dedicatedHostZoneIdForMaster: String?

            public var dedicatedHostZoneIdForSlave: String?

            public var deletionProtection: Bool?

            public var destroyTime: String?

            public var engine: String?

            public var engineVersion: String?

            public var expireTime: String?

            public var generalGroupName: String?

            public var greenInstanceName: String?

            public var guardDBInstanceId: String?

            public var instanceNetworkType: String?

            public var ioAccelerationEnabled: String?

            public var lockMode: String?

            public var lockReason: String?

            public var masterInstanceId: String?

            public var mutriORsignle: Bool?

            public var payType: String?

            public var readOnlyDBInstanceIds: DescribeDBInstancesResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds?

            public var regionId: String?

            public var resourceGroupId: String?

            public var switchWeight: Int32?

            public var tempDBInstanceId: String?

            public var tips: String?

            public var tipsLevel: Int32?

            public var vSwitchId: String?

            public var vpcCloudInstanceId: String?

            public var vpcId: String?

            public var vpcName: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.readOnlyDBInstanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blueGreenDeploymentName != nil {
                    map["BlueGreenDeploymentName"] = self.blueGreenDeploymentName!
                }
                if self.blueInstanceName != nil {
                    map["BlueInstanceName"] = self.blueInstanceName!
                }
                if self.bpeEnabled != nil {
                    map["BpeEnabled"] = self.bpeEnabled!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.coldDataEnabled != nil {
                    map["ColdDataEnabled"] = self.coldDataEnabled!
                }
                if self.connectionMode != nil {
                    map["ConnectionMode"] = self.connectionMode!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.DBInstanceCPU != nil {
                    map["DBInstanceCPU"] = self.DBInstanceCPU!
                }
                if self.DBInstanceClass != nil {
                    map["DBInstanceClass"] = self.DBInstanceClass!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceMemory != nil {
                    map["DBInstanceMemory"] = self.DBInstanceMemory!
                }
                if self.DBInstanceNetType != nil {
                    map["DBInstanceNetType"] = self.DBInstanceNetType!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.DBInstanceStorageType != nil {
                    map["DBInstanceStorageType"] = self.DBInstanceStorageType!
                }
                if self.DBInstanceType != nil {
                    map["DBInstanceType"] = self.DBInstanceType!
                }
                if self.dedicatedHostGroupId != nil {
                    map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
                }
                if self.dedicatedHostGroupName != nil {
                    map["DedicatedHostGroupName"] = self.dedicatedHostGroupName!
                }
                if self.dedicatedHostIdForLog != nil {
                    map["DedicatedHostIdForLog"] = self.dedicatedHostIdForLog!
                }
                if self.dedicatedHostIdForMaster != nil {
                    map["DedicatedHostIdForMaster"] = self.dedicatedHostIdForMaster!
                }
                if self.dedicatedHostIdForSlave != nil {
                    map["DedicatedHostIdForSlave"] = self.dedicatedHostIdForSlave!
                }
                if self.dedicatedHostNameForLog != nil {
                    map["DedicatedHostNameForLog"] = self.dedicatedHostNameForLog!
                }
                if self.dedicatedHostNameForMaster != nil {
                    map["DedicatedHostNameForMaster"] = self.dedicatedHostNameForMaster!
                }
                if self.dedicatedHostNameForSlave != nil {
                    map["DedicatedHostNameForSlave"] = self.dedicatedHostNameForSlave!
                }
                if self.dedicatedHostZoneIdForLog != nil {
                    map["DedicatedHostZoneIdForLog"] = self.dedicatedHostZoneIdForLog!
                }
                if self.dedicatedHostZoneIdForMaster != nil {
                    map["DedicatedHostZoneIdForMaster"] = self.dedicatedHostZoneIdForMaster!
                }
                if self.dedicatedHostZoneIdForSlave != nil {
                    map["DedicatedHostZoneIdForSlave"] = self.dedicatedHostZoneIdForSlave!
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.destroyTime != nil {
                    map["DestroyTime"] = self.destroyTime!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.generalGroupName != nil {
                    map["GeneralGroupName"] = self.generalGroupName!
                }
                if self.greenInstanceName != nil {
                    map["GreenInstanceName"] = self.greenInstanceName!
                }
                if self.guardDBInstanceId != nil {
                    map["GuardDBInstanceId"] = self.guardDBInstanceId!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.ioAccelerationEnabled != nil {
                    map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.mutriORsignle != nil {
                    map["MutriORsignle"] = self.mutriORsignle!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.readOnlyDBInstanceIds != nil {
                    map["ReadOnlyDBInstanceIds"] = self.readOnlyDBInstanceIds?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.switchWeight != nil {
                    map["SwitchWeight"] = self.switchWeight!
                }
                if self.tempDBInstanceId != nil {
                    map["TempDBInstanceId"] = self.tempDBInstanceId!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                if self.tipsLevel != nil {
                    map["TipsLevel"] = self.tipsLevel!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcCloudInstanceId != nil {
                    map["VpcCloudInstanceId"] = self.vpcCloudInstanceId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BlueGreenDeploymentName"] as? String {
                    self.blueGreenDeploymentName = value
                }
                if let value = dict["BlueInstanceName"] as? String {
                    self.blueInstanceName = value
                }
                if let value = dict["BpeEnabled"] as? String {
                    self.bpeEnabled = value
                }
                if let value = dict["BurstingEnabled"] as? Bool {
                    self.burstingEnabled = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["ColdDataEnabled"] as? Bool {
                    self.coldDataEnabled = value
                }
                if let value = dict["ConnectionMode"] as? String {
                    self.connectionMode = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DBInstanceCPU"] as? String {
                    self.DBInstanceCPU = value
                }
                if let value = dict["DBInstanceClass"] as? String {
                    self.DBInstanceClass = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceMemory"] as? Int32 {
                    self.DBInstanceMemory = value
                }
                if let value = dict["DBInstanceNetType"] as? String {
                    self.DBInstanceNetType = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["DBInstanceStorageType"] as? String {
                    self.DBInstanceStorageType = value
                }
                if let value = dict["DBInstanceType"] as? String {
                    self.DBInstanceType = value
                }
                if let value = dict["DedicatedHostGroupId"] as? String {
                    self.dedicatedHostGroupId = value
                }
                if let value = dict["DedicatedHostGroupName"] as? String {
                    self.dedicatedHostGroupName = value
                }
                if let value = dict["DedicatedHostIdForLog"] as? String {
                    self.dedicatedHostIdForLog = value
                }
                if let value = dict["DedicatedHostIdForMaster"] as? String {
                    self.dedicatedHostIdForMaster = value
                }
                if let value = dict["DedicatedHostIdForSlave"] as? String {
                    self.dedicatedHostIdForSlave = value
                }
                if let value = dict["DedicatedHostNameForLog"] as? String {
                    self.dedicatedHostNameForLog = value
                }
                if let value = dict["DedicatedHostNameForMaster"] as? String {
                    self.dedicatedHostNameForMaster = value
                }
                if let value = dict["DedicatedHostNameForSlave"] as? String {
                    self.dedicatedHostNameForSlave = value
                }
                if let value = dict["DedicatedHostZoneIdForLog"] as? String {
                    self.dedicatedHostZoneIdForLog = value
                }
                if let value = dict["DedicatedHostZoneIdForMaster"] as? String {
                    self.dedicatedHostZoneIdForMaster = value
                }
                if let value = dict["DedicatedHostZoneIdForSlave"] as? String {
                    self.dedicatedHostZoneIdForSlave = value
                }
                if let value = dict["DeletionProtection"] as? Bool {
                    self.deletionProtection = value
                }
                if let value = dict["DestroyTime"] as? String {
                    self.destroyTime = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["GeneralGroupName"] as? String {
                    self.generalGroupName = value
                }
                if let value = dict["GreenInstanceName"] as? String {
                    self.greenInstanceName = value
                }
                if let value = dict["GuardDBInstanceId"] as? String {
                    self.guardDBInstanceId = value
                }
                if let value = dict["InstanceNetworkType"] as? String {
                    self.instanceNetworkType = value
                }
                if let value = dict["IoAccelerationEnabled"] as? String {
                    self.ioAccelerationEnabled = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["MutriORsignle"] as? Bool {
                    self.mutriORsignle = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["ReadOnlyDBInstanceIds"] as? [String: Any?] {
                    var model = DescribeDBInstancesResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds()
                    model.fromMap(value)
                    self.readOnlyDBInstanceIds = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SwitchWeight"] as? Int32 {
                    self.switchWeight = value
                }
                if let value = dict["TempDBInstanceId"] as? String {
                    self.tempDBInstanceId = value
                }
                if let value = dict["Tips"] as? String {
                    self.tips = value
                }
                if let value = dict["TipsLevel"] as? Int32 {
                    self.tipsLevel = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcCloudInstanceId"] as? String {
                    self.vpcCloudInstanceId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VpcName"] as? String {
                    self.vpcName = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBInstance: [DescribeDBInstancesResponseBody.Items.DBInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstance != nil {
                var tmp : [Any] = []
                for k in self.DBInstance! {
                    tmp.append(k.toMap())
                }
                map["DBInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstance"] as? [Any?] {
                var tmp : [DescribeDBInstancesResponseBody.Items.DBInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancesResponseBody.Items.DBInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstance = tmp
            }
        }
    }
    public var items: DescribeDBInstancesResponseBody.Items?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstancesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancesAsCsvRequest : Tea.TeaModel {
    public var cachedAsync: Bool?

    public var DBInstanceId: String?

    public var exportKey: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cachedAsync != nil {
            map["CachedAsync"] = self.cachedAsync!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.exportKey != nil {
            map["ExportKey"] = self.exportKey!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CachedAsync"] as? Bool {
            self.cachedAsync = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ExportKey"] as? String {
            self.exportKey = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBInstancesAsCsvResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceAttribute : Tea.TeaModel {
            public class SlaveZones : Tea.TeaModel {
                public var slaveRegion: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slaveRegion != nil {
                        map["slaveRegion"] = self.slaveRegion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["slaveRegion"] as? [String] {
                        self.slaveRegion = value
                    }
                }
            }
            public var accountMaxQuantity: Int32?

            public var accountType: String?

            public var availabilityValue: String?

            public var category: String?

            public var connectionMode: String?

            public var connectionString: String?

            public var creationTime: String?

            public var DBInstanceCPU: String?

            public var DBInstanceClass: String?

            public var DBInstanceClassType: String?

            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var DBInstanceMemory: Int64?

            public var DBInstanceNetType: String?

            public var DBInstanceStatus: String?

            public var DBInstanceStorage: Int32?

            public var DBInstanceType: String?

            public var DBMaxQuantity: Int32?

            public var engine: String?

            public var engineVersion: String?

            public var expireTime: String?

            public var exportKey: String?

            public var guardDBInstanceId: String?

            public var incrementSourceDBInstanceId: String?

            public var instanceNetworkType: String?

            public var lockMode: String?

            public var lockReason: String?

            public var maintainTime: String?

            public var masterInstanceId: String?

            public var maxConnections: Int32?

            public var maxIOPS: Int32?

            public var payType: String?

            public var port: String?

            public var readDelayTime: String?

            public var regionId: String?

            public var securityIPList: String?

            public var slaveZones: DescribeDBInstancesAsCsvResponseBody.Items.DBInstanceAttribute.SlaveZones?

            public var supportUpgradeAccountType: String?

            public var tags: String?

            public var tempDBInstanceId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.slaveZones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountMaxQuantity != nil {
                    map["AccountMaxQuantity"] = self.accountMaxQuantity!
                }
                if self.accountType != nil {
                    map["AccountType"] = self.accountType!
                }
                if self.availabilityValue != nil {
                    map["AvailabilityValue"] = self.availabilityValue!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.connectionMode != nil {
                    map["ConnectionMode"] = self.connectionMode!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.DBInstanceCPU != nil {
                    map["DBInstanceCPU"] = self.DBInstanceCPU!
                }
                if self.DBInstanceClass != nil {
                    map["DBInstanceClass"] = self.DBInstanceClass!
                }
                if self.DBInstanceClassType != nil {
                    map["DBInstanceClassType"] = self.DBInstanceClassType!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceMemory != nil {
                    map["DBInstanceMemory"] = self.DBInstanceMemory!
                }
                if self.DBInstanceNetType != nil {
                    map["DBInstanceNetType"] = self.DBInstanceNetType!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.DBInstanceStorage != nil {
                    map["DBInstanceStorage"] = self.DBInstanceStorage!
                }
                if self.DBInstanceType != nil {
                    map["DBInstanceType"] = self.DBInstanceType!
                }
                if self.DBMaxQuantity != nil {
                    map["DBMaxQuantity"] = self.DBMaxQuantity!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.exportKey != nil {
                    map["ExportKey"] = self.exportKey!
                }
                if self.guardDBInstanceId != nil {
                    map["GuardDBInstanceId"] = self.guardDBInstanceId!
                }
                if self.incrementSourceDBInstanceId != nil {
                    map["IncrementSourceDBInstanceId"] = self.incrementSourceDBInstanceId!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.maintainTime != nil {
                    map["MaintainTime"] = self.maintainTime!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.maxConnections != nil {
                    map["MaxConnections"] = self.maxConnections!
                }
                if self.maxIOPS != nil {
                    map["MaxIOPS"] = self.maxIOPS!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.readDelayTime != nil {
                    map["ReadDelayTime"] = self.readDelayTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityIPList != nil {
                    map["SecurityIPList"] = self.securityIPList!
                }
                if self.slaveZones != nil {
                    map["SlaveZones"] = self.slaveZones?.toMap()
                }
                if self.supportUpgradeAccountType != nil {
                    map["SupportUpgradeAccountType"] = self.supportUpgradeAccountType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.tempDBInstanceId != nil {
                    map["TempDBInstanceId"] = self.tempDBInstanceId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountMaxQuantity"] as? Int32 {
                    self.accountMaxQuantity = value
                }
                if let value = dict["AccountType"] as? String {
                    self.accountType = value
                }
                if let value = dict["AvailabilityValue"] as? String {
                    self.availabilityValue = value
                }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["ConnectionMode"] as? String {
                    self.connectionMode = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DBInstanceCPU"] as? String {
                    self.DBInstanceCPU = value
                }
                if let value = dict["DBInstanceClass"] as? String {
                    self.DBInstanceClass = value
                }
                if let value = dict["DBInstanceClassType"] as? String {
                    self.DBInstanceClassType = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceMemory"] as? Int64 {
                    self.DBInstanceMemory = value
                }
                if let value = dict["DBInstanceNetType"] as? String {
                    self.DBInstanceNetType = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["DBInstanceStorage"] as? Int32 {
                    self.DBInstanceStorage = value
                }
                if let value = dict["DBInstanceType"] as? String {
                    self.DBInstanceType = value
                }
                if let value = dict["DBMaxQuantity"] as? Int32 {
                    self.DBMaxQuantity = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["ExportKey"] as? String {
                    self.exportKey = value
                }
                if let value = dict["GuardDBInstanceId"] as? String {
                    self.guardDBInstanceId = value
                }
                if let value = dict["IncrementSourceDBInstanceId"] as? String {
                    self.incrementSourceDBInstanceId = value
                }
                if let value = dict["InstanceNetworkType"] as? String {
                    self.instanceNetworkType = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["MaintainTime"] as? String {
                    self.maintainTime = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["MaxConnections"] as? Int32 {
                    self.maxConnections = value
                }
                if let value = dict["MaxIOPS"] as? Int32 {
                    self.maxIOPS = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["ReadDelayTime"] as? String {
                    self.readDelayTime = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecurityIPList"] as? String {
                    self.securityIPList = value
                }
                if let value = dict["SlaveZones"] as? [String: Any?] {
                    var model = DescribeDBInstancesAsCsvResponseBody.Items.DBInstanceAttribute.SlaveZones()
                    model.fromMap(value)
                    self.slaveZones = model
                }
                if let value = dict["SupportUpgradeAccountType"] as? String {
                    self.supportUpgradeAccountType = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
                if let value = dict["TempDBInstanceId"] as? String {
                    self.tempDBInstanceId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBInstanceAttribute: [DescribeDBInstancesAsCsvResponseBody.Items.DBInstanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceAttribute"] as? [Any?] {
                var tmp : [DescribeDBInstancesAsCsvResponseBody.Items.DBInstanceAttribute] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancesAsCsvResponseBody.Items.DBInstanceAttribute()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceAttribute = tmp
            }
        }
    }
    public var items: DescribeDBInstancesAsCsvResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstancesAsCsvResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBInstancesAsCsvResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancesAsCsvResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancesAsCsvResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancesByExpireTimeRequest : Tea.TeaModel {
    public var expirePeriod: Int32?

    public var expired: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expirePeriod != nil {
            map["ExpirePeriod"] = self.expirePeriod!
        }
        if self.expired != nil {
            map["Expired"] = self.expired!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ExpirePeriod"] as? Int32 {
            self.expirePeriod = value
        }
        if let value = dict["Expired"] as? Bool {
            self.expired = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeDBInstancesByExpireTimeResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstanceExpireTime : Tea.TeaModel {
            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var DBInstanceStatus: String?

            public var expireTime: String?

            public var lockMode: String?

            public var payType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
            }
        }
        public var DBInstanceExpireTime: [DescribeDBInstancesByExpireTimeResponseBody.Items.DBInstanceExpireTime]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceExpireTime != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceExpireTime! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceExpireTime"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceExpireTime"] as? [Any?] {
                var tmp : [DescribeDBInstancesByExpireTimeResponseBody.Items.DBInstanceExpireTime] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancesByExpireTimeResponseBody.Items.DBInstanceExpireTime()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceExpireTime = tmp
            }
        }
    }
    public var items: DescribeDBInstancesByExpireTimeResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstancesByExpireTimeResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstancesByExpireTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancesByExpireTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancesByExpireTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancesByPerformanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var tag: [DescribeDBInstancesByPerformanceRequest.Tag]?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sortKey: String?

    public var sortMethod: String?

    public var tags: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sortKey != nil {
            map["SortKey"] = self.sortKey!
        }
        if self.sortMethod != nil {
            map["SortMethod"] = self.sortMethod!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDBInstancesByPerformanceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBInstancesByPerformanceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SortKey"] as? String {
            self.sortKey = value
        }
        if let value = dict["SortMethod"] as? String {
            self.sortMethod = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeDBInstancesByPerformanceResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstancePerformance : Tea.TeaModel {
            public var CPUUsage: String?

            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var diskUsage: String?

            public var IOPSUsage: String?

            public var sessionUsage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CPUUsage != nil {
                    map["CPUUsage"] = self.CPUUsage!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.diskUsage != nil {
                    map["DiskUsage"] = self.diskUsage!
                }
                if self.IOPSUsage != nil {
                    map["IOPSUsage"] = self.IOPSUsage!
                }
                if self.sessionUsage != nil {
                    map["SessionUsage"] = self.sessionUsage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CPUUsage"] as? String {
                    self.CPUUsage = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DiskUsage"] as? String {
                    self.diskUsage = value
                }
                if let value = dict["IOPSUsage"] as? String {
                    self.IOPSUsage = value
                }
                if let value = dict["SessionUsage"] as? String {
                    self.sessionUsage = value
                }
            }
        }
        public var DBInstancePerformance: [DescribeDBInstancesByPerformanceResponseBody.Items.DBInstancePerformance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstancePerformance != nil {
                var tmp : [Any] = []
                for k in self.DBInstancePerformance! {
                    tmp.append(k.toMap())
                }
                map["DBInstancePerformance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstancePerformance"] as? [Any?] {
                var tmp : [DescribeDBInstancesByPerformanceResponseBody.Items.DBInstancePerformance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancesByPerformanceResponseBody.Items.DBInstancePerformance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstancePerformance = tmp
            }
        }
    }
    public var items: DescribeDBInstancesByPerformanceResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstancesByPerformanceResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstancesByPerformanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancesByPerformanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancesByPerformanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBInstancesForCloneRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionMode: String?

    public var currentInstanceId: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStatus: String?

    public var DBInstanceType: String?

    public var engine: String?

    public var engineVersion: String?

    public var expired: String?

    public var instanceNetworkType: String?

    public var nodeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var searchKey: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionMode != nil {
            map["ConnectionMode"] = self.connectionMode!
        }
        if self.currentInstanceId != nil {
            map["CurrentInstanceId"] = self.currentInstanceId!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStatus != nil {
            map["DBInstanceStatus"] = self.DBInstanceStatus!
        }
        if self.DBInstanceType != nil {
            map["DBInstanceType"] = self.DBInstanceType!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.expired != nil {
            map["Expired"] = self.expired!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionMode"] as? String {
            self.connectionMode = value
        }
        if let value = dict["CurrentInstanceId"] as? String {
            self.currentInstanceId = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStatus"] as? String {
            self.DBInstanceStatus = value
        }
        if let value = dict["DBInstanceType"] as? String {
            self.DBInstanceType = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["Expired"] as? String {
            self.expired = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SearchKey"] as? String {
            self.searchKey = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeDBInstancesForCloneResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBInstance : Tea.TeaModel {
            public class ReadOnlyDBInstanceIds : Tea.TeaModel {
                public class ReadOnlyDBInstanceId : Tea.TeaModel {
                    public var DBInstanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.DBInstanceId != nil {
                            map["DBInstanceId"] = self.DBInstanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DBInstanceId"] as? String {
                            self.DBInstanceId = value
                        }
                    }
                }
                public var readOnlyDBInstanceId: [DescribeDBInstancesForCloneResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readOnlyDBInstanceId != nil {
                        var tmp : [Any] = []
                        for k in self.readOnlyDBInstanceId! {
                            tmp.append(k.toMap())
                        }
                        map["ReadOnlyDBInstanceId"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadOnlyDBInstanceId"] as? [Any?] {
                        var tmp : [DescribeDBInstancesForCloneResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBInstancesForCloneResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds.ReadOnlyDBInstanceId()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.readOnlyDBInstanceId = tmp
                    }
                }
            }
            public var category: String?

            public var connectionMode: String?

            public var createTime: String?

            public var DBInstanceClass: String?

            public var DBInstanceDescription: String?

            public var DBInstanceId: String?

            public var DBInstanceNetType: String?

            public var DBInstanceStatus: String?

            public var DBInstanceStorageType: String?

            public var DBInstanceType: String?

            public var destroyTime: String?

            public var engine: String?

            public var engineVersion: String?

            public var expireTime: String?

            public var guardDBInstanceId: String?

            public var insId: Int32?

            public var instanceNetworkType: String?

            public var lockMode: String?

            public var lockReason: String?

            public var masterInstanceId: String?

            public var mutriORsignle: Bool?

            public var payType: String?

            public var readOnlyDBInstanceIds: DescribeDBInstancesForCloneResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds?

            public var regionId: String?

            public var replicateId: String?

            public var resourceGroupId: String?

            public var tempDBInstanceId: String?

            public var vSwitchId: String?

            public var vpcCloudInstanceId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.readOnlyDBInstanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.connectionMode != nil {
                    map["ConnectionMode"] = self.connectionMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.DBInstanceClass != nil {
                    map["DBInstanceClass"] = self.DBInstanceClass!
                }
                if self.DBInstanceDescription != nil {
                    map["DBInstanceDescription"] = self.DBInstanceDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBInstanceNetType != nil {
                    map["DBInstanceNetType"] = self.DBInstanceNetType!
                }
                if self.DBInstanceStatus != nil {
                    map["DBInstanceStatus"] = self.DBInstanceStatus!
                }
                if self.DBInstanceStorageType != nil {
                    map["DBInstanceStorageType"] = self.DBInstanceStorageType!
                }
                if self.DBInstanceType != nil {
                    map["DBInstanceType"] = self.DBInstanceType!
                }
                if self.destroyTime != nil {
                    map["DestroyTime"] = self.destroyTime!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.guardDBInstanceId != nil {
                    map["GuardDBInstanceId"] = self.guardDBInstanceId!
                }
                if self.insId != nil {
                    map["InsId"] = self.insId!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.mutriORsignle != nil {
                    map["MutriORsignle"] = self.mutriORsignle!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.readOnlyDBInstanceIds != nil {
                    map["ReadOnlyDBInstanceIds"] = self.readOnlyDBInstanceIds?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.replicateId != nil {
                    map["ReplicateId"] = self.replicateId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tempDBInstanceId != nil {
                    map["TempDBInstanceId"] = self.tempDBInstanceId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcCloudInstanceId != nil {
                    map["VpcCloudInstanceId"] = self.vpcCloudInstanceId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["ConnectionMode"] as? String {
                    self.connectionMode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DBInstanceClass"] as? String {
                    self.DBInstanceClass = value
                }
                if let value = dict["DBInstanceDescription"] as? String {
                    self.DBInstanceDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBInstanceNetType"] as? String {
                    self.DBInstanceNetType = value
                }
                if let value = dict["DBInstanceStatus"] as? String {
                    self.DBInstanceStatus = value
                }
                if let value = dict["DBInstanceStorageType"] as? String {
                    self.DBInstanceStorageType = value
                }
                if let value = dict["DBInstanceType"] as? String {
                    self.DBInstanceType = value
                }
                if let value = dict["DestroyTime"] as? String {
                    self.destroyTime = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["GuardDBInstanceId"] as? String {
                    self.guardDBInstanceId = value
                }
                if let value = dict["InsId"] as? Int32 {
                    self.insId = value
                }
                if let value = dict["InstanceNetworkType"] as? String {
                    self.instanceNetworkType = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["MasterInstanceId"] as? String {
                    self.masterInstanceId = value
                }
                if let value = dict["MutriORsignle"] as? Bool {
                    self.mutriORsignle = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["ReadOnlyDBInstanceIds"] as? [String: Any?] {
                    var model = DescribeDBInstancesForCloneResponseBody.Items.DBInstance.ReadOnlyDBInstanceIds()
                    model.fromMap(value)
                    self.readOnlyDBInstanceIds = model
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReplicateId"] as? String {
                    self.replicateId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["TempDBInstanceId"] as? String {
                    self.tempDBInstanceId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcCloudInstanceId"] as? String {
                    self.vpcCloudInstanceId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBInstance: [DescribeDBInstancesForCloneResponseBody.Items.DBInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstance != nil {
                var tmp : [Any] = []
                for k in self.DBInstance! {
                    tmp.append(k.toMap())
                }
                map["DBInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstance"] as? [Any?] {
                var tmp : [DescribeDBInstancesForCloneResponseBody.Items.DBInstance] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBInstancesForCloneResponseBody.Items.DBInstance()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstance = tmp
            }
        }
    }
    public var items: DescribeDBInstancesForCloneResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBInstancesForCloneResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDBInstancesForCloneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBInstancesForCloneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBInstancesForCloneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBMiniEngineVersionsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var dedicatedHostGroupId: String?

    public var engine: String?

    public var engineVersion: String?

    public var minorVersionTag: String?

    public var nodeType: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var storageType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.minorVersionTag != nil {
            map["MinorVersionTag"] = self.minorVersionTag!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["MinorVersionTag"] as? String {
            self.minorVersionTag = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageType"] as? String {
            self.storageType = value
        }
    }
}

public class DescribeDBMiniEngineVersionsResponseBody : Tea.TeaModel {
    public class MinorVersionItems : Tea.TeaModel {
        public var communityMinorVersion: String?

        public var engine: String?

        public var engineVersion: String?

        public var expireDate: String?

        public var expireStatus: String?

        public var isHotfixVersion: Bool?

        public var minorVersion: String?

        public var nodeType: String?

        public var releaseNote: String?

        public var releaseType: String?

        public var statusDesc: String?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.communityMinorVersion != nil {
                map["CommunityMinorVersion"] = self.communityMinorVersion!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineVersion != nil {
                map["EngineVersion"] = self.engineVersion!
            }
            if self.expireDate != nil {
                map["ExpireDate"] = self.expireDate!
            }
            if self.expireStatus != nil {
                map["ExpireStatus"] = self.expireStatus!
            }
            if self.isHotfixVersion != nil {
                map["IsHotfixVersion"] = self.isHotfixVersion!
            }
            if self.minorVersion != nil {
                map["MinorVersion"] = self.minorVersion!
            }
            if self.nodeType != nil {
                map["NodeType"] = self.nodeType!
            }
            if self.releaseNote != nil {
                map["ReleaseNote"] = self.releaseNote!
            }
            if self.releaseType != nil {
                map["ReleaseType"] = self.releaseType!
            }
            if self.statusDesc != nil {
                map["StatusDesc"] = self.statusDesc!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CommunityMinorVersion"] as? String {
                self.communityMinorVersion = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineVersion"] as? String {
                self.engineVersion = value
            }
            if let value = dict["ExpireDate"] as? String {
                self.expireDate = value
            }
            if let value = dict["ExpireStatus"] as? String {
                self.expireStatus = value
            }
            if let value = dict["IsHotfixVersion"] as? Bool {
                self.isHotfixVersion = value
            }
            if let value = dict["MinorVersion"] as? String {
                self.minorVersion = value
            }
            if let value = dict["NodeType"] as? String {
                self.nodeType = value
            }
            if let value = dict["ReleaseNote"] as? String {
                self.releaseNote = value
            }
            if let value = dict["ReleaseType"] as? String {
                self.releaseType = value
            }
            if let value = dict["StatusDesc"] as? String {
                self.statusDesc = value
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var DBInstanceId: String?

    public var maxRecordsPerPage: Int32?

    public var minorVersionItems: [DescribeDBMiniEngineVersionsResponseBody.MinorVersionItems]?

    public var pageNumbers: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.maxRecordsPerPage != nil {
            map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
        }
        if self.minorVersionItems != nil {
            var tmp : [Any] = []
            for k in self.minorVersionItems! {
                tmp.append(k.toMap())
            }
            map["MinorVersionItems"] = tmp
        }
        if self.pageNumbers != nil {
            map["PageNumbers"] = self.pageNumbers!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["MaxRecordsPerPage"] as? Int32 {
            self.maxRecordsPerPage = value
        }
        if let value = dict["MinorVersionItems"] as? [Any?] {
            var tmp : [DescribeDBMiniEngineVersionsResponseBody.MinorVersionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBMiniEngineVersionsResponseBody.MinorVersionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.minorVersionItems = tmp
        }
        if let value = dict["PageNumbers"] as? Int32 {
            self.pageNumbers = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDBMiniEngineVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBMiniEngineVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBMiniEngineVersionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBProxyRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBProxyResponseBody : Tea.TeaModel {
    public class DBProxyAVZones : Tea.TeaModel {
        public var DBProxyAVZones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBProxyAVZones != nil {
                map["DBProxyAVZones"] = self.DBProxyAVZones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBProxyAVZones"] as? [String] {
                self.DBProxyAVZones = value
            }
        }
    }
    public class DBProxyConnectStringItems : Tea.TeaModel {
        public class DBProxyConnectStringItems : Tea.TeaModel {
            public var DBProxyConnectString: String?

            public var DBProxyConnectStringNetType: String?

            public var DBProxyConnectStringNetWorkType: String?

            public var DBProxyConnectStringPort: String?

            public var DBProxyEndpointId: String?

            public var DBProxyEndpointName: String?

            public var DBProxyVpcId: String?

            public var DBProxyVpcInstanceId: String?

            public var DBProxyVswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBProxyConnectString != nil {
                    map["DBProxyConnectString"] = self.DBProxyConnectString!
                }
                if self.DBProxyConnectStringNetType != nil {
                    map["DBProxyConnectStringNetType"] = self.DBProxyConnectStringNetType!
                }
                if self.DBProxyConnectStringNetWorkType != nil {
                    map["DBProxyConnectStringNetWorkType"] = self.DBProxyConnectStringNetWorkType!
                }
                if self.DBProxyConnectStringPort != nil {
                    map["DBProxyConnectStringPort"] = self.DBProxyConnectStringPort!
                }
                if self.DBProxyEndpointId != nil {
                    map["DBProxyEndpointId"] = self.DBProxyEndpointId!
                }
                if self.DBProxyEndpointName != nil {
                    map["DBProxyEndpointName"] = self.DBProxyEndpointName!
                }
                if self.DBProxyVpcId != nil {
                    map["DBProxyVpcId"] = self.DBProxyVpcId!
                }
                if self.DBProxyVpcInstanceId != nil {
                    map["DBProxyVpcInstanceId"] = self.DBProxyVpcInstanceId!
                }
                if self.DBProxyVswitchId != nil {
                    map["DBProxyVswitchId"] = self.DBProxyVswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBProxyConnectString"] as? String {
                    self.DBProxyConnectString = value
                }
                if let value = dict["DBProxyConnectStringNetType"] as? String {
                    self.DBProxyConnectStringNetType = value
                }
                if let value = dict["DBProxyConnectStringNetWorkType"] as? String {
                    self.DBProxyConnectStringNetWorkType = value
                }
                if let value = dict["DBProxyConnectStringPort"] as? String {
                    self.DBProxyConnectStringPort = value
                }
                if let value = dict["DBProxyEndpointId"] as? String {
                    self.DBProxyEndpointId = value
                }
                if let value = dict["DBProxyEndpointName"] as? String {
                    self.DBProxyEndpointName = value
                }
                if let value = dict["DBProxyVpcId"] as? String {
                    self.DBProxyVpcId = value
                }
                if let value = dict["DBProxyVpcInstanceId"] as? String {
                    self.DBProxyVpcInstanceId = value
                }
                if let value = dict["DBProxyVswitchId"] as? String {
                    self.DBProxyVswitchId = value
                }
            }
        }
        public var DBProxyConnectStringItems: [DescribeDBProxyResponseBody.DBProxyConnectStringItems.DBProxyConnectStringItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBProxyConnectStringItems != nil {
                var tmp : [Any] = []
                for k in self.DBProxyConnectStringItems! {
                    tmp.append(k.toMap())
                }
                map["DBProxyConnectStringItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBProxyConnectStringItems"] as? [Any?] {
                var tmp : [DescribeDBProxyResponseBody.DBProxyConnectStringItems.DBProxyConnectStringItems] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyResponseBody.DBProxyConnectStringItems.DBProxyConnectStringItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBProxyConnectStringItems = tmp
            }
        }
    }
    public class DBProxyNodes : Tea.TeaModel {
        public class DBProxyNodes : Tea.TeaModel {
            public var cpuCores: String?

            public var nodeId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCores != nil {
                    map["cpuCores"] = self.cpuCores!
                }
                if self.nodeId != nil {
                    map["nodeId"] = self.nodeId!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cpuCores"] as? String {
                    self.cpuCores = value
                }
                if let value = dict["nodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBProxyNodes: [DescribeDBProxyResponseBody.DBProxyNodes.DBProxyNodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBProxyNodes != nil {
                var tmp : [Any] = []
                for k in self.DBProxyNodes! {
                    tmp.append(k.toMap())
                }
                map["DBProxyNodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBProxyNodes"] as? [Any?] {
                var tmp : [DescribeDBProxyResponseBody.DBProxyNodes.DBProxyNodes] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyResponseBody.DBProxyNodes.DBProxyNodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBProxyNodes = tmp
            }
        }
    }
    public class DbProxyEndpointItems : Tea.TeaModel {
        public class DbProxyEndpointItems : Tea.TeaModel {
            public var dbProxyEndpointAliases: String?

            public var dbProxyEndpointName: String?

            public var dbProxyEndpointType: String?

            public var dbProxyReadWriteMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbProxyEndpointAliases != nil {
                    map["DbProxyEndpointAliases"] = self.dbProxyEndpointAliases!
                }
                if self.dbProxyEndpointName != nil {
                    map["DbProxyEndpointName"] = self.dbProxyEndpointName!
                }
                if self.dbProxyEndpointType != nil {
                    map["DbProxyEndpointType"] = self.dbProxyEndpointType!
                }
                if self.dbProxyReadWriteMode != nil {
                    map["DbProxyReadWriteMode"] = self.dbProxyReadWriteMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DbProxyEndpointAliases"] as? String {
                    self.dbProxyEndpointAliases = value
                }
                if let value = dict["DbProxyEndpointName"] as? String {
                    self.dbProxyEndpointName = value
                }
                if let value = dict["DbProxyEndpointType"] as? String {
                    self.dbProxyEndpointType = value
                }
                if let value = dict["DbProxyReadWriteMode"] as? String {
                    self.dbProxyReadWriteMode = value
                }
            }
        }
        public var dbProxyEndpointItems: [DescribeDBProxyResponseBody.DbProxyEndpointItems.DbProxyEndpointItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbProxyEndpointItems != nil {
                var tmp : [Any] = []
                for k in self.dbProxyEndpointItems! {
                    tmp.append(k.toMap())
                }
                map["DbProxyEndpointItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbProxyEndpointItems"] as? [Any?] {
                var tmp : [DescribeDBProxyResponseBody.DbProxyEndpointItems.DbProxyEndpointItems] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyResponseBody.DbProxyEndpointItems.DbProxyEndpointItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dbProxyEndpointItems = tmp
            }
        }
    }
    public var DBProxyAVZones: DescribeDBProxyResponseBody.DBProxyAVZones?

    public var DBProxyConnectStringItems: DescribeDBProxyResponseBody.DBProxyConnectStringItems?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceCurrentMinorVersion: String?

    public var DBProxyInstanceLatestMinorVersion: String?

    public var DBProxyInstanceName: String?

    public var DBProxyInstanceNum: Int32?

    public var DBProxyInstanceSize: String?

    public var DBProxyInstanceStatus: String?

    public var DBProxyInstanceType: String?

    public var DBProxyKindCode: String?

    public var DBProxyNodes: DescribeDBProxyResponseBody.DBProxyNodes?

    public var DBProxyPersistentConnectionStatus: String?

    public var DBProxyServiceStatus: String?

    public var dbProxyEndpointItems: DescribeDBProxyResponseBody.DbProxyEndpointItems?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBProxyAVZones?.validate()
        try self.DBProxyConnectStringItems?.validate()
        try self.DBProxyNodes?.validate()
        try self.dbProxyEndpointItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBProxyAVZones != nil {
            map["DBProxyAVZones"] = self.DBProxyAVZones?.toMap()
        }
        if self.DBProxyConnectStringItems != nil {
            map["DBProxyConnectStringItems"] = self.DBProxyConnectStringItems?.toMap()
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceCurrentMinorVersion != nil {
            map["DBProxyInstanceCurrentMinorVersion"] = self.DBProxyInstanceCurrentMinorVersion!
        }
        if self.DBProxyInstanceLatestMinorVersion != nil {
            map["DBProxyInstanceLatestMinorVersion"] = self.DBProxyInstanceLatestMinorVersion!
        }
        if self.DBProxyInstanceName != nil {
            map["DBProxyInstanceName"] = self.DBProxyInstanceName!
        }
        if self.DBProxyInstanceNum != nil {
            map["DBProxyInstanceNum"] = self.DBProxyInstanceNum!
        }
        if self.DBProxyInstanceSize != nil {
            map["DBProxyInstanceSize"] = self.DBProxyInstanceSize!
        }
        if self.DBProxyInstanceStatus != nil {
            map["DBProxyInstanceStatus"] = self.DBProxyInstanceStatus!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.DBProxyKindCode != nil {
            map["DBProxyKindCode"] = self.DBProxyKindCode!
        }
        if self.DBProxyNodes != nil {
            map["DBProxyNodes"] = self.DBProxyNodes?.toMap()
        }
        if self.DBProxyPersistentConnectionStatus != nil {
            map["DBProxyPersistentConnectionStatus"] = self.DBProxyPersistentConnectionStatus!
        }
        if self.DBProxyServiceStatus != nil {
            map["DBProxyServiceStatus"] = self.DBProxyServiceStatus!
        }
        if self.dbProxyEndpointItems != nil {
            map["DbProxyEndpointItems"] = self.dbProxyEndpointItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBProxyAVZones"] as? [String: Any?] {
            var model = DescribeDBProxyResponseBody.DBProxyAVZones()
            model.fromMap(value)
            self.DBProxyAVZones = model
        }
        if let value = dict["DBProxyConnectStringItems"] as? [String: Any?] {
            var model = DescribeDBProxyResponseBody.DBProxyConnectStringItems()
            model.fromMap(value)
            self.DBProxyConnectStringItems = model
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceCurrentMinorVersion"] as? String {
            self.DBProxyInstanceCurrentMinorVersion = value
        }
        if let value = dict["DBProxyInstanceLatestMinorVersion"] as? String {
            self.DBProxyInstanceLatestMinorVersion = value
        }
        if let value = dict["DBProxyInstanceName"] as? String {
            self.DBProxyInstanceName = value
        }
        if let value = dict["DBProxyInstanceNum"] as? Int32 {
            self.DBProxyInstanceNum = value
        }
        if let value = dict["DBProxyInstanceSize"] as? String {
            self.DBProxyInstanceSize = value
        }
        if let value = dict["DBProxyInstanceStatus"] as? String {
            self.DBProxyInstanceStatus = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["DBProxyKindCode"] as? String {
            self.DBProxyKindCode = value
        }
        if let value = dict["DBProxyNodes"] as? [String: Any?] {
            var model = DescribeDBProxyResponseBody.DBProxyNodes()
            model.fromMap(value)
            self.DBProxyNodes = model
        }
        if let value = dict["DBProxyPersistentConnectionStatus"] as? String {
            self.DBProxyPersistentConnectionStatus = value
        }
        if let value = dict["DBProxyServiceStatus"] as? String {
            self.DBProxyServiceStatus = value
        }
        if let value = dict["DbProxyEndpointItems"] as? [String: Any?] {
            var model = DescribeDBProxyResponseBody.DbProxyEndpointItems()
            model.fromMap(value)
            self.dbProxyEndpointItems = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DescribeDBProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBProxyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBProxyEndpointRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyConnectString: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEngineType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyConnectString != nil {
            map["DBProxyConnectString"] = self.DBProxyConnectString!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyConnectString"] as? String {
            self.DBProxyConnectString = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBProxyEndpointResponseBody : Tea.TeaModel {
    public class DBProxyNodes : Tea.TeaModel {
        public class DBProxyNodes : Tea.TeaModel {
            public var cpuCores: String?

            public var nodeId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCores != nil {
                    map["cpuCores"] = self.cpuCores!
                }
                if self.nodeId != nil {
                    map["nodeId"] = self.nodeId!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cpuCores"] as? String {
                    self.cpuCores = value
                }
                if let value = dict["nodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBProxyNodes: [DescribeDBProxyEndpointResponseBody.DBProxyNodes.DBProxyNodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBProxyNodes != nil {
                var tmp : [Any] = []
                for k in self.DBProxyNodes! {
                    tmp.append(k.toMap())
                }
                map["DBProxyNodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBProxyNodes"] as? [Any?] {
                var tmp : [DescribeDBProxyEndpointResponseBody.DBProxyNodes.DBProxyNodes] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyEndpointResponseBody.DBProxyNodes.DBProxyNodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBProxyNodes = tmp
            }
        }
    }
    public class EndpointConnectItems : Tea.TeaModel {
        public class EndpointConnectItems : Tea.TeaModel {
            public var dbProxyEndpointConnectString: String?

            public var dbProxyEndpointNetType: String?

            public var dbProxyEndpointPort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbProxyEndpointConnectString != nil {
                    map["DbProxyEndpointConnectString"] = self.dbProxyEndpointConnectString!
                }
                if self.dbProxyEndpointNetType != nil {
                    map["DbProxyEndpointNetType"] = self.dbProxyEndpointNetType!
                }
                if self.dbProxyEndpointPort != nil {
                    map["DbProxyEndpointPort"] = self.dbProxyEndpointPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DbProxyEndpointConnectString"] as? String {
                    self.dbProxyEndpointConnectString = value
                }
                if let value = dict["DbProxyEndpointNetType"] as? String {
                    self.dbProxyEndpointNetType = value
                }
                if let value = dict["DbProxyEndpointPort"] as? String {
                    self.dbProxyEndpointPort = value
                }
            }
        }
        public var endpointConnectItems: [DescribeDBProxyEndpointResponseBody.EndpointConnectItems.EndpointConnectItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointConnectItems != nil {
                var tmp : [Any] = []
                for k in self.endpointConnectItems! {
                    tmp.append(k.toMap())
                }
                map["EndpointConnectItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EndpointConnectItems"] as? [Any?] {
                var tmp : [DescribeDBProxyEndpointResponseBody.EndpointConnectItems.EndpointConnectItems] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyEndpointResponseBody.EndpointConnectItems.EndpointConnectItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.endpointConnectItems = tmp
            }
        }
    }
    public var causalConsistReadTimeout: String?

    public var DBProxyConnectString: String?

    public var DBProxyConnectStringNetType: String?

    public var DBProxyConnectStringPort: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEndpointMinSlaveCount: String?

    public var DBProxyEngineType: String?

    public var DBProxyFeatures: String?

    public var DBProxyNodes: DescribeDBProxyEndpointResponseBody.DBProxyNodes?

    public var dbProxyEndpointAliases: String?

    public var dbProxyEndpointReadWriteMode: String?

    public var dbProxyEndpointVpcId: String?

    public var dbProxyEndpointVswitchId: String?

    public var dbProxyEndpointZoneId: String?

    public var endpointConnectItems: DescribeDBProxyEndpointResponseBody.EndpointConnectItems?

    public var readOnlyInstanceDistributionType: String?

    public var readOnlyInstanceMaxDelayTime: String?

    public var readOnlyInstanceWeight: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.DBProxyNodes?.validate()
        try self.endpointConnectItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.causalConsistReadTimeout != nil {
            map["CausalConsistReadTimeout"] = self.causalConsistReadTimeout!
        }
        if self.DBProxyConnectString != nil {
            map["DBProxyConnectString"] = self.DBProxyConnectString!
        }
        if self.DBProxyConnectStringNetType != nil {
            map["DBProxyConnectStringNetType"] = self.DBProxyConnectStringNetType!
        }
        if self.DBProxyConnectStringPort != nil {
            map["DBProxyConnectStringPort"] = self.DBProxyConnectStringPort!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEndpointMinSlaveCount != nil {
            map["DBProxyEndpointMinSlaveCount"] = self.DBProxyEndpointMinSlaveCount!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyFeatures != nil {
            map["DBProxyFeatures"] = self.DBProxyFeatures!
        }
        if self.DBProxyNodes != nil {
            map["DBProxyNodes"] = self.DBProxyNodes?.toMap()
        }
        if self.dbProxyEndpointAliases != nil {
            map["DbProxyEndpointAliases"] = self.dbProxyEndpointAliases!
        }
        if self.dbProxyEndpointReadWriteMode != nil {
            map["DbProxyEndpointReadWriteMode"] = self.dbProxyEndpointReadWriteMode!
        }
        if self.dbProxyEndpointVpcId != nil {
            map["DbProxyEndpointVpcId"] = self.dbProxyEndpointVpcId!
        }
        if self.dbProxyEndpointVswitchId != nil {
            map["DbProxyEndpointVswitchId"] = self.dbProxyEndpointVswitchId!
        }
        if self.dbProxyEndpointZoneId != nil {
            map["DbProxyEndpointZoneId"] = self.dbProxyEndpointZoneId!
        }
        if self.endpointConnectItems != nil {
            map["EndpointConnectItems"] = self.endpointConnectItems?.toMap()
        }
        if self.readOnlyInstanceDistributionType != nil {
            map["ReadOnlyInstanceDistributionType"] = self.readOnlyInstanceDistributionType!
        }
        if self.readOnlyInstanceMaxDelayTime != nil {
            map["ReadOnlyInstanceMaxDelayTime"] = self.readOnlyInstanceMaxDelayTime!
        }
        if self.readOnlyInstanceWeight != nil {
            map["ReadOnlyInstanceWeight"] = self.readOnlyInstanceWeight!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CausalConsistReadTimeout"] as? String {
            self.causalConsistReadTimeout = value
        }
        if let value = dict["DBProxyConnectString"] as? String {
            self.DBProxyConnectString = value
        }
        if let value = dict["DBProxyConnectStringNetType"] as? String {
            self.DBProxyConnectStringNetType = value
        }
        if let value = dict["DBProxyConnectStringPort"] as? String {
            self.DBProxyConnectStringPort = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEndpointMinSlaveCount"] as? String {
            self.DBProxyEndpointMinSlaveCount = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyFeatures"] as? String {
            self.DBProxyFeatures = value
        }
        if let value = dict["DBProxyNodes"] as? [String: Any?] {
            var model = DescribeDBProxyEndpointResponseBody.DBProxyNodes()
            model.fromMap(value)
            self.DBProxyNodes = model
        }
        if let value = dict["DbProxyEndpointAliases"] as? String {
            self.dbProxyEndpointAliases = value
        }
        if let value = dict["DbProxyEndpointReadWriteMode"] as? String {
            self.dbProxyEndpointReadWriteMode = value
        }
        if let value = dict["DbProxyEndpointVpcId"] as? String {
            self.dbProxyEndpointVpcId = value
        }
        if let value = dict["DbProxyEndpointVswitchId"] as? String {
            self.dbProxyEndpointVswitchId = value
        }
        if let value = dict["DbProxyEndpointZoneId"] as? String {
            self.dbProxyEndpointZoneId = value
        }
        if let value = dict["EndpointConnectItems"] as? [String: Any?] {
            var model = DescribeDBProxyEndpointResponseBody.EndpointConnectItems()
            model.fromMap(value)
            self.endpointConnectItems = model
        }
        if let value = dict["ReadOnlyInstanceDistributionType"] as? String {
            self.readOnlyInstanceDistributionType = value
        }
        if let value = dict["ReadOnlyInstanceMaxDelayTime"] as? String {
            self.readOnlyInstanceMaxDelayTime = value
        }
        if let value = dict["ReadOnlyInstanceWeight"] as? String {
            self.readOnlyInstanceWeight = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBProxyEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBProxyEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBProxyEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBProxyPerformanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceType: String?

    public var dimension: String?

    public var endTime: String?

    public var metricsName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricsName != nil {
            map["MetricsName"] = self.metricsName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["Dimension"] as? String {
            self.dimension = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["MetricsName"] as? String {
            self.metricsName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBProxyPerformanceResponseBody : Tea.TeaModel {
    public class PerformanceKeys : Tea.TeaModel {
        public class PerformanceKey : Tea.TeaModel {
            public class Values : Tea.TeaModel {
                public class PerformanceValue : Tea.TeaModel {
                    public var date: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.date != nil {
                            map["Date"] = self.date!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Date"] as? String {
                            self.date = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var performanceValue: [DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.performanceValue != nil {
                        var tmp : [Any] = []
                        for k in self.performanceValue! {
                            tmp.append(k.toMap())
                        }
                        map["PerformanceValue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PerformanceValue"] as? [Any?] {
                        var tmp : [DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey.Values.PerformanceValue()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.performanceValue = tmp
                    }
                }
            }
            public var key: String?

            public var node: String?

            public var service: String?

            public var valueFormat: String?

            public var values: DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey.Values?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.values?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.node != nil {
                    map["Node"] = self.node!
                }
                if self.service != nil {
                    map["Service"] = self.service!
                }
                if self.valueFormat != nil {
                    map["ValueFormat"] = self.valueFormat!
                }
                if self.values != nil {
                    map["Values"] = self.values?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Node"] as? String {
                    self.node = value
                }
                if let value = dict["Service"] as? String {
                    self.service = value
                }
                if let value = dict["ValueFormat"] as? String {
                    self.valueFormat = value
                }
                if let value = dict["Values"] as? [String: Any?] {
                    var model = DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey.Values()
                    model.fromMap(value)
                    self.values = model
                }
            }
        }
        public var performanceKey: [DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.performanceKey != nil {
                var tmp : [Any] = []
                for k in self.performanceKey! {
                    tmp.append(k.toMap())
                }
                map["PerformanceKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PerformanceKey"] as? [Any?] {
                var tmp : [DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBProxyPerformanceResponseBody.PerformanceKeys.PerformanceKey()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.performanceKey = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var endTime: String?

    public var performanceKeys: DescribeDBProxyPerformanceResponseBody.PerformanceKeys?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.performanceKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.performanceKeys != nil {
            map["PerformanceKeys"] = self.performanceKeys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PerformanceKeys"] as? [String: Any?] {
            var model = DescribeDBProxyPerformanceResponseBody.PerformanceKeys()
            model.fromMap(value)
            self.performanceKeys = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBProxyPerformanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBProxyPerformanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBProxyPerformanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDTCSecurityIpHostsForSQLServerRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeDTCSecurityIpHostsForSQLServerResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class WhiteListGroups : Tea.TeaModel {
            public var securityIpHosts: String?

            public var whitelistGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.securityIpHosts != nil {
                    map["SecurityIpHosts"] = self.securityIpHosts!
                }
                if self.whitelistGroupName != nil {
                    map["WhitelistGroupName"] = self.whitelistGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SecurityIpHosts"] as? String {
                    self.securityIpHosts = value
                }
                if let value = dict["WhitelistGroupName"] as? String {
                    self.whitelistGroupName = value
                }
            }
        }
        public var whiteListGroups: [DescribeDTCSecurityIpHostsForSQLServerResponseBody.Items.WhiteListGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.whiteListGroups != nil {
                var tmp : [Any] = []
                for k in self.whiteListGroups! {
                    tmp.append(k.toMap())
                }
                map["WhiteListGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["WhiteListGroups"] as? [Any?] {
                var tmp : [DescribeDTCSecurityIpHostsForSQLServerResponseBody.Items.WhiteListGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDTCSecurityIpHostsForSQLServerResponseBody.Items.WhiteListGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.whiteListGroups = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var ipHostPairNum: String?

    public var items: DescribeDTCSecurityIpHostsForSQLServerResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ipHostPairNum != nil {
            map["IpHostPairNum"] = self.ipHostPairNum!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["IpHostPairNum"] as? String {
            self.ipHostPairNum = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDTCSecurityIpHostsForSQLServerResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDTCSecurityIpHostsForSQLServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDTCSecurityIpHostsForSQLServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDTCSecurityIpHostsForSQLServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDatabasesRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBName: String?

    public var DBStatus: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.DBStatus != nil {
            map["DBStatus"] = self.DBStatus!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DBStatus"] as? String {
            self.DBStatus = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDatabasesResponseBody : Tea.TeaModel {
    public class Databases : Tea.TeaModel {
        public class Database : Tea.TeaModel {
            public class Accounts : Tea.TeaModel {
                public class AccountPrivilegeInfo : Tea.TeaModel {
                    public var account: String?

                    public var accountPrivilege: String?

                    public var accountPrivilegeDetail: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.account != nil {
                            map["Account"] = self.account!
                        }
                        if self.accountPrivilege != nil {
                            map["AccountPrivilege"] = self.accountPrivilege!
                        }
                        if self.accountPrivilegeDetail != nil {
                            map["AccountPrivilegeDetail"] = self.accountPrivilegeDetail!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Account"] as? String {
                            self.account = value
                        }
                        if let value = dict["AccountPrivilege"] as? String {
                            self.accountPrivilege = value
                        }
                        if let value = dict["AccountPrivilegeDetail"] as? String {
                            self.accountPrivilegeDetail = value
                        }
                    }
                }
                public var accountPrivilegeInfo: [DescribeDatabasesResponseBody.Databases.Database.Accounts.AccountPrivilegeInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountPrivilegeInfo != nil {
                        var tmp : [Any] = []
                        for k in self.accountPrivilegeInfo! {
                            tmp.append(k.toMap())
                        }
                        map["AccountPrivilegeInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccountPrivilegeInfo"] as? [Any?] {
                        var tmp : [DescribeDatabasesResponseBody.Databases.Database.Accounts.AccountPrivilegeInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDatabasesResponseBody.Databases.Database.Accounts.AccountPrivilegeInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.accountPrivilegeInfo = tmp
                    }
                }
            }
            public class AdvancedInfo : Tea.TeaModel {
                public var advancedDbProperty: [[String: Any]]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.advancedDbProperty != nil {
                        map["AdvancedDbProperty"] = self.advancedDbProperty!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AdvancedDbProperty"] as? [[String: Any]] {
                        self.advancedDbProperty = value
                    }
                }
            }
            public class BasicInfo : Tea.TeaModel {
                public var basicDbProperty: [[String: Any]]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.basicDbProperty != nil {
                        map["BasicDbProperty"] = self.basicDbProperty!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BasicDbProperty"] as? [[String: Any]] {
                        self.basicDbProperty = value
                    }
                }
            }
            public class RuntimeInfo : Tea.TeaModel {
                public var runtimeDbProperty: [[String: Any]]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runtimeDbProperty != nil {
                        map["RuntimeDbProperty"] = self.runtimeDbProperty!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RuntimeDbProperty"] as? [[String: Any]] {
                        self.runtimeDbProperty = value
                    }
                }
            }
            public var accounts: DescribeDatabasesResponseBody.Databases.Database.Accounts?

            public var advancedInfo: DescribeDatabasesResponseBody.Databases.Database.AdvancedInfo?

            public var basicInfo: DescribeDatabasesResponseBody.Databases.Database.BasicInfo?

            public var characterSetName: String?

            public var collate: String?

            public var connLimit: String?

            public var ctype: String?

            public var DBDescription: String?

            public var DBInstanceId: String?

            public var DBName: String?

            public var DBStatus: String?

            public var engine: String?

            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var runtimeInfo: DescribeDatabasesResponseBody.Databases.Database.RuntimeInfo?

            public var tablespace: String?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.accounts?.validate()
                try self.advancedInfo?.validate()
                try self.basicInfo?.validate()
                try self.runtimeInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accounts != nil {
                    map["Accounts"] = self.accounts?.toMap()
                }
                if self.advancedInfo != nil {
                    map["AdvancedInfo"] = self.advancedInfo?.toMap()
                }
                if self.basicInfo != nil {
                    map["BasicInfo"] = self.basicInfo?.toMap()
                }
                if self.characterSetName != nil {
                    map["CharacterSetName"] = self.characterSetName!
                }
                if self.collate != nil {
                    map["Collate"] = self.collate!
                }
                if self.connLimit != nil {
                    map["ConnLimit"] = self.connLimit!
                }
                if self.ctype != nil {
                    map["Ctype"] = self.ctype!
                }
                if self.DBDescription != nil {
                    map["DBDescription"] = self.DBDescription!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.DBStatus != nil {
                    map["DBStatus"] = self.DBStatus!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.runtimeInfo != nil {
                    map["RuntimeInfo"] = self.runtimeInfo?.toMap()
                }
                if self.tablespace != nil {
                    map["Tablespace"] = self.tablespace!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Accounts"] as? [String: Any?] {
                    var model = DescribeDatabasesResponseBody.Databases.Database.Accounts()
                    model.fromMap(value)
                    self.accounts = model
                }
                if let value = dict["AdvancedInfo"] as? [String: Any?] {
                    var model = DescribeDatabasesResponseBody.Databases.Database.AdvancedInfo()
                    model.fromMap(value)
                    self.advancedInfo = model
                }
                if let value = dict["BasicInfo"] as? [String: Any?] {
                    var model = DescribeDatabasesResponseBody.Databases.Database.BasicInfo()
                    model.fromMap(value)
                    self.basicInfo = model
                }
                if let value = dict["CharacterSetName"] as? String {
                    self.characterSetName = value
                }
                if let value = dict["Collate"] as? String {
                    self.collate = value
                }
                if let value = dict["ConnLimit"] as? String {
                    self.connLimit = value
                }
                if let value = dict["Ctype"] as? String {
                    self.ctype = value
                }
                if let value = dict["DBDescription"] as? String {
                    self.DBDescription = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["DBStatus"] as? String {
                    self.DBStatus = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["PageNumber"] as? Int32 {
                    self.pageNumber = value
                }
                if let value = dict["PageSize"] as? Int32 {
                    self.pageSize = value
                }
                if let value = dict["RuntimeInfo"] as? [String: Any?] {
                    var model = DescribeDatabasesResponseBody.Databases.Database.RuntimeInfo()
                    model.fromMap(value)
                    self.runtimeInfo = model
                }
                if let value = dict["Tablespace"] as? String {
                    self.tablespace = value
                }
                if let value = dict["TotalCount"] as? Int32 {
                    self.totalCount = value
                }
            }
        }
        public var database: [DescribeDatabasesResponseBody.Databases.Database]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                var tmp : [Any] = []
                for k in self.database! {
                    tmp.append(k.toMap())
                }
                map["Database"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Database"] as? [Any?] {
                var tmp : [DescribeDatabasesResponseBody.Databases.Database] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDatabasesResponseBody.Databases.Database()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.database = tmp
            }
        }
    }
    public var databases: DescribeDatabasesResponseBody.Databases?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databases?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databases != nil {
            map["Databases"] = self.databases?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Databases"] as? [String: Any?] {
            var model = DescribeDatabasesResponseBody.Databases()
            model.fromMap(value)
            self.databases = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDatabasesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostGroupsRequest : Tea.TeaModel {
    public var dedicatedHostGroupId: String?

    public var imageCategory: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.imageCategory != nil {
            map["ImageCategory"] = self.imageCategory!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["ImageCategory"] as? String {
            self.imageCategory = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDedicatedHostGroupsResponseBody : Tea.TeaModel {
    public class DedicatedHostGroups : Tea.TeaModel {
        public class DedicatedHostGroups : Tea.TeaModel {
            public class ZoneIDList : Tea.TeaModel {
                public var zoneIDList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zoneIDList != nil {
                        map["ZoneIDList"] = self.zoneIDList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ZoneIDList"] as? [String] {
                        self.zoneIDList = value
                    }
                }
            }
            public var allocationPolicy: String?

            public var bastionInstanceId: String?

            public var cpuAllocateRation: Double?

            public var cpuAllocatedAmount: Double?

            public var cpuAllocationRatio: Int32?

            public var createTime: String?

            public var dedicatedHostCountGroupByHostType: [String: Any]?

            public var dedicatedHostGroupDesc: String?

            public var dedicatedHostGroupId: String?

            public var diskAllocateRation: Double?

            public var diskAllocatedAmount: Double?

            public var diskAllocationRatio: Int32?

            public var diskUsedAmount: Double?

            public var diskUtility: Double?

            public var engine: String?

            public var hostNumber: Int32?

            public var hostReplacePolicy: String?

            public var instanceNumber: Int32?

            public var memAllocateRation: Double?

            public var memAllocatedAmount: Double?

            public var memAllocationRatio: Int32?

            public var memUsedAmount: Double?

            public var memUtility: Double?

            public var openPermission: String?

            public var text: String?

            public var VPCId: String?

            public var zoneIDList: DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups.DedicatedHostGroups.ZoneIDList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.zoneIDList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationPolicy != nil {
                    map["AllocationPolicy"] = self.allocationPolicy!
                }
                if self.bastionInstanceId != nil {
                    map["BastionInstanceId"] = self.bastionInstanceId!
                }
                if self.cpuAllocateRation != nil {
                    map["CpuAllocateRation"] = self.cpuAllocateRation!
                }
                if self.cpuAllocatedAmount != nil {
                    map["CpuAllocatedAmount"] = self.cpuAllocatedAmount!
                }
                if self.cpuAllocationRatio != nil {
                    map["CpuAllocationRatio"] = self.cpuAllocationRatio!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dedicatedHostCountGroupByHostType != nil {
                    map["DedicatedHostCountGroupByHostType"] = self.dedicatedHostCountGroupByHostType!
                }
                if self.dedicatedHostGroupDesc != nil {
                    map["DedicatedHostGroupDesc"] = self.dedicatedHostGroupDesc!
                }
                if self.dedicatedHostGroupId != nil {
                    map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
                }
                if self.diskAllocateRation != nil {
                    map["DiskAllocateRation"] = self.diskAllocateRation!
                }
                if self.diskAllocatedAmount != nil {
                    map["DiskAllocatedAmount"] = self.diskAllocatedAmount!
                }
                if self.diskAllocationRatio != nil {
                    map["DiskAllocationRatio"] = self.diskAllocationRatio!
                }
                if self.diskUsedAmount != nil {
                    map["DiskUsedAmount"] = self.diskUsedAmount!
                }
                if self.diskUtility != nil {
                    map["DiskUtility"] = self.diskUtility!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.hostNumber != nil {
                    map["HostNumber"] = self.hostNumber!
                }
                if self.hostReplacePolicy != nil {
                    map["HostReplacePolicy"] = self.hostReplacePolicy!
                }
                if self.instanceNumber != nil {
                    map["InstanceNumber"] = self.instanceNumber!
                }
                if self.memAllocateRation != nil {
                    map["MemAllocateRation"] = self.memAllocateRation!
                }
                if self.memAllocatedAmount != nil {
                    map["MemAllocatedAmount"] = self.memAllocatedAmount!
                }
                if self.memAllocationRatio != nil {
                    map["MemAllocationRatio"] = self.memAllocationRatio!
                }
                if self.memUsedAmount != nil {
                    map["MemUsedAmount"] = self.memUsedAmount!
                }
                if self.memUtility != nil {
                    map["MemUtility"] = self.memUtility!
                }
                if self.openPermission != nil {
                    map["OpenPermission"] = self.openPermission!
                }
                if self.text != nil {
                    map["Text"] = self.text!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.zoneIDList != nil {
                    map["ZoneIDList"] = self.zoneIDList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocationPolicy"] as? String {
                    self.allocationPolicy = value
                }
                if let value = dict["BastionInstanceId"] as? String {
                    self.bastionInstanceId = value
                }
                if let value = dict["CpuAllocateRation"] as? Double {
                    self.cpuAllocateRation = value
                }
                if let value = dict["CpuAllocatedAmount"] as? Double {
                    self.cpuAllocatedAmount = value
                }
                if let value = dict["CpuAllocationRatio"] as? Int32 {
                    self.cpuAllocationRatio = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DedicatedHostCountGroupByHostType"] as? [String: Any] {
                    self.dedicatedHostCountGroupByHostType = value
                }
                if let value = dict["DedicatedHostGroupDesc"] as? String {
                    self.dedicatedHostGroupDesc = value
                }
                if let value = dict["DedicatedHostGroupId"] as? String {
                    self.dedicatedHostGroupId = value
                }
                if let value = dict["DiskAllocateRation"] as? Double {
                    self.diskAllocateRation = value
                }
                if let value = dict["DiskAllocatedAmount"] as? Double {
                    self.diskAllocatedAmount = value
                }
                if let value = dict["DiskAllocationRatio"] as? Int32 {
                    self.diskAllocationRatio = value
                }
                if let value = dict["DiskUsedAmount"] as? Double {
                    self.diskUsedAmount = value
                }
                if let value = dict["DiskUtility"] as? Double {
                    self.diskUtility = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["HostNumber"] as? Int32 {
                    self.hostNumber = value
                }
                if let value = dict["HostReplacePolicy"] as? String {
                    self.hostReplacePolicy = value
                }
                if let value = dict["InstanceNumber"] as? Int32 {
                    self.instanceNumber = value
                }
                if let value = dict["MemAllocateRation"] as? Double {
                    self.memAllocateRation = value
                }
                if let value = dict["MemAllocatedAmount"] as? Double {
                    self.memAllocatedAmount = value
                }
                if let value = dict["MemAllocationRatio"] as? Int32 {
                    self.memAllocationRatio = value
                }
                if let value = dict["MemUsedAmount"] as? Double {
                    self.memUsedAmount = value
                }
                if let value = dict["MemUtility"] as? Double {
                    self.memUtility = value
                }
                if let value = dict["OpenPermission"] as? String {
                    self.openPermission = value
                }
                if let value = dict["Text"] as? String {
                    self.text = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["ZoneIDList"] as? [String: Any?] {
                    var model = DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups.DedicatedHostGroups.ZoneIDList()
                    model.fromMap(value)
                    self.zoneIDList = model
                }
            }
        }
        public var dedicatedHostGroups: [DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups.DedicatedHostGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostGroups != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostGroups! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostGroups"] as? [Any?] {
                var tmp : [DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups.DedicatedHostGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups.DedicatedHostGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHostGroups = tmp
            }
        }
    }
    public var dedicatedHostGroups: DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostGroups != nil {
            map["DedicatedHostGroups"] = self.dedicatedHostGroups?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostGroups"] as? [String: Any?] {
            var model = DescribeDedicatedHostGroupsResponseBody.DedicatedHostGroups()
            model.fromMap(value)
            self.dedicatedHostGroups = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDedicatedHostGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDedicatedHostsRequest : Tea.TeaModel {
    public var allocationStatus: String?

    public var dedicatedHostGroupId: String?

    public var dedicatedHostId: String?

    public var hostStatus: String?

    public var hostType: String?

    public var orderId: Int64?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationStatus != nil {
            map["AllocationStatus"] = self.allocationStatus!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.hostStatus != nil {
            map["HostStatus"] = self.hostStatus!
        }
        if self.hostType != nil {
            map["HostType"] = self.hostType!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationStatus"] as? String {
            self.allocationStatus = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["HostStatus"] as? String {
            self.hostStatus = value
        }
        if let value = dict["HostType"] as? String {
            self.hostType = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHosts : Tea.TeaModel {
        public class DedicatedHosts : Tea.TeaModel {
            public var accountName: String?

            public var allocationStatus: String?

            public var bastionInstanceId: String?

            public var CPUAllocationRatio: String?

            public var cpuUsed: String?

            public var createdTime: String?

            public var dedicatedHostGroupId: String?

            public var dedicatedHostId: String?

            public var diskAllocationRatio: String?

            public var endTime: String?

            public var engine: String?

            public var hostCPU: String?

            public var hostClass: String?

            public var hostMem: String?

            public var hostName: String?

            public var hostStatus: String?

            public var hostStorage: String?

            public var hostType: String?

            public var IPAddress: String?

            public var imageCategory: String?

            public var instanceNumber: String?

            public var memAllocationRatio: String?

            public var memoryUsed: String?

            public var openPermission: String?

            public var storageUsed: String?

            public var VPCId: String?

            public var vSwitchId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.bastionInstanceId != nil {
                    map["BastionInstanceId"] = self.bastionInstanceId!
                }
                if self.CPUAllocationRatio != nil {
                    map["CPUAllocationRatio"] = self.CPUAllocationRatio!
                }
                if self.cpuUsed != nil {
                    map["CpuUsed"] = self.cpuUsed!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.dedicatedHostGroupId != nil {
                    map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.diskAllocationRatio != nil {
                    map["DiskAllocationRatio"] = self.diskAllocationRatio!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.hostCPU != nil {
                    map["HostCPU"] = self.hostCPU!
                }
                if self.hostClass != nil {
                    map["HostClass"] = self.hostClass!
                }
                if self.hostMem != nil {
                    map["HostMem"] = self.hostMem!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.hostStatus != nil {
                    map["HostStatus"] = self.hostStatus!
                }
                if self.hostStorage != nil {
                    map["HostStorage"] = self.hostStorage!
                }
                if self.hostType != nil {
                    map["HostType"] = self.hostType!
                }
                if self.IPAddress != nil {
                    map["IPAddress"] = self.IPAddress!
                }
                if self.imageCategory != nil {
                    map["ImageCategory"] = self.imageCategory!
                }
                if self.instanceNumber != nil {
                    map["InstanceNumber"] = self.instanceNumber!
                }
                if self.memAllocationRatio != nil {
                    map["MemAllocationRatio"] = self.memAllocationRatio!
                }
                if self.memoryUsed != nil {
                    map["MemoryUsed"] = self.memoryUsed!
                }
                if self.openPermission != nil {
                    map["OpenPermission"] = self.openPermission!
                }
                if self.storageUsed != nil {
                    map["StorageUsed"] = self.storageUsed!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["AllocationStatus"] as? String {
                    self.allocationStatus = value
                }
                if let value = dict["BastionInstanceId"] as? String {
                    self.bastionInstanceId = value
                }
                if let value = dict["CPUAllocationRatio"] as? String {
                    self.CPUAllocationRatio = value
                }
                if let value = dict["CpuUsed"] as? String {
                    self.cpuUsed = value
                }
                if let value = dict["CreatedTime"] as? String {
                    self.createdTime = value
                }
                if let value = dict["DedicatedHostGroupId"] as? String {
                    self.dedicatedHostGroupId = value
                }
                if let value = dict["DedicatedHostId"] as? String {
                    self.dedicatedHostId = value
                }
                if let value = dict["DiskAllocationRatio"] as? String {
                    self.diskAllocationRatio = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["HostCPU"] as? String {
                    self.hostCPU = value
                }
                if let value = dict["HostClass"] as? String {
                    self.hostClass = value
                }
                if let value = dict["HostMem"] as? String {
                    self.hostMem = value
                }
                if let value = dict["HostName"] as? String {
                    self.hostName = value
                }
                if let value = dict["HostStatus"] as? String {
                    self.hostStatus = value
                }
                if let value = dict["HostStorage"] as? String {
                    self.hostStorage = value
                }
                if let value = dict["HostType"] as? String {
                    self.hostType = value
                }
                if let value = dict["IPAddress"] as? String {
                    self.IPAddress = value
                }
                if let value = dict["ImageCategory"] as? String {
                    self.imageCategory = value
                }
                if let value = dict["InstanceNumber"] as? String {
                    self.instanceNumber = value
                }
                if let value = dict["MemAllocationRatio"] as? String {
                    self.memAllocationRatio = value
                }
                if let value = dict["MemoryUsed"] as? String {
                    self.memoryUsed = value
                }
                if let value = dict["OpenPermission"] as? String {
                    self.openPermission = value
                }
                if let value = dict["StorageUsed"] as? String {
                    self.storageUsed = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var dedicatedHosts: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHosts]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHosts != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHosts! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHosts"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHosts"] as? [Any?] {
                var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHosts] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHosts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dedicatedHosts = tmp
            }
        }
    }
    public var dedicatedHostGroupId: String?

    public var dedicatedHosts: DescribeDedicatedHostsResponseBody.DedicatedHosts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHosts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.dedicatedHosts != nil {
            map["DedicatedHosts"] = self.dedicatedHosts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DedicatedHosts"] as? [String: Any?] {
            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts()
            model.fromMap(value)
            self.dedicatedHosts = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDedicatedHostsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDetachedBackupsRequest : Tea.TeaModel {
    public var backupId: String?

    public var backupMode: String?

    public var backupStatus: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.backupStatus != nil {
            map["BackupStatus"] = self.backupStatus!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["BackupStatus"] as? String {
            self.backupStatus = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDetachedBackupsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Backup : Tea.TeaModel {
            public var backupDownloadURL: String?

            public var backupEndTime: String?

            public var backupId: String?

            public var backupIntranetDownloadURL: String?

            public var backupMethod: String?

            public var backupMode: String?

            public var backupSize: Int64?

            public var backupStartTime: String?

            public var backupStatus: String?

            public var backupType: String?

            public var consistentTime: Int64?

            public var DBInstanceComment: String?

            public var DBInstanceId: String?

            public var hostInstanceID: String?

            public var isAvail: Int32?

            public var metaStatus: String?

            public var storeStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupDownloadURL != nil {
                    map["BackupDownloadURL"] = self.backupDownloadURL!
                }
                if self.backupEndTime != nil {
                    map["BackupEndTime"] = self.backupEndTime!
                }
                if self.backupId != nil {
                    map["BackupId"] = self.backupId!
                }
                if self.backupIntranetDownloadURL != nil {
                    map["BackupIntranetDownloadURL"] = self.backupIntranetDownloadURL!
                }
                if self.backupMethod != nil {
                    map["BackupMethod"] = self.backupMethod!
                }
                if self.backupMode != nil {
                    map["BackupMode"] = self.backupMode!
                }
                if self.backupSize != nil {
                    map["BackupSize"] = self.backupSize!
                }
                if self.backupStartTime != nil {
                    map["BackupStartTime"] = self.backupStartTime!
                }
                if self.backupStatus != nil {
                    map["BackupStatus"] = self.backupStatus!
                }
                if self.backupType != nil {
                    map["BackupType"] = self.backupType!
                }
                if self.consistentTime != nil {
                    map["ConsistentTime"] = self.consistentTime!
                }
                if self.DBInstanceComment != nil {
                    map["DBInstanceComment"] = self.DBInstanceComment!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.hostInstanceID != nil {
                    map["HostInstanceID"] = self.hostInstanceID!
                }
                if self.isAvail != nil {
                    map["IsAvail"] = self.isAvail!
                }
                if self.metaStatus != nil {
                    map["MetaStatus"] = self.metaStatus!
                }
                if self.storeStatus != nil {
                    map["StoreStatus"] = self.storeStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupDownloadURL"] as? String {
                    self.backupDownloadURL = value
                }
                if let value = dict["BackupEndTime"] as? String {
                    self.backupEndTime = value
                }
                if let value = dict["BackupId"] as? String {
                    self.backupId = value
                }
                if let value = dict["BackupIntranetDownloadURL"] as? String {
                    self.backupIntranetDownloadURL = value
                }
                if let value = dict["BackupMethod"] as? String {
                    self.backupMethod = value
                }
                if let value = dict["BackupMode"] as? String {
                    self.backupMode = value
                }
                if let value = dict["BackupSize"] as? Int64 {
                    self.backupSize = value
                }
                if let value = dict["BackupStartTime"] as? String {
                    self.backupStartTime = value
                }
                if let value = dict["BackupStatus"] as? String {
                    self.backupStatus = value
                }
                if let value = dict["BackupType"] as? String {
                    self.backupType = value
                }
                if let value = dict["ConsistentTime"] as? Int64 {
                    self.consistentTime = value
                }
                if let value = dict["DBInstanceComment"] as? String {
                    self.DBInstanceComment = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["HostInstanceID"] as? String {
                    self.hostInstanceID = value
                }
                if let value = dict["IsAvail"] as? Int32 {
                    self.isAvail = value
                }
                if let value = dict["MetaStatus"] as? String {
                    self.metaStatus = value
                }
                if let value = dict["StoreStatus"] as? String {
                    self.storeStatus = value
                }
            }
        }
        public var backup: [DescribeDetachedBackupsResponseBody.Items.Backup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backup != nil {
                var tmp : [Any] = []
                for k in self.backup! {
                    tmp.append(k.toMap())
                }
                map["Backup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Backup"] as? [Any?] {
                var tmp : [DescribeDetachedBackupsResponseBody.Items.Backup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDetachedBackupsResponseBody.Items.Backup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.backup = tmp
            }
        }
    }
    public var items: DescribeDetachedBackupsResponseBody.Items?

    public var pageNumber: String?

    public var pageRecordCount: String?

    public var requestId: String?

    public var totalRecordCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDetachedBackupsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? String {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? String {
            self.totalRecordCount = value
        }
    }
}

public class DescribeDetachedBackupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDetachedBackupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDetachedBackupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeErrorLogsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeErrorLogsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class ErrorLog : Tea.TeaModel {
            public var createTime: String?

            public var errorInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.errorInfo != nil {
                    map["ErrorInfo"] = self.errorInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["ErrorInfo"] as? String {
                    self.errorInfo = value
                }
            }
        }
        public var errorLog: [DescribeErrorLogsResponseBody.Items.ErrorLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorLog != nil {
                var tmp : [Any] = []
                for k in self.errorLog! {
                    tmp.append(k.toMap())
                }
                map["ErrorLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorLog"] as? [Any?] {
                var tmp : [DescribeErrorLogsResponseBody.Items.ErrorLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeErrorLogsResponseBody.Items.ErrorLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorLog = tmp
            }
        }
    }
    public var items: DescribeErrorLogsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeErrorLogsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeErrorLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeErrorLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeErrorLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEventsRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeEventsResponseBody : Tea.TeaModel {
    public class EventItems : Tea.TeaModel {
        public class EventItems : Tea.TeaModel {
            public var callerUid: Int64?

            public var eventId: Int32?

            public var eventName: String?

            public var eventPayload: String?

            public var eventReason: String?

            public var eventRecordTime: String?

            public var eventTime: String?

            public var eventType: String?

            public var eventUserType: String?

            public var regionId: String?

            public var resourceName: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callerUid != nil {
                    map["CallerUid"] = self.callerUid!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventName != nil {
                    map["EventName"] = self.eventName!
                }
                if self.eventPayload != nil {
                    map["EventPayload"] = self.eventPayload!
                }
                if self.eventReason != nil {
                    map["EventReason"] = self.eventReason!
                }
                if self.eventRecordTime != nil {
                    map["EventRecordTime"] = self.eventRecordTime!
                }
                if self.eventTime != nil {
                    map["EventTime"] = self.eventTime!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.eventUserType != nil {
                    map["EventUserType"] = self.eventUserType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CallerUid"] as? Int64 {
                    self.callerUid = value
                }
                if let value = dict["EventId"] as? Int32 {
                    self.eventId = value
                }
                if let value = dict["EventName"] as? String {
                    self.eventName = value
                }
                if let value = dict["EventPayload"] as? String {
                    self.eventPayload = value
                }
                if let value = dict["EventReason"] as? String {
                    self.eventReason = value
                }
                if let value = dict["EventRecordTime"] as? String {
                    self.eventRecordTime = value
                }
                if let value = dict["EventTime"] as? String {
                    self.eventTime = value
                }
                if let value = dict["EventType"] as? String {
                    self.eventType = value
                }
                if let value = dict["EventUserType"] as? String {
                    self.eventUserType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public var eventItems: [DescribeEventsResponseBody.EventItems.EventItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventItems != nil {
                var tmp : [Any] = []
                for k in self.eventItems! {
                    tmp.append(k.toMap())
                }
                map["EventItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EventItems"] as? [Any?] {
                var tmp : [DescribeEventsResponseBody.EventItems.EventItems] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEventsResponseBody.EventItems.EventItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.eventItems = tmp
            }
        }
    }
    public var eventItems: DescribeEventsResponseBody.EventItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventItems != nil {
            map["EventItems"] = self.eventItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventItems"] as? [String: Any?] {
            var model = DescribeEventsResponseBody.EventItems()
            model.fromMap(value)
            self.eventItems = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGadInstancesRequest : Tea.TeaModel {
    public var gadInstanceName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gadInstanceName != nil {
            map["GadInstanceName"] = self.gadInstanceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GadInstanceName"] as? String {
            self.gadInstanceName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DescribeGadInstancesResponseBody : Tea.TeaModel {
    public class GadInstances : Tea.TeaModel {
        public class GadInstanceMembers : Tea.TeaModel {
            public var DBInstanceID: String?

            public var dtsInstance: String?

            public var engine: String?

            public var engineVersion: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceID != nil {
                    map["DBInstanceID"] = self.DBInstanceID!
                }
                if self.dtsInstance != nil {
                    map["DtsInstance"] = self.dtsInstance!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceID"] as? String {
                    self.DBInstanceID = value
                }
                if let value = dict["DtsInstance"] as? String {
                    self.dtsInstance = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var gadInstanceMembers: [DescribeGadInstancesResponseBody.GadInstances.GadInstanceMembers]?

        public var gadInstanceName: String?

        public var modificationTime: String?

        public var service: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gadInstanceMembers != nil {
                var tmp : [Any] = []
                for k in self.gadInstanceMembers! {
                    tmp.append(k.toMap())
                }
                map["GadInstanceMembers"] = tmp
            }
            if self.gadInstanceName != nil {
                map["GadInstanceName"] = self.gadInstanceName!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.service != nil {
                map["Service"] = self.service!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GadInstanceMembers"] as? [Any?] {
                var tmp : [DescribeGadInstancesResponseBody.GadInstances.GadInstanceMembers] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGadInstancesResponseBody.GadInstances.GadInstanceMembers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.gadInstanceMembers = tmp
            }
            if let value = dict["GadInstanceName"] as? String {
                self.gadInstanceName = value
            }
            if let value = dict["ModificationTime"] as? String {
                self.modificationTime = value
            }
            if let value = dict["Service"] as? String {
                self.service = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var gadInstances: [DescribeGadInstancesResponseBody.GadInstances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gadInstances != nil {
            var tmp : [Any] = []
            for k in self.gadInstances! {
                tmp.append(k.toMap())
            }
            map["GadInstances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GadInstances"] as? [Any?] {
            var tmp : [DescribeGadInstancesResponseBody.GadInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeGadInstancesResponseBody.GadInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.gadInstances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeGadInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGadInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGadInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHADiagnoseConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHADiagnoseConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tcpConnectionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tcpConnectionType != nil {
            map["TcpConnectionType"] = self.tcpConnectionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TcpConnectionType"] as? String {
            self.tcpConnectionType = value
        }
    }
}

public class DescribeHADiagnoseConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHADiagnoseConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHADiagnoseConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHASwitchConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHASwitchConfigResponseBody : Tea.TeaModel {
    public var HAConfig: String?

    public var manualHATime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.HAConfig != nil {
            map["HAConfig"] = self.HAConfig!
        }
        if self.manualHATime != nil {
            map["ManualHATime"] = self.manualHATime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HAConfig"] as? String {
            self.HAConfig = value
        }
        if let value = dict["ManualHATime"] as? String {
            self.manualHATime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeHASwitchConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHASwitchConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHASwitchConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHistoryEventsRequest : Tea.TeaModel {
    public var archiveStatus: String?

    public var eventCategory: String?

    public var eventId: String?

    public var eventLevel: String?

    public var eventStatus: String?

    public var eventType: String?

    public var fromStartTime: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceType: String?

    public var securityToken: String?

    public var taskId: String?

    public var toStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveStatus != nil {
            map["ArchiveStatus"] = self.archiveStatus!
        }
        if self.eventCategory != nil {
            map["EventCategory"] = self.eventCategory!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventLevel != nil {
            map["EventLevel"] = self.eventLevel!
        }
        if self.eventStatus != nil {
            map["EventStatus"] = self.eventStatus!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.fromStartTime != nil {
            map["FromStartTime"] = self.fromStartTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.toStartTime != nil {
            map["ToStartTime"] = self.toStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveStatus"] as? String {
            self.archiveStatus = value
        }
        if let value = dict["EventCategory"] as? String {
            self.eventCategory = value
        }
        if let value = dict["EventId"] as? String {
            self.eventId = value
        }
        if let value = dict["EventLevel"] as? String {
            self.eventLevel = value
        }
        if let value = dict["EventStatus"] as? String {
            self.eventStatus = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["FromStartTime"] as? String {
            self.fromStartTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["ToStartTime"] as? String {
            self.toStartTime = value
        }
    }
}

public class DescribeHistoryEventsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public var cmsProduct: String?

            public var dbType: String?

            public var detailImpact: String?

            public var detailReason: String?

            public var endTime: String?

            public var eventCategory: String?

            public var eventCode: String?

            public var eventDetail: String?

            public var eventId: String?

            public var eventImpact: String?

            public var eventLevel: String?

            public var eventReason: String?

            public var eventStatus: String?

            public var eventType: String?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var handleStatus: String?

            public var hasLifeCycle: Int32?

            public var instanceId: String?

            public var instanceName: String?

            public var isClosed: Int32?

            public var product: String?

            public var regionId: String?

            public var resourceType: String?

            public var sourceType: String?

            public var startTime: String?

            public var uid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cmsProduct != nil {
                    map["CmsProduct"] = self.cmsProduct!
                }
                if self.dbType != nil {
                    map["DbType"] = self.dbType!
                }
                if self.detailImpact != nil {
                    map["DetailImpact"] = self.detailImpact!
                }
                if self.detailReason != nil {
                    map["DetailReason"] = self.detailReason!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.eventCategory != nil {
                    map["EventCategory"] = self.eventCategory!
                }
                if self.eventCode != nil {
                    map["EventCode"] = self.eventCode!
                }
                if self.eventDetail != nil {
                    map["EventDetail"] = self.eventDetail!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventImpact != nil {
                    map["EventImpact"] = self.eventImpact!
                }
                if self.eventLevel != nil {
                    map["EventLevel"] = self.eventLevel!
                }
                if self.eventReason != nil {
                    map["EventReason"] = self.eventReason!
                }
                if self.eventStatus != nil {
                    map["EventStatus"] = self.eventStatus!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.handleStatus != nil {
                    map["HandleStatus"] = self.handleStatus!
                }
                if self.hasLifeCycle != nil {
                    map["HasLifeCycle"] = self.hasLifeCycle!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.isClosed != nil {
                    map["IsClosed"] = self.isClosed!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CmsProduct"] as? String {
                    self.cmsProduct = value
                }
                if let value = dict["DbType"] as? String {
                    self.dbType = value
                }
                if let value = dict["DetailImpact"] as? String {
                    self.detailImpact = value
                }
                if let value = dict["DetailReason"] as? String {
                    self.detailReason = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["EventCategory"] as? String {
                    self.eventCategory = value
                }
                if let value = dict["EventCode"] as? String {
                    self.eventCode = value
                }
                if let value = dict["EventDetail"] as? String {
                    self.eventDetail = value
                }
                if let value = dict["EventId"] as? String {
                    self.eventId = value
                }
                if let value = dict["EventImpact"] as? String {
                    self.eventImpact = value
                }
                if let value = dict["EventLevel"] as? String {
                    self.eventLevel = value
                }
                if let value = dict["EventReason"] as? String {
                    self.eventReason = value
                }
                if let value = dict["EventStatus"] as? String {
                    self.eventStatus = value
                }
                if let value = dict["EventType"] as? String {
                    self.eventType = value
                }
                if let value = dict["GmtCreated"] as? String {
                    self.gmtCreated = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["HandleStatus"] as? String {
                    self.handleStatus = value
                }
                if let value = dict["HasLifeCycle"] as? Int32 {
                    self.hasLifeCycle = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["InstanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["IsClosed"] as? Int32 {
                    self.isClosed = value
                }
                if let value = dict["Product"] as? String {
                    self.product = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Uid"] as? String {
                    self.uid = value
                }
            }
        }
        public var data: DescribeHistoryEventsResponseBody.Items.Data?

        public var id: String?

        public var region: String?

        public var source: String?

        public var specversion: String?

        public var subject: String?

        public var time: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.specversion != nil {
                map["Specversion"] = self.specversion!
            }
            if self.subject != nil {
                map["Subject"] = self.subject!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Data"] as? [String: Any?] {
                var model = DescribeHistoryEventsResponseBody.Items.Data()
                model.fromMap(value)
                self.data = model
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
            if let value = dict["Specversion"] as? String {
                self.specversion = value
            }
            if let value = dict["Subject"] as? String {
                self.subject = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var items: [DescribeHistoryEventsResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeHistoryEventsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeHistoryEventsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHistoryEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHistoryEventsStatRequest : Tea.TeaModel {
    public var archiveStatus: String?

    public var fromStartTime: String?

    public var regionId: String?

    public var securityToken: String?

    public var toStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveStatus != nil {
            map["ArchiveStatus"] = self.archiveStatus!
        }
        if self.fromStartTime != nil {
            map["FromStartTime"] = self.fromStartTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.toStartTime != nil {
            map["ToStartTime"] = self.toStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveStatus"] as? String {
            self.archiveStatus = value
        }
        if let value = dict["FromStartTime"] as? String {
            self.fromStartTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["ToStartTime"] as? String {
            self.toStartTime = value
        }
    }
}

public class DescribeHistoryEventsStatResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var eventCategory: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCategory != nil {
                map["EventCategory"] = self.eventCategory!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EventCategory"] as? String {
                self.eventCategory = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var items: [DescribeHistoryEventsStatResponseBody.Items]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeHistoryEventsStatResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeHistoryEventsStatResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeHistoryEventsStatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryEventsStatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHistoryEventsStatResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHistoryTasksRequest : Tea.TeaModel {
    public var fromExecTime: Int32?

    public var fromStartTime: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: Int64?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var status: String?

    public var taskId: String?

    public var taskType: String?

    public var toExecTime: Int32?

    public var toStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fromExecTime != nil {
            map["FromExecTime"] = self.fromExecTime!
        }
        if self.fromStartTime != nil {
            map["FromStartTime"] = self.fromStartTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.toExecTime != nil {
            map["ToExecTime"] = self.toExecTime!
        }
        if self.toStartTime != nil {
            map["ToStartTime"] = self.toStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FromExecTime"] as? Int32 {
            self.fromExecTime = value
        }
        if let value = dict["FromStartTime"] as? String {
            self.fromStartTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? Int64 {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["ToExecTime"] as? Int32 {
            self.toExecTime = value
        }
        if let value = dict["ToStartTime"] as? String {
            self.toStartTime = value
        }
    }
}

public class DescribeHistoryTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var actionInfo: String?

        public var callerSource: String?

        public var callerUid: String?

        public var currentStepName: String?

        public var dbType: String?

        public var endTime: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceType: String?

        public var product: String?

        public var progress: Double?

        public var reasonCode: String?

        public var regionId: String?

        public var remainTime: Int32?

        public var startTime: String?

        public var status: String?

        public var taskDetail: String?

        public var taskId: String?

        public var taskType: String?

        public var uid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionInfo != nil {
                map["ActionInfo"] = self.actionInfo!
            }
            if self.callerSource != nil {
                map["CallerSource"] = self.callerSource!
            }
            if self.callerUid != nil {
                map["CallerUid"] = self.callerUid!
            }
            if self.currentStepName != nil {
                map["CurrentStepName"] = self.currentStepName!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.product != nil {
                map["Product"] = self.product!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.reasonCode != nil {
                map["ReasonCode"] = self.reasonCode!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.remainTime != nil {
                map["RemainTime"] = self.remainTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskDetail != nil {
                map["TaskDetail"] = self.taskDetail!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActionInfo"] as? String {
                self.actionInfo = value
            }
            if let value = dict["CallerSource"] as? String {
                self.callerSource = value
            }
            if let value = dict["CallerUid"] as? String {
                self.callerUid = value
            }
            if let value = dict["CurrentStepName"] as? String {
                self.currentStepName = value
            }
            if let value = dict["DbType"] as? String {
                self.dbType = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Product"] as? String {
                self.product = value
            }
            if let value = dict["Progress"] as? Double {
                self.progress = value
            }
            if let value = dict["ReasonCode"] as? String {
                self.reasonCode = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RemainTime"] as? Int32 {
                self.remainTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskDetail"] as? String {
                self.taskDetail = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
            if let value = dict["Uid"] as? String {
                self.uid = value
            }
        }
    }
    public var items: [DescribeHistoryTasksResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeHistoryTasksResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeHistoryTasksResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeHistoryTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHistoryTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHistoryTasksStatRequest : Tea.TeaModel {
    public var fromExecTime: Int32?

    public var fromStartTime: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: Int64?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var status: String?

    public var taskId: String?

    public var taskType: String?

    public var toExecTime: Int32?

    public var toStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fromExecTime != nil {
            map["FromExecTime"] = self.fromExecTime!
        }
        if self.fromStartTime != nil {
            map["FromStartTime"] = self.fromStartTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.toExecTime != nil {
            map["ToExecTime"] = self.toExecTime!
        }
        if self.toStartTime != nil {
            map["ToStartTime"] = self.toStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FromExecTime"] as? Int32 {
            self.fromExecTime = value
        }
        if let value = dict["FromStartTime"] as? String {
            self.fromStartTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? Int64 {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["ToExecTime"] as? Int32 {
            self.toExecTime = value
        }
        if let value = dict["ToStartTime"] as? String {
            self.toStartTime = value
        }
    }
}

public class DescribeHistoryTasksStatResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var status: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var items: [DescribeHistoryTasksStatResponseBody.Items]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeHistoryTasksStatResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeHistoryTasksStatResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeHistoryTasksStatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryTasksStatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHistoryTasksStatResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHostGroupElasticStrategyParametersRequest : Tea.TeaModel {
    public var dedicatedHostGroupName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostGroupName != nil {
            map["DedicatedHostGroupName"] = self.dedicatedHostGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostGroupName"] as? String {
            self.dedicatedHostGroupName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHostGroupElasticStrategyParametersResponseBody : Tea.TeaModel {
    public var cpuShar: Int32?

    public var cpuZoom: Int32?

    public var iopsZoom: Int32?

    public var maxConnZoom: Int32?

    public var memoryZoom: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuShar != nil {
            map["CpuShar"] = self.cpuShar!
        }
        if self.cpuZoom != nil {
            map["CpuZoom"] = self.cpuZoom!
        }
        if self.iopsZoom != nil {
            map["IopsZoom"] = self.iopsZoom!
        }
        if self.maxConnZoom != nil {
            map["MaxConnZoom"] = self.maxConnZoom!
        }
        if self.memoryZoom != nil {
            map["MemoryZoom"] = self.memoryZoom!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CpuShar"] as? Int32 {
            self.cpuShar = value
        }
        if let value = dict["CpuZoom"] as? Int32 {
            self.cpuZoom = value
        }
        if let value = dict["IopsZoom"] as? Int32 {
            self.iopsZoom = value
        }
        if let value = dict["MaxConnZoom"] as? Int32 {
            self.maxConnZoom = value
        }
        if let value = dict["MemoryZoom"] as? Int32 {
            self.memoryZoom = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeHostGroupElasticStrategyParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHostGroupElasticStrategyParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHostGroupElasticStrategyParametersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHostWebShellRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var DBInstanceId: String?

    public var hostName: String?

    public var ownerId: Int64?

    public var regionID: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionID != nil {
            map["RegionID"] = self.regionID!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionID"] as? String {
            self.regionID = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeHostWebShellResponseBody : Tea.TeaModel {
    public var loginUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loginUrl != nil {
            map["LoginUrl"] = self.loginUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LoginUrl"] as? String {
            self.loginUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeHostWebShellResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHostWebShellResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHostWebShellResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRenewalAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeInstanceAutoRenewalAttributeResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var autoRenew: String?

            public var DBInstanceId: String?

            public var duration: Int32?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenew != nil {
                    map["AutoRenew"] = self.autoRenew!
                }
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoRenew"] as? String {
                    self.autoRenew = value
                }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var item: [DescribeInstanceAutoRenewalAttributeResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Item"] as? [Any?] {
                var tmp : [DescribeInstanceAutoRenewalAttributeResponseBody.Items.Item] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceAutoRenewalAttributeResponseBody.Items.Item()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.item = tmp
            }
        }
    }
    public var items: DescribeInstanceAutoRenewalAttributeResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeInstanceAutoRenewalAttributeResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeInstanceAutoRenewalAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRenewalAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceAutoRenewalAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceCrossBackupPolicyRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceCrossBackupPolicyResponseBody : Tea.TeaModel {
    public var backupEnabled: String?

    public var backupEnabledTime: String?

    public var crossBackupRegion: String?

    public var crossBackupType: String?

    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var DBInstanceStatus: String?

    public var engine: String?

    public var engineVersion: String?

    public var lockMode: String?

    public var logBackupEnabled: String?

    public var logBackupEnabledTime: String?

    public var regionId: String?

    public var requestId: String?

    public var retentType: Int32?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupEnabled != nil {
            map["BackupEnabled"] = self.backupEnabled!
        }
        if self.backupEnabledTime != nil {
            map["BackupEnabledTime"] = self.backupEnabledTime!
        }
        if self.crossBackupRegion != nil {
            map["CrossBackupRegion"] = self.crossBackupRegion!
        }
        if self.crossBackupType != nil {
            map["CrossBackupType"] = self.crossBackupType!
        }
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStatus != nil {
            map["DBInstanceStatus"] = self.DBInstanceStatus!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.lockMode != nil {
            map["LockMode"] = self.lockMode!
        }
        if self.logBackupEnabled != nil {
            map["LogBackupEnabled"] = self.logBackupEnabled!
        }
        if self.logBackupEnabledTime != nil {
            map["LogBackupEnabledTime"] = self.logBackupEnabledTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retentType != nil {
            map["RetentType"] = self.retentType!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupEnabled"] as? String {
            self.backupEnabled = value
        }
        if let value = dict["BackupEnabledTime"] as? String {
            self.backupEnabledTime = value
        }
        if let value = dict["CrossBackupRegion"] as? String {
            self.crossBackupRegion = value
        }
        if let value = dict["CrossBackupType"] as? String {
            self.crossBackupType = value
        }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStatus"] as? String {
            self.DBInstanceStatus = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["LockMode"] as? String {
            self.lockMode = value
        }
        if let value = dict["LogBackupEnabled"] as? String {
            self.logBackupEnabled = value
        }
        if let value = dict["LogBackupEnabledTime"] as? String {
            self.logBackupEnabledTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetentType"] as? Int32 {
            self.retentType = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
    }
}

public class DescribeInstanceCrossBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceCrossBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceCrossBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceKeywordsRequest : Tea.TeaModel {
    public var key: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceKeywordsResponseBody : Tea.TeaModel {
    public class Words : Tea.TeaModel {
        public var word: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.word != nil {
                map["word"] = self.word!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["word"] as? [String] {
                self.word = value
            }
        }
    }
    public var key: String?

    public var requestId: String?

    public var words: DescribeInstanceKeywordsResponseBody.Words?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.words?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.words != nil {
            map["Words"] = self.words?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Words"] as? [String: Any?] {
            var model = DescribeInstanceKeywordsResponseBody.Words()
            model.fromMap(value)
            self.words = model
        }
    }
}

public class DescribeInstanceKeywordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceKeywordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceKeywordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceLinkedWhitelistTemplateRequest : Tea.TeaModel {
    public var insName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insName != nil {
            map["InsName"] = self.insName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InsName"] as? String {
            self.insName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInstanceLinkedWhitelistTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Templates : Tea.TeaModel {
            public var id: Int32?

            public var ips: String?

            public var templateId: Int32?

            public var templateName: String?

            public var userId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Ips"] as? String {
                    self.ips = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["UserId"] as? Int32 {
                    self.userId = value
                }
            }
        }
        public var insName: String?

        public var templates: [DescribeInstanceLinkedWhitelistTemplateResponseBody.Data.Templates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.insName != nil {
                map["InsName"] = self.insName!
            }
            if self.templates != nil {
                var tmp : [Any] = []
                for k in self.templates! {
                    tmp.append(k.toMap())
                }
                map["Templates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InsName"] as? String {
                self.insName = value
            }
            if let value = dict["Templates"] as? [Any?] {
                var tmp : [DescribeInstanceLinkedWhitelistTemplateResponseBody.Data.Templates] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceLinkedWhitelistTemplateResponseBody.Data.Templates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.templates = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeInstanceLinkedWhitelistTemplateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeInstanceLinkedWhitelistTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeInstanceLinkedWhitelistTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceLinkedWhitelistTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceLinkedWhitelistTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeKmsAssociateResourcesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var kmsResourceId: String?

    public var kmsResourceRegionId: String?

    public var kmsResourceType: String?

    public var kmsResourceUser: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.kmsResourceId != nil {
            map["KmsResourceId"] = self.kmsResourceId!
        }
        if self.kmsResourceRegionId != nil {
            map["KmsResourceRegionId"] = self.kmsResourceRegionId!
        }
        if self.kmsResourceType != nil {
            map["KmsResourceType"] = self.kmsResourceType!
        }
        if self.kmsResourceUser != nil {
            map["KmsResourceUser"] = self.kmsResourceUser!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["KmsResourceId"] as? String {
            self.kmsResourceId = value
        }
        if let value = dict["KmsResourceRegionId"] as? String {
            self.kmsResourceRegionId = value
        }
        if let value = dict["KmsResourceType"] as? String {
            self.kmsResourceType = value
        }
        if let value = dict["KmsResourceUser"] as? String {
            self.kmsResourceUser = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeKmsAssociateResourcesResponseBody : Tea.TeaModel {
    public class AssociateDBInstances : Tea.TeaModel {
        public var DBInstanceName: String?

        public var engine: String?

        public var keyUsedBy: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.keyUsedBy != nil {
                map["KeyUsedBy"] = self.keyUsedBy!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["KeyUsedBy"] as? String {
                self.keyUsedBy = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var associateDBInstances: [DescribeKmsAssociateResourcesResponseBody.AssociateDBInstances]?

    public var associateStatus: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateDBInstances != nil {
            var tmp : [Any] = []
            for k in self.associateDBInstances! {
                tmp.append(k.toMap())
            }
            map["AssociateDBInstances"] = tmp
        }
        if self.associateStatus != nil {
            map["AssociateStatus"] = self.associateStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AssociateDBInstances"] as? [Any?] {
            var tmp : [DescribeKmsAssociateResourcesResponseBody.AssociateDBInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeKmsAssociateResourcesResponseBody.AssociateDBInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.associateDBInstances = tmp
        }
        if let value = dict["AssociateStatus"] as? Bool {
            self.associateStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeKmsAssociateResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKmsAssociateResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeKmsAssociateResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLocalAvailableRecoveryTimeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var region: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeLocalAvailableRecoveryTimeResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var recoveryBeginTime: String?

    public var recoveryEndTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.recoveryBeginTime != nil {
            map["RecoveryBeginTime"] = self.recoveryBeginTime!
        }
        if self.recoveryEndTime != nil {
            map["RecoveryEndTime"] = self.recoveryEndTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RecoveryBeginTime"] as? String {
            self.recoveryBeginTime = value
        }
        if let value = dict["RecoveryEndTime"] as? String {
            self.recoveryEndTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLocalAvailableRecoveryTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLocalAvailableRecoveryTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLocalAvailableRecoveryTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLogBackupFilesRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLogBackupFilesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class BinLogFile : Tea.TeaModel {
            public var downloadLink: String?

            public var fileSize: Int64?

            public var intranetDownloadLink: String?

            public var linkExpiredTime: String?

            public var logBeginTime: String?

            public var logEndTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downloadLink != nil {
                    map["DownloadLink"] = self.downloadLink!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.intranetDownloadLink != nil {
                    map["IntranetDownloadLink"] = self.intranetDownloadLink!
                }
                if self.linkExpiredTime != nil {
                    map["LinkExpiredTime"] = self.linkExpiredTime!
                }
                if self.logBeginTime != nil {
                    map["LogBeginTime"] = self.logBeginTime!
                }
                if self.logEndTime != nil {
                    map["LogEndTime"] = self.logEndTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DownloadLink"] as? String {
                    self.downloadLink = value
                }
                if let value = dict["FileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["IntranetDownloadLink"] as? String {
                    self.intranetDownloadLink = value
                }
                if let value = dict["LinkExpiredTime"] as? String {
                    self.linkExpiredTime = value
                }
                if let value = dict["LogBeginTime"] as? String {
                    self.logBeginTime = value
                }
                if let value = dict["LogEndTime"] as? String {
                    self.logEndTime = value
                }
            }
        }
        public var binLogFile: [DescribeLogBackupFilesResponseBody.Items.BinLogFile]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.binLogFile != nil {
                var tmp : [Any] = []
                for k in self.binLogFile! {
                    tmp.append(k.toMap())
                }
                map["BinLogFile"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BinLogFile"] as? [Any?] {
                var tmp : [DescribeLogBackupFilesResponseBody.Items.BinLogFile] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLogBackupFilesResponseBody.Items.BinLogFile()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.binLogFile = tmp
            }
        }
    }
    public var items: DescribeLogBackupFilesResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalFileSize: Int64?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalFileSize != nil {
            map["TotalFileSize"] = self.totalFileSize!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeLogBackupFilesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalFileSize"] as? Int64 {
            self.totalFileSize = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeLogBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLogBackupFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMarketingActivityRequest : Tea.TeaModel {
    public var aliUid: Int64?

    public var bid: String?

    public var clientToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var upgradeCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUid != nil {
            map["AliUid"] = self.aliUid!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.upgradeCode != nil {
            map["UpgradeCode"] = self.upgradeCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliUid"] as? Int64 {
            self.aliUid = value
        }
        if let value = dict["Bid"] as? String {
            self.bid = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UpgradeCode"] as? String {
            self.upgradeCode = value
        }
    }
}

public class DescribeMarketingActivityResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var category: String?

        public var chargeType: String?

        public var classCode: String?

        public var classGroup: String?

        public var cpu: String?

        public var diskSize: Int32?

        public var engine: String?

        public var engineVersion: String?

        public var instanceId: String?

        public var instanceName: String?

        public var maxConnections: Int32?

        public var maxIombps: Int32?

        public var maxIops: Int32?

        public var memory: Int64?

        public var storageType: String?

        public var upgradeCategory: String?

        public var upgradeClassCode: String?

        public var upgradeClassGroup: String?

        public var upgradeCpu: String?

        public var upgradeDescContent: String?

        public var upgradeDiskSize: Int32?

        public var upgradeMaxConnections: Int32?

        public var upgradeMaxIombps: Int32?

        public var upgradeMaxIops: Int32?

        public var upgradeMemory: Int64?

        public var upgradeReferencePrice: String?

        public var upgradeStorageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.classCode != nil {
                map["ClassCode"] = self.classCode!
            }
            if self.classGroup != nil {
                map["ClassGroup"] = self.classGroup!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.diskSize != nil {
                map["DiskSize"] = self.diskSize!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineVersion != nil {
                map["EngineVersion"] = self.engineVersion!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.maxConnections != nil {
                map["MaxConnections"] = self.maxConnections!
            }
            if self.maxIombps != nil {
                map["MaxIombps"] = self.maxIombps!
            }
            if self.maxIops != nil {
                map["MaxIops"] = self.maxIops!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            if self.upgradeCategory != nil {
                map["UpgradeCategory"] = self.upgradeCategory!
            }
            if self.upgradeClassCode != nil {
                map["UpgradeClassCode"] = self.upgradeClassCode!
            }
            if self.upgradeClassGroup != nil {
                map["UpgradeClassGroup"] = self.upgradeClassGroup!
            }
            if self.upgradeCpu != nil {
                map["UpgradeCpu"] = self.upgradeCpu!
            }
            if self.upgradeDescContent != nil {
                map["UpgradeDescContent"] = self.upgradeDescContent!
            }
            if self.upgradeDiskSize != nil {
                map["UpgradeDiskSize"] = self.upgradeDiskSize!
            }
            if self.upgradeMaxConnections != nil {
                map["UpgradeMaxConnections"] = self.upgradeMaxConnections!
            }
            if self.upgradeMaxIombps != nil {
                map["UpgradeMaxIombps"] = self.upgradeMaxIombps!
            }
            if self.upgradeMaxIops != nil {
                map["UpgradeMaxIops"] = self.upgradeMaxIops!
            }
            if self.upgradeMemory != nil {
                map["UpgradeMemory"] = self.upgradeMemory!
            }
            if self.upgradeReferencePrice != nil {
                map["UpgradeReferencePrice"] = self.upgradeReferencePrice!
            }
            if self.upgradeStorageType != nil {
                map["UpgradeStorageType"] = self.upgradeStorageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["ChargeType"] as? String {
                self.chargeType = value
            }
            if let value = dict["ClassCode"] as? String {
                self.classCode = value
            }
            if let value = dict["ClassGroup"] as? String {
                self.classGroup = value
            }
            if let value = dict["Cpu"] as? String {
                self.cpu = value
            }
            if let value = dict["DiskSize"] as? Int32 {
                self.diskSize = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineVersion"] as? String {
                self.engineVersion = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["MaxConnections"] as? Int32 {
                self.maxConnections = value
            }
            if let value = dict["MaxIombps"] as? Int32 {
                self.maxIombps = value
            }
            if let value = dict["MaxIops"] as? Int32 {
                self.maxIops = value
            }
            if let value = dict["Memory"] as? Int64 {
                self.memory = value
            }
            if let value = dict["StorageType"] as? String {
                self.storageType = value
            }
            if let value = dict["UpgradeCategory"] as? String {
                self.upgradeCategory = value
            }
            if let value = dict["UpgradeClassCode"] as? String {
                self.upgradeClassCode = value
            }
            if let value = dict["UpgradeClassGroup"] as? String {
                self.upgradeClassGroup = value
            }
            if let value = dict["UpgradeCpu"] as? String {
                self.upgradeCpu = value
            }
            if let value = dict["UpgradeDescContent"] as? String {
                self.upgradeDescContent = value
            }
            if let value = dict["UpgradeDiskSize"] as? Int32 {
                self.upgradeDiskSize = value
            }
            if let value = dict["UpgradeMaxConnections"] as? Int32 {
                self.upgradeMaxConnections = value
            }
            if let value = dict["UpgradeMaxIombps"] as? Int32 {
                self.upgradeMaxIombps = value
            }
            if let value = dict["UpgradeMaxIops"] as? Int32 {
                self.upgradeMaxIops = value
            }
            if let value = dict["UpgradeMemory"] as? Int64 {
                self.upgradeMemory = value
            }
            if let value = dict["UpgradeReferencePrice"] as? String {
                self.upgradeReferencePrice = value
            }
            if let value = dict["UpgradeStorageType"] as? String {
                self.upgradeStorageType = value
            }
        }
    }
    public var aliUid: Int64?

    public var bid: String?

    public var items: [DescribeMarketingActivityResponseBody.Items]?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUid != nil {
            map["AliUid"] = self.aliUid!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliUid"] as? Int64 {
            self.aliUid = value
        }
        if let value = dict["Bid"] as? String {
            self.bid = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeMarketingActivityResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeMarketingActivityResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeMarketingActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMarketingActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMarketingActivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMaskingRulesRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class DescribeMaskingRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public class RuleConfig : Tea.TeaModel {
                public var columns: [String]?

                public var databases: [String]?

                public var tables: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.databases != nil {
                        map["Databases"] = self.databases!
                    }
                    if self.tables != nil {
                        map["Tables"] = self.tables!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Columns"] as? [String] {
                        self.columns = value
                    }
                    if let value = dict["Databases"] as? [String] {
                        self.databases = value
                    }
                    if let value = dict["Tables"] as? [String] {
                        self.tables = value
                    }
                }
            }
            public var defaultAlgo: String?

            public var enabled: String?

            public var maskingAlgo: String?

            public var ruleConfig: DescribeMaskingRulesResponseBody.Data.Rules.RuleConfig?

            public var ruleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ruleConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultAlgo != nil {
                    map["DefaultAlgo"] = self.defaultAlgo!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.maskingAlgo != nil {
                    map["MaskingAlgo"] = self.maskingAlgo!
                }
                if self.ruleConfig != nil {
                    map["RuleConfig"] = self.ruleConfig?.toMap()
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DefaultAlgo"] as? String {
                    self.defaultAlgo = value
                }
                if let value = dict["Enabled"] as? String {
                    self.enabled = value
                }
                if let value = dict["MaskingAlgo"] as? String {
                    self.maskingAlgo = value
                }
                if let value = dict["RuleConfig"] as? [String: Any?] {
                    var model = DescribeMaskingRulesResponseBody.Data.Rules.RuleConfig()
                    model.fromMap(value)
                    self.ruleConfig = model
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
            }
        }
        public var rules: [DescribeMaskingRulesResponseBody.Data.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [DescribeMaskingRulesResponseBody.Data.Rules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeMaskingRulesResponseBody.Data.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
        }
    }
    public var data: DescribeMaskingRulesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeMaskingRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeMaskingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMaskingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMaskingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMetaListRequest : Tea.TeaModel {
    public var backupSetID: Int64?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var getDbName: String?

    public var ownerId: Int64?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var pattern: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var restoreType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetID != nil {
            map["BackupSetID"] = self.backupSetID!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.getDbName != nil {
            map["GetDbName"] = self.getDbName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.restoreType != nil {
            map["RestoreType"] = self.restoreType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetID"] as? Int64 {
            self.backupSetID = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["GetDbName"] as? String {
            self.getDbName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageIndex"] as? Int32 {
            self.pageIndex = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Pattern"] as? String {
            self.pattern = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["RestoreType"] as? String {
            self.restoreType = value
        }
    }
}

public class DescribeMetaListResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Meta : Tea.TeaModel {
            public var database: String?

            public var size: String?

            public var tables: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Size"] as? String {
                    self.size = value
                }
                if let value = dict["Tables"] as? String {
                    self.tables = value
                }
            }
        }
        public var meta: [DescribeMetaListResponseBody.Items.Meta]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.meta != nil {
                var tmp : [Any] = []
                for k in self.meta! {
                    tmp.append(k.toMap())
                }
                map["Meta"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Meta"] as? [Any?] {
                var tmp : [DescribeMetaListResponseBody.Items.Meta] = []
                for v in value {
                    if v != nil {
                        var model = DescribeMetaListResponseBody.Items.Meta()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.meta = tmp
            }
        }
    }
    public var DBInstanceName: String?

    public var items: DescribeMetaListResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalPageCount: Int32?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalPageCount != nil {
            map["TotalPageCount"] = self.totalPageCount!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeMetaListResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalPageCount"] as? Int32 {
            self.totalPageCount = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeMetaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMetaListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMigrateTaskByIdRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var migrateTaskId: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeMigrateTaskByIdResponseBody : Tea.TeaModel {
    public var backupMode: String?

    public var createTime: String?

    public var DBInstanceName: String?

    public var DBName: String?

    public var description_: String?

    public var endTime: String?

    public var isDBReplaced: String?

    public var migrateTaskId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupMode != nil {
            map["BackupMode"] = self.backupMode!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.isDBReplaced != nil {
            map["IsDBReplaced"] = self.isDBReplaced!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupMode"] as? String {
            self.backupMode = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["IsDBReplaced"] as? String {
            self.isDBReplaced = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeMigrateTaskByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrateTaskByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMigrateTaskByIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMigrateTasksRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeMigrateTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class MigrateTask : Tea.TeaModel {
            public var backupMode: String?

            public var createTime: String?

            public var DBName: String?

            public var description_: String?

            public var endTime: String?

            public var isDBReplaced: String?

            public var migrateTaskId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupMode != nil {
                    map["BackupMode"] = self.backupMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.isDBReplaced != nil {
                    map["IsDBReplaced"] = self.isDBReplaced!
                }
                if self.migrateTaskId != nil {
                    map["MigrateTaskId"] = self.migrateTaskId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupMode"] as? String {
                    self.backupMode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["IsDBReplaced"] as? String {
                    self.isDBReplaced = value
                }
                if let value = dict["MigrateTaskId"] as? String {
                    self.migrateTaskId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var migrateTask: [DescribeMigrateTasksResponseBody.Items.MigrateTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrateTask != nil {
                var tmp : [Any] = []
                for k in self.migrateTask! {
                    tmp.append(k.toMap())
                }
                map["MigrateTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MigrateTask"] as? [Any?] {
                var tmp : [DescribeMigrateTasksResponseBody.Items.MigrateTask] = []
                for v in value {
                    if v != nil {
                        var model = DescribeMigrateTasksResponseBody.Items.MigrateTask()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.migrateTask = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var items: DescribeMigrateTasksResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeMigrateTasksResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeMigrateTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrateTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMigrateTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeModifyPGHbaConfigLogRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeModifyPGHbaConfigLogResponseBody : Tea.TeaModel {
    public class HbaLogItems : Tea.TeaModel {
        public class HbaLogItem : Tea.TeaModel {
            public class AfterHbaItems : Tea.TeaModel {
                public class HbaItem : Tea.TeaModel {
                    public var address: String?

                    public var database: String?

                    public var mask: String?

                    public var method: String?

                    public var option: String?

                    public var priorityId: Int32?

                    public var type: String?

                    public var user: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.database != nil {
                            map["Database"] = self.database!
                        }
                        if self.mask != nil {
                            map["Mask"] = self.mask!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.option != nil {
                            map["Option"] = self.option!
                        }
                        if self.priorityId != nil {
                            map["PriorityId"] = self.priorityId!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.user != nil {
                            map["User"] = self.user!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["Database"] as? String {
                            self.database = value
                        }
                        if let value = dict["Mask"] as? String {
                            self.mask = value
                        }
                        if let value = dict["Method"] as? String {
                            self.method = value
                        }
                        if let value = dict["Option"] as? String {
                            self.option = value
                        }
                        if let value = dict["PriorityId"] as? Int32 {
                            self.priorityId = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["User"] as? String {
                            self.user = value
                        }
                    }
                }
                public var hbaItem: [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.AfterHbaItems.HbaItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.hbaItem != nil {
                        var tmp : [Any] = []
                        for k in self.hbaItem! {
                            tmp.append(k.toMap())
                        }
                        map["HbaItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HbaItem"] as? [Any?] {
                        var tmp : [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.AfterHbaItems.HbaItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.AfterHbaItems.HbaItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.hbaItem = tmp
                    }
                }
            }
            public class BeforeHbaItems : Tea.TeaModel {
                public class HbaItem : Tea.TeaModel {
                    public var address: String?

                    public var database: String?

                    public var mask: String?

                    public var method: String?

                    public var option: String?

                    public var priorityId: Int32?

                    public var type: String?

                    public var user: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.database != nil {
                            map["Database"] = self.database!
                        }
                        if self.mask != nil {
                            map["Mask"] = self.mask!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.option != nil {
                            map["Option"] = self.option!
                        }
                        if self.priorityId != nil {
                            map["PriorityId"] = self.priorityId!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.user != nil {
                            map["User"] = self.user!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Address"] as? String {
                            self.address = value
                        }
                        if let value = dict["Database"] as? String {
                            self.database = value
                        }
                        if let value = dict["Mask"] as? String {
                            self.mask = value
                        }
                        if let value = dict["Method"] as? String {
                            self.method = value
                        }
                        if let value = dict["Option"] as? String {
                            self.option = value
                        }
                        if let value = dict["PriorityId"] as? Int32 {
                            self.priorityId = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["User"] as? String {
                            self.user = value
                        }
                    }
                }
                public var hbaItem: [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.BeforeHbaItems.HbaItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.hbaItem != nil {
                        var tmp : [Any] = []
                        for k in self.hbaItem! {
                            tmp.append(k.toMap())
                        }
                        map["HbaItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HbaItem"] as? [Any?] {
                        var tmp : [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.BeforeHbaItems.HbaItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.BeforeHbaItems.HbaItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.hbaItem = tmp
                    }
                }
            }
            public var afterHbaItems: DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.AfterHbaItems?

            public var beforeHbaItems: DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.BeforeHbaItems?

            public var modifyStatus: String?

            public var modifyTime: String?

            public var statusReason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.afterHbaItems?.validate()
                try self.beforeHbaItems?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.afterHbaItems != nil {
                    map["AfterHbaItems"] = self.afterHbaItems?.toMap()
                }
                if self.beforeHbaItems != nil {
                    map["BeforeHbaItems"] = self.beforeHbaItems?.toMap()
                }
                if self.modifyStatus != nil {
                    map["ModifyStatus"] = self.modifyStatus!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.statusReason != nil {
                    map["StatusReason"] = self.statusReason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AfterHbaItems"] as? [String: Any?] {
                    var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.AfterHbaItems()
                    model.fromMap(value)
                    self.afterHbaItems = model
                }
                if let value = dict["BeforeHbaItems"] as? [String: Any?] {
                    var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem.BeforeHbaItems()
                    model.fromMap(value)
                    self.beforeHbaItems = model
                }
                if let value = dict["ModifyStatus"] as? String {
                    self.modifyStatus = value
                }
                if let value = dict["ModifyTime"] as? String {
                    self.modifyTime = value
                }
                if let value = dict["StatusReason"] as? String {
                    self.statusReason = value
                }
            }
        }
        public var hbaLogItem: [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hbaLogItem != nil {
                var tmp : [Any] = []
                for k in self.hbaLogItem! {
                    tmp.append(k.toMap())
                }
                map["HbaLogItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HbaLogItem"] as? [Any?] {
                var tmp : [DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems.HbaLogItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hbaLogItem = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var hbaLogItems: DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems?

    public var logItemCount: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hbaLogItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.hbaLogItems != nil {
            map["HbaLogItems"] = self.hbaLogItems?.toMap()
        }
        if self.logItemCount != nil {
            map["LogItemCount"] = self.logItemCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["HbaLogItems"] as? [String: Any?] {
            var model = DescribeModifyPGHbaConfigLogResponseBody.HbaLogItems()
            model.fromMap(value)
            self.hbaLogItems = model
        }
        if let value = dict["LogItemCount"] as? Int32 {
            self.logItemCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeModifyPGHbaConfigLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModifyPGHbaConfigLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeModifyPGHbaConfigLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeModifyParameterLogRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeModifyParameterLogResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class ParameterChangeLog : Tea.TeaModel {
            public var modifyTime: String?

            public var newParameterValue: String?

            public var oldParameterValue: String?

            public var parameterName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.newParameterValue != nil {
                    map["NewParameterValue"] = self.newParameterValue!
                }
                if self.oldParameterValue != nil {
                    map["OldParameterValue"] = self.oldParameterValue!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ModifyTime"] as? String {
                    self.modifyTime = value
                }
                if let value = dict["NewParameterValue"] as? String {
                    self.newParameterValue = value
                }
                if let value = dict["OldParameterValue"] as? String {
                    self.oldParameterValue = value
                }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var parameterChangeLog: [DescribeModifyParameterLogResponseBody.Items.ParameterChangeLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parameterChangeLog != nil {
                var tmp : [Any] = []
                for k in self.parameterChangeLog! {
                    tmp.append(k.toMap())
                }
                map["ParameterChangeLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParameterChangeLog"] as? [Any?] {
                var tmp : [DescribeModifyParameterLogResponseBody.Items.ParameterChangeLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeModifyParameterLogResponseBody.Items.ParameterChangeLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.parameterChangeLog = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var engine: String?

    public var engineVersion: String?

    public var items: DescribeModifyParameterLogResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeModifyParameterLogResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeModifyParameterLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModifyParameterLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeModifyParameterLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeOssDownloadsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var migrateTaskId: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeOssDownloadsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class OssDownload : Tea.TeaModel {
            public var backupMode: String?

            public var createTime: String?

            public var description_: String?

            public var endTime: String?

            public var fileName: String?

            public var fileSize: String?

            public var isAvailable: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupMode != nil {
                    map["BackupMode"] = self.backupMode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.isAvailable != nil {
                    map["IsAvailable"] = self.isAvailable!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupMode"] as? String {
                    self.backupMode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["FileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["FileSize"] as? String {
                    self.fileSize = value
                }
                if let value = dict["IsAvailable"] as? String {
                    self.isAvailable = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var ossDownload: [DescribeOssDownloadsResponseBody.Items.OssDownload]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossDownload != nil {
                var tmp : [Any] = []
                for k in self.ossDownload! {
                    tmp.append(k.toMap())
                }
                map["OssDownload"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OssDownload"] as? [Any?] {
                var tmp : [DescribeOssDownloadsResponseBody.Items.OssDownload] = []
                for v in value {
                    if v != nil {
                        var model = DescribeOssDownloadsResponseBody.Items.OssDownload()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ossDownload = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var items: DescribeOssDownloadsResponseBody.Items?

    public var migrateTaskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeOssDownloadsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeOssDownloadsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOssDownloadsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeOssDownloadsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePGHbaConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePGHbaConfigResponseBody : Tea.TeaModel {
    public class DefaultHbaItems : Tea.TeaModel {
        public class HbaItem : Tea.TeaModel {
            public var address: String?

            public var database: String?

            public var mask: String?

            public var method: String?

            public var option: String?

            public var priorityId: Int32?

            public var type: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.mask != nil {
                    map["Mask"] = self.mask!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.option != nil {
                    map["Option"] = self.option!
                }
                if self.priorityId != nil {
                    map["PriorityId"] = self.priorityId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Mask"] as? String {
                    self.mask = value
                }
                if let value = dict["Method"] as? String {
                    self.method = value
                }
                if let value = dict["Option"] as? String {
                    self.option = value
                }
                if let value = dict["PriorityId"] as? Int32 {
                    self.priorityId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var hbaItem: [DescribePGHbaConfigResponseBody.DefaultHbaItems.HbaItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hbaItem != nil {
                var tmp : [Any] = []
                for k in self.hbaItem! {
                    tmp.append(k.toMap())
                }
                map["HbaItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HbaItem"] as? [Any?] {
                var tmp : [DescribePGHbaConfigResponseBody.DefaultHbaItems.HbaItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribePGHbaConfigResponseBody.DefaultHbaItems.HbaItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hbaItem = tmp
            }
        }
    }
    public class RunningHbaItems : Tea.TeaModel {
        public class HbaItem : Tea.TeaModel {
            public var address: String?

            public var database: String?

            public var mask: String?

            public var method: String?

            public var option: String?

            public var priorityId: Int32?

            public var type: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.mask != nil {
                    map["Mask"] = self.mask!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.option != nil {
                    map["Option"] = self.option!
                }
                if self.priorityId != nil {
                    map["PriorityId"] = self.priorityId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Address"] as? String {
                    self.address = value
                }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Mask"] as? String {
                    self.mask = value
                }
                if let value = dict["Method"] as? String {
                    self.method = value
                }
                if let value = dict["Option"] as? String {
                    self.option = value
                }
                if let value = dict["PriorityId"] as? Int32 {
                    self.priorityId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var hbaItem: [DescribePGHbaConfigResponseBody.RunningHbaItems.HbaItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hbaItem != nil {
                var tmp : [Any] = []
                for k in self.hbaItem! {
                    tmp.append(k.toMap())
                }
                map["HbaItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HbaItem"] as? [Any?] {
                var tmp : [DescribePGHbaConfigResponseBody.RunningHbaItems.HbaItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribePGHbaConfigResponseBody.RunningHbaItems.HbaItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hbaItem = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var defaultHbaItems: DescribePGHbaConfigResponseBody.DefaultHbaItems?

    public var hbaModifyTime: String?

    public var lastModifyStatus: String?

    public var modifyStatusReason: String?

    public var requestId: String?

    public var runningHbaItems: DescribePGHbaConfigResponseBody.RunningHbaItems?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.defaultHbaItems?.validate()
        try self.runningHbaItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.defaultHbaItems != nil {
            map["DefaultHbaItems"] = self.defaultHbaItems?.toMap()
        }
        if self.hbaModifyTime != nil {
            map["HbaModifyTime"] = self.hbaModifyTime!
        }
        if self.lastModifyStatus != nil {
            map["LastModifyStatus"] = self.lastModifyStatus!
        }
        if self.modifyStatusReason != nil {
            map["ModifyStatusReason"] = self.modifyStatusReason!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.runningHbaItems != nil {
            map["RunningHbaItems"] = self.runningHbaItems?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DefaultHbaItems"] as? [String: Any?] {
            var model = DescribePGHbaConfigResponseBody.DefaultHbaItems()
            model.fromMap(value)
            self.defaultHbaItems = model
        }
        if let value = dict["HbaModifyTime"] as? String {
            self.hbaModifyTime = value
        }
        if let value = dict["LastModifyStatus"] as? String {
            self.lastModifyStatus = value
        }
        if let value = dict["ModifyStatusReason"] as? String {
            self.modifyStatusReason = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RunningHbaItems"] as? [String: Any?] {
            var model = DescribePGHbaConfigResponseBody.RunningHbaItems()
            model.fromMap(value)
            self.runningHbaItems = model
        }
    }
}

public class DescribePGHbaConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePGHbaConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePGHbaConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeParameterGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var parameterGroupId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeParameterGroupResponseBody : Tea.TeaModel {
    public class ParamGroup : Tea.TeaModel {
        public class ParameterGroup : Tea.TeaModel {
            public class ParamDetail : Tea.TeaModel {
                public class ParameterDetail : Tea.TeaModel {
                    public var paramName: String?

                    public var paramValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.paramName != nil {
                            map["ParamName"] = self.paramName!
                        }
                        if self.paramValue != nil {
                            map["ParamValue"] = self.paramValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ParamName"] as? String {
                            self.paramName = value
                        }
                        if let value = dict["ParamValue"] as? String {
                            self.paramValue = value
                        }
                    }
                }
                public var parameterDetail: [DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup.ParamDetail.ParameterDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterDetail != nil {
                        var tmp : [Any] = []
                        for k in self.parameterDetail! {
                            tmp.append(k.toMap())
                        }
                        map["ParameterDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ParameterDetail"] as? [Any?] {
                        var tmp : [DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup.ParamDetail.ParameterDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup.ParamDetail.ParameterDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.parameterDetail = tmp
                    }
                }
            }
            public var createTime: String?

            public var engine: String?

            public var engineVersion: String?

            public var forceRestart: Int32?

            public var paramCounts: Int32?

            public var paramDetail: DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup.ParamDetail?

            public var parameterGroupDesc: String?

            public var parameterGroupId: String?

            public var parameterGroupName: String?

            public var parameterGroupType: Int32?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.paramDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.forceRestart != nil {
                    map["ForceRestart"] = self.forceRestart!
                }
                if self.paramCounts != nil {
                    map["ParamCounts"] = self.paramCounts!
                }
                if self.paramDetail != nil {
                    map["ParamDetail"] = self.paramDetail?.toMap()
                }
                if self.parameterGroupDesc != nil {
                    map["ParameterGroupDesc"] = self.parameterGroupDesc!
                }
                if self.parameterGroupId != nil {
                    map["ParameterGroupId"] = self.parameterGroupId!
                }
                if self.parameterGroupName != nil {
                    map["ParameterGroupName"] = self.parameterGroupName!
                }
                if self.parameterGroupType != nil {
                    map["ParameterGroupType"] = self.parameterGroupType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ForceRestart"] as? Int32 {
                    self.forceRestart = value
                }
                if let value = dict["ParamCounts"] as? Int32 {
                    self.paramCounts = value
                }
                if let value = dict["ParamDetail"] as? [String: Any?] {
                    var model = DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup.ParamDetail()
                    model.fromMap(value)
                    self.paramDetail = model
                }
                if let value = dict["ParameterGroupDesc"] as? String {
                    self.parameterGroupDesc = value
                }
                if let value = dict["ParameterGroupId"] as? String {
                    self.parameterGroupId = value
                }
                if let value = dict["ParameterGroupName"] as? String {
                    self.parameterGroupName = value
                }
                if let value = dict["ParameterGroupType"] as? Int32 {
                    self.parameterGroupType = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
            }
        }
        public var parameterGroup: [DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parameterGroup != nil {
                var tmp : [Any] = []
                for k in self.parameterGroup! {
                    tmp.append(k.toMap())
                }
                map["ParameterGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParameterGroup"] as? [Any?] {
                var tmp : [DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParameterGroupResponseBody.ParamGroup.ParameterGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.parameterGroup = tmp
            }
        }
    }
    public class RelatedCustinsInfo : Tea.TeaModel {
        public class RelatedCustinsInfo : Tea.TeaModel {
            public var appliedTime: String?

            public var DBInstanceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appliedTime != nil {
                    map["AppliedTime"] = self.appliedTime!
                }
                if self.DBInstanceName != nil {
                    map["DBInstanceName"] = self.DBInstanceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppliedTime"] as? String {
                    self.appliedTime = value
                }
                if let value = dict["DBInstanceName"] as? String {
                    self.DBInstanceName = value
                }
            }
        }
        public var relatedCustinsInfo: [DescribeParameterGroupResponseBody.RelatedCustinsInfo.RelatedCustinsInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.relatedCustinsInfo != nil {
                var tmp : [Any] = []
                for k in self.relatedCustinsInfo! {
                    tmp.append(k.toMap())
                }
                map["RelatedCustinsInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RelatedCustinsInfo"] as? [Any?] {
                var tmp : [DescribeParameterGroupResponseBody.RelatedCustinsInfo.RelatedCustinsInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParameterGroupResponseBody.RelatedCustinsInfo.RelatedCustinsInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.relatedCustinsInfo = tmp
            }
        }
    }
    public var paramGroup: DescribeParameterGroupResponseBody.ParamGroup?

    public var relatedCustinsInfo: DescribeParameterGroupResponseBody.RelatedCustinsInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.paramGroup?.validate()
        try self.relatedCustinsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.paramGroup != nil {
            map["ParamGroup"] = self.paramGroup?.toMap()
        }
        if self.relatedCustinsInfo != nil {
            map["RelatedCustinsInfo"] = self.relatedCustinsInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ParamGroup"] as? [String: Any?] {
            var model = DescribeParameterGroupResponseBody.ParamGroup()
            model.fromMap(value)
            self.paramGroup = model
        }
        if let value = dict["RelatedCustinsInfo"] as? [String: Any?] {
            var model = DescribeParameterGroupResponseBody.RelatedCustinsInfo()
            model.fromMap(value)
            self.relatedCustinsInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeParameterGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParameterGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeParameterGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeParameterGroupsRequest : Tea.TeaModel {
    public var enableDetail: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableDetail != nil {
            map["EnableDetail"] = self.enableDetail!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableDetail"] as? Bool {
            self.enableDetail = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeParameterGroupsResponseBody : Tea.TeaModel {
    public class ParameterGroups : Tea.TeaModel {
        public class ParameterGroup : Tea.TeaModel {
            public var createTime: String?

            public var engine: String?

            public var engineVersion: String?

            public var forceRestart: Int32?

            public var paramCounts: Int32?

            public var parameterGroupDesc: String?

            public var parameterGroupId: String?

            public var parameterGroupName: String?

            public var parameterGroupType: Int32?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.forceRestart != nil {
                    map["ForceRestart"] = self.forceRestart!
                }
                if self.paramCounts != nil {
                    map["ParamCounts"] = self.paramCounts!
                }
                if self.parameterGroupDesc != nil {
                    map["ParameterGroupDesc"] = self.parameterGroupDesc!
                }
                if self.parameterGroupId != nil {
                    map["ParameterGroupId"] = self.parameterGroupId!
                }
                if self.parameterGroupName != nil {
                    map["ParameterGroupName"] = self.parameterGroupName!
                }
                if self.parameterGroupType != nil {
                    map["ParameterGroupType"] = self.parameterGroupType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ForceRestart"] as? Int32 {
                    self.forceRestart = value
                }
                if let value = dict["ParamCounts"] as? Int32 {
                    self.paramCounts = value
                }
                if let value = dict["ParameterGroupDesc"] as? String {
                    self.parameterGroupDesc = value
                }
                if let value = dict["ParameterGroupId"] as? String {
                    self.parameterGroupId = value
                }
                if let value = dict["ParameterGroupName"] as? String {
                    self.parameterGroupName = value
                }
                if let value = dict["ParameterGroupType"] as? Int32 {
                    self.parameterGroupType = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
            }
        }
        public var parameterGroup: [DescribeParameterGroupsResponseBody.ParameterGroups.ParameterGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parameterGroup != nil {
                var tmp : [Any] = []
                for k in self.parameterGroup! {
                    tmp.append(k.toMap())
                }
                map["ParameterGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParameterGroup"] as? [Any?] {
                var tmp : [DescribeParameterGroupsResponseBody.ParameterGroups.ParameterGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParameterGroupsResponseBody.ParameterGroups.ParameterGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.parameterGroup = tmp
            }
        }
    }
    public var parameterGroups: DescribeParameterGroupsResponseBody.ParameterGroups?

    public var requestId: String?

    public var signalForOptimizeParams: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.parameterGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameterGroups != nil {
            map["ParameterGroups"] = self.parameterGroups?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signalForOptimizeParams != nil {
            map["SignalForOptimizeParams"] = self.signalForOptimizeParams!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ParameterGroups"] as? [String: Any?] {
            var model = DescribeParameterGroupsResponseBody.ParameterGroups()
            model.fromMap(value)
            self.parameterGroups = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SignalForOptimizeParams"] as? Bool {
            self.signalForOptimizeParams = value
        }
    }
}

public class DescribeParameterGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParameterGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeParameterGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeParameterTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var engine: String?

    public var engineVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeParameterTemplatesResponseBody : Tea.TeaModel {
    public class Parameters : Tea.TeaModel {
        public class TemplateRecord : Tea.TeaModel {
            public var checkingCode: String?

            public var forceModify: String?

            public var forceRestart: String?

            public var parameterDescription: String?

            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingCode != nil {
                    map["CheckingCode"] = self.checkingCode!
                }
                if self.forceModify != nil {
                    map["ForceModify"] = self.forceModify!
                }
                if self.forceRestart != nil {
                    map["ForceRestart"] = self.forceRestart!
                }
                if self.parameterDescription != nil {
                    map["ParameterDescription"] = self.parameterDescription!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckingCode"] as? String {
                    self.checkingCode = value
                }
                if let value = dict["ForceModify"] as? String {
                    self.forceModify = value
                }
                if let value = dict["ForceRestart"] as? String {
                    self.forceRestart = value
                }
                if let value = dict["ParameterDescription"] as? String {
                    self.parameterDescription = value
                }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var templateRecord: [DescribeParameterTemplatesResponseBody.Parameters.TemplateRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.templateRecord != nil {
                var tmp : [Any] = []
                for k in self.templateRecord! {
                    tmp.append(k.toMap())
                }
                map["TemplateRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TemplateRecord"] as? [Any?] {
                var tmp : [DescribeParameterTemplatesResponseBody.Parameters.TemplateRecord] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParameterTemplatesResponseBody.Parameters.TemplateRecord()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.templateRecord = tmp
            }
        }
    }
    public var engine: String?

    public var engineVersion: String?

    public var parameterCount: String?

    public var parameters: DescribeParameterTemplatesResponseBody.Parameters?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.parameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.parameterCount != nil {
            map["ParameterCount"] = self.parameterCount!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["ParameterCount"] as? String {
            self.parameterCount = value
        }
        if let value = dict["Parameters"] as? [String: Any?] {
            var model = DescribeParameterTemplatesResponseBody.Parameters()
            model.fromMap(value)
            self.parameters = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeParameterTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParameterTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeParameterTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeParametersRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeParametersResponseBody : Tea.TeaModel {
    public class ConfigParameters : Tea.TeaModel {
        public class DBInstanceParameter : Tea.TeaModel {
            public var parameterDescription: String?

            public var parameterName: String?

            public var parameterValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterDescription != nil {
                    map["ParameterDescription"] = self.parameterDescription!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterDescription"] as? String {
                    self.parameterDescription = value
                }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
            }
        }
        public var DBInstanceParameter: [DescribeParametersResponseBody.ConfigParameters.DBInstanceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceParameter != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceParameter! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceParameter"] as? [Any?] {
                var tmp : [DescribeParametersResponseBody.ConfigParameters.DBInstanceParameter] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParametersResponseBody.ConfigParameters.DBInstanceParameter()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceParameter = tmp
            }
        }
    }
    public class ParamGroupInfo : Tea.TeaModel {
        public var paramGroupId: String?

        public var parameterGroupDesc: String?

        public var parameterGroupName: String?

        public var parameterGroupType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramGroupId != nil {
                map["ParamGroupId"] = self.paramGroupId!
            }
            if self.parameterGroupDesc != nil {
                map["ParameterGroupDesc"] = self.parameterGroupDesc!
            }
            if self.parameterGroupName != nil {
                map["ParameterGroupName"] = self.parameterGroupName!
            }
            if self.parameterGroupType != nil {
                map["ParameterGroupType"] = self.parameterGroupType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ParamGroupId"] as? String {
                self.paramGroupId = value
            }
            if let value = dict["ParameterGroupDesc"] as? String {
                self.parameterGroupDesc = value
            }
            if let value = dict["ParameterGroupName"] as? String {
                self.parameterGroupName = value
            }
            if let value = dict["ParameterGroupType"] as? String {
                self.parameterGroupType = value
            }
        }
    }
    public class RunningParameters : Tea.TeaModel {
        public class DBInstanceParameter : Tea.TeaModel {
            public var parameterDefaultValue: String?

            public var parameterDescription: String?

            public var parameterName: String?

            public var parameterValue: String?

            public var parameterValueRange: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parameterDefaultValue != nil {
                    map["ParameterDefaultValue"] = self.parameterDefaultValue!
                }
                if self.parameterDescription != nil {
                    map["ParameterDescription"] = self.parameterDescription!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.parameterValue != nil {
                    map["ParameterValue"] = self.parameterValue!
                }
                if self.parameterValueRange != nil {
                    map["ParameterValueRange"] = self.parameterValueRange!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ParameterDefaultValue"] as? String {
                    self.parameterDefaultValue = value
                }
                if let value = dict["ParameterDescription"] as? String {
                    self.parameterDescription = value
                }
                if let value = dict["ParameterName"] as? String {
                    self.parameterName = value
                }
                if let value = dict["ParameterValue"] as? String {
                    self.parameterValue = value
                }
                if let value = dict["ParameterValueRange"] as? String {
                    self.parameterValueRange = value
                }
            }
        }
        public var DBInstanceParameter: [DescribeParametersResponseBody.RunningParameters.DBInstanceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceParameter != nil {
                var tmp : [Any] = []
                for k in self.DBInstanceParameter! {
                    tmp.append(k.toMap())
                }
                map["DBInstanceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceParameter"] as? [Any?] {
                var tmp : [DescribeParametersResponseBody.RunningParameters.DBInstanceParameter] = []
                for v in value {
                    if v != nil {
                        var model = DescribeParametersResponseBody.RunningParameters.DBInstanceParameter()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBInstanceParameter = tmp
            }
        }
    }
    public var configParameters: DescribeParametersResponseBody.ConfigParameters?

    public var engine: String?

    public var engineVersion: String?

    public var paramGroupInfo: DescribeParametersResponseBody.ParamGroupInfo?

    public var requestId: String?

    public var runningParameters: DescribeParametersResponseBody.RunningParameters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configParameters?.validate()
        try self.paramGroupInfo?.validate()
        try self.runningParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configParameters != nil {
            map["ConfigParameters"] = self.configParameters?.toMap()
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.paramGroupInfo != nil {
            map["ParamGroupInfo"] = self.paramGroupInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.runningParameters != nil {
            map["RunningParameters"] = self.runningParameters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigParameters"] as? [String: Any?] {
            var model = DescribeParametersResponseBody.ConfigParameters()
            model.fromMap(value)
            self.configParameters = model
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["ParamGroupInfo"] as? [String: Any?] {
            var model = DescribeParametersResponseBody.ParamGroupInfo()
            model.fromMap(value)
            self.paramGroupInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RunningParameters"] as? [String: Any?] {
            var model = DescribeParametersResponseBody.RunningParameters()
            model.fromMap(value)
            self.runningParameters = model
        }
    }
}

public class DescribeParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeParametersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePostgresExtensionsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePostgresExtensionsResponseBody : Tea.TeaModel {
    public class InstalledExtensions : Tea.TeaModel {
        public var category: String?

        public var comment: String?

        public var defaultVersion: String?

        public var installedVersion: String?

        public var name: String?

        public var owner: String?

        public var priority: String?

        public var requires: String?

        public var uid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.defaultVersion != nil {
                map["DefaultVersion"] = self.defaultVersion!
            }
            if self.installedVersion != nil {
                map["InstalledVersion"] = self.installedVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.requires != nil {
                map["Requires"] = self.requires!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["DefaultVersion"] as? String {
                self.defaultVersion = value
            }
            if let value = dict["InstalledVersion"] as? String {
                self.installedVersion = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["Requires"] as? String {
                self.requires = value
            }
            if let value = dict["Uid"] as? String {
                self.uid = value
            }
        }
    }
    public class UninstalledExtensions : Tea.TeaModel {
        public var category: String?

        public var comment: String?

        public var defaultVersion: String?

        public var installedVersion: String?

        public var name: String?

        public var owner: String?

        public var priority: String?

        public var requires: String?

        public var uid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.defaultVersion != nil {
                map["DefaultVersion"] = self.defaultVersion!
            }
            if self.installedVersion != nil {
                map["InstalledVersion"] = self.installedVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.requires != nil {
                map["Requires"] = self.requires!
            }
            if self.uid != nil {
                map["Uid"] = self.uid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["DefaultVersion"] as? String {
                self.defaultVersion = value
            }
            if let value = dict["InstalledVersion"] as? String {
                self.installedVersion = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["Requires"] as? String {
                self.requires = value
            }
            if let value = dict["Uid"] as? String {
                self.uid = value
            }
        }
    }
    public var installedExtensions: [DescribePostgresExtensionsResponseBody.InstalledExtensions]?

    public var overview: [String: Any]?

    public var requestId: String?

    public var uninstalledExtensions: [DescribePostgresExtensionsResponseBody.UninstalledExtensions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.installedExtensions != nil {
            var tmp : [Any] = []
            for k in self.installedExtensions! {
                tmp.append(k.toMap())
            }
            map["InstalledExtensions"] = tmp
        }
        if self.overview != nil {
            map["Overview"] = self.overview!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uninstalledExtensions != nil {
            var tmp : [Any] = []
            for k in self.uninstalledExtensions! {
                tmp.append(k.toMap())
            }
            map["UninstalledExtensions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstalledExtensions"] as? [Any?] {
            var tmp : [DescribePostgresExtensionsResponseBody.InstalledExtensions] = []
            for v in value {
                if v != nil {
                    var model = DescribePostgresExtensionsResponseBody.InstalledExtensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.installedExtensions = tmp
        }
        if let value = dict["Overview"] as? [String: Any] {
            self.overview = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UninstalledExtensions"] as? [Any?] {
            var tmp : [DescribePostgresExtensionsResponseBody.UninstalledExtensions] = []
            for v in value {
                if v != nil {
                    var model = DescribePostgresExtensionsResponseBody.UninstalledExtensions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.uninstalledExtensions = tmp
        }
    }
}

public class DescribePostgresExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePostgresExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePostgresExtensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public class DBNode : Tea.TeaModel {
        public var classCode: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classCode != nil {
                map["ClassCode"] = self.classCode!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClassCode"] as? String {
                self.classCode = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public class ServerlessConfig : Tea.TeaModel {
        public var maxCapacity: Double?

        public var minCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxCapacity != nil {
                map["MaxCapacity"] = self.maxCapacity!
            }
            if self.minCapacity != nil {
                map["MinCapacity"] = self.minCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxCapacity"] as? Double {
                self.maxCapacity = value
            }
            if let value = dict["MinCapacity"] as? Double {
                self.minCapacity = value
            }
        }
    }
    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var DBNode: [DescribePriceRequest.DBNode]?

    public var engine: String?

    public var engineVersion: String?

    public var instanceUsedType: Int32?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverlessConfig: DescribePriceRequest.ServerlessConfig?

    public var timeType: String?

    public var usedTime: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serverlessConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBNode != nil {
            var tmp : [Any] = []
            for k in self.DBNode! {
                tmp.append(k.toMap())
            }
            map["DBNode"] = tmp
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceUsedType != nil {
            map["InstanceUsedType"] = self.instanceUsedType!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverlessConfig != nil {
            map["ServerlessConfig"] = self.serverlessConfig?.toMap()
        }
        if self.timeType != nil {
            map["TimeType"] = self.timeType!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBNode"] as? [Any?] {
            var tmp : [DescribePriceRequest.DBNode] = []
            for v in value {
                if v != nil {
                    var model = DescribePriceRequest.DBNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBNode = tmp
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceUsedType"] as? Int32 {
            self.instanceUsedType = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Quantity"] as? Int32 {
            self.quantity = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerlessConfig"] as? [String: Any?] {
            var model = DescribePriceRequest.ServerlessConfig()
            model.fromMap(value)
            self.serverlessConfig = model
        }
        if let value = dict["TimeType"] as? String {
            self.timeType = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribePriceShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var DBNodeShrink: String?

    public var engine: String?

    public var engineVersion: String?

    public var instanceUsedType: Int32?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverlessConfigShrink: String?

    public var timeType: String?

    public var usedTime: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBNodeShrink != nil {
            map["DBNode"] = self.DBNodeShrink!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.instanceUsedType != nil {
            map["InstanceUsedType"] = self.instanceUsedType!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverlessConfigShrink != nil {
            map["ServerlessConfig"] = self.serverlessConfigShrink!
        }
        if self.timeType != nil {
            map["TimeType"] = self.timeType!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBNode"] as? String {
            self.DBNodeShrink = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["InstanceUsedType"] as? Int32 {
            self.instanceUsedType = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Quantity"] as? Int32 {
            self.quantity = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerlessConfig"] as? String {
            self.serverlessConfigShrink = value
        }
        if let value = dict["TimeType"] as? String {
            self.timeType = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class ActivityInfo : Tea.TeaModel {
            public var checkErrMsg: String?

            public var errorCode: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkErrMsg != nil {
                    map["CheckErrMsg"] = self.checkErrMsg!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckErrMsg"] as? String {
                    self.checkErrMsg = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? String {
                    self.success = value
                }
            }
        }
        public class Coupons : Tea.TeaModel {
            public class Coupon : Tea.TeaModel {
                public var couponNo: String?

                public var description_: String?

                public var isSelected: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.couponNo != nil {
                        map["CouponNo"] = self.couponNo!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.isSelected != nil {
                        map["IsSelected"] = self.isSelected!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CouponNo"] as? String {
                        self.couponNo = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["IsSelected"] as? String {
                        self.isSelected = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var coupon: [DescribePriceResponseBody.PriceInfo.Coupons.Coupon]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coupon != nil {
                    var tmp : [Any] = []
                    for k in self.coupon! {
                        tmp.append(k.toMap())
                    }
                    map["Coupon"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Coupon"] as? [Any?] {
                    var tmp : [DescribePriceResponseBody.PriceInfo.Coupons.Coupon] = []
                    for v in value {
                        if v != nil {
                            var model = DescribePriceResponseBody.PriceInfo.Coupons.Coupon()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.coupon = tmp
                }
            }
        }
        public class RuleIds : Tea.TeaModel {
            public var ruleId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleId"] as? [String] {
                    self.ruleId = value
                }
            }
        }
        public var activityInfo: DescribePriceResponseBody.PriceInfo.ActivityInfo?

        public var coupons: DescribePriceResponseBody.PriceInfo.Coupons?

        public var currency: String?

        public var discountPrice: Double?

        public var orderLines: Any?

        public var originalPrice: Double?

        public var ruleIds: DescribePriceResponseBody.PriceInfo.RuleIds?

        public var tradeMaxRCUAmount: Double?

        public var tradeMinRCUAmount: Double?

        public var tradePrice: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.activityInfo?.validate()
            try self.coupons?.validate()
            try self.ruleIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityInfo != nil {
                map["ActivityInfo"] = self.activityInfo?.toMap()
            }
            if self.coupons != nil {
                map["Coupons"] = self.coupons?.toMap()
            }
            if self.currency != nil {
                map["Currency"] = self.currency!
            }
            if self.discountPrice != nil {
                map["DiscountPrice"] = self.discountPrice!
            }
            if self.orderLines != nil {
                map["OrderLines"] = self.orderLines!
            }
            if self.originalPrice != nil {
                map["OriginalPrice"] = self.originalPrice!
            }
            if self.ruleIds != nil {
                map["RuleIds"] = self.ruleIds?.toMap()
            }
            if self.tradeMaxRCUAmount != nil {
                map["TradeMaxRCUAmount"] = self.tradeMaxRCUAmount!
            }
            if self.tradeMinRCUAmount != nil {
                map["TradeMinRCUAmount"] = self.tradeMinRCUAmount!
            }
            if self.tradePrice != nil {
                map["TradePrice"] = self.tradePrice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivityInfo"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.ActivityInfo()
                model.fromMap(value)
                self.activityInfo = model
            }
            if let value = dict["Coupons"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.Coupons()
                model.fromMap(value)
                self.coupons = model
            }
            if let value = dict["Currency"] as? String {
                self.currency = value
            }
            if let value = dict["DiscountPrice"] as? Double {
                self.discountPrice = value
            }
            if let value = dict["OrderLines"] as? Any {
                self.orderLines = value
            }
            if let value = dict["OriginalPrice"] as? Double {
                self.originalPrice = value
            }
            if let value = dict["RuleIds"] as? [String: Any?] {
                var model = DescribePriceResponseBody.PriceInfo.RuleIds()
                model.fromMap(value)
                self.ruleIds = model
            }
            if let value = dict["TradeMaxRCUAmount"] as? Double {
                self.tradeMaxRCUAmount = value
            }
            if let value = dict["TradeMinRCUAmount"] as? Double {
                self.tradeMinRCUAmount = value
            }
            if let value = dict["TradePrice"] as? Double {
                self.tradePrice = value
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public class Rule : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var ruleId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RuleId"] as? Int64 {
                    self.ruleId = value
                }
            }
        }
        public var rule: [DescribePriceResponseBody.Rules.Rule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.rule != nil {
                var tmp : [Any] = []
                for k in self.rule! {
                    tmp.append(k.toMap())
                }
                map["Rule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Rule"] as? [Any?] {
                var tmp : [DescribePriceResponseBody.Rules.Rule] = []
                for v in value {
                    if v != nil {
                        var model = DescribePriceResponseBody.Rules.Rule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rule = tmp
            }
        }
    }
    public class ServerlessPrice : Tea.TeaModel {
        public var RCUDiscountMaxAmount: Double?

        public var RCUDiscountMinAmount: Double?

        public var RCUOriginalMaxAmount: Double?

        public var RCUOriginalMinAmount: Double?

        public var storageOriginalAmount: Double?

        public var totalOriginalMaxAmount: Double?

        public var totalOriginalMinAmount: Double?

        public var tradeMaxRCUAmount: Double?

        public var tradeMinRCUAmount: Double?

        public var storageDiscountAmount: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.RCUDiscountMaxAmount != nil {
                map["RCUDiscountMaxAmount"] = self.RCUDiscountMaxAmount!
            }
            if self.RCUDiscountMinAmount != nil {
                map["RCUDiscountMinAmount"] = self.RCUDiscountMinAmount!
            }
            if self.RCUOriginalMaxAmount != nil {
                map["RCUOriginalMaxAmount"] = self.RCUOriginalMaxAmount!
            }
            if self.RCUOriginalMinAmount != nil {
                map["RCUOriginalMinAmount"] = self.RCUOriginalMinAmount!
            }
            if self.storageOriginalAmount != nil {
                map["StorageOriginalAmount"] = self.storageOriginalAmount!
            }
            if self.totalOriginalMaxAmount != nil {
                map["TotalOriginalMaxAmount"] = self.totalOriginalMaxAmount!
            }
            if self.totalOriginalMinAmount != nil {
                map["TotalOriginalMinAmount"] = self.totalOriginalMinAmount!
            }
            if self.tradeMaxRCUAmount != nil {
                map["TradeMaxRCUAmount"] = self.tradeMaxRCUAmount!
            }
            if self.tradeMinRCUAmount != nil {
                map["TradeMinRCUAmount"] = self.tradeMinRCUAmount!
            }
            if self.storageDiscountAmount != nil {
                map["storageDiscountAmount"] = self.storageDiscountAmount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RCUDiscountMaxAmount"] as? Double {
                self.RCUDiscountMaxAmount = value
            }
            if let value = dict["RCUDiscountMinAmount"] as? Double {
                self.RCUDiscountMinAmount = value
            }
            if let value = dict["RCUOriginalMaxAmount"] as? Double {
                self.RCUOriginalMaxAmount = value
            }
            if let value = dict["RCUOriginalMinAmount"] as? Double {
                self.RCUOriginalMinAmount = value
            }
            if let value = dict["StorageOriginalAmount"] as? Double {
                self.storageOriginalAmount = value
            }
            if let value = dict["TotalOriginalMaxAmount"] as? Double {
                self.totalOriginalMaxAmount = value
            }
            if let value = dict["TotalOriginalMinAmount"] as? Double {
                self.totalOriginalMinAmount = value
            }
            if let value = dict["TradeMaxRCUAmount"] as? Double {
                self.tradeMaxRCUAmount = value
            }
            if let value = dict["TradeMinRCUAmount"] as? Double {
                self.tradeMinRCUAmount = value
            }
            if let value = dict["storageDiscountAmount"] as? Double {
                self.storageDiscountAmount = value
            }
        }
    }
    public var orderParams: String?

    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public var rules: DescribePriceResponseBody.Rules?

    public var serverlessPrice: DescribePriceResponseBody.ServerlessPrice?

    public var showDiscount: Bool?

    public var tradeMaxRCUAmount: Double?

    public var tradeMinRCUAmount: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
        try self.rules?.validate()
        try self.serverlessPrice?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderParams != nil {
            map["OrderParams"] = self.orderParams!
        }
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rules != nil {
            map["Rules"] = self.rules?.toMap()
        }
        if self.serverlessPrice != nil {
            map["ServerlessPrice"] = self.serverlessPrice?.toMap()
        }
        if self.showDiscount != nil {
            map["ShowDiscount"] = self.showDiscount!
        }
        if self.tradeMaxRCUAmount != nil {
            map["TradeMaxRCUAmount"] = self.tradeMaxRCUAmount!
        }
        if self.tradeMinRCUAmount != nil {
            map["TradeMinRCUAmount"] = self.tradeMinRCUAmount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderParams"] as? String {
            self.orderParams = value
        }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Rules"] as? [String: Any?] {
            var model = DescribePriceResponseBody.Rules()
            model.fromMap(value)
            self.rules = model
        }
        if let value = dict["ServerlessPrice"] as? [String: Any?] {
            var model = DescribePriceResponseBody.ServerlessPrice()
            model.fromMap(value)
            self.serverlessPrice = model
        }
        if let value = dict["ShowDiscount"] as? Bool {
            self.showDiscount = value
        }
        if let value = dict["TradeMaxRCUAmount"] as? Double {
            self.tradeMaxRCUAmount = value
        }
        if let value = dict["TradeMinRCUAmount"] as? Double {
            self.tradeMinRCUAmount = value
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeQuickSaleConfigRequest : Tea.TeaModel {
    public var commodity: String?

    public var engine: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodity != nil {
            map["Commodity"] = self.commodity!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Commodity"] as? String {
            self.commodity = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeQuickSaleConfigResponseBody : Tea.TeaModel {
    public var commodity: String?

    public var items: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodity != nil {
            map["Commodity"] = self.commodity!
        }
        if self.items != nil {
            map["Items"] = self.items!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Commodity"] as? String {
            self.commodity = value
        }
        if let value = dict["Items"] as? [String: Any] {
            self.items = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeQuickSaleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQuickSaleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeQuickSaleConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCClusterConfigRequest : Tea.TeaModel {
    public var regionId: String?

    public var temporaryDurationMinutes: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.temporaryDurationMinutes != nil {
            map["TemporaryDurationMinutes"] = self.temporaryDurationMinutes!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TemporaryDurationMinutes"] as? Int32 {
            self.temporaryDurationMinutes = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCClusterConfigResponseBody : Tea.TeaModel {
    public var config: String?

    public var expiration: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.expiration != nil {
            map["Expiration"] = self.expiration!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Config"] as? String {
            self.config = value
        }
        if let value = dict["Expiration"] as? String {
            self.expiration = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCClusterConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCClusterConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCClusterConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCClusterNodesRequest : Tea.TeaModel {
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCClusterNodesResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var creationTime: String?

        public var dockerVersion: String?

        public var imageId: String?

        public var instanceId: String?

        public var instanceRole: String?

        public var ipAddresses: [String]?

        public var isAliyunNode: Bool?

        public var nodeName: String?

        public var nodePoolId: String?

        public var nodeStatus: String?

        public var runtimeVersion: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.dockerVersion != nil {
                map["DockerVersion"] = self.dockerVersion!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceRole != nil {
                map["InstanceRole"] = self.instanceRole!
            }
            if self.ipAddresses != nil {
                map["IpAddresses"] = self.ipAddresses!
            }
            if self.isAliyunNode != nil {
                map["IsAliyunNode"] = self.isAliyunNode!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.nodePoolId != nil {
                map["NodePoolId"] = self.nodePoolId!
            }
            if self.nodeStatus != nil {
                map["NodeStatus"] = self.nodeStatus!
            }
            if self.runtimeVersion != nil {
                map["RuntimeVersion"] = self.runtimeVersion!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DockerVersion"] as? String {
                self.dockerVersion = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceRole"] as? String {
                self.instanceRole = value
            }
            if let value = dict["IpAddresses"] as? [String] {
                self.ipAddresses = value
            }
            if let value = dict["IsAliyunNode"] as? Bool {
                self.isAliyunNode = value
            }
            if let value = dict["NodeName"] as? String {
                self.nodeName = value
            }
            if let value = dict["NodePoolId"] as? String {
                self.nodePoolId = value
            }
            if let value = dict["NodeStatus"] as? String {
                self.nodeStatus = value
            }
            if let value = dict["RuntimeVersion"] as? String {
                self.runtimeVersion = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public class Page : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var nodes: [DescribeRCClusterNodesResponseBody.Nodes]?

    public var page: DescribeRCClusterNodesResponseBody.Page?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.page?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.page != nil {
            map["Page"] = self.page?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Nodes"] as? [Any?] {
            var tmp : [DescribeRCClusterNodesResponseBody.Nodes] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCClusterNodesResponseBody.Nodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nodes = tmp
        }
        if let value = dict["Page"] as? [String: Any?] {
            var model = DescribeRCClusterNodesResponseBody.Page()
            model.fromMap(value)
            self.page = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCClusterNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCClusterNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCClusterNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCClustersRequest : Tea.TeaModel {
    public var profile: String?

    public var regionId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Profile"] as? String {
            self.profile = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCClustersResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var createTime: String?

        public var profile: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.profile != nil {
                map["Profile"] = self.profile!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["ClusterName"] as? String {
                self.clusterName = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Profile"] as? String {
                self.profile = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var clusters: [DescribeRCClustersResponseBody.Clusters]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            var tmp : [Any] = []
            for k in self.clusters! {
                tmp.append(k.toMap())
            }
            map["Clusters"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Clusters"] as? [Any?] {
            var tmp : [DescribeRCClustersResponseBody.Clusters] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCClustersResponseBody.Clusters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.clusters = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCDeploymentSetsRequest : Tea.TeaModel {
    public var deploymentSetIds: String?

    public var deploymentSetName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var strategy: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetIds != nil {
            map["DeploymentSetIds"] = self.deploymentSetIds!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSetIds"] as? String {
            self.deploymentSetIds = value
        }
        if let value = dict["DeploymentSetName"] as? String {
            self.deploymentSetName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Strategy"] as? String {
            self.strategy = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
    }
}

public class DescribeRCDeploymentSetsResponseBody : Tea.TeaModel {
    public class DeploymentSets : Tea.TeaModel {
        public class DeploymentSet : Tea.TeaModel {
            public class Capacities : Tea.TeaModel {
                public class Capacity : Tea.TeaModel {
                    public var availableAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvailableAmount"] as? Int32 {
                            self.availableAmount = value
                        }
                        if let value = dict["UsedAmount"] as? Int32 {
                            self.usedAmount = value
                        }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var capacity: [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacity != nil {
                        var tmp : [Any] = []
                        for k in self.capacity! {
                            tmp.append(k.toMap())
                        }
                        map["Capacity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Capacity"] as? [Any?] {
                        var tmp : [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.capacity = tmp
                    }
                }
            }
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceId"] as? [String] {
                        self.instanceId = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var resourceId: String?

                    public var resourceType: String?

                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var capacities: DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities?

            public var createTime: String?

            public var deploymentSetDescription: String?

            public var deploymentSetId: String?

            public var deploymentSetName: String?

            public var deploymentStrategy: String?

            public var domain: String?

            public var granularity: String?

            public var groupCount: Int32?

            public var instanceAmount: Int32?

            public var instanceIds: DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds?

            public var strategy: String?

            public var tags: DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacities?.validate()
                try self.instanceIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacities != nil {
                    map["Capacities"] = self.capacities?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.deploymentSetDescription != nil {
                    map["DeploymentSetDescription"] = self.deploymentSetDescription!
                }
                if self.deploymentSetId != nil {
                    map["DeploymentSetId"] = self.deploymentSetId!
                }
                if self.deploymentSetName != nil {
                    map["DeploymentSetName"] = self.deploymentSetName!
                }
                if self.deploymentStrategy != nil {
                    map["DeploymentStrategy"] = self.deploymentStrategy!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.granularity != nil {
                    map["Granularity"] = self.granularity!
                }
                if self.groupCount != nil {
                    map["GroupCount"] = self.groupCount!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Capacities"] as? [String: Any?] {
                    var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities()
                    model.fromMap(value)
                    self.capacities = model
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DeploymentSetDescription"] as? String {
                    self.deploymentSetDescription = value
                }
                if let value = dict["DeploymentSetId"] as? String {
                    self.deploymentSetId = value
                }
                if let value = dict["DeploymentSetName"] as? String {
                    self.deploymentSetName = value
                }
                if let value = dict["DeploymentStrategy"] as? String {
                    self.deploymentStrategy = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Granularity"] as? String {
                    self.granularity = value
                }
                if let value = dict["GroupCount"] as? Int32 {
                    self.groupCount = value
                }
                if let value = dict["InstanceAmount"] as? Int32 {
                    self.instanceAmount = value
                }
                if let value = dict["InstanceIds"] as? [String: Any?] {
                    var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds()
                    model.fromMap(value)
                    self.instanceIds = model
                }
                if let value = dict["Strategy"] as? String {
                    self.strategy = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var deploymentSet: [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deploymentSet != nil {
                var tmp : [Any] = []
                for k in self.deploymentSet! {
                    tmp.append(k.toMap())
                }
                map["DeploymentSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeploymentSet"] as? [Any?] {
                var tmp : [DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets.DeploymentSet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.deploymentSet = tmp
            }
        }
    }
    public var deploymentSets: DescribeRCDeploymentSetsResponseBody.DeploymentSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deploymentSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSets != nil {
            map["DeploymentSets"] = self.deploymentSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeploymentSets"] as? [String: Any?] {
            var model = DescribeRCDeploymentSetsResponseBody.DeploymentSets()
            model.fromMap(value)
            self.deploymentSets = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRCDeploymentSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCDeploymentSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCDeploymentSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCDisksRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var diskIds: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var tag: [DescribeRCDisksRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskIds"] as? String {
            self.diskIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeRCDisksRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCDisksRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeRCDisksResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var category: String?

        public var creationTime: String?

        public var deleteAutoSnapshot: Bool?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskChargeType: String?

        public var diskId: String?

        public var diskName: String?

        public var encrypted: Bool?

        public var expiredTime: String?

        public var IOPS: Int64?

        public var imageId: String?

        public var instanceId: String?

        public var performanceLevel: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var serialNumber: String?

        public var size: Int64?

        public var sourceSnapshotId: String?

        public var status: String?

        public var storageClusterId: String?

        public var storageSetId: String?

        public var tag: [DescribeRCDisksResponseBody.Disks.Tag]?

        public var type: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deleteAutoSnapshot != nil {
                map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskChargeType != nil {
                map["DiskChargeType"] = self.diskChargeType!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.IOPS != nil {
                map["IOPS"] = self.IOPS!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.serialNumber != nil {
                map["SerialNumber"] = self.serialNumber!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.sourceSnapshotId != nil {
                map["SourceSnapshotId"] = self.sourceSnapshotId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            if self.storageSetId != nil {
                map["StorageSetId"] = self.storageSetId!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["DeleteAutoSnapshot"] as? Bool {
                self.deleteAutoSnapshot = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["DiskChargeType"] as? String {
                self.diskChargeType = value
            }
            if let value = dict["DiskId"] as? String {
                self.diskId = value
            }
            if let value = dict["DiskName"] as? String {
                self.diskName = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["ExpiredTime"] as? String {
                self.expiredTime = value
            }
            if let value = dict["IOPS"] as? Int64 {
                self.IOPS = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SerialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["Size"] as? Int64 {
                self.size = value
            }
            if let value = dict["SourceSnapshotId"] as? String {
                self.sourceSnapshotId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StorageClusterId"] as? String {
                self.storageClusterId = value
            }
            if let value = dict["StorageSetId"] as? String {
                self.storageSetId = value
            }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeRCDisksResponseBody.Disks.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCDisksResponseBody.Disks.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var disks: [DescribeRCDisksResponseBody.Disks]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            var tmp : [Any] = []
            for k in self.disks! {
                tmp.append(k.toMap())
            }
            map["Disks"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Disks"] as? [Any?] {
            var tmp : [DescribeRCDisksResponseBody.Disks] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCDisksResponseBody.Disks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.disks = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeRCDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCDisksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCImageListRequest : Tea.TeaModel {
    public var architecture: String?

    public var imageId: String?

    public var imageName: String?

    public var instanceType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Architecture"] as? String {
            self.architecture = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageName"] as? String {
            self.imageName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeRCImageListResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class DiskDeviceMappings : Tea.TeaModel {
            public var device: String?

            public var size: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["Size"] as? String {
                    self.size = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var architecture: String?

        public var creationTime: String?

        public var description_: String?

        public var diskDeviceMappings: [DescribeRCImageListResponseBody.Images.DiskDeviceMappings]?

        public var imageId: String?

        public var imageName: String?

        public var imageVersion: String?

        public var isPublic: Bool?

        public var isSupportRdsCustom: Bool?

        public var OSName: String?

        public var OSNameEn: String?

        public var OSType: String?

        public var platform: String?

        public var size: Int64?

        public var status: String?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architecture != nil {
                map["Architecture"] = self.architecture!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskDeviceMappings != nil {
                var tmp : [Any] = []
                for k in self.diskDeviceMappings! {
                    tmp.append(k.toMap())
                }
                map["DiskDeviceMappings"] = tmp
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageVersion != nil {
                map["ImageVersion"] = self.imageVersion!
            }
            if self.isPublic != nil {
                map["IsPublic"] = self.isPublic!
            }
            if self.isSupportRdsCustom != nil {
                map["IsSupportRdsCustom"] = self.isSupportRdsCustom!
            }
            if self.OSName != nil {
                map["OSName"] = self.OSName!
            }
            if self.OSNameEn != nil {
                map["OSNameEn"] = self.OSNameEn!
            }
            if self.OSType != nil {
                map["OSType"] = self.OSType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Architecture"] as? String {
                self.architecture = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DiskDeviceMappings"] as? [Any?] {
                var tmp : [DescribeRCImageListResponseBody.Images.DiskDeviceMappings] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCImageListResponseBody.Images.DiskDeviceMappings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diskDeviceMappings = tmp
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["ImageName"] as? String {
                self.imageName = value
            }
            if let value = dict["ImageVersion"] as? String {
                self.imageVersion = value
            }
            if let value = dict["IsPublic"] as? Bool {
                self.isPublic = value
            }
            if let value = dict["IsSupportRdsCustom"] as? Bool {
                self.isSupportRdsCustom = value
            }
            if let value = dict["OSName"] as? String {
                self.OSName = value
            }
            if let value = dict["OSNameEn"] as? String {
                self.OSNameEn = value
            }
            if let value = dict["OSType"] as? String {
                self.OSType = value
            }
            if let value = dict["Platform"] as? String {
                self.platform = value
            }
            if let value = dict["Size"] as? Int64 {
                self.size = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Usage"] as? String {
                self.usage = value
            }
        }
    }
    public var images: [DescribeRCImageListResponseBody.Images]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            var tmp : [Any] = []
            for k in self.images! {
                tmp.append(k.toMap())
            }
            map["Images"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Images"] as? [Any?] {
            var tmp : [DescribeRCImageListResponseBody.Images] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCImageListResponseBody.Images()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.images = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRCImageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCImageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCImageListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var privateIpAddress: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceAttributeResponseBody : Tea.TeaModel {
    public class DataDisks : Tea.TeaModel {
        public class DataDisk : Tea.TeaModel {
            public var category: String?

            public var deleteWithInstance: Bool?

            public var encrypted: String?

            public var performanceLevel: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Encrypted"] as? String {
                    self.encrypted = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
            }
        }
        public var dataDisk: [DescribeRCInstanceAttributeResponseBody.DataDisks.DataDisk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataDisk"] as? [Any?] {
                var tmp : [DescribeRCInstanceAttributeResponseBody.DataDisks.DataDisk] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceAttributeResponseBody.DataDisks.DataDisk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDisk = tmp
            }
        }
    }
    public class DedicatedHostAttribute : Tea.TeaModel {
        public var dedicatedHostId: String?

        public var dedicatedHostName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.dedicatedHostName != nil {
                map["DedicatedHostName"] = self.dedicatedHostName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DedicatedHostId"] as? String {
                self.dedicatedHostId = value
            }
            if let value = dict["DedicatedHostName"] as? String {
                self.dedicatedHostName = value
            }
        }
    }
    public class EipAddress : Tea.TeaModel {
        public var allocationId: String?

        public var bandwidth: Int32?

        public var internetChargeType: String?

        public var ipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllocationId"] as? String {
                self.allocationId = value
            }
            if let value = dict["Bandwidth"] as? Int32 {
                self.bandwidth = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["IpAddress"] as? String {
                self.ipAddress = value
            }
        }
    }
    public class InnerIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpAddress"] as? [String] {
                self.ipAddress = value
            }
        }
    }
    public class OperationLocks : Tea.TeaModel {
        public class LockReason : Tea.TeaModel {
            public var lockReason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
            }
        }
        public var lockReason: [DescribeRCInstanceAttributeResponseBody.OperationLocks.LockReason]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lockReason != nil {
                var tmp : [Any] = []
                for k in self.lockReason! {
                    tmp.append(k.toMap())
                }
                map["LockReason"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LockReason"] as? [Any?] {
                var tmp : [DescribeRCInstanceAttributeResponseBody.OperationLocks.LockReason] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceAttributeResponseBody.OperationLocks.LockReason()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.lockReason = tmp
            }
        }
    }
    public class PublicIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IpAddress"] as? [String] {
                self.ipAddress = value
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupId"] as? [String] {
                self.securityGroupId = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var deleteWithInstance: Bool?

        public var encrypted: String?

        public var systemDiskCategory: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["SystemDiskCategory"] as? String {
                self.systemDiskCategory = value
            }
            if let value = dict["SystemDiskPerformanceLevel"] as? String {
                self.systemDiskPerformanceLevel = value
            }
            if let value = dict["SystemDiskSize"] as? Int64 {
                self.systemDiskSize = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tag: [DescribeRCInstanceAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeRCInstanceAttributeResponseBody.Tags.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceAttributeResponseBody.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public class VpcAttributes : Tea.TeaModel {
        public class PrivateIpAddress : Tea.TeaModel {
            public var ipAddress: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IpAddress"] as? [String] {
                    self.ipAddress = value
                }
            }
        }
        public var natIpAddress: String?

        public var privateIpAddress: DescribeRCInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.privateIpAddress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natIpAddress != nil {
                map["NatIpAddress"] = self.natIpAddress!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NatIpAddress"] as? String {
                self.natIpAddress = value
            }
            if let value = dict["PrivateIpAddress"] as? [String: Any?] {
                var model = DescribeRCInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress()
                model.fromMap(value)
                self.privateIpAddress = model
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var autoRenew: Bool?

    public var clusterId: String?

    public var cpu: Int32?

    public var createMode: Int32?

    public var creationTime: String?

    public var creditSpecification: String?

    public var dataDisks: DescribeRCInstanceAttributeResponseBody.DataDisks?

    public var dbType: String?

    public var dedicatedHostAttribute: DescribeRCInstanceAttributeResponseBody.DedicatedHostAttribute?

    public var deploymentSetId: String?

    public var description_: String?

    public var diskType: String?

    public var ecsInstanceType: String?

    public var eipAddress: DescribeRCInstanceAttributeResponseBody.EipAddress?

    public var enableJumboFrame: Bool?

    public var expiredTime: String?

    public var hostName: String?

    public var hostType: String?

    public var imageId: String?

    public var innerIpAddress: DescribeRCInstanceAttributeResponseBody.InnerIpAddress?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var instanceName: String?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var memory: Int32?

    public var operationLocks: DescribeRCInstanceAttributeResponseBody.OperationLocks?

    public var publicIpAddress: DescribeRCInstanceAttributeResponseBody.PublicIpAddress?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityGroupIds: DescribeRCInstanceAttributeResponseBody.SecurityGroupIds?

    public var serialNumber: String?

    public var spotStrategy: String?

    public var status: String?

    public var stoppedMode: String?

    public var systemDisk: DescribeRCInstanceAttributeResponseBody.SystemDisk?

    public var tags: DescribeRCInstanceAttributeResponseBody.Tags?

    public var vlanId: String?

    public var vpcAttributes: DescribeRCInstanceAttributeResponseBody.VpcAttributes?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataDisks?.validate()
        try self.dedicatedHostAttribute?.validate()
        try self.eipAddress?.validate()
        try self.innerIpAddress?.validate()
        try self.operationLocks?.validate()
        try self.publicIpAddress?.validate()
        try self.securityGroupIds?.validate()
        try self.systemDisk?.validate()
        try self.tags?.validate()
        try self.vpcAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.createMode != nil {
            map["CreateMode"] = self.createMode!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisks != nil {
            map["DataDisks"] = self.dataDisks?.toMap()
        }
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.dedicatedHostAttribute != nil {
            map["DedicatedHostAttribute"] = self.dedicatedHostAttribute?.toMap()
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.ecsInstanceType != nil {
            map["EcsInstanceType"] = self.ecsInstanceType!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress?.toMap()
        }
        if self.enableJumboFrame != nil {
            map["EnableJumboFrame"] = self.enableJumboFrame!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostType != nil {
            map["HostType"] = self.hostType!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddress != nil {
            map["InnerIpAddress"] = self.innerIpAddress?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.operationLocks != nil {
            map["OperationLocks"] = self.operationLocks?.toMap()
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.vpcAttributes != nil {
            map["VpcAttributes"] = self.vpcAttributes?.toMap()
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CreateMode"] as? Int32 {
            self.createMode = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["CreditSpecification"] as? String {
            self.creditSpecification = value
        }
        if let value = dict["DataDisks"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.DataDisks()
            model.fromMap(value)
            self.dataDisks = model
        }
        if let value = dict["DbType"] as? String {
            self.dbType = value
        }
        if let value = dict["DedicatedHostAttribute"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.DedicatedHostAttribute()
            model.fromMap(value)
            self.dedicatedHostAttribute = model
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DiskType"] as? String {
            self.diskType = value
        }
        if let value = dict["EcsInstanceType"] as? String {
            self.ecsInstanceType = value
        }
        if let value = dict["EipAddress"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.EipAddress()
            model.fromMap(value)
            self.eipAddress = model
        }
        if let value = dict["EnableJumboFrame"] as? Bool {
            self.enableJumboFrame = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["HostType"] as? String {
            self.hostType = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InnerIpAddress"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.InnerIpAddress()
            model.fromMap(value)
            self.innerIpAddress = model
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthIn"] as? Int32 {
            self.internetMaxBandwidthIn = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["OperationLocks"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.OperationLocks()
            model.fromMap(value)
            self.operationLocks = model
        }
        if let value = dict["PublicIpAddress"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.PublicIpAddress()
            model.fromMap(value)
            self.publicIpAddress = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityGroupIds"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.SecurityGroupIds()
            model.fromMap(value)
            self.securityGroupIds = model
        }
        if let value = dict["SerialNumber"] as? String {
            self.serialNumber = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["StoppedMode"] as? String {
            self.stoppedMode = value
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Tags"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.Tags()
            model.fromMap(value)
            self.tags = model
        }
        if let value = dict["VlanId"] as? String {
            self.vlanId = value
        }
        if let value = dict["VpcAttributes"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody.VpcAttributes()
            model.fromMap(value)
            self.vpcAttributes = model
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeRCInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceDdosCountRequest : Tea.TeaModel {
    public var ddosRegionId: String?

    public var instanceType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ddosRegionId != nil {
            map["DdosRegionId"] = self.ddosRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DdosRegionId"] as? String {
            self.ddosRegionId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceDdosCountResponseBody : Tea.TeaModel {
    public class DdosCount : Tea.TeaModel {
        public var blackholeCount: String?

        public var defenseCount: String?

        public var instacenCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blackholeCount != nil {
                map["BlackholeCount"] = self.blackholeCount!
            }
            if self.defenseCount != nil {
                map["DefenseCount"] = self.defenseCount!
            }
            if self.instacenCount != nil {
                map["InstacenCount"] = self.instacenCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BlackholeCount"] as? String {
                self.blackholeCount = value
            }
            if let value = dict["DefenseCount"] as? String {
                self.defenseCount = value
            }
            if let value = dict["InstacenCount"] as? String {
                self.instacenCount = value
            }
        }
    }
    public var ddosCount: DescribeRCInstanceDdosCountResponseBody.DdosCount?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ddosCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ddosCount != nil {
            map["DdosCount"] = self.ddosCount?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DdosCount"] as? [String: Any?] {
            var model = DescribeRCInstanceDdosCountResponseBody.DdosCount()
            model.fromMap(value)
            self.ddosCount = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCInstanceDdosCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceDdosCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceDdosCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceHistoryEventsRequest : Tea.TeaModel {
    public class EventPublishTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class NotBefore : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["End"] as? String {
                self.end = value
            }
            if let value = dict["Start"] as? String {
                self.start = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var eventPublishTime: DescribeRCInstanceHistoryEventsRequest.EventPublishTime?

    public var notBefore: DescribeRCInstanceHistoryEventsRequest.NotBefore?

    public var eventCycleStatus: String?

    public var eventId: [String]?

    public var eventType: String?

    public var impactLevel: String?

    public var instanceEventCycleStatus: [String]?

    public var instanceEventType: [String]?

    public var instanceId: String?

    public var maxResults: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var tag: [DescribeRCInstanceHistoryEventsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventPublishTime?.validate()
        try self.notBefore?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventPublishTime != nil {
            map["EventPublishTime"] = self.eventPublishTime?.toMap()
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore?.toMap()
        }
        if self.eventCycleStatus != nil {
            map["EventCycleStatus"] = self.eventCycleStatus!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.impactLevel != nil {
            map["ImpactLevel"] = self.impactLevel!
        }
        if self.instanceEventCycleStatus != nil {
            map["InstanceEventCycleStatus"] = self.instanceEventCycleStatus!
        }
        if self.instanceEventType != nil {
            map["InstanceEventType"] = self.instanceEventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EventPublishTime"] as? [String: Any?] {
            var model = DescribeRCInstanceHistoryEventsRequest.EventPublishTime()
            model.fromMap(value)
            self.eventPublishTime = model
        }
        if let value = dict["NotBefore"] as? [String: Any?] {
            var model = DescribeRCInstanceHistoryEventsRequest.NotBefore()
            model.fromMap(value)
            self.notBefore = model
        }
        if let value = dict["EventCycleStatus"] as? String {
            self.eventCycleStatus = value
        }
        if let value = dict["EventId"] as? [String] {
            self.eventId = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["ImpactLevel"] as? String {
            self.impactLevel = value
        }
        if let value = dict["InstanceEventCycleStatus"] as? [String] {
            self.instanceEventCycleStatus = value
        }
        if let value = dict["InstanceEventType"] as? [String] {
            self.instanceEventType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? String {
            self.maxResults = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeRCInstanceHistoryEventsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCInstanceHistoryEventsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeRCInstanceHistoryEventsResponseBody : Tea.TeaModel {
    public class InstanceSystemEventSet : Tea.TeaModel {
        public class EventCycleStatus : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class EventType : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class ExtendedAttribute : Tea.TeaModel {
            public class InactiveDisks : Tea.TeaModel {
                public var creationTime: String?

                public var deviceCategory: String?

                public var deviceSize: String?

                public var deviceType: String?

                public var releaseTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.deviceCategory != nil {
                        map["DeviceCategory"] = self.deviceCategory!
                    }
                    if self.deviceSize != nil {
                        map["DeviceSize"] = self.deviceSize!
                    }
                    if self.deviceType != nil {
                        map["DeviceType"] = self.deviceType!
                    }
                    if self.releaseTime != nil {
                        map["ReleaseTime"] = self.releaseTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CreationTime"] as? String {
                        self.creationTime = value
                    }
                    if let value = dict["DeviceCategory"] as? String {
                        self.deviceCategory = value
                    }
                    if let value = dict["DeviceSize"] as? String {
                        self.deviceSize = value
                    }
                    if let value = dict["DeviceType"] as? String {
                        self.deviceType = value
                    }
                    if let value = dict["ReleaseTime"] as? String {
                        self.releaseTime = value
                    }
                }
            }
            public var canAccept: String?

            public var code: String?

            public var device: String?

            public var diskId: String?

            public var hostId: String?

            public var hostType: String?

            public var inactiveDisks: [DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.ExtendedAttribute.InactiveDisks]?

            public var migrationOptions: [String]?

            public var onlineRepairPolicy: String?

            public var punishDomain: String?

            public var punishType: String?

            public var punishUrl: String?

            public var rack: String?

            public var responseResult: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canAccept != nil {
                    map["CanAccept"] = self.canAccept!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.hostType != nil {
                    map["HostType"] = self.hostType!
                }
                if self.inactiveDisks != nil {
                    var tmp : [Any] = []
                    for k in self.inactiveDisks! {
                        tmp.append(k.toMap())
                    }
                    map["InactiveDisks"] = tmp
                }
                if self.migrationOptions != nil {
                    map["MigrationOptions"] = self.migrationOptions!
                }
                if self.onlineRepairPolicy != nil {
                    map["OnlineRepairPolicy"] = self.onlineRepairPolicy!
                }
                if self.punishDomain != nil {
                    map["PunishDomain"] = self.punishDomain!
                }
                if self.punishType != nil {
                    map["PunishType"] = self.punishType!
                }
                if self.punishUrl != nil {
                    map["PunishUrl"] = self.punishUrl!
                }
                if self.rack != nil {
                    map["Rack"] = self.rack!
                }
                if self.responseResult != nil {
                    map["ResponseResult"] = self.responseResult!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CanAccept"] as? String {
                    self.canAccept = value
                }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Device"] as? String {
                    self.device = value
                }
                if let value = dict["DiskId"] as? String {
                    self.diskId = value
                }
                if let value = dict["HostId"] as? String {
                    self.hostId = value
                }
                if let value = dict["HostType"] as? String {
                    self.hostType = value
                }
                if let value = dict["InactiveDisks"] as? [Any?] {
                    var tmp : [DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.ExtendedAttribute.InactiveDisks] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.ExtendedAttribute.InactiveDisks()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.inactiveDisks = tmp
                }
                if let value = dict["MigrationOptions"] as? [String] {
                    self.migrationOptions = value
                }
                if let value = dict["OnlineRepairPolicy"] as? String {
                    self.onlineRepairPolicy = value
                }
                if let value = dict["PunishDomain"] as? String {
                    self.punishDomain = value
                }
                if let value = dict["PunishType"] as? String {
                    self.punishType = value
                }
                if let value = dict["PunishUrl"] as? String {
                    self.punishUrl = value
                }
                if let value = dict["Rack"] as? String {
                    self.rack = value
                }
                if let value = dict["ResponseResult"] as? String {
                    self.responseResult = value
                }
            }
        }
        public var eventCycleStatus: DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.EventCycleStatus?

        public var eventFinishTime: String?

        public var eventId: String?

        public var eventPublishTime: String?

        public var eventType: DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.EventType?

        public var extendedAttribute: DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.ExtendedAttribute?

        public var impactLevel: String?

        public var instanceId: String?

        public var notBefore: String?

        public var reason: String?

        public var reasonCode: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventCycleStatus?.validate()
            try self.eventType?.validate()
            try self.extendedAttribute?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCycleStatus != nil {
                map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
            }
            if self.eventFinishTime != nil {
                map["EventFinishTime"] = self.eventFinishTime!
            }
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            if self.eventPublishTime != nil {
                map["EventPublishTime"] = self.eventPublishTime!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType?.toMap()
            }
            if self.extendedAttribute != nil {
                map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
            }
            if self.impactLevel != nil {
                map["ImpactLevel"] = self.impactLevel!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.notBefore != nil {
                map["NotBefore"] = self.notBefore!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.reasonCode != nil {
                map["ReasonCode"] = self.reasonCode!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EventCycleStatus"] as? [String: Any?] {
                var model = DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.EventCycleStatus()
                model.fromMap(value)
                self.eventCycleStatus = model
            }
            if let value = dict["EventFinishTime"] as? String {
                self.eventFinishTime = value
            }
            if let value = dict["EventId"] as? String {
                self.eventId = value
            }
            if let value = dict["EventPublishTime"] as? String {
                self.eventPublishTime = value
            }
            if let value = dict["EventType"] as? [String: Any?] {
                var model = DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.EventType()
                model.fromMap(value)
                self.eventType = model
            }
            if let value = dict["ExtendedAttribute"] as? [String: Any?] {
                var model = DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet.ExtendedAttribute()
                model.fromMap(value)
                self.extendedAttribute = model
            }
            if let value = dict["ImpactLevel"] as? String {
                self.impactLevel = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["NotBefore"] as? String {
                self.notBefore = value
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["ReasonCode"] as? String {
                self.reasonCode = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
        }
    }
    public var instanceSystemEventSet: [DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet]?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSystemEventSet != nil {
            var tmp : [Any] = []
            for k in self.instanceSystemEventSet! {
                tmp.append(k.toMap())
            }
            map["InstanceSystemEventSet"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceSystemEventSet"] as? [Any?] {
            var tmp : [DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCInstanceHistoryEventsResponseBody.InstanceSystemEventSet()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instanceSystemEventSet = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRCInstanceHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceHistoryEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceIpAddressRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var ddosRegionId: String?

    public var ddosStatus: String?

    public var instanceId: String?

    public var instanceIp: String?

    public var instanceName: String?

    public var instanceType: String?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.ddosRegionId != nil {
            map["DdosRegionId"] = self.ddosRegionId!
        }
        if self.ddosStatus != nil {
            map["DdosStatus"] = self.ddosStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["DdosRegionId"] as? String {
            self.ddosRegionId = value
        }
        if let value = dict["DdosStatus"] as? String {
            self.ddosStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceIp"] as? String {
            self.instanceIp = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class DescribeRCInstanceIpAddressResponseBody : Tea.TeaModel {
    public class RCInstanceList : Tea.TeaModel {
        public class IpAddressConfig : Tea.TeaModel {
            public var blackholeThreshold: Int32?

            public var defenseBpsThreshold: Int32?

            public var defensePpsThreshold: Int32?

            public var elasticThreshold: Int32?

            public var instanceIp: String?

            public var ipStatus: String?

            public var ipVersion: String?

            public var isBgppack: Bool?

            public var isFullProtection: Int32?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blackholeThreshold != nil {
                    map["BlackholeThreshold"] = self.blackholeThreshold!
                }
                if self.defenseBpsThreshold != nil {
                    map["DefenseBpsThreshold"] = self.defenseBpsThreshold!
                }
                if self.defensePpsThreshold != nil {
                    map["DefensePpsThreshold"] = self.defensePpsThreshold!
                }
                if self.elasticThreshold != nil {
                    map["ElasticThreshold"] = self.elasticThreshold!
                }
                if self.instanceIp != nil {
                    map["InstanceIp"] = self.instanceIp!
                }
                if self.ipStatus != nil {
                    map["IpStatus"] = self.ipStatus!
                }
                if self.ipVersion != nil {
                    map["IpVersion"] = self.ipVersion!
                }
                if self.isBgppack != nil {
                    map["IsBgppack"] = self.isBgppack!
                }
                if self.isFullProtection != nil {
                    map["IsFullProtection"] = self.isFullProtection!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BlackholeThreshold"] as? Int32 {
                    self.blackholeThreshold = value
                }
                if let value = dict["DefenseBpsThreshold"] as? Int32 {
                    self.defenseBpsThreshold = value
                }
                if let value = dict["DefensePpsThreshold"] as? Int32 {
                    self.defensePpsThreshold = value
                }
                if let value = dict["ElasticThreshold"] as? Int32 {
                    self.elasticThreshold = value
                }
                if let value = dict["InstanceIp"] as? String {
                    self.instanceIp = value
                }
                if let value = dict["IpStatus"] as? String {
                    self.ipStatus = value
                }
                if let value = dict["IpVersion"] as? String {
                    self.ipVersion = value
                }
                if let value = dict["IsBgppack"] as? Bool {
                    self.isBgppack = value
                }
                if let value = dict["IsFullProtection"] as? Int32 {
                    self.isFullProtection = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var instanceId: String?

        public var instanceName: String?

        public var instanceStatus: String?

        public var instanceType: String?

        public var ipAddressConfig: [DescribeRCInstanceIpAddressResponseBody.RCInstanceList.IpAddressConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipAddressConfig != nil {
                var tmp : [Any] = []
                for k in self.ipAddressConfig! {
                    tmp.append(k.toMap())
                }
                map["IpAddressConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InstanceStatus"] as? String {
                self.instanceStatus = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["IpAddressConfig"] as? [Any?] {
                var tmp : [DescribeRCInstanceIpAddressResponseBody.RCInstanceList.IpAddressConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceIpAddressResponseBody.RCInstanceList.IpAddressConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipAddressConfig = tmp
            }
        }
    }
    public var RCInstanceList: [DescribeRCInstanceIpAddressResponseBody.RCInstanceList]?

    public var requestId: String?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.RCInstanceList != nil {
            var tmp : [Any] = []
            for k in self.RCInstanceList! {
                tmp.append(k.toMap())
            }
            map["RCInstanceList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RCInstanceList"] as? [Any?] {
            var tmp : [DescribeRCInstanceIpAddressResponseBody.RCInstanceList] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCInstanceIpAddressResponseBody.RCInstanceList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.RCInstanceList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? String {
            self.total = value
        }
    }
}

public class DescribeRCInstanceIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceIpAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceTypeFamiliesRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceTypeFamiliesResponseBody : Tea.TeaModel {
    public class InstanceTypeFamilies : Tea.TeaModel {
        public class InstanceTypeFamily : Tea.TeaModel {
            public var instanceTypeFamilyDesc: String?

            public var instanceTypeFamilyId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceTypeFamilyDesc != nil {
                    map["InstanceTypeFamilyDesc"] = self.instanceTypeFamilyDesc!
                }
                if self.instanceTypeFamilyId != nil {
                    map["InstanceTypeFamilyId"] = self.instanceTypeFamilyId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["InstanceTypeFamilyDesc"] as? String {
                    self.instanceTypeFamilyDesc = value
                }
                if let value = dict["InstanceTypeFamilyId"] as? String {
                    self.instanceTypeFamilyId = value
                }
            }
        }
        public var instanceTypeFamily: [DescribeRCInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceTypeFamily != nil {
                var tmp : [Any] = []
                for k in self.instanceTypeFamily! {
                    tmp.append(k.toMap())
                }
                map["InstanceTypeFamily"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceTypeFamily"] as? [Any?] {
                var tmp : [DescribeRCInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceTypeFamily = tmp
            }
        }
    }
    public var instanceTypeFamilies: DescribeRCInstanceTypeFamiliesResponseBody.InstanceTypeFamilies?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypeFamilies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTypeFamilies"] as? [String: Any?] {
            var model = DescribeRCInstanceTypeFamiliesResponseBody.InstanceTypeFamilies()
            model.fromMap(value)
            self.instanceTypeFamilies = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCInstanceTypeFamiliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceTypeFamiliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceTypeFamiliesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceTypesRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var engine: String?

    public var instanceType: [String]?

    public var instanceTypeFamily: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceType"] as? [String] {
            self.instanceType = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceTypesShrinkRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var engine: String?

    public var instanceTypeShrink: String?

    public var instanceTypeFamily: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceTypeShrink != nil {
            map["InstanceType"] = self.instanceTypeShrink!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceTypeShrink = value
        }
        if let value = dict["InstanceTypeFamily"] as? String {
            self.instanceTypeFamily = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public var cpuCoreCount: Int32?

            public var instanceTypeFamily: String?

            public var instanceTypeId: String?

            public var memorySize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CpuCoreCount"] as? Int32 {
                    self.cpuCoreCount = value
                }
                if let value = dict["InstanceTypeFamily"] as? String {
                    self.instanceTypeFamily = value
                }
                if let value = dict["InstanceTypeId"] as? String {
                    self.instanceTypeId = value
                }
                if let value = dict["MemorySize"] as? Int32 {
                    self.memorySize = value
                }
            }
        }
        public var instanceType: [DescribeRCInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? [Any?] {
                var tmp : [DescribeRCInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstanceTypesResponseBody.InstanceTypes.InstanceType()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instanceType = tmp
            }
        }
    }
    public var instanceTypes: DescribeRCInstanceTypesResponseBody.InstanceTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceTypes"] as? [String: Any?] {
            var model = DescribeRCInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(value)
            self.instanceTypes = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstanceVncUrlRequest : Tea.TeaModel {
    public var dbType: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbType != nil {
            map["DbType"] = self.dbType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbType"] as? String {
            self.dbType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCInstanceVncUrlResponseBody : Tea.TeaModel {
    public var loginUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loginUrl != nil {
            map["LoginUrl"] = self.loginUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LoginUrl"] as? String {
            self.loginUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCInstanceVncUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstanceVncUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstanceVncUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCInstancesRequest : Tea.TeaModel {
    public var hostIp: String?

    public var instanceId: String?

    public var instanceIds: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var publicIp: String?

    public var regionId: String?

    public var status: String?

    public var tag: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostIp != nil {
            map["HostIp"] = self.hostIp!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publicIp != nil {
            map["PublicIp"] = self.publicIp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HostIp"] as? String {
            self.hostIp = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PublicIp"] as? String {
            self.publicIp = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCInstancesResponseBody : Tea.TeaModel {
    public class RCInstances : Tea.TeaModel {
        public class TagResources : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class VpcAttributes : Tea.TeaModel {
            public var natIpAddress: String?

            public var privateIpAddress: [String]?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.natIpAddress != nil {
                    map["NatIpAddress"] = self.natIpAddress!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NatIpAddress"] as? String {
                    self.natIpAddress = value
                }
                if let value = dict["PrivateIpAddress"] as? [String] {
                    self.privateIpAddress = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var clusterName: String?

        public var cpu: Int32?

        public var createMode: String?

        public var dbType: String?

        public var deploymentSetId: String?

        public var description_: String?

        public var expiredTime: String?

        public var gmtCreated: String?

        public var hostIp: String?

        public var hostName: String?

        public var imageId: String?

        public var instanceChargeType: String?

        public var instanceId: String?

        public var instanceType: String?

        public var instanceTypeFamily: String?

        public var memory: Int32?

        public var publicIp: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var spotStrategy: String?

        public var status: String?

        public var tagResources: [DescribeRCInstancesResponseBody.RCInstances.TagResources]?

        public var tags: [DescribeRCInstancesResponseBody.RCInstances.Tags]?

        public var vpcAttributes: DescribeRCInstancesResponseBody.RCInstances.VpcAttributes?

        public var vpcId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.vpcAttributes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.createMode != nil {
                map["CreateMode"] = self.createMode!
            }
            if self.dbType != nil {
                map["DbType"] = self.dbType!
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.hostIp != nil {
                map["HostIp"] = self.hostIp!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.instanceTypeFamily != nil {
                map["InstanceTypeFamily"] = self.instanceTypeFamily!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tagResources != nil {
                var tmp : [Any] = []
                for k in self.tagResources! {
                    tmp.append(k.toMap())
                }
                map["TagResources"] = tmp
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.vpcAttributes != nil {
                map["VpcAttributes"] = self.vpcAttributes?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterName"] as? String {
                self.clusterName = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CreateMode"] as? String {
                self.createMode = value
            }
            if let value = dict["DbType"] as? String {
                self.dbType = value
            }
            if let value = dict["DeploymentSetId"] as? String {
                self.deploymentSetId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ExpiredTime"] as? String {
                self.expiredTime = value
            }
            if let value = dict["GmtCreated"] as? String {
                self.gmtCreated = value
            }
            if let value = dict["HostIp"] as? String {
                self.hostIp = value
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceChargeType"] as? String {
                self.instanceChargeType = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["InstanceTypeFamily"] as? String {
                self.instanceTypeFamily = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["PublicIp"] as? String {
                self.publicIp = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TagResources"] as? [Any?] {
                var tmp : [DescribeRCInstancesResponseBody.RCInstances.TagResources] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstancesResponseBody.RCInstances.TagResources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResources = tmp
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeRCInstancesResponseBody.RCInstances.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCInstancesResponseBody.RCInstances.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["VpcAttributes"] as? [String: Any?] {
                var model = DescribeRCInstancesResponseBody.RCInstances.VpcAttributes()
                model.fromMap(value)
                self.vpcAttributes = model
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var RCInstances: [DescribeRCInstancesResponseBody.RCInstances]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.RCInstances != nil {
            var tmp : [Any] = []
            for k in self.RCInstances! {
                tmp.append(k.toMap())
            }
            map["RCInstances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RCInstances"] as? [Any?] {
            var tmp : [DescribeRCInstancesResponseBody.RCInstances] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCInstancesResponseBody.RCInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.RCInstances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCMetricListRequest : Tea.TeaModel {
    public var dimensions: String?

    public var endTime: String?

    public var express: String?

    public var instanceId: String?

    public var length: String?

    public var metricName: String?

    public var nextToken: String?

    public var period: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dimensions != nil {
            map["Dimensions"] = self.dimensions!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.express != nil {
            map["Express"] = self.express!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Dimensions"] as? String {
            self.dimensions = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Express"] as? String {
            self.express = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Length"] as? String {
            self.length = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricName = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRCMetricListResponseBody : Tea.TeaModel {
    public var code: String?

    public var datapoints: String?

    public var message: String?

    public var nextToken: String?

    public var period: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.datapoints != nil {
            map["Datapoints"] = self.datapoints!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Datapoints"] as? String {
            self.datapoints = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeRCMetricListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCMetricListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCMetricListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCNodePoolRequest : Tea.TeaModel {
    public var clusterId: String?

    public var nodePoolId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.nodePoolId != nil {
            map["NodePoolId"] = self.nodePoolId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["NodePoolId"] as? String {
            self.nodePoolId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeRCNodePoolResponseBody : Tea.TeaModel {
    public class NodePoolList : Tea.TeaModel {
        public class DataDisk : Tea.TeaModel {
            public var category: String?

            public var deleteWithInstance: Bool?

            public var encrypted: String?

            public var performanceLevel: String?

            public var size: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["DeleteWithInstance"] as? Bool {
                    self.deleteWithInstance = value
                }
                if let value = dict["Encrypted"] as? String {
                    self.encrypted = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
            }
        }
        public class SystemDisk : Tea.TeaModel {
            public var category: String?

            public var performanceLevel: String?

            public var size: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["PerformanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["Size"] as? Int32 {
                    self.size = value
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var autoPay: Bool?

        public var autoRenew: Bool?

        public var clusterId: String?

        public var createMode: String?

        public var dataDisk: [DescribeRCNodePoolResponseBody.NodePoolList.DataDisk]?

        public var deploymentSetId: String?

        public var description_: String?

        public var hostName: String?

        public var imageId: String?

        public var instanceChargeType: String?

        public var instanceName: String?

        public var instanceType: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var nodePoolId: String?

        public var nodePoolName: String?

        public var password: String?

        public var period: Int32?

        public var periodUnit: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var spotStrategy: String?

        public var systemDisk: DescribeRCNodePoolResponseBody.NodePoolList.SystemDisk?

        public var tag: [DescribeRCNodePoolResponseBody.NodePoolList.Tag]?

        public var vSwitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.systemDisk?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPay != nil {
                map["AutoPay"] = self.autoPay!
            }
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.createMode != nil {
                map["CreateMode"] = self.createMode!
            }
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.nodePoolId != nil {
                map["NodePoolId"] = self.nodePoolId!
            }
            if self.nodePoolName != nil {
                map["NodePoolName"] = self.nodePoolName!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.periodUnit != nil {
                map["PeriodUnit"] = self.periodUnit!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoPay"] as? Bool {
                self.autoPay = value
            }
            if let value = dict["AutoRenew"] as? Bool {
                self.autoRenew = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["CreateMode"] as? String {
                self.createMode = value
            }
            if let value = dict["DataDisk"] as? [Any?] {
                var tmp : [DescribeRCNodePoolResponseBody.NodePoolList.DataDisk] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCNodePoolResponseBody.NodePoolList.DataDisk()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDisk = tmp
            }
            if let value = dict["DeploymentSetId"] as? String {
                self.deploymentSetId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["HostName"] as? String {
                self.hostName = value
            }
            if let value = dict["ImageId"] as? String {
                self.imageId = value
            }
            if let value = dict["InstanceChargeType"] as? String {
                self.instanceChargeType = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["InternetChargeType"] as? String {
                self.internetChargeType = value
            }
            if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
                self.internetMaxBandwidthOut = value
            }
            if let value = dict["IoOptimized"] as? String {
                self.ioOptimized = value
            }
            if let value = dict["KeyPairName"] as? String {
                self.keyPairName = value
            }
            if let value = dict["NodePoolId"] as? String {
                self.nodePoolId = value
            }
            if let value = dict["NodePoolName"] as? String {
                self.nodePoolName = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["Period"] as? Int32 {
                self.period = value
            }
            if let value = dict["PeriodUnit"] as? String {
                self.periodUnit = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SecurityEnhancementStrategy"] as? String {
                self.securityEnhancementStrategy = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SpotStrategy"] as? String {
                self.spotStrategy = value
            }
            if let value = dict["SystemDisk"] as? [String: Any?] {
                var model = DescribeRCNodePoolResponseBody.NodePoolList.SystemDisk()
                model.fromMap(value)
                self.systemDisk = model
            }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeRCNodePoolResponseBody.NodePoolList.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRCNodePoolResponseBody.NodePoolList.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var nodePoolList: [DescribeRCNodePoolResponseBody.NodePoolList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodePoolList != nil {
            var tmp : [Any] = []
            for k in self.nodePoolList! {
                tmp.append(k.toMap())
            }
            map["NodePoolList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NodePoolList"] as? [Any?] {
            var tmp : [DescribeRCNodePoolResponseBody.NodePoolList] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCNodePoolResponseBody.NodePoolList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nodePoolList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCNodePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCNodePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCNodePoolResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCSecurityGroupListRequest : Tea.TeaModel {
    public var regionId: String?

    public var securityGroupId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCSecurityGroupListResponseBody : Tea.TeaModel {
    public class RCSecurityGroups : Tea.TeaModel {
        public var availableInstanceAmount: Int32?

        public var creationTime: String?

        public var description_: String?

        public var instanceCount: Int32?

        public var securityGroupId: String?

        public var securityGroupType: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableInstanceAmount != nil {
                map["AvailableInstanceAmount"] = self.availableInstanceAmount!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupType != nil {
                map["SecurityGroupType"] = self.securityGroupType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableInstanceAmount"] as? Int32 {
                self.availableInstanceAmount = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceCount"] as? Int32 {
                self.instanceCount = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["SecurityGroupType"] as? String {
                self.securityGroupType = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var RCSecurityGroups: [DescribeRCSecurityGroupListResponseBody.RCSecurityGroups]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.RCSecurityGroups != nil {
            var tmp : [Any] = []
            for k in self.RCSecurityGroups! {
                tmp.append(k.toMap())
            }
            map["RCSecurityGroups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RCSecurityGroups"] as? [Any?] {
            var tmp : [DescribeRCSecurityGroupListResponseBody.RCSecurityGroups] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCSecurityGroupListResponseBody.RCSecurityGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.RCSecurityGroups = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRCSecurityGroupListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCSecurityGroupListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCSecurityGroupListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCSecurityGroupPermissionRequest : Tea.TeaModel {
    public var regionId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class DescribeRCSecurityGroupPermissionResponseBody : Tea.TeaModel {
    public class SecurityGroupPermissions : Tea.TeaModel {
        public var createTime: String?

        public var destCidrIp: String?

        public var direction: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var securityGroupRuleId: String?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.securityGroupRuleId != nil {
                map["SecurityGroupRuleId"] = self.securityGroupRuleId!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DestCidrIp"] as? String {
                self.destCidrIp = value
            }
            if let value = dict["Direction"] as? String {
                self.direction = value
            }
            if let value = dict["IpProtocol"] as? String {
                self.ipProtocol = value
            }
            if let value = dict["Policy"] as? String {
                self.policy = value
            }
            if let value = dict["PortRange"] as? String {
                self.portRange = value
            }
            if let value = dict["Priority"] as? String {
                self.priority = value
            }
            if let value = dict["SecurityGroupRuleId"] as? String {
                self.securityGroupRuleId = value
            }
            if let value = dict["SourceCidrIp"] as? String {
                self.sourceCidrIp = value
            }
            if let value = dict["SourcePortRange"] as? String {
                self.sourcePortRange = value
            }
        }
    }
    public var innerAccessPolicy: String?

    public var regionId: String?

    public var requestId: String?

    public var securityGroupId: String?

    public var securityGroupPermissions: [DescribeRCSecurityGroupPermissionResponseBody.SecurityGroupPermissions]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.innerAccessPolicy != nil {
            map["InnerAccessPolicy"] = self.innerAccessPolicy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupPermissions != nil {
            var tmp : [Any] = []
            for k in self.securityGroupPermissions! {
                tmp.append(k.toMap())
            }
            map["SecurityGroupPermissions"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InnerAccessPolicy"] as? String {
            self.innerAccessPolicy = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupPermissions"] as? [Any?] {
            var tmp : [DescribeRCSecurityGroupPermissionResponseBody.SecurityGroupPermissions] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCSecurityGroupPermissionResponseBody.SecurityGroupPermissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.securityGroupPermissions = tmp
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeRCSecurityGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCSecurityGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCSecurityGroupPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRCSnapshotsRequest : Tea.TeaModel {
    public var diskId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var snapshotIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.snapshotIds != nil {
            map["SnapshotIds"] = self.snapshotIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SnapshotIds"] as? String {
            self.snapshotIds = value
        }
    }
}

public class DescribeRCSnapshotsResponseBody : Tea.TeaModel {
    public class Snapshots : Tea.TeaModel {
        public var available: Bool?

        public var category: String?

        public var creationTime: String?

        public var description_: String?

        public var encrypted: Bool?

        public var instantAccess: Bool?

        public var progress: String?

        public var regionId: String?

        public var snapshotId: String?

        public var snapshotName: String?

        public var snapshotType: String?

        public var sourceDiskId: String?

        public var sourceDiskSize: Int64?

        public var sourceDiskType: String?

        public var sourceStorageType: String?

        public var status: String?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["Available"] = self.available!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.instantAccess != nil {
                map["InstantAccess"] = self.instantAccess!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.snapshotName != nil {
                map["SnapshotName"] = self.snapshotName!
            }
            if self.snapshotType != nil {
                map["SnapshotType"] = self.snapshotType!
            }
            if self.sourceDiskId != nil {
                map["SourceDiskId"] = self.sourceDiskId!
            }
            if self.sourceDiskSize != nil {
                map["SourceDiskSize"] = self.sourceDiskSize!
            }
            if self.sourceDiskType != nil {
                map["SourceDiskType"] = self.sourceDiskType!
            }
            if self.sourceStorageType != nil {
                map["SourceStorageType"] = self.sourceStorageType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Available"] as? Bool {
                self.available = value
            }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["InstantAccess"] as? Bool {
                self.instantAccess = value
            }
            if let value = dict["Progress"] as? String {
                self.progress = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
            if let value = dict["SnapshotName"] as? String {
                self.snapshotName = value
            }
            if let value = dict["SnapshotType"] as? String {
                self.snapshotType = value
            }
            if let value = dict["SourceDiskId"] as? String {
                self.sourceDiskId = value
            }
            if let value = dict["SourceDiskSize"] as? Int64 {
                self.sourceDiskSize = value
            }
            if let value = dict["SourceDiskType"] as? String {
                self.sourceDiskType = value
            }
            if let value = dict["SourceStorageType"] as? String {
                self.sourceStorageType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Usage"] as? String {
                self.usage = value
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var snapshots: [DescribeRCSnapshotsResponseBody.Snapshots]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            var tmp : [Any] = []
            for k in self.snapshots! {
                tmp.append(k.toMap())
            }
            map["Snapshots"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Snapshots"] as? [Any?] {
            var tmp : [DescribeRCSnapshotsResponseBody.Snapshots] = []
            for v in value {
                if v != nil {
                    var model = DescribeRCSnapshotsResponseBody.Snapshots()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.snapshots = tmp
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeRCSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRCSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRCSnapshotsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRdsResourceSettingsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceNiche: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceNiche != nil {
            map["ResourceNiche"] = self.resourceNiche!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceNiche"] as? String {
            self.resourceNiche = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRdsResourceSettingsResponseBody : Tea.TeaModel {
    public class RdsInstanceResourceSettings : Tea.TeaModel {
        public class RdsInstanceResourceSetting : Tea.TeaModel {
            public var endDate: String?

            public var isTop: String?

            public var noticeBarContent: String?

            public var poppedUpButtonText: String?

            public var poppedUpButtonType: String?

            public var poppedUpButtonUrl: String?

            public var poppedUpContent: String?

            public var resourceNiche: String?

            public var startDate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.isTop != nil {
                    map["IsTop"] = self.isTop!
                }
                if self.noticeBarContent != nil {
                    map["NoticeBarContent"] = self.noticeBarContent!
                }
                if self.poppedUpButtonText != nil {
                    map["PoppedUpButtonText"] = self.poppedUpButtonText!
                }
                if self.poppedUpButtonType != nil {
                    map["PoppedUpButtonType"] = self.poppedUpButtonType!
                }
                if self.poppedUpButtonUrl != nil {
                    map["PoppedUpButtonUrl"] = self.poppedUpButtonUrl!
                }
                if self.poppedUpContent != nil {
                    map["PoppedUpContent"] = self.poppedUpContent!
                }
                if self.resourceNiche != nil {
                    map["ResourceNiche"] = self.resourceNiche!
                }
                if self.startDate != nil {
                    map["StartDate"] = self.startDate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndDate"] as? String {
                    self.endDate = value
                }
                if let value = dict["IsTop"] as? String {
                    self.isTop = value
                }
                if let value = dict["NoticeBarContent"] as? String {
                    self.noticeBarContent = value
                }
                if let value = dict["PoppedUpButtonText"] as? String {
                    self.poppedUpButtonText = value
                }
                if let value = dict["PoppedUpButtonType"] as? String {
                    self.poppedUpButtonType = value
                }
                if let value = dict["PoppedUpButtonUrl"] as? String {
                    self.poppedUpButtonUrl = value
                }
                if let value = dict["PoppedUpContent"] as? String {
                    self.poppedUpContent = value
                }
                if let value = dict["ResourceNiche"] as? String {
                    self.resourceNiche = value
                }
                if let value = dict["StartDate"] as? String {
                    self.startDate = value
                }
            }
        }
        public var rdsInstanceResourceSetting: [DescribeRdsResourceSettingsResponseBody.RdsInstanceResourceSettings.RdsInstanceResourceSetting]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.rdsInstanceResourceSetting != nil {
                var tmp : [Any] = []
                for k in self.rdsInstanceResourceSetting! {
                    tmp.append(k.toMap())
                }
                map["RdsInstanceResourceSetting"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RdsInstanceResourceSetting"] as? [Any?] {
                var tmp : [DescribeRdsResourceSettingsResponseBody.RdsInstanceResourceSettings.RdsInstanceResourceSetting] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRdsResourceSettingsResponseBody.RdsInstanceResourceSettings.RdsInstanceResourceSetting()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rdsInstanceResourceSetting = tmp
            }
        }
    }
    public var rdsInstanceResourceSettings: DescribeRdsResourceSettingsResponseBody.RdsInstanceResourceSettings?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rdsInstanceResourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rdsInstanceResourceSettings != nil {
            map["RdsInstanceResourceSettings"] = self.rdsInstanceResourceSettings?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RdsInstanceResourceSettings"] as? [String: Any?] {
            var model = DescribeRdsResourceSettingsResponseBody.RdsInstanceResourceSettings()
            model.fromMap(value)
            self.rdsInstanceResourceSettings = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRdsResourceSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRdsResourceSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRdsResourceSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeReadDBInstanceDelayRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var readInstanceId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.readInstanceId != nil {
            map["ReadInstanceId"] = self.readInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReadInstanceId"] as? String {
            self.readInstanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeReadDBInstanceDelayResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class ReadDBInstanceNames : Tea.TeaModel {
                public var readDBInstanceName: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readDBInstanceName != nil {
                        map["ReadDBInstanceName"] = self.readDBInstanceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadDBInstanceName"] as? [String] {
                        self.readDBInstanceName = value
                    }
                }
            }
            public class ReadDelayTimes : Tea.TeaModel {
                public var readDelayTime: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readDelayTime != nil {
                        map["ReadDelayTime"] = self.readDelayTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadDelayTime"] as? [String] {
                        self.readDelayTime = value
                    }
                }
            }
            public class ReadonlyInstanceDelay : Tea.TeaModel {
                public class ReadonlyInstanceDelay : Tea.TeaModel {
                    public var flushLag: String?

                    public var flushLatency: String?

                    public var readDBInstanceName: String?

                    public var replayLag: String?

                    public var replayLatency: String?

                    public var sendLatency: String?

                    public var writeLag: String?

                    public var writeLatency: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.flushLag != nil {
                            map["FlushLag"] = self.flushLag!
                        }
                        if self.flushLatency != nil {
                            map["FlushLatency"] = self.flushLatency!
                        }
                        if self.readDBInstanceName != nil {
                            map["ReadDBInstanceName"] = self.readDBInstanceName!
                        }
                        if self.replayLag != nil {
                            map["ReplayLag"] = self.replayLag!
                        }
                        if self.replayLatency != nil {
                            map["ReplayLatency"] = self.replayLatency!
                        }
                        if self.sendLatency != nil {
                            map["SendLatency"] = self.sendLatency!
                        }
                        if self.writeLag != nil {
                            map["WriteLag"] = self.writeLag!
                        }
                        if self.writeLatency != nil {
                            map["WriteLatency"] = self.writeLatency!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["FlushLag"] as? String {
                            self.flushLag = value
                        }
                        if let value = dict["FlushLatency"] as? String {
                            self.flushLatency = value
                        }
                        if let value = dict["ReadDBInstanceName"] as? String {
                            self.readDBInstanceName = value
                        }
                        if let value = dict["ReplayLag"] as? String {
                            self.replayLag = value
                        }
                        if let value = dict["ReplayLatency"] as? String {
                            self.replayLatency = value
                        }
                        if let value = dict["SendLatency"] as? String {
                            self.sendLatency = value
                        }
                        if let value = dict["WriteLag"] as? String {
                            self.writeLag = value
                        }
                        if let value = dict["WriteLatency"] as? String {
                            self.writeLatency = value
                        }
                    }
                }
                public var readonlyInstanceDelay: [DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadonlyInstanceDelay.ReadonlyInstanceDelay]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.readonlyInstanceDelay != nil {
                        var tmp : [Any] = []
                        for k in self.readonlyInstanceDelay! {
                            tmp.append(k.toMap())
                        }
                        map["ReadonlyInstanceDelay"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReadonlyInstanceDelay"] as? [Any?] {
                        var tmp : [DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadonlyInstanceDelay.ReadonlyInstanceDelay] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadonlyInstanceDelay.ReadonlyInstanceDelay()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.readonlyInstanceDelay = tmp
                    }
                }
            }
            public var DBInstanceId: String?

            public var readDBInstanceNames: DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadDBInstanceNames?

            public var readDelayTimes: DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadDelayTimes?

            public var readonlyInstanceDelay: DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadonlyInstanceDelay?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.readDBInstanceNames?.validate()
                try self.readDelayTimes?.validate()
                try self.readonlyInstanceDelay?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceId != nil {
                    map["DBInstanceId"] = self.DBInstanceId!
                }
                if self.readDBInstanceNames != nil {
                    map["ReadDBInstanceNames"] = self.readDBInstanceNames?.toMap()
                }
                if self.readDelayTimes != nil {
                    map["ReadDelayTimes"] = self.readDelayTimes?.toMap()
                }
                if self.readonlyInstanceDelay != nil {
                    map["ReadonlyInstanceDelay"] = self.readonlyInstanceDelay?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceId"] as? String {
                    self.DBInstanceId = value
                }
                if let value = dict["ReadDBInstanceNames"] as? [String: Any?] {
                    var model = DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadDBInstanceNames()
                    model.fromMap(value)
                    self.readDBInstanceNames = model
                }
                if let value = dict["ReadDelayTimes"] as? [String: Any?] {
                    var model = DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadDelayTimes()
                    model.fromMap(value)
                    self.readDelayTimes = model
                }
                if let value = dict["ReadonlyInstanceDelay"] as? [String: Any?] {
                    var model = DescribeReadDBInstanceDelayResponseBody.Items.Items.ReadonlyInstanceDelay()
                    model.fromMap(value)
                    self.readonlyInstanceDelay = model
                }
            }
        }
        public var items: [DescribeReadDBInstanceDelayResponseBody.Items.Items]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Items"] as? [Any?] {
                var tmp : [DescribeReadDBInstanceDelayResponseBody.Items.Items] = []
                for v in value {
                    if v != nil {
                        var model = DescribeReadDBInstanceDelayResponseBody.Items.Items()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.items = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var delayTime: Int32?

    public var items: DescribeReadDBInstanceDelayResponseBody.Items?

    public var readDBInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.readDBInstanceId != nil {
            map["ReadDBInstanceId"] = self.readDBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DelayTime"] as? Int32 {
            self.delayTime = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeReadDBInstanceDelayResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["ReadDBInstanceId"] as? String {
            self.readDBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeReadDBInstanceDelayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReadDBInstanceDelayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeReadDBInstanceDelayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionInfosRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRegionInfosResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class RDSRegion : Tea.TeaModel {
            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var RDSRegion: [DescribeRegionInfosResponseBody.Regions.RDSRegion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.RDSRegion != nil {
                var tmp : [Any] = []
                for k in self.RDSRegion! {
                    tmp.append(k.toMap())
                }
                map["RDSRegion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RDSRegion"] as? [Any?] {
                var tmp : [DescribeRegionInfosResponseBody.Regions.RDSRegion] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionInfosResponseBody.Regions.RDSRegion()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.RDSRegion = tmp
            }
        }
    }
    public var regions: DescribeRegionInfosResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionInfosResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionInfosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class RDSRegion : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public var zoneId: String?

            public var zoneName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneName != nil {
                    map["ZoneName"] = self.zoneName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["RegionEndpoint"] as? String {
                    self.regionEndpoint = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
                if let value = dict["ZoneName"] as? String {
                    self.zoneName = value
                }
            }
        }
        public var RDSRegion: [DescribeRegionsResponseBody.Regions.RDSRegion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.RDSRegion != nil {
                var tmp : [Any] = []
                for k in self.RDSRegion! {
                    tmp.append(k.toMap())
                }
                map["RDSRegion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RDSRegion"] as? [Any?] {
                var tmp : [DescribeRegionsResponseBody.Regions.RDSRegion] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionsResponseBody.Regions.RDSRegion()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.RDSRegion = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRenewalPriceRequest : Tea.TeaModel {
    public var businessInfo: String?

    public var clientToken: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timeType: String?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeType != nil {
            map["TimeType"] = self.timeType!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Quantity"] as? Int32 {
            self.quantity = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TimeType"] as? String {
            self.timeType = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
    }
}

public class DescribeRenewalPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class ActivityInfo : Tea.TeaModel {
            public var checkErrMsg: String?

            public var errorCode: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkErrMsg != nil {
                    map["CheckErrMsg"] = self.checkErrMsg!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckErrMsg"] as? String {
                    self.checkErrMsg = value
                }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["Success"] as? String {
                    self.success = value
                }
            }
        }
        public class Coupons : Tea.TeaModel {
            public class Coupon : Tea.TeaModel {
                public var couponNo: String?

                public var description_: String?

                public var isSelected: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.couponNo != nil {
                        map["CouponNo"] = self.couponNo!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.isSelected != nil {
                        map["IsSelected"] = self.isSelected!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CouponNo"] as? String {
                        self.couponNo = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["IsSelected"] as? String {
                        self.isSelected = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var coupon: [DescribeRenewalPriceResponseBody.PriceInfo.Coupons.Coupon]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coupon != nil {
                    var tmp : [Any] = []
                    for k in self.coupon! {
                        tmp.append(k.toMap())
                    }
                    map["Coupon"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Coupon"] as? [Any?] {
                    var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Coupons.Coupon] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeRenewalPriceResponseBody.PriceInfo.Coupons.Coupon()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.coupon = tmp
                }
            }
        }
        public class RuleIds : Tea.TeaModel {
            public var ruleId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleId"] as? [String] {
                    self.ruleId = value
                }
            }
        }
        public var activityInfo: DescribeRenewalPriceResponseBody.PriceInfo.ActivityInfo?

        public var coupons: DescribeRenewalPriceResponseBody.PriceInfo.Coupons?

        public var currency: String?

        public var discountPrice: Double?

        public var originalPrice: Double?

        public var ruleIds: DescribeRenewalPriceResponseBody.PriceInfo.RuleIds?

        public var tradePrice: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.activityInfo?.validate()
            try self.coupons?.validate()
            try self.ruleIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activityInfo != nil {
                map["ActivityInfo"] = self.activityInfo?.toMap()
            }
            if self.coupons != nil {
                map["Coupons"] = self.coupons?.toMap()
            }
            if self.currency != nil {
                map["Currency"] = self.currency!
            }
            if self.discountPrice != nil {
                map["DiscountPrice"] = self.discountPrice!
            }
            if self.originalPrice != nil {
                map["OriginalPrice"] = self.originalPrice!
            }
            if self.ruleIds != nil {
                map["RuleIds"] = self.ruleIds?.toMap()
            }
            if self.tradePrice != nil {
                map["TradePrice"] = self.tradePrice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActivityInfo"] as? [String: Any?] {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.ActivityInfo()
                model.fromMap(value)
                self.activityInfo = model
            }
            if let value = dict["Coupons"] as? [String: Any?] {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Coupons()
                model.fromMap(value)
                self.coupons = model
            }
            if let value = dict["Currency"] as? String {
                self.currency = value
            }
            if let value = dict["DiscountPrice"] as? Double {
                self.discountPrice = value
            }
            if let value = dict["OriginalPrice"] as? Double {
                self.originalPrice = value
            }
            if let value = dict["RuleIds"] as? [String: Any?] {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.RuleIds()
                model.fromMap(value)
                self.ruleIds = model
            }
            if let value = dict["TradePrice"] as? Double {
                self.tradePrice = value
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public class Rule : Tea.TeaModel {
            public var description_: String?

            public var name: String?

            public var ruleId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RuleId"] as? Int64 {
                    self.ruleId = value
                }
            }
        }
        public var rule: [DescribeRenewalPriceResponseBody.Rules.Rule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.rule != nil {
                var tmp : [Any] = []
                for k in self.rule! {
                    tmp.append(k.toMap())
                }
                map["Rule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Rule"] as? [Any?] {
                var tmp : [DescribeRenewalPriceResponseBody.Rules.Rule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRenewalPriceResponseBody.Rules.Rule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rule = tmp
            }
        }
    }
    public var priceInfo: DescribeRenewalPriceResponseBody.PriceInfo?

    public var requestId: String?

    public var rules: DescribeRenewalPriceResponseBody.Rules?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
        try self.rules?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rules != nil {
            map["Rules"] = self.rules?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PriceInfo"] as? [String: Any?] {
            var model = DescribeRenewalPriceResponseBody.PriceInfo()
            model.fromMap(value)
            self.priceInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Rules"] as? [String: Any?] {
            var model = DescribeRenewalPriceResponseBody.Rules()
            model.fromMap(value)
            self.rules = model
        }
    }
}

public class DescribeRenewalPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRenewalPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRenewalPriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeReplicationLinkLogsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var taskId: Int64?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
    }
}

public class DescribeReplicationLinkLogsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var detail: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var replicationInfo: String?

        public var replicationState: String?

        public var replicatorAccount: String?

        public var replicatorPassword: String?

        public var sourceAddress: String?

        public var sourceCategory: String?

        public var sourcePort: Int64?

        public var targetInstanceId: String?

        public var taskId: Int64?

        public var taskName: String?

        public var taskStage: String?

        public var taskStatus: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.replicationInfo != nil {
                map["ReplicationInfo"] = self.replicationInfo!
            }
            if self.replicationState != nil {
                map["ReplicationState"] = self.replicationState!
            }
            if self.replicatorAccount != nil {
                map["ReplicatorAccount"] = self.replicatorAccount!
            }
            if self.replicatorPassword != nil {
                map["ReplicatorPassword"] = self.replicatorPassword!
            }
            if self.sourceAddress != nil {
                map["SourceAddress"] = self.sourceAddress!
            }
            if self.sourceCategory != nil {
                map["SourceCategory"] = self.sourceCategory!
            }
            if self.sourcePort != nil {
                map["SourcePort"] = self.sourcePort!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskStage != nil {
                map["TaskStage"] = self.taskStage!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["GmtCreated"] as? String {
                self.gmtCreated = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["ReplicationInfo"] as? String {
                self.replicationInfo = value
            }
            if let value = dict["ReplicationState"] as? String {
                self.replicationState = value
            }
            if let value = dict["ReplicatorAccount"] as? String {
                self.replicatorAccount = value
            }
            if let value = dict["ReplicatorPassword"] as? String {
                self.replicatorPassword = value
            }
            if let value = dict["SourceAddress"] as? String {
                self.sourceAddress = value
            }
            if let value = dict["SourceCategory"] as? String {
                self.sourceCategory = value
            }
            if let value = dict["SourcePort"] as? Int64 {
                self.sourcePort = value
            }
            if let value = dict["TargetInstanceId"] as? String {
                self.targetInstanceId = value
            }
            if let value = dict["TaskId"] as? Int64 {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
            if let value = dict["TaskStage"] as? String {
                self.taskStage = value
            }
            if let value = dict["TaskStatus"] as? String {
                self.taskStatus = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
        }
    }
    public var DBInstanceId: String?

    public var items: [DescribeReplicationLinkLogsResponseBody.Items]?

    public var requestId: String?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeReplicationLinkLogsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeReplicationLinkLogsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class DescribeReplicationLinkLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReplicationLinkLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeReplicationLinkLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeResourceDetailsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeResourceDetailsResponseBody : Tea.TeaModel {
    public class RdsEcsSecurityGroupRel : Tea.TeaModel {
        public var securityGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroupName"] as? String {
                self.securityGroupName = value
            }
        }
    }
    public var backupDataSize: Int64?

    public var backupLogSize: Int64?

    public var backupSize: Int64?

    public var dbInstanceStorage: Int64?

    public var dbProxyInstanceName: String?

    public var diskUsed: Int64?

    public var instanceStorageType: String?

    public var rdsEcsSecurityGroupRel: [DescribeResourceDetailsResponseBody.RdsEcsSecurityGroupRel]?

    public var region: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityIPList: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupDataSize != nil {
            map["BackupDataSize"] = self.backupDataSize!
        }
        if self.backupLogSize != nil {
            map["BackupLogSize"] = self.backupLogSize!
        }
        if self.backupSize != nil {
            map["BackupSize"] = self.backupSize!
        }
        if self.dbInstanceStorage != nil {
            map["DbInstanceStorage"] = self.dbInstanceStorage!
        }
        if self.dbProxyInstanceName != nil {
            map["DbProxyInstanceName"] = self.dbProxyInstanceName!
        }
        if self.diskUsed != nil {
            map["DiskUsed"] = self.diskUsed!
        }
        if self.instanceStorageType != nil {
            map["InstanceStorageType"] = self.instanceStorageType!
        }
        if self.rdsEcsSecurityGroupRel != nil {
            var tmp : [Any] = []
            for k in self.rdsEcsSecurityGroupRel! {
                tmp.append(k.toMap())
            }
            map["RdsEcsSecurityGroupRel"] = tmp
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityIPList != nil {
            map["SecurityIPList"] = self.securityIPList!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupDataSize"] as? Int64 {
            self.backupDataSize = value
        }
        if let value = dict["BackupLogSize"] as? Int64 {
            self.backupLogSize = value
        }
        if let value = dict["BackupSize"] as? Int64 {
            self.backupSize = value
        }
        if let value = dict["DbInstanceStorage"] as? Int64 {
            self.dbInstanceStorage = value
        }
        if let value = dict["DbProxyInstanceName"] as? String {
            self.dbProxyInstanceName = value
        }
        if let value = dict["DiskUsed"] as? Int64 {
            self.diskUsed = value
        }
        if let value = dict["InstanceStorageType"] as? String {
            self.instanceStorageType = value
        }
        if let value = dict["RdsEcsSecurityGroupRel"] as? [Any?] {
            var tmp : [DescribeResourceDetailsResponseBody.RdsEcsSecurityGroupRel] = []
            for v in value {
                if v != nil {
                    var model = DescribeResourceDetailsResponseBody.RdsEcsSecurityGroupRel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.rdsEcsSecurityGroupRel = tmp
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityIPList"] as? String {
            self.securityIPList = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class DescribeResourceDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeResourceDetailsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeResourceUsageRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeResourceUsageResponseBody : Tea.TeaModel {
    public var archiveBackupSize: Int64?

    public var backupDataSize: Int64?

    public var backupEcsSnapshotSize: String?

    public var backupLogSize: Int64?

    public var backupOssDataSize: Int64?

    public var backupOssLogSize: Int64?

    public var backupSize: Int64?

    public var coldBackupSize: Int64?

    public var DBInstanceId: String?

    public var dataSize: Int64?

    public var diskUsed: Int64?

    public var engine: String?

    public var logSize: Int64?

    public var paidBackupSize: Int64?

    public var requestId: String?

    public var SQLSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveBackupSize != nil {
            map["ArchiveBackupSize"] = self.archiveBackupSize!
        }
        if self.backupDataSize != nil {
            map["BackupDataSize"] = self.backupDataSize!
        }
        if self.backupEcsSnapshotSize != nil {
            map["BackupEcsSnapshotSize"] = self.backupEcsSnapshotSize!
        }
        if self.backupLogSize != nil {
            map["BackupLogSize"] = self.backupLogSize!
        }
        if self.backupOssDataSize != nil {
            map["BackupOssDataSize"] = self.backupOssDataSize!
        }
        if self.backupOssLogSize != nil {
            map["BackupOssLogSize"] = self.backupOssLogSize!
        }
        if self.backupSize != nil {
            map["BackupSize"] = self.backupSize!
        }
        if self.coldBackupSize != nil {
            map["ColdBackupSize"] = self.coldBackupSize!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dataSize != nil {
            map["DataSize"] = self.dataSize!
        }
        if self.diskUsed != nil {
            map["DiskUsed"] = self.diskUsed!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.logSize != nil {
            map["LogSize"] = self.logSize!
        }
        if self.paidBackupSize != nil {
            map["PaidBackupSize"] = self.paidBackupSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLSize != nil {
            map["SQLSize"] = self.SQLSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveBackupSize"] as? Int64 {
            self.archiveBackupSize = value
        }
        if let value = dict["BackupDataSize"] as? Int64 {
            self.backupDataSize = value
        }
        if let value = dict["BackupEcsSnapshotSize"] as? String {
            self.backupEcsSnapshotSize = value
        }
        if let value = dict["BackupLogSize"] as? Int64 {
            self.backupLogSize = value
        }
        if let value = dict["BackupOssDataSize"] as? Int64 {
            self.backupOssDataSize = value
        }
        if let value = dict["BackupOssLogSize"] as? Int64 {
            self.backupOssLogSize = value
        }
        if let value = dict["BackupSize"] as? Int64 {
            self.backupSize = value
        }
        if let value = dict["ColdBackupSize"] as? Int64 {
            self.coldBackupSize = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DataSize"] as? Int64 {
            self.dataSize = value
        }
        if let value = dict["DiskUsed"] as? Int64 {
            self.diskUsed = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["LogSize"] as? Int64 {
            self.logSize = value
        }
        if let value = dict["PaidBackupSize"] as? Int64 {
            self.paidBackupSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQLSize"] as? Int64 {
            self.SQLSize = value
        }
    }
}

public class DescribeResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeResourceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLCollectorPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSQLCollectorPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var SQLCollectorStatus: String?

    public var storagePeriod: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLCollectorStatus != nil {
            map["SQLCollectorStatus"] = self.SQLCollectorStatus!
        }
        if self.storagePeriod != nil {
            map["StoragePeriod"] = self.storagePeriod!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQLCollectorStatus"] as? String {
            self.SQLCollectorStatus = value
        }
        if let value = dict["StoragePeriod"] as? Int32 {
            self.storagePeriod = value
        }
    }
}

public class DescribeSQLCollectorPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLCollectorPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLCollectorPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLCollectorRetentionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeSQLCollectorRetentionResponseBody : Tea.TeaModel {
    public var configValue: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigValue"] as? String {
            self.configValue = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSQLCollectorRetentionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLCollectorRetentionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLCollectorRetentionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLLogFilesRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var fileName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["FileName"] as? String {
            self.fileName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSQLLogFilesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class LogFile : Tea.TeaModel {
            public var fileID: String?

            public var logDownloadURL: String?

            public var logEndTime: String?

            public var logSize: String?

            public var logStartTime: String?

            public var logStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileID != nil {
                    map["FileID"] = self.fileID!
                }
                if self.logDownloadURL != nil {
                    map["LogDownloadURL"] = self.logDownloadURL!
                }
                if self.logEndTime != nil {
                    map["LogEndTime"] = self.logEndTime!
                }
                if self.logSize != nil {
                    map["LogSize"] = self.logSize!
                }
                if self.logStartTime != nil {
                    map["LogStartTime"] = self.logStartTime!
                }
                if self.logStatus != nil {
                    map["LogStatus"] = self.logStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FileID"] as? String {
                    self.fileID = value
                }
                if let value = dict["LogDownloadURL"] as? String {
                    self.logDownloadURL = value
                }
                if let value = dict["LogEndTime"] as? String {
                    self.logEndTime = value
                }
                if let value = dict["LogSize"] as? String {
                    self.logSize = value
                }
                if let value = dict["LogStartTime"] as? String {
                    self.logStartTime = value
                }
                if let value = dict["LogStatus"] as? String {
                    self.logStatus = value
                }
            }
        }
        public var logFile: [DescribeSQLLogFilesResponseBody.Items.LogFile]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logFile != nil {
                var tmp : [Any] = []
                for k in self.logFile! {
                    tmp.append(k.toMap())
                }
                map["LogFile"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LogFile"] as? [Any?] {
                var tmp : [DescribeSQLLogFilesResponseBody.Items.LogFile] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSQLLogFilesResponseBody.Items.LogFile()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.logFile = tmp
            }
        }
    }
    public var items: DescribeSQLLogFilesResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSQLLogFilesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeSQLLogFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLLogFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLLogFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLLogRecordsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var database: String?

    public var endTime: String?

    public var form: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryKeywords: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var SQLId: Int64?

    public var startTime: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.form != nil {
            map["Form"] = self.form!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryKeywords != nil {
            map["QueryKeywords"] = self.queryKeywords!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.SQLId != nil {
            map["SQLId"] = self.SQLId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Database"] as? String {
            self.database = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Form"] as? String {
            self.form = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["QueryKeywords"] as? String {
            self.queryKeywords = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SQLId"] as? Int64 {
            self.SQLId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["User"] as? String {
            self.user = value
        }
    }
}

public class DescribeSQLLogRecordsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class SQLRecord : Tea.TeaModel {
            public var accountName: String?

            public var DBName: String?

            public var executeTime: String?

            public var hostAddress: String?

            public var returnRowCounts: Int64?

            public var SQLText: String?

            public var threadID: String?

            public var totalExecutionTimes: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.returnRowCounts != nil {
                    map["ReturnRowCounts"] = self.returnRowCounts!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.threadID != nil {
                    map["ThreadID"] = self.threadID!
                }
                if self.totalExecutionTimes != nil {
                    map["TotalExecutionTimes"] = self.totalExecutionTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["ExecuteTime"] as? String {
                    self.executeTime = value
                }
                if let value = dict["HostAddress"] as? String {
                    self.hostAddress = value
                }
                if let value = dict["ReturnRowCounts"] as? Int64 {
                    self.returnRowCounts = value
                }
                if let value = dict["SQLText"] as? String {
                    self.SQLText = value
                }
                if let value = dict["ThreadID"] as? String {
                    self.threadID = value
                }
                if let value = dict["TotalExecutionTimes"] as? Int64 {
                    self.totalExecutionTimes = value
                }
            }
        }
        public var SQLRecord: [DescribeSQLLogRecordsResponseBody.Items.SQLRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SQLRecord != nil {
                var tmp : [Any] = []
                for k in self.SQLRecord! {
                    tmp.append(k.toMap())
                }
                map["SQLRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SQLRecord"] as? [Any?] {
                var tmp : [DescribeSQLLogRecordsResponseBody.Items.SQLRecord] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSQLLogRecordsResponseBody.Items.SQLRecord()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.SQLRecord = tmp
            }
        }
    }
    public var items: DescribeSQLLogRecordsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSQLLogRecordsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int64 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeSQLLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLLogRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLLogReportListRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeSQLLogReportListResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public class LatencyTopNItems : Tea.TeaModel {
                public class LatencyTopNItem : Tea.TeaModel {
                    public var avgLatency: Int64?

                    public var SQLExecuteTimes: Int64?

                    public var SQLText: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgLatency != nil {
                            map["AvgLatency"] = self.avgLatency!
                        }
                        if self.SQLExecuteTimes != nil {
                            map["SQLExecuteTimes"] = self.SQLExecuteTimes!
                        }
                        if self.SQLText != nil {
                            map["SQLText"] = self.SQLText!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvgLatency"] as? Int64 {
                            self.avgLatency = value
                        }
                        if let value = dict["SQLExecuteTimes"] as? Int64 {
                            self.SQLExecuteTimes = value
                        }
                        if let value = dict["SQLText"] as? String {
                            self.SQLText = value
                        }
                    }
                }
                public var latencyTopNItem: [DescribeSQLLogReportListResponseBody.Items.Item.LatencyTopNItems.LatencyTopNItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.latencyTopNItem != nil {
                        var tmp : [Any] = []
                        for k in self.latencyTopNItem! {
                            tmp.append(k.toMap())
                        }
                        map["LatencyTopNItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LatencyTopNItem"] as? [Any?] {
                        var tmp : [DescribeSQLLogReportListResponseBody.Items.Item.LatencyTopNItems.LatencyTopNItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSQLLogReportListResponseBody.Items.Item.LatencyTopNItems.LatencyTopNItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.latencyTopNItem = tmp
                    }
                }
            }
            public class QPSTopNItems : Tea.TeaModel {
                public class QPSTopNItem : Tea.TeaModel {
                    public var SQLExecuteTimes: Int64?

                    public var SQLText: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.SQLExecuteTimes != nil {
                            map["SQLExecuteTimes"] = self.SQLExecuteTimes!
                        }
                        if self.SQLText != nil {
                            map["SQLText"] = self.SQLText!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["SQLExecuteTimes"] as? Int64 {
                            self.SQLExecuteTimes = value
                        }
                        if let value = dict["SQLText"] as? String {
                            self.SQLText = value
                        }
                    }
                }
                public var QPSTopNItem: [DescribeSQLLogReportListResponseBody.Items.Item.QPSTopNItems.QPSTopNItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.QPSTopNItem != nil {
                        var tmp : [Any] = []
                        for k in self.QPSTopNItem! {
                            tmp.append(k.toMap())
                        }
                        map["QPSTopNItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["QPSTopNItem"] as? [Any?] {
                        var tmp : [DescribeSQLLogReportListResponseBody.Items.Item.QPSTopNItems.QPSTopNItem] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeSQLLogReportListResponseBody.Items.Item.QPSTopNItems.QPSTopNItem()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.QPSTopNItem = tmp
                    }
                }
            }
            public var latencyTopNItems: DescribeSQLLogReportListResponseBody.Items.Item.LatencyTopNItems?

            public var QPSTopNItems: DescribeSQLLogReportListResponseBody.Items.Item.QPSTopNItems?

            public var reportTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.latencyTopNItems?.validate()
                try self.QPSTopNItems?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.latencyTopNItems != nil {
                    map["LatencyTopNItems"] = self.latencyTopNItems?.toMap()
                }
                if self.QPSTopNItems != nil {
                    map["QPSTopNItems"] = self.QPSTopNItems?.toMap()
                }
                if self.reportTime != nil {
                    map["ReportTime"] = self.reportTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LatencyTopNItems"] as? [String: Any?] {
                    var model = DescribeSQLLogReportListResponseBody.Items.Item.LatencyTopNItems()
                    model.fromMap(value)
                    self.latencyTopNItems = model
                }
                if let value = dict["QPSTopNItems"] as? [String: Any?] {
                    var model = DescribeSQLLogReportListResponseBody.Items.Item.QPSTopNItems()
                    model.fromMap(value)
                    self.QPSTopNItems = model
                }
                if let value = dict["ReportTime"] as? String {
                    self.reportTime = value
                }
            }
        }
        public var item: [DescribeSQLLogReportListResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Item"] as? [Any?] {
                var tmp : [DescribeSQLLogReportListResponseBody.Items.Item] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSQLLogReportListResponseBody.Items.Item()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.item = tmp
            }
        }
    }
    public var items: DescribeSQLLogReportListResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSQLLogReportListResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeSQLLogReportListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLLogReportListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLLogReportListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecretsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var clientToken: String?

    public var dbInstanceId: String?

    public var engine: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSecretsResponseBody : Tea.TeaModel {
    public class Secrets : Tea.TeaModel {
        public var accountId: String?

        public var description_: String?

        public var regionId: String?

        public var secretArn: String?

        public var secretName: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.secretArn != nil {
                map["SecretArn"] = self.secretArn!
            }
            if self.secretName != nil {
                map["SecretName"] = self.secretName!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? String {
                self.accountId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecretArn"] as? String {
                self.secretArn = value
            }
            if let value = dict["SecretName"] as? String {
                self.secretName = value
            }
            if let value = dict["Username"] as? String {
                self.username = value
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var secrets: [DescribeSecretsResponseBody.Secrets]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secrets != nil {
            var tmp : [Any] = []
            for k in self.secrets! {
                tmp.append(k.toMap())
            }
            map["Secrets"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Secrets"] as? [Any?] {
            var tmp : [DescribeSecretsResponseBody.Secrets] = []
            for v in value {
                if v != nil {
                    var model = DescribeSecretsResponseBody.Secrets()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.secrets = tmp
        }
    }
}

public class DescribeSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecretsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecurityGroupConfigurationRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSecurityGroupConfigurationResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class EcsSecurityGroupRelation : Tea.TeaModel {
            public var networkType: String?

            public var regionId: String?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecurityGroupId"] as? String {
                    self.securityGroupId = value
                }
                if let value = dict["SecurityGroupName"] as? String {
                    self.securityGroupName = value
                }
            }
        }
        public var ecsSecurityGroupRelation: [DescribeSecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsSecurityGroupRelation != nil {
                var tmp : [Any] = []
                for k in self.ecsSecurityGroupRelation! {
                    tmp.append(k.toMap())
                }
                map["EcsSecurityGroupRelation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcsSecurityGroupRelation"] as? [Any?] {
                var tmp : [DescribeSecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecsSecurityGroupRelation = tmp
            }
        }
    }
    public var DBInstanceName: String?

    public var items: DescribeSecurityGroupConfigurationResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSecurityGroupConfigurationResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSecurityGroupConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecurityGroupConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlotsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeSlotsResponseBody : Tea.TeaModel {
    public class Slots : Tea.TeaModel {
        public var database: String?

        public var plugin: String?

        public var slotName: String?

        public var slotStatus: String?

        public var slotType: String?

        public var subReplayLag: String?

        public var temporary: String?

        public var walDelay: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.plugin != nil {
                map["Plugin"] = self.plugin!
            }
            if self.slotName != nil {
                map["SlotName"] = self.slotName!
            }
            if self.slotStatus != nil {
                map["SlotStatus"] = self.slotStatus!
            }
            if self.slotType != nil {
                map["SlotType"] = self.slotType!
            }
            if self.subReplayLag != nil {
                map["SubReplayLag"] = self.subReplayLag!
            }
            if self.temporary != nil {
                map["Temporary"] = self.temporary!
            }
            if self.walDelay != nil {
                map["WalDelay"] = self.walDelay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Database"] as? String {
                self.database = value
            }
            if let value = dict["Plugin"] as? String {
                self.plugin = value
            }
            if let value = dict["SlotName"] as? String {
                self.slotName = value
            }
            if let value = dict["SlotStatus"] as? String {
                self.slotStatus = value
            }
            if let value = dict["SlotType"] as? String {
                self.slotType = value
            }
            if let value = dict["SubReplayLag"] as? String {
                self.subReplayLag = value
            }
            if let value = dict["Temporary"] as? String {
                self.temporary = value
            }
            if let value = dict["WalDelay"] as? String {
                self.walDelay = value
            }
        }
    }
    public var requestId: String?

    public var slots: [DescribeSlotsResponseBody.Slots]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slots != nil {
            var tmp : [Any] = []
            for k in self.slots! {
                tmp.append(k.toMap())
            }
            map["Slots"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Slots"] as? [Any?] {
            var tmp : [DescribeSlotsResponseBody.Slots] = []
            for v in value {
                if v != nil {
                    var model = DescribeSlotsResponseBody.Slots()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.slots = tmp
        }
    }
}

public class DescribeSlotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlotsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlowLogRecordsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBName: String?

    public var endTime: String?

    public var nodeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var SQLHASH: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.SQLHASH != nil {
            map["SQLHASH"] = self.SQLHASH!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SQLHASH"] as? String {
            self.SQLHASH = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeSlowLogRecordsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class SQLSlowRecord : Tea.TeaModel {
            public var applicationName: String?

            public var clientHostName: String?

            public var cpuTime: Int64?

            public var DBName: String?

            public var executionStartTime: String?

            public var hostAddress: String?

            public var lastRowsAffectedCount: Int64?

            public var lockTimes: Int64?

            public var logicalIORead: Int64?

            public var parseRowCounts: Int64?

            public var physicalIORead: Int64?

            public var queryTimeMS: Int64?

            public var queryTimes: Int64?

            public var returnRowCounts: Int64?

            public var rowsAffectedCount: Int64?

            public var SQLHash: String?

            public var SQLText: String?

            public var userName: String?

            public var writeIOCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationName != nil {
                    map["ApplicationName"] = self.applicationName!
                }
                if self.clientHostName != nil {
                    map["ClientHostName"] = self.clientHostName!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executionStartTime != nil {
                    map["ExecutionStartTime"] = self.executionStartTime!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.lastRowsAffectedCount != nil {
                    map["LastRowsAffectedCount"] = self.lastRowsAffectedCount!
                }
                if self.lockTimes != nil {
                    map["LockTimes"] = self.lockTimes!
                }
                if self.logicalIORead != nil {
                    map["LogicalIORead"] = self.logicalIORead!
                }
                if self.parseRowCounts != nil {
                    map["ParseRowCounts"] = self.parseRowCounts!
                }
                if self.physicalIORead != nil {
                    map["PhysicalIORead"] = self.physicalIORead!
                }
                if self.queryTimeMS != nil {
                    map["QueryTimeMS"] = self.queryTimeMS!
                }
                if self.queryTimes != nil {
                    map["QueryTimes"] = self.queryTimes!
                }
                if self.returnRowCounts != nil {
                    map["ReturnRowCounts"] = self.returnRowCounts!
                }
                if self.rowsAffectedCount != nil {
                    map["RowsAffectedCount"] = self.rowsAffectedCount!
                }
                if self.SQLHash != nil {
                    map["SQLHash"] = self.SQLHash!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                if self.writeIOCount != nil {
                    map["WriteIOCount"] = self.writeIOCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ApplicationName"] as? String {
                    self.applicationName = value
                }
                if let value = dict["ClientHostName"] as? String {
                    self.clientHostName = value
                }
                if let value = dict["CpuTime"] as? Int64 {
                    self.cpuTime = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["ExecutionStartTime"] as? String {
                    self.executionStartTime = value
                }
                if let value = dict["HostAddress"] as? String {
                    self.hostAddress = value
                }
                if let value = dict["LastRowsAffectedCount"] as? Int64 {
                    self.lastRowsAffectedCount = value
                }
                if let value = dict["LockTimes"] as? Int64 {
                    self.lockTimes = value
                }
                if let value = dict["LogicalIORead"] as? Int64 {
                    self.logicalIORead = value
                }
                if let value = dict["ParseRowCounts"] as? Int64 {
                    self.parseRowCounts = value
                }
                if let value = dict["PhysicalIORead"] as? Int64 {
                    self.physicalIORead = value
                }
                if let value = dict["QueryTimeMS"] as? Int64 {
                    self.queryTimeMS = value
                }
                if let value = dict["QueryTimes"] as? Int64 {
                    self.queryTimes = value
                }
                if let value = dict["ReturnRowCounts"] as? Int64 {
                    self.returnRowCounts = value
                }
                if let value = dict["RowsAffectedCount"] as? Int64 {
                    self.rowsAffectedCount = value
                }
                if let value = dict["SQLHash"] as? String {
                    self.SQLHash = value
                }
                if let value = dict["SQLText"] as? String {
                    self.SQLText = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
                if let value = dict["WriteIOCount"] as? Int64 {
                    self.writeIOCount = value
                }
            }
        }
        public var SQLSlowRecord: [DescribeSlowLogRecordsResponseBody.Items.SQLSlowRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SQLSlowRecord != nil {
                var tmp : [Any] = []
                for k in self.SQLSlowRecord! {
                    tmp.append(k.toMap())
                }
                map["SQLSlowRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SQLSlowRecord"] as? [Any?] {
                var tmp : [DescribeSlowLogRecordsResponseBody.Items.SQLSlowRecord] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSlowLogRecordsResponseBody.Items.SQLSlowRecord()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.SQLSlowRecord = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var engine: String?

    public var items: DescribeSlowLogRecordsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSlowLogRecordsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeSlowLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlowLogRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSlowLogsRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBName: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sortKey: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sortKey != nil {
            map["SortKey"] = self.sortKey!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SortKey"] as? String {
            self.sortKey = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeSlowLogsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class SQLSlowLog : Tea.TeaModel {
            public var avgExecutionTime: Int64?

            public var avgIOWriteCounts: Int64?

            public var avgLastRowsAffectedCounts: Int64?

            public var avgLogicalReadCounts: Int64?

            public var avgPhysicalReadCounts: Int64?

            public var avgRowsAffectedCounts: Int64?

            public var createTime: String?

            public var DBName: String?

            public var maxExecutionTime: Int64?

            public var maxExecutionTimeMS: Int64?

            public var maxIOWriteCounts: Int64?

            public var maxLastRowsAffectedCounts: Int64?

            public var maxLockTime: Int64?

            public var maxLockTimeMS: Int64?

            public var maxLogicalReadCounts: Int64?

            public var maxPhysicalReadCounts: Int64?

            public var maxRowsAffectedCounts: Int64?

            public var minIOWriteCounts: Int64?

            public var minLastRowsAffectedCounts: Int64?

            public var minLogicalReadCounts: Int64?

            public var minPhysicalReadCounts: Int64?

            public var minRowsAffectedCounts: Int64?

            public var mySQLTotalExecutionCounts: Int64?

            public var mySQLTotalExecutionTimes: Int64?

            public var parseMaxRowCount: Int64?

            public var parseTotalRowCounts: Int64?

            public var reportTime: String?

            public var returnMaxRowCount: Int64?

            public var returnTotalRowCounts: Int64?

            public var SQLHASH: String?

            public var SQLIdStr: String?

            public var SQLServerAvgCpuTime: Int64?

            public var SQLServerAvgExecutionTime: Int64?

            public var SQLServerMaxCpuTime: Int64?

            public var SQLServerMinCpuTime: Int64?

            public var SQLServerMinExecutionTime: Int64?

            public var SQLServerTotalCpuTime: Int64?

            public var SQLServerTotalExecutionCounts: Int64?

            public var SQLServerTotalExecutionTimes: Int64?

            public var SQLText: String?

            public var slowLogId: Int64?

            public var totalIOWriteCounts: Int64?

            public var totalLastRowsAffectedCounts: Int64?

            public var totalLockTimes: Int64?

            public var totalLogicalReadCounts: Int64?

            public var totalPhysicalReadCounts: Int64?

            public var totalRowsAffectedCounts: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgExecutionTime != nil {
                    map["AvgExecutionTime"] = self.avgExecutionTime!
                }
                if self.avgIOWriteCounts != nil {
                    map["AvgIOWriteCounts"] = self.avgIOWriteCounts!
                }
                if self.avgLastRowsAffectedCounts != nil {
                    map["AvgLastRowsAffectedCounts"] = self.avgLastRowsAffectedCounts!
                }
                if self.avgLogicalReadCounts != nil {
                    map["AvgLogicalReadCounts"] = self.avgLogicalReadCounts!
                }
                if self.avgPhysicalReadCounts != nil {
                    map["AvgPhysicalReadCounts"] = self.avgPhysicalReadCounts!
                }
                if self.avgRowsAffectedCounts != nil {
                    map["AvgRowsAffectedCounts"] = self.avgRowsAffectedCounts!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.maxExecutionTime != nil {
                    map["MaxExecutionTime"] = self.maxExecutionTime!
                }
                if self.maxExecutionTimeMS != nil {
                    map["MaxExecutionTimeMS"] = self.maxExecutionTimeMS!
                }
                if self.maxIOWriteCounts != nil {
                    map["MaxIOWriteCounts"] = self.maxIOWriteCounts!
                }
                if self.maxLastRowsAffectedCounts != nil {
                    map["MaxLastRowsAffectedCounts"] = self.maxLastRowsAffectedCounts!
                }
                if self.maxLockTime != nil {
                    map["MaxLockTime"] = self.maxLockTime!
                }
                if self.maxLockTimeMS != nil {
                    map["MaxLockTimeMS"] = self.maxLockTimeMS!
                }
                if self.maxLogicalReadCounts != nil {
                    map["MaxLogicalReadCounts"] = self.maxLogicalReadCounts!
                }
                if self.maxPhysicalReadCounts != nil {
                    map["MaxPhysicalReadCounts"] = self.maxPhysicalReadCounts!
                }
                if self.maxRowsAffectedCounts != nil {
                    map["MaxRowsAffectedCounts"] = self.maxRowsAffectedCounts!
                }
                if self.minIOWriteCounts != nil {
                    map["MinIOWriteCounts"] = self.minIOWriteCounts!
                }
                if self.minLastRowsAffectedCounts != nil {
                    map["MinLastRowsAffectedCounts"] = self.minLastRowsAffectedCounts!
                }
                if self.minLogicalReadCounts != nil {
                    map["MinLogicalReadCounts"] = self.minLogicalReadCounts!
                }
                if self.minPhysicalReadCounts != nil {
                    map["MinPhysicalReadCounts"] = self.minPhysicalReadCounts!
                }
                if self.minRowsAffectedCounts != nil {
                    map["MinRowsAffectedCounts"] = self.minRowsAffectedCounts!
                }
                if self.mySQLTotalExecutionCounts != nil {
                    map["MySQLTotalExecutionCounts"] = self.mySQLTotalExecutionCounts!
                }
                if self.mySQLTotalExecutionTimes != nil {
                    map["MySQLTotalExecutionTimes"] = self.mySQLTotalExecutionTimes!
                }
                if self.parseMaxRowCount != nil {
                    map["ParseMaxRowCount"] = self.parseMaxRowCount!
                }
                if self.parseTotalRowCounts != nil {
                    map["ParseTotalRowCounts"] = self.parseTotalRowCounts!
                }
                if self.reportTime != nil {
                    map["ReportTime"] = self.reportTime!
                }
                if self.returnMaxRowCount != nil {
                    map["ReturnMaxRowCount"] = self.returnMaxRowCount!
                }
                if self.returnTotalRowCounts != nil {
                    map["ReturnTotalRowCounts"] = self.returnTotalRowCounts!
                }
                if self.SQLHASH != nil {
                    map["SQLHASH"] = self.SQLHASH!
                }
                if self.SQLIdStr != nil {
                    map["SQLIdStr"] = self.SQLIdStr!
                }
                if self.SQLServerAvgCpuTime != nil {
                    map["SQLServerAvgCpuTime"] = self.SQLServerAvgCpuTime!
                }
                if self.SQLServerAvgExecutionTime != nil {
                    map["SQLServerAvgExecutionTime"] = self.SQLServerAvgExecutionTime!
                }
                if self.SQLServerMaxCpuTime != nil {
                    map["SQLServerMaxCpuTime"] = self.SQLServerMaxCpuTime!
                }
                if self.SQLServerMinCpuTime != nil {
                    map["SQLServerMinCpuTime"] = self.SQLServerMinCpuTime!
                }
                if self.SQLServerMinExecutionTime != nil {
                    map["SQLServerMinExecutionTime"] = self.SQLServerMinExecutionTime!
                }
                if self.SQLServerTotalCpuTime != nil {
                    map["SQLServerTotalCpuTime"] = self.SQLServerTotalCpuTime!
                }
                if self.SQLServerTotalExecutionCounts != nil {
                    map["SQLServerTotalExecutionCounts"] = self.SQLServerTotalExecutionCounts!
                }
                if self.SQLServerTotalExecutionTimes != nil {
                    map["SQLServerTotalExecutionTimes"] = self.SQLServerTotalExecutionTimes!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.slowLogId != nil {
                    map["SlowLogId"] = self.slowLogId!
                }
                if self.totalIOWriteCounts != nil {
                    map["TotalIOWriteCounts"] = self.totalIOWriteCounts!
                }
                if self.totalLastRowsAffectedCounts != nil {
                    map["TotalLastRowsAffectedCounts"] = self.totalLastRowsAffectedCounts!
                }
                if self.totalLockTimes != nil {
                    map["TotalLockTimes"] = self.totalLockTimes!
                }
                if self.totalLogicalReadCounts != nil {
                    map["TotalLogicalReadCounts"] = self.totalLogicalReadCounts!
                }
                if self.totalPhysicalReadCounts != nil {
                    map["TotalPhysicalReadCounts"] = self.totalPhysicalReadCounts!
                }
                if self.totalRowsAffectedCounts != nil {
                    map["TotalRowsAffectedCounts"] = self.totalRowsAffectedCounts!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AvgExecutionTime"] as? Int64 {
                    self.avgExecutionTime = value
                }
                if let value = dict["AvgIOWriteCounts"] as? Int64 {
                    self.avgIOWriteCounts = value
                }
                if let value = dict["AvgLastRowsAffectedCounts"] as? Int64 {
                    self.avgLastRowsAffectedCounts = value
                }
                if let value = dict["AvgLogicalReadCounts"] as? Int64 {
                    self.avgLogicalReadCounts = value
                }
                if let value = dict["AvgPhysicalReadCounts"] as? Int64 {
                    self.avgPhysicalReadCounts = value
                }
                if let value = dict["AvgRowsAffectedCounts"] as? Int64 {
                    self.avgRowsAffectedCounts = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["MaxExecutionTime"] as? Int64 {
                    self.maxExecutionTime = value
                }
                if let value = dict["MaxExecutionTimeMS"] as? Int64 {
                    self.maxExecutionTimeMS = value
                }
                if let value = dict["MaxIOWriteCounts"] as? Int64 {
                    self.maxIOWriteCounts = value
                }
                if let value = dict["MaxLastRowsAffectedCounts"] as? Int64 {
                    self.maxLastRowsAffectedCounts = value
                }
                if let value = dict["MaxLockTime"] as? Int64 {
                    self.maxLockTime = value
                }
                if let value = dict["MaxLockTimeMS"] as? Int64 {
                    self.maxLockTimeMS = value
                }
                if let value = dict["MaxLogicalReadCounts"] as? Int64 {
                    self.maxLogicalReadCounts = value
                }
                if let value = dict["MaxPhysicalReadCounts"] as? Int64 {
                    self.maxPhysicalReadCounts = value
                }
                if let value = dict["MaxRowsAffectedCounts"] as? Int64 {
                    self.maxRowsAffectedCounts = value
                }
                if let value = dict["MinIOWriteCounts"] as? Int64 {
                    self.minIOWriteCounts = value
                }
                if let value = dict["MinLastRowsAffectedCounts"] as? Int64 {
                    self.minLastRowsAffectedCounts = value
                }
                if let value = dict["MinLogicalReadCounts"] as? Int64 {
                    self.minLogicalReadCounts = value
                }
                if let value = dict["MinPhysicalReadCounts"] as? Int64 {
                    self.minPhysicalReadCounts = value
                }
                if let value = dict["MinRowsAffectedCounts"] as? Int64 {
                    self.minRowsAffectedCounts = value
                }
                if let value = dict["MySQLTotalExecutionCounts"] as? Int64 {
                    self.mySQLTotalExecutionCounts = value
                }
                if let value = dict["MySQLTotalExecutionTimes"] as? Int64 {
                    self.mySQLTotalExecutionTimes = value
                }
                if let value = dict["ParseMaxRowCount"] as? Int64 {
                    self.parseMaxRowCount = value
                }
                if let value = dict["ParseTotalRowCounts"] as? Int64 {
                    self.parseTotalRowCounts = value
                }
                if let value = dict["ReportTime"] as? String {
                    self.reportTime = value
                }
                if let value = dict["ReturnMaxRowCount"] as? Int64 {
                    self.returnMaxRowCount = value
                }
                if let value = dict["ReturnTotalRowCounts"] as? Int64 {
                    self.returnTotalRowCounts = value
                }
                if let value = dict["SQLHASH"] as? String {
                    self.SQLHASH = value
                }
                if let value = dict["SQLIdStr"] as? String {
                    self.SQLIdStr = value
                }
                if let value = dict["SQLServerAvgCpuTime"] as? Int64 {
                    self.SQLServerAvgCpuTime = value
                }
                if let value = dict["SQLServerAvgExecutionTime"] as? Int64 {
                    self.SQLServerAvgExecutionTime = value
                }
                if let value = dict["SQLServerMaxCpuTime"] as? Int64 {
                    self.SQLServerMaxCpuTime = value
                }
                if let value = dict["SQLServerMinCpuTime"] as? Int64 {
                    self.SQLServerMinCpuTime = value
                }
                if let value = dict["SQLServerMinExecutionTime"] as? Int64 {
                    self.SQLServerMinExecutionTime = value
                }
                if let value = dict["SQLServerTotalCpuTime"] as? Int64 {
                    self.SQLServerTotalCpuTime = value
                }
                if let value = dict["SQLServerTotalExecutionCounts"] as? Int64 {
                    self.SQLServerTotalExecutionCounts = value
                }
                if let value = dict["SQLServerTotalExecutionTimes"] as? Int64 {
                    self.SQLServerTotalExecutionTimes = value
                }
                if let value = dict["SQLText"] as? String {
                    self.SQLText = value
                }
                if let value = dict["SlowLogId"] as? Int64 {
                    self.slowLogId = value
                }
                if let value = dict["TotalIOWriteCounts"] as? Int64 {
                    self.totalIOWriteCounts = value
                }
                if let value = dict["TotalLastRowsAffectedCounts"] as? Int64 {
                    self.totalLastRowsAffectedCounts = value
                }
                if let value = dict["TotalLockTimes"] as? Int64 {
                    self.totalLockTimes = value
                }
                if let value = dict["TotalLogicalReadCounts"] as? Int64 {
                    self.totalLogicalReadCounts = value
                }
                if let value = dict["TotalPhysicalReadCounts"] as? Int64 {
                    self.totalPhysicalReadCounts = value
                }
                if let value = dict["TotalRowsAffectedCounts"] as? Int64 {
                    self.totalRowsAffectedCounts = value
                }
            }
        }
        public var SQLSlowLog: [DescribeSlowLogsResponseBody.Items.SQLSlowLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.SQLSlowLog != nil {
                var tmp : [Any] = []
                for k in self.SQLSlowLog! {
                    tmp.append(k.toMap())
                }
                map["SQLSlowLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SQLSlowLog"] as? [Any?] {
                var tmp : [DescribeSlowLogsResponseBody.Items.SQLSlowLog] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSlowLogsResponseBody.Items.SQLSlowLog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.SQLSlowLog = tmp
            }
        }
    }
    public var DBInstanceId: String?

    public var endTime: String?

    public var engine: String?

    public var items: DescribeSlowLogsResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var startTime: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSlowLogsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeSlowLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSlowLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSupportOnlineResizeDiskRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
    }
}

public class DescribeSupportOnlineResizeDiskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeSupportOnlineResizeDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportOnlineResizeDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSupportOnlineResizeDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tags: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class TagInfos : Tea.TeaModel {
            public class DBInstanceIds : Tea.TeaModel {
                public var DBInstanceIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DBInstanceIds != nil {
                        map["DBInstanceIds"] = self.DBInstanceIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DBInstanceIds"] as? [String] {
                        self.DBInstanceIds = value
                    }
                }
            }
            public var DBInstanceIds: DescribeTagsResponseBody.Items.TagInfos.DBInstanceIds?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.DBInstanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceIds != nil {
                    map["DBInstanceIds"] = self.DBInstanceIds?.toMap()
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceIds"] as? [String: Any?] {
                    var model = DescribeTagsResponseBody.Items.TagInfos.DBInstanceIds()
                    model.fromMap(value)
                    self.DBInstanceIds = model
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagInfos: [DescribeTagsResponseBody.Items.TagInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagInfos != nil {
                var tmp : [Any] = []
                for k in self.tagInfos! {
                    tmp.append(k.toMap())
                }
                map["TagInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagInfos"] as? [Any?] {
                var tmp : [DescribeTagsResponseBody.Items.TagInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTagsResponseBody.Items.TagInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagInfos = tmp
            }
        }
    }
    public var items: DescribeTagsResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeTagsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTasksRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var status: String?

    public var taskAction: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskAction"] as? String {
            self.taskAction = value
        }
    }
}

public class DescribeTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class TaskProgressInfo : Tea.TeaModel {
            public var beginTime: String?

            public var currentStepName: String?

            public var DBName: String?

            public var expectedFinishTime: String?

            public var finishTime: String?

            public var progress: String?

            public var progressInfo: String?

            public var remain: Int32?

            public var status: String?

            public var stepProgressInfo: String?

            public var stepsInfo: String?

            public var taskAction: String?

            public var taskErrorCode: String?

            public var taskErrorMessage: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginTime != nil {
                    map["BeginTime"] = self.beginTime!
                }
                if self.currentStepName != nil {
                    map["CurrentStepName"] = self.currentStepName!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.expectedFinishTime != nil {
                    map["ExpectedFinishTime"] = self.expectedFinishTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.progressInfo != nil {
                    map["ProgressInfo"] = self.progressInfo!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepProgressInfo != nil {
                    map["StepProgressInfo"] = self.stepProgressInfo!
                }
                if self.stepsInfo != nil {
                    map["StepsInfo"] = self.stepsInfo!
                }
                if self.taskAction != nil {
                    map["TaskAction"] = self.taskAction!
                }
                if self.taskErrorCode != nil {
                    map["TaskErrorCode"] = self.taskErrorCode!
                }
                if self.taskErrorMessage != nil {
                    map["TaskErrorMessage"] = self.taskErrorMessage!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginTime"] as? String {
                    self.beginTime = value
                }
                if let value = dict["CurrentStepName"] as? String {
                    self.currentStepName = value
                }
                if let value = dict["DBName"] as? String {
                    self.DBName = value
                }
                if let value = dict["ExpectedFinishTime"] as? String {
                    self.expectedFinishTime = value
                }
                if let value = dict["FinishTime"] as? String {
                    self.finishTime = value
                }
                if let value = dict["Progress"] as? String {
                    self.progress = value
                }
                if let value = dict["ProgressInfo"] as? String {
                    self.progressInfo = value
                }
                if let value = dict["Remain"] as? Int32 {
                    self.remain = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StepProgressInfo"] as? String {
                    self.stepProgressInfo = value
                }
                if let value = dict["StepsInfo"] as? String {
                    self.stepsInfo = value
                }
                if let value = dict["TaskAction"] as? String {
                    self.taskAction = value
                }
                if let value = dict["TaskErrorCode"] as? String {
                    self.taskErrorCode = value
                }
                if let value = dict["TaskErrorMessage"] as? String {
                    self.taskErrorMessage = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
            }
        }
        public var taskProgressInfo: [DescribeTasksResponseBody.Items.TaskProgressInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskProgressInfo != nil {
                var tmp : [Any] = []
                for k in self.taskProgressInfo! {
                    tmp.append(k.toMap())
                }
                map["TaskProgressInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskProgressInfo"] as? [Any?] {
                var tmp : [DescribeTasksResponseBody.Items.TaskProgressInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTasksResponseBody.Items.TaskProgressInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskProgressInfo = tmp
            }
        }
    }
    public var items: DescribeTasksResponseBody.Items?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeTasksResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUpgradeMajorVersionPrecheckTaskRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetMajorVersion: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetMajorVersion != nil {
            map["TargetMajorVersion"] = self.targetMajorVersion!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetMajorVersion"] as? String {
            self.targetMajorVersion = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class DescribeUpgradeMajorVersionPrecheckTaskResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var checkTime: String?

        public var detail: String?

        public var effectiveTime: String?

        public var recommendDiskSize: Int32?

        public var recommendLeastMemSize: Int32?

        public var recommendMemSize: Int32?

        public var result: String?

        public var sourceMajorVersion: String?

        public var targetMajorVersion: String?

        public var taskId: Int32?

        public var upgradeMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkTime != nil {
                map["CheckTime"] = self.checkTime!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.effectiveTime != nil {
                map["EffectiveTime"] = self.effectiveTime!
            }
            if self.recommendDiskSize != nil {
                map["RecommendDiskSize"] = self.recommendDiskSize!
            }
            if self.recommendLeastMemSize != nil {
                map["RecommendLeastMemSize"] = self.recommendLeastMemSize!
            }
            if self.recommendMemSize != nil {
                map["RecommendMemSize"] = self.recommendMemSize!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.sourceMajorVersion != nil {
                map["SourceMajorVersion"] = self.sourceMajorVersion!
            }
            if self.targetMajorVersion != nil {
                map["TargetMajorVersion"] = self.targetMajorVersion!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.upgradeMode != nil {
                map["UpgradeMode"] = self.upgradeMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckTime"] as? String {
                self.checkTime = value
            }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["EffectiveTime"] as? String {
                self.effectiveTime = value
            }
            if let value = dict["RecommendDiskSize"] as? Int32 {
                self.recommendDiskSize = value
            }
            if let value = dict["RecommendLeastMemSize"] as? Int32 {
                self.recommendLeastMemSize = value
            }
            if let value = dict["RecommendMemSize"] as? Int32 {
                self.recommendMemSize = value
            }
            if let value = dict["Result"] as? String {
                self.result = value
            }
            if let value = dict["SourceMajorVersion"] as? String {
                self.sourceMajorVersion = value
            }
            if let value = dict["TargetMajorVersion"] as? String {
                self.targetMajorVersion = value
            }
            if let value = dict["TaskId"] as? Int32 {
                self.taskId = value
            }
            if let value = dict["UpgradeMode"] as? String {
                self.upgradeMode = value
            }
        }
    }
    public var items: [DescribeUpgradeMajorVersionPrecheckTaskResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeUpgradeMajorVersionPrecheckTaskResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeUpgradeMajorVersionPrecheckTaskResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeUpgradeMajorVersionPrecheckTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpgradeMajorVersionPrecheckTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUpgradeMajorVersionPrecheckTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUpgradeMajorVersionTasksRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetMajorVersion: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetMajorVersion != nil {
            map["TargetMajorVersion"] = self.targetMajorVersion!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetMajorVersion"] as? String {
            self.targetMajorVersion = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class DescribeUpgradeMajorVersionTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var collectStatMode: String?

        public var detail: String?

        public var endTime: String?

        public var result: String?

        public var sourceInsName: String?

        public var sourceMajorVersion: String?

        public var startTime: String?

        public var switchEndTime: String?

        public var switchTime: String?

        public var targetInsName: String?

        public var targetMajorVersion: String?

        public var taskId: Int32?

        public var upgradeMode: String?

        public var cutOver: Bool?

        public var totalLogicRepDelayTime: Int32?

        public var totalLogicRepLatencyMB: Int32?

        public var zeroDownTimeConnectionString: String?

        public var zeroDownTimePort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectStatMode != nil {
                map["CollectStatMode"] = self.collectStatMode!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.sourceInsName != nil {
                map["SourceInsName"] = self.sourceInsName!
            }
            if self.sourceMajorVersion != nil {
                map["SourceMajorVersion"] = self.sourceMajorVersion!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.switchEndTime != nil {
                map["SwitchEndTime"] = self.switchEndTime!
            }
            if self.switchTime != nil {
                map["SwitchTime"] = self.switchTime!
            }
            if self.targetInsName != nil {
                map["TargetInsName"] = self.targetInsName!
            }
            if self.targetMajorVersion != nil {
                map["TargetMajorVersion"] = self.targetMajorVersion!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.upgradeMode != nil {
                map["UpgradeMode"] = self.upgradeMode!
            }
            if self.cutOver != nil {
                map["cutOver"] = self.cutOver!
            }
            if self.totalLogicRepDelayTime != nil {
                map["totalLogicRepDelayTime"] = self.totalLogicRepDelayTime!
            }
            if self.totalLogicRepLatencyMB != nil {
                map["totalLogicRepLatencyMB"] = self.totalLogicRepLatencyMB!
            }
            if self.zeroDownTimeConnectionString != nil {
                map["zeroDownTimeConnectionString"] = self.zeroDownTimeConnectionString!
            }
            if self.zeroDownTimePort != nil {
                map["zeroDownTimePort"] = self.zeroDownTimePort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CollectStatMode"] as? String {
                self.collectStatMode = value
            }
            if let value = dict["Detail"] as? String {
                self.detail = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Result"] as? String {
                self.result = value
            }
            if let value = dict["SourceInsName"] as? String {
                self.sourceInsName = value
            }
            if let value = dict["SourceMajorVersion"] as? String {
                self.sourceMajorVersion = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["SwitchEndTime"] as? String {
                self.switchEndTime = value
            }
            if let value = dict["SwitchTime"] as? String {
                self.switchTime = value
            }
            if let value = dict["TargetInsName"] as? String {
                self.targetInsName = value
            }
            if let value = dict["TargetMajorVersion"] as? String {
                self.targetMajorVersion = value
            }
            if let value = dict["TaskId"] as? Int32 {
                self.taskId = value
            }
            if let value = dict["UpgradeMode"] as? String {
                self.upgradeMode = value
            }
            if let value = dict["cutOver"] as? Bool {
                self.cutOver = value
            }
            if let value = dict["totalLogicRepDelayTime"] as? Int32 {
                self.totalLogicRepDelayTime = value
            }
            if let value = dict["totalLogicRepLatencyMB"] as? Int32 {
                self.totalLogicRepLatencyMB = value
            }
            if let value = dict["zeroDownTimeConnectionString"] as? String {
                self.zeroDownTimeConnectionString = value
            }
            if let value = dict["zeroDownTimePort"] as? Int32 {
                self.zeroDownTimePort = value
            }
        }
    }
    public var items: [DescribeUpgradeMajorVersionTasksResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeUpgradeMajorVersionTasksResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeUpgradeMajorVersionTasksResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageRecordCount"] as? Int32 {
            self.pageRecordCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalRecordCount"] as? Int32 {
            self.totalRecordCount = value
        }
    }
}

public class DescribeUpgradeMajorVersionTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpgradeMajorVersionTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUpgradeMajorVersionTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public var dedicatedHostGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitchs : Tea.TeaModel {
        public var availableIpAddressCount: String?

        public var cidrBlock: String?

        public var description_: String?

        public var isDefault: Bool?

        public var izNo: String?

        public var status: String?

        public var vSwitchId: String?

        public var vSwitchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableIpAddressCount != nil {
                map["AvailableIpAddressCount"] = self.availableIpAddressCount!
            }
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.izNo != nil {
                map["IzNo"] = self.izNo!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchName != nil {
                map["VSwitchName"] = self.vSwitchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvailableIpAddressCount"] as? String {
                self.availableIpAddressCount = value
            }
            if let value = dict["CidrBlock"] as? String {
                self.cidrBlock = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["IsDefault"] as? Bool {
                self.isDefault = value
            }
            if let value = dict["IzNo"] as? String {
                self.izNo = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VSwitchName"] as? String {
                self.vSwitchName = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitchs: [DescribeVSwitchesResponseBody.VSwitchs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitchs != nil {
            var tmp : [Any] = []
            for k in self.vSwitchs! {
                tmp.append(k.toMap())
            }
            map["VSwitchs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
        if let value = dict["VSwitchs"] as? [Any?] {
            var tmp : [DescribeVSwitchesResponseBody.VSwitchs] = []
            for v in value {
                if v != nil {
                    var model = DescribeVSwitchesResponseBody.VSwitchs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vSwitchs = tmp
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWhitelistTemplateRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
    }
}

public class DescribeWhitelistTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var id: Int32?

            public var ips: String?

            public var templateId: Int32?

            public var templateName: String?

            public var userId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ips != nil {
                    map["Ips"] = self.ips!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Ips"] as? String {
                    self.ips = value
                }
                if let value = dict["TemplateId"] as? Int32 {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["UserId"] as? Int32 {
                    self.userId = value
                }
            }
        }
        public var template: DescribeWhitelistTemplateResponseBody.Data.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                map["Template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Template"] as? [String: Any?] {
                var model = DescribeWhitelistTemplateResponseBody.Data.Template()
                model.fromMap(value)
                self.template = model
            }
        }
    }
    public var code: String?

    public var data: DescribeWhitelistTemplateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeWhitelistTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeWhitelistTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWhitelistTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeWhitelistTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWhitelistTemplateLinkedInstanceRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
    }
}

public class DescribeWhitelistTemplateLinkedInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var insName: [String]?

        public var templateId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.insName != nil {
                map["InsName"] = self.insName!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InsName"] as? [String] {
                self.insName = value
            }
            if let value = dict["TemplateId"] as? Int32 {
                self.templateId = value
            }
        }
    }
    public var code: String?

    public var data: DescribeWhitelistTemplateLinkedInstanceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeWhitelistTemplateLinkedInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeWhitelistTemplateLinkedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWhitelistTemplateLinkedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeWhitelistTemplateLinkedInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DestroyDBInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DestroyDBInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DestroyDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DestroyDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DestroyDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachGadInstanceMemberRequest : Tea.TeaModel {
    public var gadInstanceName: String?

    public var memberInstanceName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gadInstanceName != nil {
            map["GadInstanceName"] = self.gadInstanceName!
        }
        if self.memberInstanceName != nil {
            map["MemberInstanceName"] = self.memberInstanceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GadInstanceName"] as? String {
            self.gadInstanceName = value
        }
        if let value = dict["MemberInstanceName"] as? String {
            self.memberInstanceName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DetachGadInstanceMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachGadInstanceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachGadInstanceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachGadInstanceMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachRCDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: Bool?

    public var diskId: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteWithInstance"] as? Bool {
            self.deleteWithInstance = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DetachRCDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachRCDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachRCDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachRCDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachWhitelistTemplateToInstanceRequest : Tea.TeaModel {
    public var insName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insName != nil {
            map["InsName"] = self.insName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InsName"] as? String {
            self.insName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
    }
}

public class DetachWhitelistTemplateToInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: DetachWhitelistTemplateToInstanceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DetachWhitelistTemplateToInstanceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DetachWhitelistTemplateToInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachWhitelistTemplateToInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachWhitelistTemplateToInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EvaluateLocalExtendDiskRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Storage"] as? Int32 {
            self.storage = value
        }
    }
}

public class EvaluateLocalExtendDiskResponseBody : Tea.TeaModel {
    public var available: String?

    public var DBInstanceId: String?

    public var DBInstanceTransType: String?

    public var localUpgradeDiskLimit: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.available != nil {
            map["Available"] = self.available!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceTransType != nil {
            map["DBInstanceTransType"] = self.DBInstanceTransType!
        }
        if self.localUpgradeDiskLimit != nil {
            map["LocalUpgradeDiskLimit"] = self.localUpgradeDiskLimit!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Available"] as? String {
            self.available = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceTransType"] as? String {
            self.DBInstanceTransType = value
        }
        if let value = dict["LocalUpgradeDiskLimit"] as? Int64 {
            self.localUpgradeDiskLimit = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EvaluateLocalExtendDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EvaluateLocalExtendDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EvaluateLocalExtendDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDBInstanceTopologyRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GetDBInstanceTopologyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Connections : Tea.TeaModel {
            public var connectionString: String?

            public var DBInstanceName: String?

            public var netType: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.DBInstanceName != nil {
                    map["DBInstanceName"] = self.DBInstanceName!
                }
                if self.netType != nil {
                    map["NetType"] = self.netType!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["DBInstanceName"] as? String {
                    self.DBInstanceName = value
                }
                if let value = dict["NetType"] as? String {
                    self.netType = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public class Nodes : Tea.TeaModel {
            public var DBInstanceName: String?

            public var dedicatedHostGroupId: String?

            public var dedicatedHostId: String?

            public var nodeId: String?

            public var role: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBInstanceName != nil {
                    map["DBInstanceName"] = self.DBInstanceName!
                }
                if self.dedicatedHostGroupId != nil {
                    map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBInstanceName"] as? String {
                    self.DBInstanceName = value
                }
                if let value = dict["DedicatedHostGroupId"] as? String {
                    self.dedicatedHostGroupId = value
                }
                if let value = dict["DedicatedHostId"] as? String {
                    self.dedicatedHostId = value
                }
                if let value = dict["NodeId"] as? String {
                    self.nodeId = value
                }
                if let value = dict["Role"] as? String {
                    self.role = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var connections: [GetDBInstanceTopologyResponseBody.Data.Connections]?

        public var DBInstanceName: String?

        public var nodes: [GetDBInstanceTopologyResponseBody.Data.Nodes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connections != nil {
                var tmp : [Any] = []
                for k in self.connections! {
                    tmp.append(k.toMap())
                }
                map["Connections"] = tmp
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Connections"] as? [Any?] {
                var tmp : [GetDBInstanceTopologyResponseBody.Data.Connections] = []
                for v in value {
                    if v != nil {
                        var model = GetDBInstanceTopologyResponseBody.Data.Connections()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.connections = tmp
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [GetDBInstanceTopologyResponseBody.Data.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = GetDBInstanceTopologyResponseBody.Data.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
        }
    }
    public var code: String?

    public var data: GetDBInstanceTopologyResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDBInstanceTopologyResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDBInstanceTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBInstanceTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDBInstanceTopologyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDbProxyInstanceSslRequest : Tea.TeaModel {
    public var DBProxyEngineType: String?

    public var dbInstanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetDbProxyInstanceSslResponseBody : Tea.TeaModel {
    public class DbProxyCertListItems : Tea.TeaModel {
        public class DbProxyCertListItems : Tea.TeaModel {
            public var certCommonName: String?

            public var dbInstanceName: String?

            public var endpointName: String?

            public var endpointType: String?

            public var sslExpiredTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certCommonName != nil {
                    map["CertCommonName"] = self.certCommonName!
                }
                if self.dbInstanceName != nil {
                    map["DbInstanceName"] = self.dbInstanceName!
                }
                if self.endpointName != nil {
                    map["EndpointName"] = self.endpointName!
                }
                if self.endpointType != nil {
                    map["EndpointType"] = self.endpointType!
                }
                if self.sslExpiredTime != nil {
                    map["SslExpiredTime"] = self.sslExpiredTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CertCommonName"] as? String {
                    self.certCommonName = value
                }
                if let value = dict["DbInstanceName"] as? String {
                    self.dbInstanceName = value
                }
                if let value = dict["EndpointName"] as? String {
                    self.endpointName = value
                }
                if let value = dict["EndpointType"] as? String {
                    self.endpointType = value
                }
                if let value = dict["SslExpiredTime"] as? String {
                    self.sslExpiredTime = value
                }
            }
        }
        public var dbProxyCertListItems: [GetDbProxyInstanceSslResponseBody.DbProxyCertListItems.DbProxyCertListItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbProxyCertListItems != nil {
                var tmp : [Any] = []
                for k in self.dbProxyCertListItems! {
                    tmp.append(k.toMap())
                }
                map["DbProxyCertListItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbProxyCertListItems"] as? [Any?] {
                var tmp : [GetDbProxyInstanceSslResponseBody.DbProxyCertListItems.DbProxyCertListItems] = []
                for v in value {
                    if v != nil {
                        var model = GetDbProxyInstanceSslResponseBody.DbProxyCertListItems.DbProxyCertListItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dbProxyCertListItems = tmp
            }
        }
    }
    public var dbProxyCertListItems: GetDbProxyInstanceSslResponseBody.DbProxyCertListItems?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dbProxyCertListItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbProxyCertListItems != nil {
            map["DbProxyCertListItems"] = self.dbProxyCertListItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbProxyCertListItems"] as? [String: Any?] {
            var model = GetDbProxyInstanceSslResponseBody.DbProxyCertListItems()
            model.fromMap(value)
            self.dbProxyCertListItems = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDbProxyInstanceSslResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDbProxyInstanceSslResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDbProxyInstanceSslResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantAccountPrivilegeRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPrivilege: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPrivilege != nil {
            map["AccountPrivilege"] = self.accountPrivilege!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPrivilege"] as? String {
            self.accountPrivilege = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GrantAccountPrivilegeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantAccountPrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantAccountPrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantAccountPrivilegeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantOperatorPermissionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var expiredTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privileges: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privileges != nil {
            map["Privileges"] = self.privileges!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Privileges"] as? String {
            self.privileges = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GrantOperatorPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantOperatorPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantOperatorPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantOperatorPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportUserBackupFileRequest : Tea.TeaModel {
    public var backupFile: String?

    public var bucketRegion: String?

    public var comment: String?

    public var DBInstanceId: String?

    public var engineVersion: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreSize: Int32?

    public var retention: Int32?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupFile != nil {
            map["BackupFile"] = self.backupFile!
        }
        if self.bucketRegion != nil {
            map["BucketRegion"] = self.bucketRegion!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreSize != nil {
            map["RestoreSize"] = self.restoreSize!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupFile"] as? String {
            self.backupFile = value
        }
        if let value = dict["BucketRegion"] as? String {
            self.bucketRegion = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreSize"] as? Int32 {
            self.restoreSize = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ImportUserBackupFileResponseBody : Tea.TeaModel {
    public var backupId: String?

    public var requestId: String?

    public var status: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? Bool {
            self.status = value
        }
    }
}

public class ImportUserBackupFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportUserBackupFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportUserBackupFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListClassesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var engine: String?

    public var orderType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ListClassesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var classCode: String?

        public var classGroup: String?

        public var cpu: String?

        public var encryptedMemory: String?

        public var instructionSetArch: String?

        public var maxConnections: String?

        public var maxIOMBPS: String?

        public var maxIOPS: String?

        public var memoryClass: String?

        public var referencePrice: String?

        public var category: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classCode != nil {
                map["ClassCode"] = self.classCode!
            }
            if self.classGroup != nil {
                map["ClassGroup"] = self.classGroup!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.encryptedMemory != nil {
                map["EncryptedMemory"] = self.encryptedMemory!
            }
            if self.instructionSetArch != nil {
                map["InstructionSetArch"] = self.instructionSetArch!
            }
            if self.maxConnections != nil {
                map["MaxConnections"] = self.maxConnections!
            }
            if self.maxIOMBPS != nil {
                map["MaxIOMBPS"] = self.maxIOMBPS!
            }
            if self.maxIOPS != nil {
                map["MaxIOPS"] = self.maxIOPS!
            }
            if self.memoryClass != nil {
                map["MemoryClass"] = self.memoryClass!
            }
            if self.referencePrice != nil {
                map["ReferencePrice"] = self.referencePrice!
            }
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.storageType != nil {
                map["storageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClassCode"] as? String {
                self.classCode = value
            }
            if let value = dict["ClassGroup"] as? String {
                self.classGroup = value
            }
            if let value = dict["Cpu"] as? String {
                self.cpu = value
            }
            if let value = dict["EncryptedMemory"] as? String {
                self.encryptedMemory = value
            }
            if let value = dict["InstructionSetArch"] as? String {
                self.instructionSetArch = value
            }
            if let value = dict["MaxConnections"] as? String {
                self.maxConnections = value
            }
            if let value = dict["MaxIOMBPS"] as? String {
                self.maxIOMBPS = value
            }
            if let value = dict["MaxIOPS"] as? String {
                self.maxIOPS = value
            }
            if let value = dict["MemoryClass"] as? String {
                self.memoryClass = value
            }
            if let value = dict["ReferencePrice"] as? String {
                self.referencePrice = value
            }
            if let value = dict["category"] as? String {
                self.category = value
            }
            if let value = dict["storageType"] as? String {
                self.storageType = value
            }
        }
    }
    public var items: [ListClassesResponseBody.Items]?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [ListClassesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = ListClassesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListClassesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClassesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListClassesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUserBackupFilesRequest : Tea.TeaModel {
    public var backupId: String?

    public var comment: String?

    public var ossUrl: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["OssUrl"] as? String {
            self.ossUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class ListUserBackupFilesResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public var backupId: String?

        public var binlogInfo: String?

        public var comment: String?

        public var creationTime: String?

        public var engine: String?

        public var engineVersion: String?

        public var finishTime: String?

        public var modificationTime: String?

        public var ossBucket: String?

        public var ossFileMetaData: String?

        public var ossFileName: String?

        public var ossFilePath: String?

        public var ossFileSize: Int64?

        public var ossUrl: String?

        public var reason: String?

        public var restoreSize: String?

        public var retention: Int32?

        public var status: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backupId != nil {
                map["BackupId"] = self.backupId!
            }
            if self.binlogInfo != nil {
                map["BinlogInfo"] = self.binlogInfo!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineVersion != nil {
                map["EngineVersion"] = self.engineVersion!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.modificationTime != nil {
                map["ModificationTime"] = self.modificationTime!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossFileMetaData != nil {
                map["OssFileMetaData"] = self.ossFileMetaData!
            }
            if self.ossFileName != nil {
                map["OssFileName"] = self.ossFileName!
            }
            if self.ossFilePath != nil {
                map["OssFilePath"] = self.ossFilePath!
            }
            if self.ossFileSize != nil {
                map["OssFileSize"] = self.ossFileSize!
            }
            if self.ossUrl != nil {
                map["OssUrl"] = self.ossUrl!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.restoreSize != nil {
                map["RestoreSize"] = self.restoreSize!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BackupId"] as? String {
                self.backupId = value
            }
            if let value = dict["BinlogInfo"] as? String {
                self.binlogInfo = value
            }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["CreationTime"] as? String {
                self.creationTime = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineVersion"] as? String {
                self.engineVersion = value
            }
            if let value = dict["FinishTime"] as? String {
                self.finishTime = value
            }
            if let value = dict["ModificationTime"] as? String {
                self.modificationTime = value
            }
            if let value = dict["OssBucket"] as? String {
                self.ossBucket = value
            }
            if let value = dict["OssFileMetaData"] as? String {
                self.ossFileMetaData = value
            }
            if let value = dict["OssFileName"] as? String {
                self.ossFileName = value
            }
            if let value = dict["OssFilePath"] as? String {
                self.ossFilePath = value
            }
            if let value = dict["OssFileSize"] as? Int64 {
                self.ossFileSize = value
            }
            if let value = dict["OssUrl"] as? String {
                self.ossUrl = value
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["RestoreSize"] as? String {
                self.restoreSize = value
            }
            if let value = dict["Retention"] as? Int32 {
                self.retention = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var records: [ListUserBackupFilesResponseBody.Records]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["Records"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Records"] as? [Any?] {
            var tmp : [ListUserBackupFilesResponseBody.Records] = []
            for v in value {
                if v != nil {
                    var model = ListUserBackupFilesResponseBody.Records()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.records = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListUserBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUserBackupFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LockAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class LockAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class LockAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LockAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LockAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateConnectionToOtherZoneRequest : Tea.TeaModel {
    public var connectionString: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class MigrateConnectionToOtherZoneResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MigrateConnectionToOtherZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateConnectionToOtherZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateConnectionToOtherZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var dedicatedHostGroupId: String?

    public var effectiveTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var specifiedTime: String?

    public var targetDedicatedHostIdForMaster: String?

    public var targetDedicatedHostIdForSlave: String?

    public var zoneIdForFollower: String?

    public var zoneIdForLog: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.specifiedTime != nil {
            map["SpecifiedTime"] = self.specifiedTime!
        }
        if self.targetDedicatedHostIdForMaster != nil {
            map["TargetDedicatedHostIdForMaster"] = self.targetDedicatedHostIdForMaster!
        }
        if self.targetDedicatedHostIdForSlave != nil {
            map["TargetDedicatedHostIdForSlave"] = self.targetDedicatedHostIdForSlave!
        }
        if self.zoneIdForFollower != nil {
            map["ZoneIdForFollower"] = self.zoneIdForFollower!
        }
        if self.zoneIdForLog != nil {
            map["ZoneIdForLog"] = self.zoneIdForLog!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpecifiedTime"] as? String {
            self.specifiedTime = value
        }
        if let value = dict["TargetDedicatedHostIdForMaster"] as? String {
            self.targetDedicatedHostIdForMaster = value
        }
        if let value = dict["TargetDedicatedHostIdForSlave"] as? String {
            self.targetDedicatedHostIdForSlave = value
        }
        if let value = dict["ZoneIdForFollower"] as? String {
            self.zoneIdForFollower = value
        }
        if let value = dict["ZoneIdForLog"] as? String {
            self.zoneIdForLog = value
        }
    }
}

public class MigrateDBInstanceResponseBody : Tea.TeaModel {
    public var migrationId: Int32?

    public var requestId: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int32 {
            self.migrationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class MigrateDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateDBNodesRequest : Tea.TeaModel {
    public class DBNode : Tea.TeaModel {
        public var nodeId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["nodeId"] = self.nodeId!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["nodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNode: [MigrateDBNodesRequest.DBNode]?

    public var effectiveTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNode != nil {
            var tmp : [Any] = []
            for k in self.DBNode! {
                tmp.append(k.toMap())
            }
            map["DBNode"] = tmp
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNode"] as? [Any?] {
            var tmp : [MigrateDBNodesRequest.DBNode] = []
            for v in value {
                if v != nil {
                    var model = MigrateDBNodesRequest.DBNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBNode = tmp
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class MigrateDBNodesShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNodeShrink: String?

    public var effectiveTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeShrink != nil {
            map["DBNode"] = self.DBNodeShrink!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNode"] as? String {
            self.DBNodeShrink = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class MigrateDBNodesResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class MigrateDBNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateDBNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateDBNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateSecurityIPModeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class MigrateSecurityIPModeResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var securityIPMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityIPMode != nil {
            map["SecurityIPMode"] = self.securityIPMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SecurityIPMode"] as? String {
            self.securityIPMode = value
        }
    }
}

public class MigrateSecurityIPModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateSecurityIPModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateSecurityIPModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateToOtherZoneRequest : Tea.TeaModel {
    public var category: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int64?

    public var DBInstanceStorageType: String?

    public var effectiveTime: String?

    public var ioAccelerationEnabled: String?

    public var isModifySpec: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.isModifySpec != nil {
            map["IsModifySpec"] = self.isModifySpec!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int64 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["IsModifySpec"] as? String {
            self.isModifySpec = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class MigrateToOtherZoneResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class MigrateToOtherZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateToOtherZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateToOtherZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyADInfoRequest : Tea.TeaModel {
    public var ADAccountName: String?

    public var ADDNS: String?

    public var ADPassword: String?

    public var ADServerIpAddress: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ADAccountName != nil {
            map["ADAccountName"] = self.ADAccountName!
        }
        if self.ADDNS != nil {
            map["ADDNS"] = self.ADDNS!
        }
        if self.ADPassword != nil {
            map["ADPassword"] = self.ADPassword!
        }
        if self.ADServerIpAddress != nil {
            map["ADServerIpAddress"] = self.ADServerIpAddress!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ADAccountName"] as? String {
            self.ADAccountName = value
        }
        if let value = dict["ADDNS"] as? String {
            self.ADDNS = value
        }
        if let value = dict["ADPassword"] as? String {
            self.ADPassword = value
        }
        if let value = dict["ADServerIpAddress"] as? String {
            self.ADServerIpAddress = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyADInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyADInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyADInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyADInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountCheckPolicyRequest : Tea.TeaModel {
    public var accountName: String?

    public var checkPolicy: Bool?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.checkPolicy != nil {
            map["CheckPolicy"] = self.checkPolicy!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["CheckPolicy"] as? Bool {
            self.checkPolicy = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyAccountCheckPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAccountCheckPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountCheckPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountCheckPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountDescriptionRequest : Tea.TeaModel {
    public var accountDescription: String?

    public var accountName: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountDescription != nil {
            map["AccountDescription"] = self.accountDescription!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountDescription"] as? String {
            self.accountDescription = value
        }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyAccountDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAccountDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountMaskingPrivilegeRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var expireTime: String?

    public var ownerId: String?

    public var privilege: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privilege != nil {
            map["Privilege"] = self.privilege!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["ExpireTime"] as? String {
            self.expireTime = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["Privilege"] as? String {
            self.privilege = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class ModifyAccountMaskingPrivilegeResponseBody : Tea.TeaModel {
    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: String] {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifyAccountMaskingPrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountMaskingPrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountMaskingPrivilegeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountSecurityPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var groupPolicy: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.groupPolicy != nil {
            map["GroupPolicy"] = self.groupPolicy!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["GroupPolicy"] as? String {
            self.groupPolicy = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyAccountSecurityPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAccountSecurityPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountSecurityPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountSecurityPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyActionEventPolicyRequest : Tea.TeaModel {
    public var enableEventLog: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableEventLog != nil {
            map["EnableEventLog"] = self.enableEventLog!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableEventLog"] as? String {
            self.enableEventLog = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyActionEventPolicyResponseBody : Tea.TeaModel {
    public var enableEventLog: String?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableEventLog != nil {
            map["EnableEventLog"] = self.enableEventLog!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableEventLog"] as? String {
            self.enableEventLog = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyActionEventPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyActionEventPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyActionEventPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyActiveOperationTasksRequest : Tea.TeaModel {
    public var ids: String?

    public var immediateStart: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var switchTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.immediateStart != nil {
            map["ImmediateStart"] = self.immediateStart!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.ids = value
        }
        if let value = dict["ImmediateStart"] as? Int32 {
            self.immediateStart = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
    }
}

public class ModifyActiveOperationTasksResponseBody : Tea.TeaModel {
    public var ids: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.ids = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyActiveOperationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyActiveOperationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyActiveOperationTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyBackupPolicyRequest : Tea.TeaModel {
    public var archiveBackupKeepCount: Int32?

    public var archiveBackupKeepPolicy: String?

    public var archiveBackupRetentionPeriod: String?

    public var backupInterval: String?

    public var backupLog: String?

    public var backupMethod: String?

    public var backupPolicyMode: String?

    public var backupPriority: Int32?

    public var backupRetentionPeriod: String?

    public var category: String?

    public var compressType: String?

    public var DBInstanceId: String?

    public var enableBackupLog: String?

    public var enableIncrementDataBackup: Bool?

    public var highSpaceUsageProtection: String?

    public var localLogRetentionHours: String?

    public var localLogRetentionSpace: String?

    public var logBackupFrequency: String?

    public var logBackupLocalRetentionNumber: Int32?

    public var logBackupRetentionPeriod: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var preferredBackupPeriod: String?

    public var preferredBackupTime: String?

    public var releasedKeepPolicy: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveBackupKeepCount != nil {
            map["ArchiveBackupKeepCount"] = self.archiveBackupKeepCount!
        }
        if self.archiveBackupKeepPolicy != nil {
            map["ArchiveBackupKeepPolicy"] = self.archiveBackupKeepPolicy!
        }
        if self.archiveBackupRetentionPeriod != nil {
            map["ArchiveBackupRetentionPeriod"] = self.archiveBackupRetentionPeriod!
        }
        if self.backupInterval != nil {
            map["BackupInterval"] = self.backupInterval!
        }
        if self.backupLog != nil {
            map["BackupLog"] = self.backupLog!
        }
        if self.backupMethod != nil {
            map["BackupMethod"] = self.backupMethod!
        }
        if self.backupPolicyMode != nil {
            map["BackupPolicyMode"] = self.backupPolicyMode!
        }
        if self.backupPriority != nil {
            map["BackupPriority"] = self.backupPriority!
        }
        if self.backupRetentionPeriod != nil {
            map["BackupRetentionPeriod"] = self.backupRetentionPeriod!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.compressType != nil {
            map["CompressType"] = self.compressType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.enableBackupLog != nil {
            map["EnableBackupLog"] = self.enableBackupLog!
        }
        if self.enableIncrementDataBackup != nil {
            map["EnableIncrementDataBackup"] = self.enableIncrementDataBackup!
        }
        if self.highSpaceUsageProtection != nil {
            map["HighSpaceUsageProtection"] = self.highSpaceUsageProtection!
        }
        if self.localLogRetentionHours != nil {
            map["LocalLogRetentionHours"] = self.localLogRetentionHours!
        }
        if self.localLogRetentionSpace != nil {
            map["LocalLogRetentionSpace"] = self.localLogRetentionSpace!
        }
        if self.logBackupFrequency != nil {
            map["LogBackupFrequency"] = self.logBackupFrequency!
        }
        if self.logBackupLocalRetentionNumber != nil {
            map["LogBackupLocalRetentionNumber"] = self.logBackupLocalRetentionNumber!
        }
        if self.logBackupRetentionPeriod != nil {
            map["LogBackupRetentionPeriod"] = self.logBackupRetentionPeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.preferredBackupPeriod != nil {
            map["PreferredBackupPeriod"] = self.preferredBackupPeriod!
        }
        if self.preferredBackupTime != nil {
            map["PreferredBackupTime"] = self.preferredBackupTime!
        }
        if self.releasedKeepPolicy != nil {
            map["ReleasedKeepPolicy"] = self.releasedKeepPolicy!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveBackupKeepCount"] as? Int32 {
            self.archiveBackupKeepCount = value
        }
        if let value = dict["ArchiveBackupKeepPolicy"] as? String {
            self.archiveBackupKeepPolicy = value
        }
        if let value = dict["ArchiveBackupRetentionPeriod"] as? String {
            self.archiveBackupRetentionPeriod = value
        }
        if let value = dict["BackupInterval"] as? String {
            self.backupInterval = value
        }
        if let value = dict["BackupLog"] as? String {
            self.backupLog = value
        }
        if let value = dict["BackupMethod"] as? String {
            self.backupMethod = value
        }
        if let value = dict["BackupPolicyMode"] as? String {
            self.backupPolicyMode = value
        }
        if let value = dict["BackupPriority"] as? Int32 {
            self.backupPriority = value
        }
        if let value = dict["BackupRetentionPeriod"] as? String {
            self.backupRetentionPeriod = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["CompressType"] as? String {
            self.compressType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EnableBackupLog"] as? String {
            self.enableBackupLog = value
        }
        if let value = dict["EnableIncrementDataBackup"] as? Bool {
            self.enableIncrementDataBackup = value
        }
        if let value = dict["HighSpaceUsageProtection"] as? String {
            self.highSpaceUsageProtection = value
        }
        if let value = dict["LocalLogRetentionHours"] as? String {
            self.localLogRetentionHours = value
        }
        if let value = dict["LocalLogRetentionSpace"] as? String {
            self.localLogRetentionSpace = value
        }
        if let value = dict["LogBackupFrequency"] as? String {
            self.logBackupFrequency = value
        }
        if let value = dict["LogBackupLocalRetentionNumber"] as? Int32 {
            self.logBackupLocalRetentionNumber = value
        }
        if let value = dict["LogBackupRetentionPeriod"] as? String {
            self.logBackupRetentionPeriod = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PreferredBackupPeriod"] as? String {
            self.preferredBackupPeriod = value
        }
        if let value = dict["PreferredBackupTime"] as? String {
            self.preferredBackupTime = value
        }
        if let value = dict["ReleasedKeepPolicy"] as? String {
            self.releasedKeepPolicy = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyBackupPolicyResponseBody : Tea.TeaModel {
    public var compressType: String?

    public var DBInstanceID: String?

    public var enableBackupLog: String?

    public var highSpaceUsageProtection: String?

    public var localLogRetentionHours: Int32?

    public var localLogRetentionSpace: String?

    public var logBackupLocalRetentionNumber: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compressType != nil {
            map["CompressType"] = self.compressType!
        }
        if self.DBInstanceID != nil {
            map["DBInstanceID"] = self.DBInstanceID!
        }
        if self.enableBackupLog != nil {
            map["EnableBackupLog"] = self.enableBackupLog!
        }
        if self.highSpaceUsageProtection != nil {
            map["HighSpaceUsageProtection"] = self.highSpaceUsageProtection!
        }
        if self.localLogRetentionHours != nil {
            map["LocalLogRetentionHours"] = self.localLogRetentionHours!
        }
        if self.localLogRetentionSpace != nil {
            map["LocalLogRetentionSpace"] = self.localLogRetentionSpace!
        }
        if self.logBackupLocalRetentionNumber != nil {
            map["LogBackupLocalRetentionNumber"] = self.logBackupLocalRetentionNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CompressType"] as? String {
            self.compressType = value
        }
        if let value = dict["DBInstanceID"] as? String {
            self.DBInstanceID = value
        }
        if let value = dict["EnableBackupLog"] as? String {
            self.enableBackupLog = value
        }
        if let value = dict["HighSpaceUsageProtection"] as? String {
            self.highSpaceUsageProtection = value
        }
        if let value = dict["LocalLogRetentionHours"] as? Int32 {
            self.localLogRetentionHours = value
        }
        if let value = dict["LocalLogRetentionSpace"] as? String {
            self.localLogRetentionSpace = value
        }
        if let value = dict["LogBackupLocalRetentionNumber"] as? Int32 {
            self.logBackupLocalRetentionNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCollationTimeZoneRequest : Tea.TeaModel {
    public var collation: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timezone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collation != nil {
            map["Collation"] = self.collation!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Collation"] as? String {
            self.collation = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
    }
}

public class ModifyCollationTimeZoneResponseBody : Tea.TeaModel {
    public var collation: String?

    public var DBInstanceId: String?

    public var requestId: String?

    public var taskId: String?

    public var timezone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collation != nil {
            map["Collation"] = self.collation!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Collation"] as? String {
            self.collation = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
    }
}

public class ModifyCollationTimeZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCollationTimeZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCollationTimeZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCustinsResourceRequest : Tea.TeaModel {
    public var adjustDeadline: String?

    public var DBInstanceId: String?

    public var increaseRatio: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var restoreOriginalSpecification: String?

    public var targetValue: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adjustDeadline != nil {
            map["AdjustDeadline"] = self.adjustDeadline!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.increaseRatio != nil {
            map["IncreaseRatio"] = self.increaseRatio!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.restoreOriginalSpecification != nil {
            map["RestoreOriginalSpecification"] = self.restoreOriginalSpecification!
        }
        if self.targetValue != nil {
            map["TargetValue"] = self.targetValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdjustDeadline"] as? String {
            self.adjustDeadline = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["IncreaseRatio"] as? String {
            self.increaseRatio = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["RestoreOriginalSpecification"] as? String {
            self.restoreOriginalSpecification = value
        }
        if let value = dict["TargetValue"] as? Int32 {
            self.targetValue = value
        }
    }
}

public class ModifyCustinsResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class ModifyCustinsResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustinsResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCustinsResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBDescriptionRequest : Tea.TeaModel {
    public var DBDescription: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBDescription != nil {
            map["DBDescription"] = self.DBDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBDescription"] as? String {
            self.DBDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceAutoUpgradeMinorVersionRequest : Tea.TeaModel {
    public var autoUpgradeMinorVersion: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoUpgradeMinorVersion != nil {
            map["AutoUpgradeMinorVersion"] = self.autoUpgradeMinorVersion!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoUpgradeMinorVersion"] as? String {
            self.autoUpgradeMinorVersion = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceAutoUpgradeMinorVersionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceAutoUpgradeMinorVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceAutoUpgradeMinorVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceAutoUpgradeMinorVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var configName: String?

    public var configValue: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var switchTimeMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.configName != nil {
            map["ConfigName"] = self.configName!
        }
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.switchTimeMode != nil {
            map["SwitchTimeMode"] = self.switchTimeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConfigName"] as? String {
            self.configName = value
        }
        if let value = dict["ConfigValue"] as? String {
            self.configValue = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["SwitchTimeMode"] as? String {
            self.switchTimeMode = value
        }
    }
}

public class ModifyDBInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceConnectionStringRequest : Tea.TeaModel {
    public var babelfishPort: String?

    public var connectionStringPrefix: String?

    public var currentConnectionString: String?

    public var DBInstanceId: String?

    public var generalGroupName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var PGBouncerPort: String?

    public var port: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.babelfishPort != nil {
            map["BabelfishPort"] = self.babelfishPort!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.currentConnectionString != nil {
            map["CurrentConnectionString"] = self.currentConnectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.generalGroupName != nil {
            map["GeneralGroupName"] = self.generalGroupName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.PGBouncerPort != nil {
            map["PGBouncerPort"] = self.PGBouncerPort!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BabelfishPort"] as? String {
            self.babelfishPort = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["CurrentConnectionString"] as? String {
            self.currentConnectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["GeneralGroupName"] as? String {
            self.generalGroupName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PGBouncerPort"] as? String {
            self.PGBouncerPort = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceConnectionStringResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceConnectionStringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceConnectionStringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceConnectionStringResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceDelayedReplicationTimeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var readSQLReplicationTime: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.readSQLReplicationTime != nil {
            map["ReadSQLReplicationTime"] = self.readSQLReplicationTime!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReadSQLReplicationTime"] as? String {
            self.readSQLReplicationTime = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceDelayedReplicationTimeResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var readSQLReplicationTime: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.readSQLReplicationTime != nil {
            map["ReadSQLReplicationTime"] = self.readSQLReplicationTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ReadSQLReplicationTime"] as? String {
            self.readSQLReplicationTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyDBInstanceDelayedReplicationTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceDelayedReplicationTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceDelayedReplicationTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceDeletionProtectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var deletionProtection: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DeletionProtection"] as? Bool {
            self.deletionProtection = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceDeletionProtectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceDeletionProtectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceDeletionProtectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceDeletionProtectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceDescriptionRequest : Tea.TeaModel {
    public var DBInstanceDescription: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceDescription != nil {
            map["DBInstanceDescription"] = self.DBInstanceDescription!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceDescription"] as? String {
            self.DBInstanceDescription = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceEndpointRequest : Tea.TeaModel {
    public class NodeItems : Tea.TeaModel {
        public var DBInstanceId: String?

        public var nodeId: String?

        public var weight: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceId != nil {
                map["DBInstanceId"] = self.DBInstanceId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceId"] as? String {
                self.DBInstanceId = value
            }
            if let value = dict["NodeId"] as? String {
                self.nodeId = value
            }
            if let value = dict["Weight"] as? Int64 {
                self.weight = value
            }
        }
    }
    public var clientToken: String?

    public var DBInstanceEndpointDescription: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var nodeItems: [ModifyDBInstanceEndpointRequest.NodeItems]?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceEndpointDescription != nil {
            map["DBInstanceEndpointDescription"] = self.DBInstanceEndpointDescription!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeItems != nil {
            var tmp : [Any] = []
            for k in self.nodeItems! {
                tmp.append(k.toMap())
            }
            map["NodeItems"] = tmp
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceEndpointDescription"] as? String {
            self.DBInstanceEndpointDescription = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeItems"] as? [Any?] {
            var tmp : [ModifyDBInstanceEndpointRequest.NodeItems] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBInstanceEndpointRequest.NodeItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nodeItems = tmp
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceEndpointShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceEndpointDescription: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var nodeItemsShrink: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceEndpointDescription != nil {
            map["DBInstanceEndpointDescription"] = self.DBInstanceEndpointDescription!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeItemsShrink != nil {
            map["NodeItems"] = self.nodeItemsShrink!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceEndpointDescription"] as? String {
            self.DBInstanceEndpointDescription = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeItems"] as? String {
            self.nodeItemsShrink = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceEndpointResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: ModifyDBInstanceEndpointResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ModifyDBInstanceEndpointResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceEndpointAddressRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionString: String?

    public var connectionStringPrefix: String?

    public var DBInstanceEndpointId: String?

    public var DBInstanceId: String?

    public var port: String?

    public var privateIpAddress: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceEndpointId != nil {
            map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceEndpointId"] as? String {
            self.DBInstanceEndpointId = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ModifyDBInstanceEndpointAddressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBInstanceEndpointId: String?

        public var DBInstanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBInstanceEndpointId != nil {
                map["DBInstanceEndpointId"] = self.DBInstanceEndpointId!
            }
            if self.DBInstanceName != nil {
                map["DBInstanceName"] = self.DBInstanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBInstanceEndpointId"] as? String {
                self.DBInstanceEndpointId = value
            }
            if let value = dict["DBInstanceName"] as? String {
                self.DBInstanceName = value
            }
        }
    }
    public var data: ModifyDBInstanceEndpointAddressResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ModifyDBInstanceEndpointAddressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceHAConfigRequest : Tea.TeaModel {
    public var dbInstanceId: String?

    public var HAMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var syncMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.HAMode != nil {
            map["HAMode"] = self.HAMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.syncMode != nil {
            map["SyncMode"] = self.syncMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["HAMode"] as? String {
            self.HAMode = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SyncMode"] as? String {
            self.syncMode = value
        }
    }
}

public class ModifyDBInstanceHAConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceHAConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceHAConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceHAConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceMaintainTimeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var maintainTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.maintainTime != nil {
            map["MaintainTime"] = self.maintainTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["MaintainTime"] as? String {
            self.maintainTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceMaintainTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceMaintainTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceMaintainTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceMaintainTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceMetricsRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var metricsConfig: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.metricsConfig != nil {
            map["MetricsConfig"] = self.metricsConfig!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["MetricsConfig"] as? String {
            self.metricsConfig = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
    }
}

public class ModifyDBInstanceMetricsResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
    }
}

public class ModifyDBInstanceMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceNetworkExpireTimeRequest : Tea.TeaModel {
    public var classicExpiredDays: Int32?

    public var connectionString: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classicExpiredDays != nil {
            map["ClassicExpiredDays"] = self.classicExpiredDays!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClassicExpiredDays"] as? Int32 {
            self.classicExpiredDays = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceNetworkExpireTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceNetworkExpireTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceNetworkExpireTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceNetworkExpireTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceNetworkTypeRequest : Tea.TeaModel {
    public var classicExpiredDays: String?

    public var DBInstanceId: String?

    public var instanceNetworkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var readWriteSplittingClassicExpiredDays: Int32?

    public var readWriteSplittingPrivateIpAddress: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retainClassic: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.classicExpiredDays != nil {
            map["ClassicExpiredDays"] = self.classicExpiredDays!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.readWriteSplittingClassicExpiredDays != nil {
            map["ReadWriteSplittingClassicExpiredDays"] = self.readWriteSplittingClassicExpiredDays!
        }
        if self.readWriteSplittingPrivateIpAddress != nil {
            map["ReadWriteSplittingPrivateIpAddress"] = self.readWriteSplittingPrivateIpAddress!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retainClassic != nil {
            map["RetainClassic"] = self.retainClassic!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClassicExpiredDays"] as? String {
            self.classicExpiredDays = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ReadWriteSplittingClassicExpiredDays"] as? Int32 {
            self.readWriteSplittingClassicExpiredDays = value
        }
        if let value = dict["ReadWriteSplittingPrivateIpAddress"] as? String {
            self.readWriteSplittingPrivateIpAddress = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetainClassic"] as? String {
            self.retainClassic = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class ModifyDBInstanceNetworkTypeResponseBody : Tea.TeaModel {
    public var connectionString: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyDBInstanceNetworkTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceNetworkTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceNetworkTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstancePayTypeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var payType: String?

    public var period: String?

    public var resourceOwnerId: Int64?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
    }
}

public class ModifyDBInstancePayTypeResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
    }
}

public class ModifyDBInstancePayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstancePayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstancePayTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceReplicationSwitchRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var externalReplication: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.externalReplication != nil {
            map["ExternalReplication"] = self.externalReplication!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ExternalReplication"] as? String {
            self.externalReplication = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBInstanceReplicationSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceReplicationSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceReplicationSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceReplicationSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceSSLRequest : Tea.TeaModel {
    public var ACL: String?

    public var CAType: String?

    public var certificate: String?

    public var clientCACert: String?

    public var clientCAEnabled: Int32?

    public var clientCertRevocationList: String?

    public var clientCrlEnabled: Int32?

    public var connectionString: String?

    public var DBInstanceId: String?

    public var forceEncryption: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passWord: String?

    public var replicationACL: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var SSLEnabled: Int32?

    public var serverCert: String?

    public var serverKey: String?

    public var tlsVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ACL != nil {
            map["ACL"] = self.ACL!
        }
        if self.CAType != nil {
            map["CAType"] = self.CAType!
        }
        if self.certificate != nil {
            map["Certificate"] = self.certificate!
        }
        if self.clientCACert != nil {
            map["ClientCACert"] = self.clientCACert!
        }
        if self.clientCAEnabled != nil {
            map["ClientCAEnabled"] = self.clientCAEnabled!
        }
        if self.clientCertRevocationList != nil {
            map["ClientCertRevocationList"] = self.clientCertRevocationList!
        }
        if self.clientCrlEnabled != nil {
            map["ClientCrlEnabled"] = self.clientCrlEnabled!
        }
        if self.connectionString != nil {
            map["ConnectionString"] = self.connectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.forceEncryption != nil {
            map["ForceEncryption"] = self.forceEncryption!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.replicationACL != nil {
            map["ReplicationACL"] = self.replicationACL!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.SSLEnabled != nil {
            map["SSLEnabled"] = self.SSLEnabled!
        }
        if self.serverCert != nil {
            map["ServerCert"] = self.serverCert!
        }
        if self.serverKey != nil {
            map["ServerKey"] = self.serverKey!
        }
        if self.tlsVersion != nil {
            map["TlsVersion"] = self.tlsVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ACL"] as? String {
            self.ACL = value
        }
        if let value = dict["CAType"] as? String {
            self.CAType = value
        }
        if let value = dict["Certificate"] as? String {
            self.certificate = value
        }
        if let value = dict["ClientCACert"] as? String {
            self.clientCACert = value
        }
        if let value = dict["ClientCAEnabled"] as? Int32 {
            self.clientCAEnabled = value
        }
        if let value = dict["ClientCertRevocationList"] as? String {
            self.clientCertRevocationList = value
        }
        if let value = dict["ClientCrlEnabled"] as? Int32 {
            self.clientCrlEnabled = value
        }
        if let value = dict["ConnectionString"] as? String {
            self.connectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ForceEncryption"] as? String {
            self.forceEncryption = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PassWord"] as? String {
            self.passWord = value
        }
        if let value = dict["ReplicationACL"] as? String {
            self.replicationACL = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SSLEnabled"] as? Int32 {
            self.SSLEnabled = value
        }
        if let value = dict["ServerCert"] as? String {
            self.serverCert = value
        }
        if let value = dict["ServerKey"] as? String {
            self.serverKey = value
        }
        if let value = dict["TlsVersion"] as? String {
            self.tlsVersion = value
        }
    }
}

public class ModifyDBInstanceSSLResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceSSLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceSSLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceSSLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceSecurityGroupRuleRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var description_: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: String?

    public var portRange: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? String {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
    }
}

public class ModifyDBInstanceSecurityGroupRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceSecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceSecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceSecurityGroupRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceSpecRequest : Tea.TeaModel {
    public class ServerlessConfiguration : Tea.TeaModel {
        public var autoPause: Bool?

        public var maxCapacity: Double?

        public var minCapacity: Double?

        public var switchForce: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoPause != nil {
                map["AutoPause"] = self.autoPause!
            }
            if self.maxCapacity != nil {
                map["MaxCapacity"] = self.maxCapacity!
            }
            if self.minCapacity != nil {
                map["MinCapacity"] = self.minCapacity!
            }
            if self.switchForce != nil {
                map["SwitchForce"] = self.switchForce!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoPause"] as? Bool {
                self.autoPause = value
            }
            if let value = dict["MaxCapacity"] as? Double {
                self.maxCapacity = value
            }
            if let value = dict["MinCapacity"] as? Double {
                self.minCapacity = value
            }
            if let value = dict["SwitchForce"] as? Bool {
                self.switchForce = value
            }
        }
    }
    public var allowMajorVersionUpgrade: Bool?

    public var autoUseCoupon: Bool?

    public var burstingEnabled: Bool?

    public var category: String?

    public var coldDataEnabled: Bool?

    public var compressionMode: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dedicatedHostGroupId: String?

    public var direction: String?

    public var effectiveTime: String?

    public var engineVersion: String?

    public var ioAccelerationEnabled: String?

    public var optimizedWrites: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var promotionCode: String?

    public var readOnlyDBInstanceClass: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverlessConfiguration: ModifyDBInstanceSpecRequest.ServerlessConfiguration?

    public var sourceBiz: String?

    public var switchTime: String?

    public var targetMinorVersion: String?

    public var usedTime: Int64?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serverlessConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowMajorVersionUpgrade != nil {
            map["AllowMajorVersionUpgrade"] = self.allowMajorVersionUpgrade!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coldDataEnabled != nil {
            map["ColdDataEnabled"] = self.coldDataEnabled!
        }
        if self.compressionMode != nil {
            map["CompressionMode"] = self.compressionMode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.optimizedWrites != nil {
            map["OptimizedWrites"] = self.optimizedWrites!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.readOnlyDBInstanceClass != nil {
            map["ReadOnlyDBInstanceClass"] = self.readOnlyDBInstanceClass!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverlessConfiguration != nil {
            map["ServerlessConfiguration"] = self.serverlessConfiguration?.toMap()
        }
        if self.sourceBiz != nil {
            map["SourceBiz"] = self.sourceBiz!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllowMajorVersionUpgrade"] as? Bool {
            self.allowMajorVersionUpgrade = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ColdDataEnabled"] as? Bool {
            self.coldDataEnabled = value
        }
        if let value = dict["CompressionMode"] as? String {
            self.compressionMode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["OptimizedWrites"] as? String {
            self.optimizedWrites = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["ReadOnlyDBInstanceClass"] as? String {
            self.readOnlyDBInstanceClass = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerlessConfiguration"] as? [String: Any?] {
            var model = ModifyDBInstanceSpecRequest.ServerlessConfiguration()
            model.fromMap(value)
            self.serverlessConfiguration = model
        }
        if let value = dict["SourceBiz"] as? String {
            self.sourceBiz = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["UsedTime"] as? Int64 {
            self.usedTime = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
    }
}

public class ModifyDBInstanceSpecShrinkRequest : Tea.TeaModel {
    public var allowMajorVersionUpgrade: Bool?

    public var autoUseCoupon: Bool?

    public var burstingEnabled: Bool?

    public var category: String?

    public var coldDataEnabled: Bool?

    public var compressionMode: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dedicatedHostGroupId: String?

    public var direction: String?

    public var effectiveTime: String?

    public var engineVersion: String?

    public var ioAccelerationEnabled: String?

    public var optimizedWrites: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var promotionCode: String?

    public var readOnlyDBInstanceClass: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var serverlessConfigurationShrink: String?

    public var sourceBiz: String?

    public var switchTime: String?

    public var targetMinorVersion: String?

    public var usedTime: Int64?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowMajorVersionUpgrade != nil {
            map["AllowMajorVersionUpgrade"] = self.allowMajorVersionUpgrade!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.coldDataEnabled != nil {
            map["ColdDataEnabled"] = self.coldDataEnabled!
        }
        if self.compressionMode != nil {
            map["CompressionMode"] = self.compressionMode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ioAccelerationEnabled != nil {
            map["IoAccelerationEnabled"] = self.ioAccelerationEnabled!
        }
        if self.optimizedWrites != nil {
            map["OptimizedWrites"] = self.optimizedWrites!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.readOnlyDBInstanceClass != nil {
            map["ReadOnlyDBInstanceClass"] = self.readOnlyDBInstanceClass!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serverlessConfigurationShrink != nil {
            map["ServerlessConfiguration"] = self.serverlessConfigurationShrink!
        }
        if self.sourceBiz != nil {
            map["SourceBiz"] = self.sourceBiz!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllowMajorVersionUpgrade"] as? Bool {
            self.allowMajorVersionUpgrade = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BurstingEnabled"] as? Bool {
            self.burstingEnabled = value
        }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["ColdDataEnabled"] as? Bool {
            self.coldDataEnabled = value
        }
        if let value = dict["CompressionMode"] as? String {
            self.compressionMode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["IoAccelerationEnabled"] as? String {
            self.ioAccelerationEnabled = value
        }
        if let value = dict["OptimizedWrites"] as? String {
            self.optimizedWrites = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["ReadOnlyDBInstanceClass"] as? String {
            self.readOnlyDBInstanceClass = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ServerlessConfiguration"] as? String {
            self.serverlessConfigurationShrink = value
        }
        if let value = dict["SourceBiz"] as? String {
            self.sourceBiz = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["UsedTime"] as? Int64 {
            self.usedTime = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
    }
}

public class ModifyDBInstanceSpecResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBInstanceTDERequest : Tea.TeaModel {
    public var certificate: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var encryptionKey: String?

    public var isRotate: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passWord: String?

    public var privateKey: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleArn: String?

    public var TDEStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificate != nil {
            map["Certificate"] = self.certificate!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.encryptionKey != nil {
            map["EncryptionKey"] = self.encryptionKey!
        }
        if self.isRotate != nil {
            map["IsRotate"] = self.isRotate!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passWord != nil {
            map["PassWord"] = self.passWord!
        }
        if self.privateKey != nil {
            map["PrivateKey"] = self.privateKey!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        if self.TDEStatus != nil {
            map["TDEStatus"] = self.TDEStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Certificate"] as? String {
            self.certificate = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["EncryptionKey"] as? String {
            self.encryptionKey = value
        }
        if let value = dict["IsRotate"] as? Bool {
            self.isRotate = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PassWord"] as? String {
            self.passWord = value
        }
        if let value = dict["PrivateKey"] as? String {
            self.privateKey = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RoleArn"] as? String {
            self.roleArn = value
        }
        if let value = dict["TDEStatus"] as? String {
            self.TDEStatus = value
        }
    }
}

public class ModifyDBInstanceTDEResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBInstanceTDEResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBInstanceTDEResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBInstanceTDEResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBNodeRequest : Tea.TeaModel {
    public class DBNode : Tea.TeaModel {
        public var classCode: String?

        public var nodeId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classCode != nil {
                map["classCode"] = self.classCode!
            }
            if self.nodeId != nil {
                map["nodeId"] = self.nodeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["classCode"] as? String {
                self.classCode = value
            }
            if let value = dict["nodeId"] as? String {
                self.nodeId = value
            }
        }
    }
    public var autoPay: Bool?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: String?

    public var DBInstanceStorageType: String?

    public var DBNode: [ModifyDBNodeRequest.DBNode]?

    public var dryRun: Bool?

    public var effectiveTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var produceAsync: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBNode != nil {
            var tmp : [Any] = []
            for k in self.DBNode! {
                tmp.append(k.toMap())
            }
            map["DBNode"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.produceAsync != nil {
            map["ProduceAsync"] = self.produceAsync!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? String {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBNode"] as? [Any?] {
            var tmp : [ModifyDBNodeRequest.DBNode] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBNodeRequest.DBNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBNode = tmp
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProduceAsync"] as? Bool {
            self.produceAsync = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBNodeShrinkRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: String?

    public var DBInstanceStorageType: String?

    public var DBNodeShrink: String?

    public var dryRun: Bool?

    public var effectiveTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var produceAsync: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.DBNodeShrink != nil {
            map["DBNode"] = self.DBNodeShrink!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.produceAsync != nil {
            map["ProduceAsync"] = self.produceAsync!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? String {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DBNode"] as? String {
            self.DBNodeShrink = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProduceAsync"] as? Bool {
            self.produceAsync = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBNodeResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyDBNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBProxyRequest : Tea.TeaModel {
    public class DBProxyNodes : Tea.TeaModel {
        public var cpuCores: String?

        public var nodeCounts: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuCores != nil {
                map["cpuCores"] = self.cpuCores!
            }
            if self.nodeCounts != nil {
                map["nodeCounts"] = self.nodeCounts!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["cpuCores"] as? String {
                self.cpuCores = value
            }
            if let value = dict["nodeCounts"] as? String {
                self.nodeCounts = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var configDBProxyService: String?

    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceNum: String?

    public var DBProxyInstanceType: String?

    public var DBProxyNodes: [ModifyDBProxyRequest.DBProxyNodes]?

    public var instanceNetworkType: String?

    public var ownerId: Int64?

    public var persistentConnectionStatus: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configDBProxyService != nil {
            map["ConfigDBProxyService"] = self.configDBProxyService!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceNum != nil {
            map["DBProxyInstanceNum"] = self.DBProxyInstanceNum!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.DBProxyNodes != nil {
            var tmp : [Any] = []
            for k in self.DBProxyNodes! {
                tmp.append(k.toMap())
            }
            map["DBProxyNodes"] = tmp
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.persistentConnectionStatus != nil {
            map["PersistentConnectionStatus"] = self.persistentConnectionStatus!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigDBProxyService"] as? String {
            self.configDBProxyService = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceNum"] as? String {
            self.DBProxyInstanceNum = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["DBProxyNodes"] as? [Any?] {
            var tmp : [ModifyDBProxyRequest.DBProxyNodes] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBProxyRequest.DBProxyNodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBProxyNodes = tmp
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PersistentConnectionStatus"] as? String {
            self.persistentConnectionStatus = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class ModifyDBProxyShrinkRequest : Tea.TeaModel {
    public var configDBProxyService: String?

    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceNum: String?

    public var DBProxyInstanceType: String?

    public var DBProxyNodesShrink: String?

    public var instanceNetworkType: String?

    public var ownerId: Int64?

    public var persistentConnectionStatus: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configDBProxyService != nil {
            map["ConfigDBProxyService"] = self.configDBProxyService!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceNum != nil {
            map["DBProxyInstanceNum"] = self.DBProxyInstanceNum!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.DBProxyNodesShrink != nil {
            map["DBProxyNodes"] = self.DBProxyNodesShrink!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.persistentConnectionStatus != nil {
            map["PersistentConnectionStatus"] = self.persistentConnectionStatus!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigDBProxyService"] as? String {
            self.configDBProxyService = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceNum"] as? String {
            self.DBProxyInstanceNum = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["DBProxyNodes"] as? String {
            self.DBProxyNodesShrink = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PersistentConnectionStatus"] as? String {
            self.persistentConnectionStatus = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class ModifyDBProxyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBProxyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBProxyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBProxyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBProxyEndpointRequest : Tea.TeaModel {
    public var causalConsistReadTimeout: String?

    public var configDBProxyFeatures: String?

    public var DBInstanceId: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEngineType: String?

    public var dbEndpointAliases: String?

    public var dbEndpointMinSlaveCount: String?

    public var dbEndpointOperator: String?

    public var dbEndpointReadWriteMode: String?

    public var dbEndpointType: String?

    public var effectiveSpecificTime: String?

    public var effectiveTime: String?

    public var ownerId: Int64?

    public var readOnlyInstanceDistributionType: String?

    public var readOnlyInstanceMaxDelayTime: String?

    public var readOnlyInstanceWeight: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.causalConsistReadTimeout != nil {
            map["CausalConsistReadTimeout"] = self.causalConsistReadTimeout!
        }
        if self.configDBProxyFeatures != nil {
            map["ConfigDBProxyFeatures"] = self.configDBProxyFeatures!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.dbEndpointAliases != nil {
            map["DbEndpointAliases"] = self.dbEndpointAliases!
        }
        if self.dbEndpointMinSlaveCount != nil {
            map["DbEndpointMinSlaveCount"] = self.dbEndpointMinSlaveCount!
        }
        if self.dbEndpointOperator != nil {
            map["DbEndpointOperator"] = self.dbEndpointOperator!
        }
        if self.dbEndpointReadWriteMode != nil {
            map["DbEndpointReadWriteMode"] = self.dbEndpointReadWriteMode!
        }
        if self.dbEndpointType != nil {
            map["DbEndpointType"] = self.dbEndpointType!
        }
        if self.effectiveSpecificTime != nil {
            map["EffectiveSpecificTime"] = self.effectiveSpecificTime!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.readOnlyInstanceDistributionType != nil {
            map["ReadOnlyInstanceDistributionType"] = self.readOnlyInstanceDistributionType!
        }
        if self.readOnlyInstanceMaxDelayTime != nil {
            map["ReadOnlyInstanceMaxDelayTime"] = self.readOnlyInstanceMaxDelayTime!
        }
        if self.readOnlyInstanceWeight != nil {
            map["ReadOnlyInstanceWeight"] = self.readOnlyInstanceWeight!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CausalConsistReadTimeout"] as? String {
            self.causalConsistReadTimeout = value
        }
        if let value = dict["ConfigDBProxyFeatures"] as? String {
            self.configDBProxyFeatures = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DbEndpointAliases"] as? String {
            self.dbEndpointAliases = value
        }
        if let value = dict["DbEndpointMinSlaveCount"] as? String {
            self.dbEndpointMinSlaveCount = value
        }
        if let value = dict["DbEndpointOperator"] as? String {
            self.dbEndpointOperator = value
        }
        if let value = dict["DbEndpointReadWriteMode"] as? String {
            self.dbEndpointReadWriteMode = value
        }
        if let value = dict["DbEndpointType"] as? String {
            self.dbEndpointType = value
        }
        if let value = dict["EffectiveSpecificTime"] as? String {
            self.effectiveSpecificTime = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReadOnlyInstanceDistributionType"] as? String {
            self.readOnlyInstanceDistributionType = value
        }
        if let value = dict["ReadOnlyInstanceMaxDelayTime"] as? String {
            self.readOnlyInstanceMaxDelayTime = value
        }
        if let value = dict["ReadOnlyInstanceWeight"] as? String {
            self.readOnlyInstanceWeight = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ModifyDBProxyEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBProxyEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBProxyEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBProxyEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBProxyEndpointAddressRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyConnectStringNetType: String?

    public var DBProxyEndpointId: String?

    public var DBProxyEngineType: String?

    public var DBProxyNewConnectString: String?

    public var DBProxyNewConnectStringPort: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyConnectStringNetType != nil {
            map["DBProxyConnectStringNetType"] = self.DBProxyConnectStringNetType!
        }
        if self.DBProxyEndpointId != nil {
            map["DBProxyEndpointId"] = self.DBProxyEndpointId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyNewConnectString != nil {
            map["DBProxyNewConnectString"] = self.DBProxyNewConnectString!
        }
        if self.DBProxyNewConnectStringPort != nil {
            map["DBProxyNewConnectStringPort"] = self.DBProxyNewConnectStringPort!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyConnectStringNetType"] as? String {
            self.DBProxyConnectStringNetType = value
        }
        if let value = dict["DBProxyEndpointId"] as? String {
            self.DBProxyEndpointId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyNewConnectString"] as? String {
            self.DBProxyNewConnectString = value
        }
        if let value = dict["DBProxyNewConnectStringPort"] as? String {
            self.DBProxyNewConnectStringPort = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBProxyEndpointAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBProxyEndpointAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBProxyEndpointAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBProxyEndpointAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBProxyInstanceRequest : Tea.TeaModel {
    public class DBProxyNodes : Tea.TeaModel {
        public var cpuCores: String?

        public var nodeCounts: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuCores != nil {
                map["cpuCores"] = self.cpuCores!
            }
            if self.nodeCounts != nil {
                map["nodeCounts"] = self.nodeCounts!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["cpuCores"] as? String {
                self.cpuCores = value
            }
            if let value = dict["nodeCounts"] as? String {
                self.nodeCounts = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public class MigrateAZ : Tea.TeaModel {
        public var dbProxyEndpointId: String?

        public var destVSwitchId: String?

        public var destVpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbProxyEndpointId != nil {
                map["dbProxyEndpointId"] = self.dbProxyEndpointId!
            }
            if self.destVSwitchId != nil {
                map["destVSwitchId"] = self.destVSwitchId!
            }
            if self.destVpcId != nil {
                map["destVpcId"] = self.destVpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dbProxyEndpointId"] as? String {
                self.dbProxyEndpointId = value
            }
            if let value = dict["destVSwitchId"] as? String {
                self.destVSwitchId = value
            }
            if let value = dict["destVpcId"] as? String {
                self.destVpcId = value
            }
        }
    }
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceNum: String?

    public var DBProxyInstanceType: String?

    public var DBProxyNodes: [ModifyDBProxyInstanceRequest.DBProxyNodes]?

    public var effectiveSpecificTime: String?

    public var effectiveTime: String?

    public var migrateAZ: [ModifyDBProxyInstanceRequest.MigrateAZ]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceNum != nil {
            map["DBProxyInstanceNum"] = self.DBProxyInstanceNum!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.DBProxyNodes != nil {
            var tmp : [Any] = []
            for k in self.DBProxyNodes! {
                tmp.append(k.toMap())
            }
            map["DBProxyNodes"] = tmp
        }
        if self.effectiveSpecificTime != nil {
            map["EffectiveSpecificTime"] = self.effectiveSpecificTime!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.migrateAZ != nil {
            var tmp : [Any] = []
            for k in self.migrateAZ! {
                tmp.append(k.toMap())
            }
            map["MigrateAZ"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceNum"] as? String {
            self.DBProxyInstanceNum = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["DBProxyNodes"] as? [Any?] {
            var tmp : [ModifyDBProxyInstanceRequest.DBProxyNodes] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBProxyInstanceRequest.DBProxyNodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.DBProxyNodes = tmp
        }
        if let value = dict["EffectiveSpecificTime"] as? String {
            self.effectiveSpecificTime = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["MigrateAZ"] as? [Any?] {
            var tmp : [ModifyDBProxyInstanceRequest.MigrateAZ] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBProxyInstanceRequest.MigrateAZ()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.migrateAZ = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchIds"] as? String {
            self.vSwitchIds = value
        }
    }
}

public class ModifyDBProxyInstanceShrinkRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var DBProxyInstanceNum: String?

    public var DBProxyInstanceType: String?

    public var DBProxyNodesShrink: String?

    public var effectiveSpecificTime: String?

    public var effectiveTime: String?

    public var migrateAZShrink: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.DBProxyInstanceNum != nil {
            map["DBProxyInstanceNum"] = self.DBProxyInstanceNum!
        }
        if self.DBProxyInstanceType != nil {
            map["DBProxyInstanceType"] = self.DBProxyInstanceType!
        }
        if self.DBProxyNodesShrink != nil {
            map["DBProxyNodes"] = self.DBProxyNodesShrink!
        }
        if self.effectiveSpecificTime != nil {
            map["EffectiveSpecificTime"] = self.effectiveSpecificTime!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.migrateAZShrink != nil {
            map["MigrateAZ"] = self.migrateAZShrink!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DBProxyInstanceNum"] as? String {
            self.DBProxyInstanceNum = value
        }
        if let value = dict["DBProxyInstanceType"] as? String {
            self.DBProxyInstanceType = value
        }
        if let value = dict["DBProxyNodes"] as? String {
            self.DBProxyNodesShrink = value
        }
        if let value = dict["EffectiveSpecificTime"] as? String {
            self.effectiveSpecificTime = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["MigrateAZ"] as? String {
            self.migrateAZShrink = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchIds"] as? String {
            self.vSwitchIds = value
        }
    }
}

public class ModifyDBProxyInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBProxyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBProxyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBProxyInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDTCSecurityIpHostsForSQLServerRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityIpHosts: String?

    public var securityToken: String?

    public var whiteListGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityIpHosts != nil {
            map["SecurityIpHosts"] = self.securityIpHosts!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.whiteListGroupName != nil {
            map["WhiteListGroupName"] = self.whiteListGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityIpHosts"] as? String {
            self.securityIpHosts = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["WhiteListGroupName"] as? String {
            self.whiteListGroupName = value
        }
    }
}

public class ModifyDTCSecurityIpHostsForSQLServerResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DTCSetResult: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DTCSetResult != nil {
            map["DTCSetResult"] = self.DTCSetResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DTCSetResult"] as? String {
            self.DTCSetResult = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyDTCSecurityIpHostsForSQLServerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDTCSecurityIpHostsForSQLServerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDTCSecurityIpHostsForSQLServerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDasInstanceConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageAutoScale: String?

    public var storageThreshold: Int32?

    public var storageUpperBound: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageAutoScale != nil {
            map["StorageAutoScale"] = self.storageAutoScale!
        }
        if self.storageThreshold != nil {
            map["StorageThreshold"] = self.storageThreshold!
        }
        if self.storageUpperBound != nil {
            map["StorageUpperBound"] = self.storageUpperBound!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StorageAutoScale"] as? String {
            self.storageAutoScale = value
        }
        if let value = dict["StorageThreshold"] as? Int32 {
            self.storageThreshold = value
        }
        if let value = dict["StorageUpperBound"] as? Int32 {
            self.storageUpperBound = value
        }
    }
}

public class ModifyDasInstanceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDasInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDasInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDasInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDatabaseConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBName: String?

    public var databasePropertyName: String?

    public var databasePropertyValue: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.databasePropertyName != nil {
            map["DatabasePropertyName"] = self.databasePropertyName!
        }
        if self.databasePropertyValue != nil {
            map["DatabasePropertyValue"] = self.databasePropertyValue!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DatabasePropertyName"] as? String {
            self.databasePropertyName = value
        }
        if let value = dict["DatabasePropertyValue"] as? String {
            self.databasePropertyValue = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDatabaseConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDatabaseConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatabaseConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDatabaseConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDbProxyInstanceSslRequest : Tea.TeaModel {
    public var DBProxyEngineType: String?

    public var dbInstanceId: String?

    public var dbProxyConnectString: String?

    public var dbProxyEndpointId: String?

    public var dbProxySslEnabled: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.dbInstanceId != nil {
            map["DbInstanceId"] = self.dbInstanceId!
        }
        if self.dbProxyConnectString != nil {
            map["DbProxyConnectString"] = self.dbProxyConnectString!
        }
        if self.dbProxyEndpointId != nil {
            map["DbProxyEndpointId"] = self.dbProxyEndpointId!
        }
        if self.dbProxySslEnabled != nil {
            map["DbProxySslEnabled"] = self.dbProxySslEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["DbInstanceId"] as? String {
            self.dbInstanceId = value
        }
        if let value = dict["DbProxyConnectString"] as? String {
            self.dbProxyConnectString = value
        }
        if let value = dict["DbProxyEndpointId"] as? String {
            self.dbProxyEndpointId = value
        }
        if let value = dict["DbProxySslEnabled"] as? String {
            self.dbProxySslEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyDbProxyInstanceSslResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDbProxyInstanceSslResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDbProxyInstanceSslResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDbProxyInstanceSslResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEventInfoRequest : Tea.TeaModel {
    public var actionParams: String?

    public var eventAction: String?

    public var eventId: String?

    public var regionId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionParams != nil {
            map["ActionParams"] = self.actionParams!
        }
        if self.eventAction != nil {
            map["EventAction"] = self.eventAction!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionParams"] as? String {
            self.actionParams = value
        }
        if let value = dict["EventAction"] as? String {
            self.eventAction = value
        }
        if let value = dict["EventId"] as? String {
            self.eventId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class ModifyEventInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorEventId: String?

    public var requestId: String?

    public var successCount: Int32?

    public var successEventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorEventId != nil {
            map["ErrorEventId"] = self.errorEventId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.successEventId != nil {
            map["SuccessEventId"] = self.successEventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorEventId"] as? String {
            self.errorEventId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
        if let value = dict["SuccessEventId"] as? String {
            self.successEventId = value
        }
    }
}

public class ModifyEventInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEventInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEventInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHADiagnoseConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tcpConnectionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tcpConnectionType != nil {
            map["TcpConnectionType"] = self.tcpConnectionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TcpConnectionType"] as? String {
            self.tcpConnectionType = value
        }
    }
}

public class ModifyHADiagnoseConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHADiagnoseConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHADiagnoseConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHADiagnoseConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyHASwitchConfigRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var HAConfig: String?

    public var manualHATime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.HAConfig != nil {
            map["HAConfig"] = self.HAConfig!
        }
        if self.manualHATime != nil {
            map["ManualHATime"] = self.manualHATime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["HAConfig"] as? String {
            self.HAConfig = value
        }
        if let value = dict["ManualHATime"] as? String {
            self.manualHATime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyHASwitchConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyHASwitchConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHASwitchConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyHASwitchConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRenewalAttributeRequest : Tea.TeaModel {
    public var autoRenew: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var duration: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Duration"] as? String {
            self.duration = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyInstanceAutoRenewalAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyInstanceAutoRenewalAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRenewalAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceAutoRenewalAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceCrossBackupPolicyRequest : Tea.TeaModel {
    public var backupEnabled: String?

    public var crossBackupRegion: String?

    public var crossBackupType: String?

    public var DBInstanceId: String?

    public var logBackupEnabled: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentType: Int32?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupEnabled != nil {
            map["BackupEnabled"] = self.backupEnabled!
        }
        if self.crossBackupRegion != nil {
            map["CrossBackupRegion"] = self.crossBackupRegion!
        }
        if self.crossBackupType != nil {
            map["CrossBackupType"] = self.crossBackupType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.logBackupEnabled != nil {
            map["LogBackupEnabled"] = self.logBackupEnabled!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentType != nil {
            map["RetentType"] = self.retentType!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupEnabled"] as? String {
            self.backupEnabled = value
        }
        if let value = dict["CrossBackupRegion"] as? String {
            self.crossBackupRegion = value
        }
        if let value = dict["CrossBackupType"] as? String {
            self.crossBackupType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["LogBackupEnabled"] as? String {
            self.logBackupEnabled = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RetentType"] as? Int32 {
            self.retentType = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
    }
}

public class ModifyInstanceCrossBackupPolicyResponseBody : Tea.TeaModel {
    public var backupEnabled: String?

    public var crossBackupRegion: String?

    public var crossBackupType: String?

    public var DBInstanceId: String?

    public var logBackupEnabled: String?

    public var regionId: String?

    public var requestId: String?

    public var retentType: Int32?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupEnabled != nil {
            map["BackupEnabled"] = self.backupEnabled!
        }
        if self.crossBackupRegion != nil {
            map["CrossBackupRegion"] = self.crossBackupRegion!
        }
        if self.crossBackupType != nil {
            map["CrossBackupType"] = self.crossBackupType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.logBackupEnabled != nil {
            map["LogBackupEnabled"] = self.logBackupEnabled!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retentType != nil {
            map["RetentType"] = self.retentType!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupEnabled"] as? String {
            self.backupEnabled = value
        }
        if let value = dict["CrossBackupRegion"] as? String {
            self.crossBackupRegion = value
        }
        if let value = dict["CrossBackupType"] as? String {
            self.crossBackupType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["LogBackupEnabled"] as? String {
            self.logBackupEnabled = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetentType"] as? Int32 {
            self.retentType = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
    }
}

public class ModifyInstanceCrossBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceCrossBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceCrossBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyMaskingRulesRequest : Tea.TeaModel {
    public class RuleConfig : Tea.TeaModel {
        public var columns: [String]?

        public var databases: [String]?

        public var tables: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.databases != nil {
                map["Databases"] = self.databases!
            }
            if self.tables != nil {
                map["Tables"] = self.tables!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["Databases"] as? [String] {
                self.databases = value
            }
            if let value = dict["Tables"] as? [String] {
                self.tables = value
            }
        }
    }
    public var DBInstanceName: String?

    public var DBName: String?

    public var defaultAlgo: String?

    public var enabled: String?

    public var maskingAlgo: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleConfig: ModifyMaskingRulesRequest.RuleConfig?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.defaultAlgo != nil {
            map["DefaultAlgo"] = self.defaultAlgo!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.maskingAlgo != nil {
            map["MaskingAlgo"] = self.maskingAlgo!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleConfig != nil {
            map["RuleConfig"] = self.ruleConfig?.toMap()
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DefaultAlgo"] as? String {
            self.defaultAlgo = value
        }
        if let value = dict["Enabled"] as? String {
            self.enabled = value
        }
        if let value = dict["MaskingAlgo"] as? String {
            self.maskingAlgo = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleConfig"] as? [String: Any?] {
            var model = ModifyMaskingRulesRequest.RuleConfig()
            model.fromMap(value)
            self.ruleConfig = model
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class ModifyMaskingRulesShrinkRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var DBName: String?

    public var defaultAlgo: String?

    public var enabled: String?

    public var maskingAlgo: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var ruleConfigShrink: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.defaultAlgo != nil {
            map["DefaultAlgo"] = self.defaultAlgo!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.maskingAlgo != nil {
            map["MaskingAlgo"] = self.maskingAlgo!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleConfigShrink != nil {
            map["RuleConfig"] = self.ruleConfigShrink!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["DefaultAlgo"] as? String {
            self.defaultAlgo = value
        }
        if let value = dict["Enabled"] as? String {
            self.enabled = value
        }
        if let value = dict["MaskingAlgo"] as? String {
            self.maskingAlgo = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RuleConfig"] as? String {
            self.ruleConfigShrink = value
        }
        if let value = dict["RuleName"] as? String {
            self.ruleName = value
        }
    }
}

public class ModifyMaskingRulesResponseBody : Tea.TeaModel {
    public var data: [String: String]?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: String] {
            self.data = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifyMaskingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMaskingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyMaskingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPGHbaConfigRequest : Tea.TeaModel {
    public class HbaItem : Tea.TeaModel {
        public var address: String?

        public var database: String?

        public var mask: String?

        public var method: String?

        public var option: String?

        public var priorityId: Int32?

        public var type: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.mask != nil {
                map["Mask"] = self.mask!
            }
            if self.method != nil {
                map["Method"] = self.method!
            }
            if self.option != nil {
                map["Option"] = self.option!
            }
            if self.priorityId != nil {
                map["PriorityId"] = self.priorityId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? String {
                self.address = value
            }
            if let value = dict["Database"] as? String {
                self.database = value
            }
            if let value = dict["Mask"] as? String {
                self.mask = value
            }
            if let value = dict["Method"] as? String {
                self.method = value
            }
            if let value = dict["Option"] as? String {
                self.option = value
            }
            if let value = dict["PriorityId"] as? Int32 {
                self.priorityId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var clientToken: String?

    public var DBInstanceId: String?

    public var hbaItem: [ModifyPGHbaConfigRequest.HbaItem]?

    public var opsType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.hbaItem != nil {
            var tmp : [Any] = []
            for k in self.hbaItem! {
                tmp.append(k.toMap())
            }
            map["HbaItem"] = tmp
        }
        if self.opsType != nil {
            map["OpsType"] = self.opsType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["HbaItem"] as? [Any?] {
            var tmp : [ModifyPGHbaConfigRequest.HbaItem] = []
            for v in value {
                if v != nil {
                    var model = ModifyPGHbaConfigRequest.HbaItem()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hbaItem = tmp
        }
        if let value = dict["OpsType"] as? String {
            self.opsType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyPGHbaConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPGHbaConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPGHbaConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPGHbaConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyParameterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var forcerestart: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameterGroupId: String?

    public var parameters: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var switchTimeMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.forcerestart != nil {
            map["Forcerestart"] = self.forcerestart!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.switchTimeMode != nil {
            map["SwitchTimeMode"] = self.switchTimeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["Forcerestart"] as? Bool {
            self.forcerestart = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["SwitchTimeMode"] as? String {
            self.switchTimeMode = value
        }
    }
}

public class ModifyParameterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyParameterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyParameterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyParameterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyParameterGroupRequest : Tea.TeaModel {
    public var modifyMode: String?

    public var ownerId: Int64?

    public var parameterGroupDesc: String?

    public var parameterGroupId: String?

    public var parameterGroupName: String?

    public var parameters: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameterGroupDesc != nil {
            map["ParameterGroupDesc"] = self.parameterGroupDesc!
        }
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.parameterGroupName != nil {
            map["ParameterGroupName"] = self.parameterGroupName!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ModifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ParameterGroupDesc"] as? String {
            self.parameterGroupDesc = value
        }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["ParameterGroupName"] as? String {
            self.parameterGroupName = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyParameterGroupResponseBody : Tea.TeaModel {
    public var parameterGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameterGroupId != nil {
            map["ParameterGroupId"] = self.parameterGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ParameterGroupId"] as? String {
            self.parameterGroupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyParameterGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyParameterGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyParameterGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCDiskSpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var diskCategory: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var performanceLevel: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["DiskCategory"] as? String {
            self.diskCategory = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["PerformanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyRCDiskSpecResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCDiskSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCDiskSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCDiskSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoUseCoupon: Bool?

    public var direction: String?

    public var dryRun: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var promotionCode: String?

    public var rebootTime: String?

    public var rebootWhenFinished: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.rebootTime != nil {
            map["RebootTime"] = self.rebootTime!
        }
        if self.rebootWhenFinished != nil {
            map["RebootWhenFinished"] = self.rebootWhenFinished!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RebootTime"] as? String {
            self.rebootTime = value
        }
        if let value = dict["RebootWhenFinished"] as? Bool {
            self.rebootWhenFinished = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyRCInstanceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceAttributeRequest : Tea.TeaModel {
    public var hostName: String?

    public var instanceId: String?

    public var password: String?

    public var reboot: Bool?

    public var regionId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.reboot != nil {
            map["Reboot"] = self.reboot!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Reboot"] as? Bool {
            self.reboot = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class ModifyRCInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var instanceIds: String?

    public var payType: String?

    public var period: String?

    public var promotionCode: String?

    public var regionId: String?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["IncludeDataDisks"] as? Bool {
            self.includeDataDisks = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
    }
}

public class ModifyRCInstanceChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public var currency: String?

        public var fee: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currency != nil {
                map["Currency"] = self.currency!
            }
            if self.fee != nil {
                map["Fee"] = self.fee!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Currency"] as? String {
                self.currency = value
            }
            if let value = dict["Fee"] as? String {
                self.fee = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
        }
    }
    public var chargeType: String?

    public var expiredTime: [String]?

    public var feeOfInstances: [ModifyRCInstanceChargeTypeResponseBody.FeeOfInstances]?

    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.feeOfInstances != nil {
            var tmp : [Any] = []
            for k in self.feeOfInstances! {
                tmp.append(k.toMap())
            }
            map["FeeOfInstances"] = tmp
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ExpiredTime"] as? [String] {
            self.expiredTime = value
        }
        if let value = dict["FeeOfInstances"] as? [Any?] {
            var tmp : [ModifyRCInstanceChargeTypeResponseBody.FeeOfInstances] = []
            for v in value {
                if v != nil {
                    var model = ModifyRCInstanceChargeTypeResponseBody.FeeOfInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.feeOfInstances = tmp
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceDescriptionRequest : Tea.TeaModel {
    public var instanceDescription: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceDescription"] as? String {
            self.instanceDescription = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyRCInstanceDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceKeyPairRequest : Tea.TeaModel {
    public var instanceId: String?

    public var keyPairName: String?

    public var reboot: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.reboot != nil {
            map["Reboot"] = self.reboot!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["Reboot"] as? Bool {
            self.reboot = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyRCInstanceKeyPairResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCInstanceNetworkSpecRequest : Tea.TeaModel {
    public var instanceId: String?

    public var internetMaxBandwidthOut: String?

    public var networkChargeType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkChargeType != nil {
            map["NetworkChargeType"] = self.networkChargeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? String {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["NetworkChargeType"] as? String {
            self.networkChargeType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyRCInstanceNetworkSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCInstanceNetworkSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCInstanceNetworkSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCInstanceNetworkSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyRCSecurityGroupPermissionRequest : Tea.TeaModel {
    public var destCidrIp: String?

    public var direction: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestCidrIp"] as? String {
            self.destCidrIp = value
        }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["IpProtocol"] as? String {
            self.ipProtocol = value
        }
        if let value = dict["Policy"] as? String {
            self.policy = value
        }
        if let value = dict["PortRange"] as? String {
            self.portRange = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleId"] as? String {
            self.securityGroupRuleId = value
        }
        if let value = dict["SourceCidrIp"] as? String {
            self.sourceCidrIp = value
        }
        if let value = dict["SourcePortRange"] as? String {
            self.sourcePortRange = value
        }
    }
}

public class ModifyRCSecurityGroupPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyRCSecurityGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRCSecurityGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyRCSecurityGroupPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyReadWriteSplittingConnectionRequest : Tea.TeaModel {
    public var connectionStringPrefix: String?

    public var DBInstanceId: String?

    public var distributionType: String?

    public var maxDelayTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var weight: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.distributionType != nil {
            map["DistributionType"] = self.distributionType!
        }
        if self.maxDelayTime != nil {
            map["MaxDelayTime"] = self.maxDelayTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DistributionType"] as? String {
            self.distributionType = value
        }
        if let value = dict["MaxDelayTime"] as? String {
            self.maxDelayTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Weight"] as? String {
            self.weight = value
        }
    }
}

public class ModifyReadWriteSplittingConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyReadWriteSplittingConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReadWriteSplittingConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyReadWriteSplittingConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyReadonlyInstanceDelayReplicationTimeRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var readSQLReplicationTime: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.readSQLReplicationTime != nil {
            map["ReadSQLReplicationTime"] = self.readSQLReplicationTime!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ReadSQLReplicationTime"] as? String {
            self.readSQLReplicationTime = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyReadonlyInstanceDelayReplicationTimeResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var readSQLReplicationTime: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.readSQLReplicationTime != nil {
            map["ReadSQLReplicationTime"] = self.readSQLReplicationTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ReadSQLReplicationTime"] as? String {
            self.readSQLReplicationTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyReadonlyInstanceDelayReplicationTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReadonlyInstanceDelayReplicationTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyReadonlyInstanceDelayReplicationTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyResourceGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ModifyResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySQLCollectorPolicyRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var SQLCollectorStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.SQLCollectorStatus != nil {
            map["SQLCollectorStatus"] = self.SQLCollectorStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SQLCollectorStatus"] as? String {
            self.SQLCollectorStatus = value
        }
    }
}

public class ModifySQLCollectorPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySQLCollectorPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySQLCollectorPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySQLCollectorPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySQLCollectorRetentionRequest : Tea.TeaModel {
    public var configValue: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigValue"] as? String {
            self.configValue = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class ModifySQLCollectorRetentionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySQLCollectorRetentionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySQLCollectorRetentionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySQLCollectorRetentionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityGroupConfigurationRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class ModifySecurityGroupConfigurationResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class EcsSecurityGroupRelation : Tea.TeaModel {
            public var networkType: String?

            public var regionId: String?

            public var securityGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NetworkType"] as? String {
                    self.networkType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecurityGroupId"] as? String {
                    self.securityGroupId = value
                }
            }
        }
        public var ecsSecurityGroupRelation: [ModifySecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsSecurityGroupRelation != nil {
                var tmp : [Any] = []
                for k in self.ecsSecurityGroupRelation! {
                    tmp.append(k.toMap())
                }
                map["EcsSecurityGroupRelation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EcsSecurityGroupRelation"] as? [Any?] {
                var tmp : [ModifySecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation] = []
                for v in value {
                    if v != nil {
                        var model = ModifySecurityGroupConfigurationResponseBody.Items.EcsSecurityGroupRelation()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ecsSecurityGroupRelation = tmp
            }
        }
    }
    public var DBInstanceName: String?

    public var items: ModifySecurityGroupConfigurationResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = ModifySecurityGroupConfigurationResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifySecurityGroupConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityGroupConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifySecurityIpsRequest : Tea.TeaModel {
    public var DBInstanceIPArrayAttribute: String?

    public var DBInstanceIPArrayName: String?

    public var DBInstanceId: String?

    public var freshWhiteListReadins: String?

    public var modifyMode: String?

    public var resourceOwnerId: Int64?

    public var securityIPType: String?

    public var securityIps: String?

    public var whitelistNetworkType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceIPArrayAttribute != nil {
            map["DBInstanceIPArrayAttribute"] = self.DBInstanceIPArrayAttribute!
        }
        if self.DBInstanceIPArrayName != nil {
            map["DBInstanceIPArrayName"] = self.DBInstanceIPArrayName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.freshWhiteListReadins != nil {
            map["FreshWhiteListReadins"] = self.freshWhiteListReadins!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityIPType != nil {
            map["SecurityIPType"] = self.securityIPType!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        if self.whitelistNetworkType != nil {
            map["WhitelistNetworkType"] = self.whitelistNetworkType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceIPArrayAttribute"] as? String {
            self.DBInstanceIPArrayAttribute = value
        }
        if let value = dict["DBInstanceIPArrayName"] as? String {
            self.DBInstanceIPArrayName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["FreshWhiteListReadins"] as? String {
            self.freshWhiteListReadins = value
        }
        if let value = dict["ModifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityIPType"] as? String {
            self.securityIPType = value
        }
        if let value = dict["SecurityIps"] as? String {
            self.securityIps = value
        }
        if let value = dict["WhitelistNetworkType"] as? String {
            self.whitelistNetworkType = value
        }
    }
}

public class ModifySecurityIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifySecurityIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifySecurityIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyTaskInfoRequest : Tea.TeaModel {
    public var actionParams: String?

    public var regionId: String?

    public var resourceOwnerAccount: Int64?

    public var resourceOwnerId: Int64?

    public var securityToken: String?

    public var stepName: String?

    public var taskAction: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionParams != nil {
            map["ActionParams"] = self.actionParams!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stepName != nil {
            map["StepName"] = self.stepName!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ActionParams"] as? String {
            self.actionParams = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? Int64 {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StepName"] as? String {
            self.stepName = value
        }
        if let value = dict["TaskAction"] as? String {
            self.taskAction = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ModifyTaskInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorTaskId: String?

    public var requestId: String?

    public var successCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorTaskId != nil {
            map["ErrorTaskId"] = self.errorTaskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["ErrorTaskId"] as? String {
            self.errorTaskId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessCount"] as? String {
            self.successCount = value
        }
    }
}

public class ModifyTaskInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTaskInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyTaskInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyWhitelistTemplateRequest : Tea.TeaModel {
    public var ipWhitelist: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: Int32?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipWhitelist != nil {
            map["IpWhitelist"] = self.ipWhitelist!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IpWhitelist"] as? String {
            self.ipWhitelist = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TemplateId"] as? Int32 {
            self.templateId = value
        }
        if let value = dict["TemplateName"] as? String {
            self.templateName = value
        }
    }
}

public class ModifyWhitelistTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: ModifyWhitelistTemplateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ModifyWhitelistTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyWhitelistTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWhitelistTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyWhitelistTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PreCheckCreateOrderForDeleteDBNodesRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var DBNodeId: [String]?

    public var engineVersion: String?

    public var nodeType: String?

    public var ownerId: Int64?

    public var promotionCode: String?

    public var regionId: String?

    public var resource: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeId != nil {
            map["DBNodeId"] = self.DBNodeId!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? [String] {
            self.DBNodeId = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? String {
            self.resource = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class PreCheckCreateOrderForDeleteDBNodesShrinkRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var DBInstanceId: String?

    public var DBNodeIdShrink: String?

    public var engineVersion: String?

    public var nodeType: String?

    public var ownerId: Int64?

    public var promotionCode: String?

    public var regionId: String?

    public var resource: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNodeIdShrink != nil {
            map["DBNodeId"] = self.DBNodeIdShrink!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNodeId"] as? String {
            self.DBNodeIdShrink = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? String {
            self.resource = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class PreCheckCreateOrderForDeleteDBNodesResponseBody : Tea.TeaModel {
    public class Failures : Tea.TeaModel {
        public class Failures : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
            }
        }
        public var failures: [PreCheckCreateOrderForDeleteDBNodesResponseBody.Failures.Failures]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failures != nil {
                var tmp : [Any] = []
                for k in self.failures! {
                    tmp.append(k.toMap())
                }
                map["Failures"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Failures"] as? [Any?] {
                var tmp : [PreCheckCreateOrderForDeleteDBNodesResponseBody.Failures.Failures] = []
                for v in value {
                    if v != nil {
                        var model = PreCheckCreateOrderForDeleteDBNodesResponseBody.Failures.Failures()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.failures = tmp
            }
        }
    }
    public var failures: PreCheckCreateOrderForDeleteDBNodesResponseBody.Failures?

    public var preCheckResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failures?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failures != nil {
            map["Failures"] = self.failures?.toMap()
        }
        if self.preCheckResult != nil {
            map["PreCheckResult"] = self.preCheckResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Failures"] as? [String: Any?] {
            var model = PreCheckCreateOrderForDeleteDBNodesResponseBody.Failures()
            model.fromMap(value)
            self.failures = model
        }
        if let value = dict["PreCheckResult"] as? Bool {
            self.preCheckResult = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PreCheckCreateOrderForDeleteDBNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreCheckCreateOrderForDeleteDBNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PreCheckCreateOrderForDeleteDBNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PurgeDBInstanceLogRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class PurgeDBInstanceLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PurgeDBInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurgeDBInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PurgeDBInstanceLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryNotifyRequest : Tea.TeaModel {
    public var from: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var to: String?

    public var withConfirmed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        if self.withConfirmed != nil {
            map["WithConfirmed"] = self.withConfirmed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["From"] as? String {
            self.from = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["To"] as? String {
            self.to = value
        }
        if let value = dict["WithConfirmed"] as? Bool {
            self.withConfirmed = value
        }
    }
}

public class QueryNotifyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class NotifyItemList : Tea.TeaModel {
            public var aliUid: Int64?

            public var confirmFlag: Bool?

            public var confirmor: Int64?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var id: Int64?

            public var idempotentCount: String?

            public var idempotentId: String?

            public var level: String?

            public var notifyElement: String?

            public var templateName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliUid != nil {
                    map["AliUid"] = self.aliUid!
                }
                if self.confirmFlag != nil {
                    map["ConfirmFlag"] = self.confirmFlag!
                }
                if self.confirmor != nil {
                    map["Confirmor"] = self.confirmor!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idempotentCount != nil {
                    map["IdempotentCount"] = self.idempotentCount!
                }
                if self.idempotentId != nil {
                    map["IdempotentId"] = self.idempotentId!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.notifyElement != nil {
                    map["NotifyElement"] = self.notifyElement!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliUid"] as? Int64 {
                    self.aliUid = value
                }
                if let value = dict["ConfirmFlag"] as? Bool {
                    self.confirmFlag = value
                }
                if let value = dict["Confirmor"] as? Int64 {
                    self.confirmor = value
                }
                if let value = dict["GmtCreated"] as? String {
                    self.gmtCreated = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["IdempotentCount"] as? String {
                    self.idempotentCount = value
                }
                if let value = dict["IdempotentId"] as? String {
                    self.idempotentId = value
                }
                if let value = dict["Level"] as? String {
                    self.level = value
                }
                if let value = dict["NotifyElement"] as? String {
                    self.notifyElement = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var notifyItemList: [QueryNotifyResponseBody.Data.NotifyItemList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalRecordCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.notifyItemList != nil {
                var tmp : [Any] = []
                for k in self.notifyItemList! {
                    tmp.append(k.toMap())
                }
                map["NotifyItemList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalRecordCount != nil {
                map["TotalRecordCount"] = self.totalRecordCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NotifyItemList"] as? [Any?] {
                var tmp : [QueryNotifyResponseBody.Data.NotifyItemList] = []
                for v in value {
                    if v != nil {
                        var model = QueryNotifyResponseBody.Data.NotifyItemList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notifyItemList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalRecordCount"] as? Int32 {
                self.totalRecordCount = value
            }
        }
    }
    public var data: QueryNotifyResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = QueryNotifyResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QueryNotifyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryNotifyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryNotifyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRecommendByCodeRequest : Tea.TeaModel {
    public var code: String?

    public var ownerId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class QueryRecommendByCodeResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class QueryRecommendByCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRecommendByCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRecommendByCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebootRCInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var forceStop: Bool?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class RebootRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RebootRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebootRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebootRCInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var forceReboot: Bool?

    public var instanceIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.forceReboot != nil {
            map["ForceReboot"] = self.forceReboot!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["ForceReboot"] as? Bool {
            self.forceReboot = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class RebootRCInstancesShrinkRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var forceReboot: Bool?

    public var instanceIdsShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.forceReboot != nil {
            map["ForceReboot"] = self.forceReboot!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["ForceReboot"] as? Bool {
            self.forceReboot = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class RebootRCInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RebootRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebootRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebuildDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var dedicatedHostGroupId: String?

    public var dedicatedHostId: String?

    public var ownerId: Int64?

    public var rebuildNodeType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.rebuildNodeType != nil {
            map["RebuildNodeType"] = self.rebuildNodeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["DedicatedHostId"] as? String {
            self.dedicatedHostId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RebuildNodeType"] as? String {
            self.rebuildNodeType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RebuildDBInstanceResponseBody : Tea.TeaModel {
    public var migrationId: Int32?

    public var requestId: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int32 {
            self.migrationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class RebuildDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebuildDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebuildDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RebuildReplicationLinkRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
    }
}

public class RebuildReplicationLinkResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class RebuildReplicationLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebuildReplicationLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RebuildReplicationLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReceiveDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var guardDBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.guardDBInstanceId != nil {
            map["GuardDBInstanceId"] = self.guardDBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["GuardDBInstanceId"] as? String {
            self.guardDBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReceiveDBInstanceResponseBody : Tea.TeaModel {
    public var guardDBInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.guardDBInstanceId != nil {
            map["GuardDBInstanceId"] = self.guardDBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GuardDBInstanceId"] as? String {
            self.guardDBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReceiveDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReceiveDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReceiveDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecoveryDBInstanceRequest : Tea.TeaModel {
    public var backupId: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var dbNames: String?

    public var instanceNetworkType: String?

    public var payType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var targetDBInstanceId: String?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.targetDBInstanceId != nil {
            map["TargetDBInstanceId"] = self.targetDBInstanceId!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["DbNames"] as? String {
            self.dbNames = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["TargetDBInstanceId"] as? String {
            self.targetDBInstanceId = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class RecoveryDBInstanceResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecoveryDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoveryDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecoveryDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseInstanceConnectionRequest : Tea.TeaModel {
    public var currentConnectionString: String?

    public var DBInstanceId: String?

    public var instanceNetworkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentConnectionString != nil {
            map["CurrentConnectionString"] = self.currentConnectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentConnectionString"] as? String {
            self.currentConnectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseInstanceConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseInstanceConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseInstanceConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseInstanceConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseInstancePublicConnectionRequest : Tea.TeaModel {
    public var currentConnectionString: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentConnectionString != nil {
            map["CurrentConnectionString"] = self.currentConnectionString!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentConnectionString"] as? String {
            self.currentConnectionString = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseInstancePublicConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseInstancePublicConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseInstancePublicConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseInstancePublicConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseReadWriteSplittingConnectionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ReleaseReadWriteSplittingConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseReadWriteSplittingConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseReadWriteSplittingConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseReadWriteSplittingConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveTagsFromResourceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var tag: [RemoveTagsFromResourceRequest.Tag]?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var proxyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RemoveTagsFromResourceRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RemoveTagsFromResourceRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["proxyId"] as? String {
            self.proxyId = value
        }
    }
}

public class RemoveTagsFromResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveTagsFromResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTagsFromResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveTagsFromResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var autoPay: String?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var promotionCode: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? String {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewRCInstanceRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var commodityCode: String?

    public var instanceId: String?

    public var ownerId: Int64?

    public var payType: String?

    public var periodAlign: Bool?

    public var promotionCode: String?

    public var regionId: String?

    public var resource: String?

    public var resourceOwnerAccount: String?

    public var timeType: String?

    public var usedTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.periodAlign != nil {
            map["PeriodAlign"] = self.periodAlign!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.timeType != nil {
            map["TimeType"] = self.timeType!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CommodityCode"] as? String {
            self.commodityCode = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["PeriodAlign"] as? Bool {
            self.periodAlign = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Resource"] as? String {
            self.resource = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["TimeType"] as? String {
            self.timeType = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
    }
}

public class RenewRCInstanceResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: String?

    public var orderIds: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.orderIds != nil {
            map["OrderIds"] = self.orderIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["OrderIds"] as? String {
            self.orderIds = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RenewRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReplaceRCInstanceSystemDiskRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceId: String?

    public var isLocalDisk: Bool?

    public var keyPairName: String?

    public var password: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isLocalDisk != nil {
            map["IsLocalDisk"] = self.isLocalDisk!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["IsLocalDisk"] as? Bool {
            self.isLocalDisk = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ReplaceRCInstanceSystemDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReplaceRCInstanceSystemDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceRCInstanceSystemDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReplaceRCInstanceSystemDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ResetAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetAccountPasswordRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ResetAccountPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetAccountPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAccountPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetAccountPasswordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResizeRCInstanceDiskRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var diskId: String?

    public var dryRun: Bool?

    public var instanceId: String?

    public var newSize: Int64?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.newSize != nil {
            map["NewSize"] = self.newSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["DiskId"] as? String {
            self.diskId = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NewSize"] as? Int64 {
            self.newSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ResizeRCInstanceDiskResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResizeRCInstanceDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeRCInstanceDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResizeRCInstanceDiskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartDBInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var nodeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RestartDBInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestartDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestoreDdrTableRequest : Tea.TeaModel {
    public var backupId: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var restoreType: String?

    public var sourceDBInstanceName: String?

    public var sourceRegion: String?

    public var tableMeta: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.restoreType != nil {
            map["RestoreType"] = self.restoreType!
        }
        if self.sourceDBInstanceName != nil {
            map["SourceDBInstanceName"] = self.sourceDBInstanceName!
        }
        if self.sourceRegion != nil {
            map["SourceRegion"] = self.sourceRegion!
        }
        if self.tableMeta != nil {
            map["TableMeta"] = self.tableMeta!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["RestoreType"] as? String {
            self.restoreType = value
        }
        if let value = dict["SourceDBInstanceName"] as? String {
            self.sourceDBInstanceName = value
        }
        if let value = dict["SourceRegion"] as? String {
            self.sourceRegion = value
        }
        if let value = dict["TableMeta"] as? String {
            self.tableMeta = value
        }
    }
}

public class RestoreDdrTableResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestoreDdrTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreDdrTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestoreDdrTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestoreTableRequest : Tea.TeaModel {
    public var backupId: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var instantRecovery: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var restoreTime: String?

    public var tableMeta: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.instantRecovery != nil {
            map["InstantRecovery"] = self.instantRecovery!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.restoreTime != nil {
            map["RestoreTime"] = self.restoreTime!
        }
        if self.tableMeta != nil {
            map["TableMeta"] = self.tableMeta!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["InstantRecovery"] as? Bool {
            self.instantRecovery = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["RestoreTime"] as? String {
            self.restoreTime = value
        }
        if let value = dict["TableMeta"] as? String {
            self.tableMeta = value
        }
    }
}

public class RestoreTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestoreTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestoreTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeAccountPrivilegeRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBInstanceId: String?

    public var DBName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RevokeAccountPrivilegeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeAccountPrivilegeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeAccountPrivilegeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeAccountPrivilegeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeOperatorPermissionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RevokeOperatorPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeOperatorPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeOperatorPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeOperatorPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeRCSecurityGroupPermissionRequest : Tea.TeaModel {
    public var direction: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupRuleIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleIdList != nil {
            map["SecurityGroupRuleIdList"] = self.securityGroupRuleIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleIdList"] as? [String] {
            self.securityGroupRuleIdList = value
        }
    }
}

public class RevokeRCSecurityGroupPermissionShrinkRequest : Tea.TeaModel {
    public var direction: String?

    public var regionId: String?

    public var securityGroupId: String?

    public var securityGroupRuleIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleIdListShrink != nil {
            map["SecurityGroupRuleIdList"] = self.securityGroupRuleIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SecurityGroupRuleIdList"] as? String {
            self.securityGroupRuleIdListShrink = value
        }
    }
}

public class RevokeRCSecurityGroupPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeRCSecurityGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeRCSecurityGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeRCSecurityGroupPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunRCInstancesRequest : Tea.TeaModel {
    public class CreateAckEdgeParam : Tea.TeaModel {
        public var clusterId: String?

        public var nodePoolId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.nodePoolId != nil {
                map["NodePoolId"] = self.nodePoolId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["NodePoolId"] as? String {
                self.nodePoolId = value
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var deleteWithInstance: Bool?

        public var device: String?

        public var encrypted: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["DeleteWithInstance"] as? Bool {
                self.deleteWithInstance = value
            }
            if let value = dict["Device"] as? String {
                self.device = value
            }
            if let value = dict["Encrypted"] as? String {
                self.encrypted = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
            if let value = dict["SnapshotId"] as? String {
                self.snapshotId = value
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["PerformanceLevel"] as? String {
                self.performanceLevel = value
            }
            if let value = dict["Size"] as? Int32 {
                self.size = value
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoUseCoupon: Bool?

    public var clientToken: String?

    public var createAckEdgeParam: RunRCInstancesRequest.CreateAckEdgeParam?

    public var createExtraParam: String?

    public var createMode: String?

    public var dataDisk: [RunRCInstancesRequest.DataDisk]?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var password: String?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotStrategy: String?

    public var supportCase: String?

    public var systemDisk: RunRCInstancesRequest.SystemDisk?

    public var tag: [RunRCInstancesRequest.Tag]?

    public var userData: String?

    public var userDataInBase64: Bool?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createAckEdgeParam?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.createAckEdgeParam != nil {
            map["CreateAckEdgeParam"] = self.createAckEdgeParam?.toMap()
        }
        if self.createExtraParam != nil {
            map["CreateExtraParam"] = self.createExtraParam!
        }
        if self.createMode != nil {
            map["CreateMode"] = self.createMode!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.supportCase != nil {
            map["SupportCase"] = self.supportCase!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userDataInBase64 != nil {
            map["UserDataInBase64"] = self.userDataInBase64!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CreateAckEdgeParam"] as? [String: Any?] {
            var model = RunRCInstancesRequest.CreateAckEdgeParam()
            model.fromMap(value)
            self.createAckEdgeParam = model
        }
        if let value = dict["CreateExtraParam"] as? String {
            self.createExtraParam = value
        }
        if let value = dict["CreateMode"] as? String {
            self.createMode = value
        }
        if let value = dict["DataDisk"] as? [Any?] {
            var tmp : [RunRCInstancesRequest.DataDisk] = []
            for v in value {
                if v != nil {
                    var model = RunRCInstancesRequest.DataDisk()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataDisk = tmp
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SupportCase"] as? String {
            self.supportCase = value
        }
        if let value = dict["SystemDisk"] as? [String: Any?] {
            var model = RunRCInstancesRequest.SystemDisk()
            model.fromMap(value)
            self.systemDisk = model
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RunRCInstancesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RunRCInstancesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["UserDataInBase64"] as? Bool {
            self.userDataInBase64 = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class RunRCInstancesShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var amount: Int32?

    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoUseCoupon: Bool?

    public var clientToken: String?

    public var createAckEdgeParamShrink: String?

    public var createExtraParam: String?

    public var createMode: String?

    public var dataDiskShrink: String?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var password: String?

    public var period: Int32?

    public var periodUnit: String?

    public var promotionCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotStrategy: String?

    public var supportCase: String?

    public var systemDiskShrink: String?

    public var tag: [RunRCInstancesShrinkRequest.Tag]?

    public var userData: String?

    public var userDataInBase64: Bool?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.createAckEdgeParamShrink != nil {
            map["CreateAckEdgeParam"] = self.createAckEdgeParamShrink!
        }
        if self.createExtraParam != nil {
            map["CreateExtraParam"] = self.createExtraParam!
        }
        if self.createMode != nil {
            map["CreateMode"] = self.createMode!
        }
        if self.dataDiskShrink != nil {
            map["DataDisk"] = self.dataDiskShrink!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.supportCase != nil {
            map["SupportCase"] = self.supportCase!
        }
        if self.systemDiskShrink != nil {
            map["SystemDisk"] = self.systemDiskShrink!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.userDataInBase64 != nil {
            map["UserDataInBase64"] = self.userDataInBase64!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Amount"] as? Int32 {
            self.amount = value
        }
        if let value = dict["AutoPay"] as? Bool {
            self.autoPay = value
        }
        if let value = dict["AutoRenew"] as? Bool {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CreateAckEdgeParam"] as? String {
            self.createAckEdgeParamShrink = value
        }
        if let value = dict["CreateExtraParam"] as? String {
            self.createExtraParam = value
        }
        if let value = dict["CreateMode"] as? String {
            self.createMode = value
        }
        if let value = dict["DataDisk"] as? String {
            self.dataDiskShrink = value
        }
        if let value = dict["DeploymentSetId"] as? String {
            self.deploymentSetId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["HostName"] as? String {
            self.hostName = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["InstanceChargeType"] as? String {
            self.instanceChargeType = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["InstanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["InternetChargeType"] as? String {
            self.internetChargeType = value
        }
        if let value = dict["InternetMaxBandwidthOut"] as? Int32 {
            self.internetMaxBandwidthOut = value
        }
        if let value = dict["IoOptimized"] as? String {
            self.ioOptimized = value
        }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["Period"] as? Int32 {
            self.period = value
        }
        if let value = dict["PeriodUnit"] as? String {
            self.periodUnit = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityEnhancementStrategy"] as? String {
            self.securityEnhancementStrategy = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["SpotStrategy"] as? String {
            self.spotStrategy = value
        }
        if let value = dict["SupportCase"] as? String {
            self.supportCase = value
        }
        if let value = dict["SystemDisk"] as? String {
            self.systemDiskShrink = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [RunRCInstancesShrinkRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = RunRCInstancesShrinkRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
        if let value = dict["UserDataInBase64"] as? Bool {
            self.userDataInBase64 = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class RunRCInstancesResponseBody : Tea.TeaModel {
    public class InstanceIdSets : Tea.TeaModel {
        public var instanceIdSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                map["InstanceIdSet"] = self.instanceIdSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceIdSet"] as? [String] {
                self.instanceIdSet = value
            }
        }
    }
    public var instanceIdSets: RunRCInstancesResponseBody.InstanceIdSets?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdSets != nil {
            map["InstanceIdSets"] = self.instanceIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIdSets"] as? [String: Any?] {
            var model = RunRCInstancesResponseBody.InstanceIdSets()
            model.fromMap(value)
            self.instanceIdSets = model
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RunRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBInstanceTransType: Int32?

    public var dedicatedHostGroupId: String?

    public var effectiveTime: String?

    public var engineVersion: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var specifiedTime: String?

    public var storage: Int32?

    public var targetDBInstanceClass: String?

    public var targetDedicatedHostIdForLog: String?

    public var targetDedicatedHostIdForMaster: String?

    public var targetDedicatedHostIdForSlave: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceTransType != nil {
            map["DBInstanceTransType"] = self.DBInstanceTransType!
        }
        if self.dedicatedHostGroupId != nil {
            map["DedicatedHostGroupId"] = self.dedicatedHostGroupId!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.specifiedTime != nil {
            map["SpecifiedTime"] = self.specifiedTime!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        if self.targetDBInstanceClass != nil {
            map["TargetDBInstanceClass"] = self.targetDBInstanceClass!
        }
        if self.targetDedicatedHostIdForLog != nil {
            map["TargetDedicatedHostIdForLog"] = self.targetDedicatedHostIdForLog!
        }
        if self.targetDedicatedHostIdForMaster != nil {
            map["TargetDedicatedHostIdForMaster"] = self.targetDedicatedHostIdForMaster!
        }
        if self.targetDedicatedHostIdForSlave != nil {
            map["TargetDedicatedHostIdForSlave"] = self.targetDedicatedHostIdForSlave!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceTransType"] as? Int32 {
            self.DBInstanceTransType = value
        }
        if let value = dict["DedicatedHostGroupId"] as? String {
            self.dedicatedHostGroupId = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SpecifiedTime"] as? String {
            self.specifiedTime = value
        }
        if let value = dict["Storage"] as? Int32 {
            self.storage = value
        }
        if let value = dict["TargetDBInstanceClass"] as? String {
            self.targetDBInstanceClass = value
        }
        if let value = dict["TargetDedicatedHostIdForLog"] as? String {
            self.targetDedicatedHostIdForLog = value
        }
        if let value = dict["TargetDedicatedHostIdForMaster"] as? String {
            self.targetDedicatedHostIdForMaster = value
        }
        if let value = dict["TargetDedicatedHostIdForSlave"] as? String {
            self.targetDedicatedHostIdForSlave = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class StartDBInstanceResponseBody : Tea.TeaModel {
    public var migrationId: Int32?

    public var requestId: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationId != nil {
            map["MigrationId"] = self.migrationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationId"] as? Int32 {
            self.migrationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class StartDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartRCInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartRCInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var instanceIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartRCInstancesShrinkRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var instanceIdsShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartRCInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopDBInstanceRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class StopDBInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopDBInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDBInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopDBInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopRCInstanceRequest : Tea.TeaModel {
    public var forceStop: Bool?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopRCInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var forceStop: Bool?

    public var instanceIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopRCInstancesShrinkRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var forceStop: Bool?

    public var instanceIdsShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BatchOptimization"] as? String {
            self.batchOptimization = value
        }
        if let value = dict["ForceStop"] as? Bool {
            self.forceStop = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopRCInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopRCInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopRCInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopRCInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchDBInstanceHARequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var effectiveTime: String?

    public var force: String?

    public var nodeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["Force"] as? String {
            self.force = value
        }
        if let value = dict["NodeId"] as? String {
            self.nodeId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class SwitchDBInstanceHAResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchDBInstanceHAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDBInstanceHAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchDBInstanceHAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchDBInstanceNetTypeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectionStringPrefix: String?

    public var connectionStringType: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var port: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.connectionStringType != nil {
            map["ConnectionStringType"] = self.connectionStringType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["ConnectionStringType"] as? String {
            self.connectionStringType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Port"] as? String {
            self.port = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class SwitchDBInstanceNetTypeResponseBody : Tea.TeaModel {
    public var newConnectionString: String?

    public var oldConnectionString: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newConnectionString != nil {
            map["NewConnectionString"] = self.newConnectionString!
        }
        if self.oldConnectionString != nil {
            map["OldConnectionString"] = self.oldConnectionString!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NewConnectionString"] as? String {
            self.newConnectionString = value
        }
        if let value = dict["OldConnectionString"] as? String {
            self.oldConnectionString = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchDBInstanceNetTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDBInstanceNetTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchDBInstanceNetTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchDBInstanceVpcRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var privateIpAddress: String?

    public var resourceOwnerId: Int64?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class SwitchDBInstanceVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchDBInstanceVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchDBInstanceVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchDBInstanceVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchOverMajorVersionUpgradeRequest : Tea.TeaModel {
    public var DBInstanceName: String?

    public var ownerId: Int64?

    public var regionId: [UInt8]?

    public var switchoverTimeout: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.switchoverTimeout != nil {
            map["SwitchoverTimeout"] = self.switchoverTimeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? [UInt8] {
            self.regionId = value
        }
        if let value = dict["SwitchoverTimeout"] as? Int32 {
            self.switchoverTimeout = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class SwitchOverMajorVersionUpgradeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SwitchOverMajorVersionUpgradeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchOverMajorVersionUpgradeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchOverMajorVersionUpgradeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SwitchReplicationLinkRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var targetInstanceName: String?

    public var targetInstanceRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.targetInstanceName != nil {
            map["TargetInstanceName"] = self.targetInstanceName!
        }
        if self.targetInstanceRegionId != nil {
            map["TargetInstanceRegionId"] = self.targetInstanceRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["TargetInstanceName"] as? String {
            self.targetInstanceName = value
        }
        if let value = dict["TargetInstanceRegionId"] as? String {
            self.targetInstanceRegionId = value
        }
    }
}

public class SwitchReplicationLinkResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var requestId: String?

    public var taskId: Int64?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class SwitchReplicationLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchReplicationLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SwitchReplicationLinkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SyncRCKeyPairRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var regionId: String?

    public var syncMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.syncMode != nil {
            map["SyncMode"] = self.syncMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["KeyPairName"] as? String {
            self.keyPairName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SyncMode"] as? Bool {
            self.syncMode = value
        }
    }
}

public class SyncRCKeyPairResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var isSyncInfo: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isSyncInfo != nil {
                map["IsSyncInfo"] = self.isSyncInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IsSyncInfo"] as? Bool {
                self.isSyncInfo = value
            }
        }
    }
    public var data: SyncRCKeyPairResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SyncRCKeyPairResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SyncRCKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncRCKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SyncRCKeyPairResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SyncRCSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class SyncRCSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SyncRCSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncRCSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SyncRCSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TerminateMigrateTaskRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var migrateTaskId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.migrateTaskId != nil {
            map["MigrateTaskId"] = self.migrateTaskId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["MigrateTaskId"] as? String {
            self.migrateTaskId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class TerminateMigrateTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TerminateMigrateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateMigrateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TerminateMigrateTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransformDBInstancePayTypeRequest : Tea.TeaModel {
    public var autoRenew: String?

    public var autoUseCoupon: Bool?

    public var businessInfo: String?

    public var clientToken: String?

    public var DBInstanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payType: String?

    public var period: String?

    public var promotionCode: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.promotionCode != nil {
            map["PromotionCode"] = self.promotionCode!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoRenew"] as? String {
            self.autoRenew = value
        }
        if let value = dict["AutoUseCoupon"] as? Bool {
            self.autoUseCoupon = value
        }
        if let value = dict["BusinessInfo"] as? String {
            self.businessInfo = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PromotionCode"] as? String {
            self.promotionCode = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["UsedTime"] as? Int32 {
            self.usedTime = value
        }
    }
}

public class TransformDBInstancePayTypeResponseBody : Tea.TeaModel {
    public var chargeType: String?

    public var DBInstanceId: String?

    public var expiredTime: String?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["OrderId"] as? Int64 {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TransformDBInstancePayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransformDBInstancePayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransformDBInstancePayTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnassociateEipAddressWithRCInstanceRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AllocationId"] as? String {
            self.allocationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UnassociateEipAddressWithRCInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnassociateEipAddressWithRCInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateEipAddressWithRCInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnassociateEipAddressWithRCInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnlockAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UnlockAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnlockAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnlockAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnlockAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePostgresExtensionsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var DBNames: String?

    public var extensions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBNames != nil {
            map["DBNames"] = self.DBNames!
        }
        if self.extensions != nil {
            map["Extensions"] = self.extensions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBNames"] as? String {
            self.DBNames = value
        }
        if let value = dict["Extensions"] as? String {
            self.extensions = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpdatePostgresExtensionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdatePostgresExtensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePostgresExtensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePostgresExtensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateUserBackupFileRequest : Tea.TeaModel {
    public var backupId: String?

    public var comment: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Retention"] as? Int32 {
            self.retention = value
        }
    }
}

public class UpdateUserBackupFileResponseBody : Tea.TeaModel {
    public var backupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateUserBackupFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserBackupFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateUserBackupFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeDBInstanceEngineVersionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBInstanceId: String?

    public var effectiveTime: String?

    public var engineVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.effectiveTime != nil {
            map["EffectiveTime"] = self.effectiveTime!
        }
        if self.engineVersion != nil {
            map["EngineVersion"] = self.engineVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["EffectiveTime"] as? String {
            self.effectiveTime = value
        }
        if let value = dict["EngineVersion"] as? String {
            self.engineVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class UpgradeDBInstanceEngineVersionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpgradeDBInstanceEngineVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeDBInstanceEngineVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeDBInstanceEngineVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeDBInstanceKernelVersionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var targetMinorVersion: String?

    public var upgradeTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.upgradeTime != nil {
            map["UpgradeTime"] = self.upgradeTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["UpgradeTime"] as? String {
            self.upgradeTime = value
        }
    }
}

public class UpgradeDBInstanceKernelVersionResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var targetMinorVersion: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetMinorVersion != nil {
            map["TargetMinorVersion"] = self.targetMinorVersion!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TargetMinorVersion"] as? String {
            self.targetMinorVersion = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpgradeDBInstanceKernelVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeDBInstanceKernelVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeDBInstanceKernelVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeDBInstanceMajorVersionRequest : Tea.TeaModel {
    public var collectStatMode: String?

    public var DBInstanceClass: String?

    public var DBInstanceId: String?

    public var DBInstanceStorage: Int32?

    public var DBInstanceStorageType: String?

    public var instanceNetworkType: String?

    public var payType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var resourceOwnerId: Int64?

    public var switchOver: String?

    public var switchTime: String?

    public var switchTimeMode: String?

    public var targetMajorVersion: String?

    public var upgradeMode: String?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public var zoneIdSlave1: String?

    public var zoneIdSlave2: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectStatMode != nil {
            map["CollectStatMode"] = self.collectStatMode!
        }
        if self.DBInstanceClass != nil {
            map["DBInstanceClass"] = self.DBInstanceClass!
        }
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBInstanceStorage != nil {
            map["DBInstanceStorage"] = self.DBInstanceStorage!
        }
        if self.DBInstanceStorageType != nil {
            map["DBInstanceStorageType"] = self.DBInstanceStorageType!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchOver != nil {
            map["SwitchOver"] = self.switchOver!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.switchTimeMode != nil {
            map["SwitchTimeMode"] = self.switchTimeMode!
        }
        if self.targetMajorVersion != nil {
            map["TargetMajorVersion"] = self.targetMajorVersion!
        }
        if self.upgradeMode != nil {
            map["UpgradeMode"] = self.upgradeMode!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneIdSlave1 != nil {
            map["ZoneIdSlave1"] = self.zoneIdSlave1!
        }
        if self.zoneIdSlave2 != nil {
            map["ZoneIdSlave2"] = self.zoneIdSlave2!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectStatMode"] as? String {
            self.collectStatMode = value
        }
        if let value = dict["DBInstanceClass"] as? String {
            self.DBInstanceClass = value
        }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBInstanceStorage"] as? Int32 {
            self.DBInstanceStorage = value
        }
        if let value = dict["DBInstanceStorageType"] as? String {
            self.DBInstanceStorageType = value
        }
        if let value = dict["InstanceNetworkType"] as? String {
            self.instanceNetworkType = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["PrivateIpAddress"] as? String {
            self.privateIpAddress = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchOver"] as? String {
            self.switchOver = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["SwitchTimeMode"] as? String {
            self.switchTimeMode = value
        }
        if let value = dict["TargetMajorVersion"] as? String {
            self.targetMajorVersion = value
        }
        if let value = dict["UpgradeMode"] as? String {
            self.upgradeMode = value
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["ZoneIdSlave1"] as? String {
            self.zoneIdSlave1 = value
        }
        if let value = dict["ZoneIdSlave2"] as? String {
            self.zoneIdSlave2 = value
        }
    }
}

public class UpgradeDBInstanceMajorVersionResponseBody : Tea.TeaModel {
    public var DBInstanceId: String?

    public var orderId: String?

    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class UpgradeDBInstanceMajorVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeDBInstanceMajorVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeDBInstanceMajorVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeDBInstanceMajorVersionPrecheckRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var resourceOwnerId: Int64?

    public var targetMajorVersion: String?

    public var upgradeMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetMajorVersion != nil {
            map["TargetMajorVersion"] = self.targetMajorVersion!
        }
        if self.upgradeMode != nil {
            map["UpgradeMode"] = self.upgradeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["TargetMajorVersion"] as? String {
            self.targetMajorVersion = value
        }
        if let value = dict["UpgradeMode"] as? String {
            self.upgradeMode = value
        }
    }
}

public class UpgradeDBInstanceMajorVersionPrecheckResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var targetMajorVersion: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetMajorVersion != nil {
            map["TargetMajorVersion"] = self.targetMajorVersion!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TargetMajorVersion"] as? String {
            self.targetMajorVersion = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpgradeDBInstanceMajorVersionPrecheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeDBInstanceMajorVersionPrecheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeDBInstanceMajorVersionPrecheckResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeDBProxyInstanceKernelVersionRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var DBProxyEngineType: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchTime: String?

    public var upgradeTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.DBProxyEngineType != nil {
            map["DBProxyEngineType"] = self.DBProxyEngineType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchTime != nil {
            map["SwitchTime"] = self.switchTime!
        }
        if self.upgradeTime != nil {
            map["UpgradeTime"] = self.upgradeTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceId"] as? String {
            self.DBInstanceId = value
        }
        if let value = dict["DBProxyEngineType"] as? String {
            self.DBProxyEngineType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchTime"] as? String {
            self.switchTime = value
        }
        if let value = dict["UpgradeTime"] as? String {
            self.upgradeTime = value
        }
    }
}

public class UpgradeDBProxyInstanceKernelVersionResponseBody : Tea.TeaModel {
    public var DBInstanceName: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceName != nil {
            map["DBInstanceName"] = self.DBInstanceName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBInstanceName"] as? String {
            self.DBInstanceName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpgradeDBProxyInstanceKernelVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeDBProxyInstanceKernelVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeDBProxyInstanceKernelVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
